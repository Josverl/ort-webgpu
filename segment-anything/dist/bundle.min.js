/*! For license information please see bundle.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}(self,(()=>(()=>{var e={122:(e,t,n)=>{"use strict";var r,a,i,o,s,u,l,d,p,c,f,h,m,g,y,b,w,v,$,_,x,S,C,E,I,T,A,k,O,R,z,B,P="/index.js",M=Object.defineProperty,D=Object.getOwnPropertyDescriptor,N=Object.getOwnPropertyNames,W=Object.prototype.hasOwnProperty,U=(e,t)=>()=>(e&&(t=e(e=0)),t),V=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),H=(e,t)=>{for(var n in t)M(e,n,{get:t[n],enumerable:!0})},L=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let n of N(t))!W.call(e,n)&&undefined!==n&&M(e,n,{get:()=>t[n],enumerable:!(r=D(t,n))||r.enumerable});return e})(M({},"__esModule",{value:!0}),e),F=U((()=>{a=new Map,i=[],o=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=a.get(e);if(void 0===r)a.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=i.indexOf(e);-1!==t&&i.splice(t,1);for(let t=0;t<i.length;t++)if(a.get(i[t]).priority<=n)return void i.splice(t,0,e);i.push(e)}}},s=async e=>{let t=0===e.length?i:e,n=[];for(let e of t){let t=a.get(e);if(t){if(t.initialized)return t.backend;if(t.aborted)continue;let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(a){r||n.push({name:e,err:a}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)}})),G=U((()=>{F()})),j=U((()=>{u="1.17.0-dev.20240116-80f274ca6f"})),q=U((()=>{j(),l="warning",d={wasm:{},webgl:{},webgpu:{},versions:{common:u},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);l=e}},get logLevel(){return l}},Object.defineProperty(d,"logLevel",{enumerable:!0})})),K=U((()=>{q(),p=d})),Y=U((()=>{c=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[3]):(a=e.dims[3],i=e.dims[2]);let o,s,u=void 0!==t?.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?o=[255,255,255,255]:"number"==typeof l.mean?o=[l.mean,l.mean,l.mean,l.mean]:(o=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(o[3]=l.mean[3])),void 0===l||void 0===l.bias?s=[0,0,0,0]:"number"==typeof l.bias?s=[l.bias,l.bias,l.bias,l.bias]:(s=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(s[3]=l.bias[3]));let d=i*a,p=0,c=d,f=2*d,h=-1;"RGBA"===u?(p=0,c=d,f=2*d,h=3*d):"RGB"===u?(p=0,c=d,f=2*d):"RBG"===u&&(p=0,f=d,c=2*d);for(let t=0;t<i;t++)for(let n=0;n<a;n++){let a=(e.data[p++]-s[0])*o[0],i=(e.data[c++]-s[1])*o[1],u=(e.data[f++]-s[2])*o[2],l=-1===h?255:(e.data[h++]-s[3])*o[3];r.fillStyle="rgba("+a+","+i+","+u+","+l+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},f=(e,t)=>{let n,r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==r)throw new Error("Can not access image data");{let a,i,o;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],i=e.dims[1],o=e.dims[3]):(a=e.dims[3],i=e.dims[2],o=e.dims[1]);let s,u,l=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?s=[255,255,255,255]:"number"==typeof d.mean?s=[d.mean,d.mean,d.mean,d.mean]:(s=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(s[3]=d.mean[3])),void 0===d||void 0===d.bias?u=[0,0,0,0]:"number"==typeof d.bias?u=[d.bias,d.bias,d.bias,d.bias]:(u=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(u[3]=d.bias[3]));let p=i*a;if(void 0!==t&&(void 0!==t.format&&4===o&&"RGBA"!==t.format||3===o&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let c=4,f=0,h=1,m=2,g=3,y=0,b=p,w=2*p,v=-1;"RGBA"===l?(y=0,b=p,w=2*p,v=3*p):"RGB"===l?(y=0,b=p,w=2*p):"RBG"===l&&(y=0,w=p,b=2*p),n=r.createImageData(a,i);for(let t=0;t<i*a;f+=c,h+=c,m+=c,g+=c,t++)n.data[f]=(e.data[y++]-u[0])*s[0],n.data[h]=(e.data[b++]-u[1])*s[1],n.data[m]=(e.data[w++]-u[2])*s[2],n.data[g]=-1===v?255:(e.data[v++]-u[3])*s[3]}return n}})),Z=U((()=>{J(),h=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:a,width:i}=t,o=t.norm??{mean:255,bias:0};n="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],r="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=a*i,d="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l),p=4,c=0,f=1,h=2,m=3,g=0,y=l,b=2*l,w=-1;"RGB"===s&&(p=3,c=0,f=1,h=2,m=-1),"RGBA"===u?w=3*l:"RBG"===u?(g=0,b=l,y=2*l):"BGR"===u&&(b=0,y=l,g=2*l);for(let t=0;t<l;t++,c+=p,h+=p,f+=p,m+=p)d[g++]=(e[c]+r[0])/n[0],d[y++]=(e[f]+r[1])/n[1],d[b++]=(e[h]+r[2])/n[2],-1!==w&&-1!==m&&(d[w++]=(e[m]+r[3])/n[3]);return new C("float32",d,"RGBA"===u?[1,4,a,i]:[1,3,a,i])},m=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,o="string"==typeof e,s=t??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},l=e=>e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){let r=u();r.width=e.width,r.height=e.height;let a=l(r);if(null==a)throw new Error("Can not access image data");{let r=e.height,i=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=r,s.width=i}else s.tensorFormat="RGBA",s.height=r,s.width=i;a.drawImage(e,0,0),n=a.getImageData(0,0,i,r).data}}else{if(!a){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=u();r.width=e.width,r.height=e.height;let a=l(r);if(null!=a){let t=e.height,r=e.width;return a.drawImage(e,0,0,r,t),n=a.getImageData(0,0,r,t).data,s.height=t,s.width=r,h(n,s)}throw new Error("Can not access image data")}if(o)return new Promise(((t,n)=>{let r=u(),a=l(r);if(!e||!a)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,a.drawImage(i,0,0,r.width,r.height);let e=a.getImageData(0,0,r.width,r.height);s.height=r.height,s.width=r.width,t(h(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,a;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,a=t.resizedWidth):(r=e.height,a=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=r,s.width=a,void 0!==t){let t=u();t.width=a,t.height=r;let i=l(t);if(null==i)throw new Error("Can not access image data");i.putImageData(e,0,0),n=i.getImageData(0,0,a,r).data}else n=e.data}}if(void 0!==n)return h(n,s);throw new Error("Input data provided is not supported - aborted tensor creation")},g=(e,t)=>{let{width:n,height:r,download:a,dispose:i}=t;return new C({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:a,dispose:i})},y=(e,t)=>{let{dataType:n,dims:r,download:a,dispose:i}=t;return new C({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:a,dispose:i})},b=(e,t,n)=>new C({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),Q=U((()=>{w=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),v=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),$=!1,_=()=>{if(!$){$=!0;let e=typeof BigInt64Array<"u"&&"function"==typeof BigInt64Array.from,t=typeof BigUint64Array<"u"&&"function"==typeof BigUint64Array.from;e&&(w.set("int64",BigInt64Array),v.set(BigInt64Array,"int64")),t&&(w.set("uint64",BigUint64Array),v.set(BigUint64Array,"uint64"))}}})),X=U((()=>{J(),x=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},S=(e,t)=>{switch(e.location){case"cpu":return new C(e.type,e.data,t);case"cpu-pinned":return new C({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new C({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new C({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),J=U((()=>{Y(),Z(),Q(),X(),C=class{constructor(e,t,n){let r,a;if(_(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,a=e.dims,e.location){case"cpu-pinned":{let t=w.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"bool"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,o;if("string"==typeof e)if(r=e,o=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");i=t}else{let n=w.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);i=t}}else if(o=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else{let t=v.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===o)o=[i.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");a=o,this.cpuData=i,this.dataLocation="cpu"}let i=x(a);if(this.cpuData&&i!==this.cpuData.length)throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=a,this.size=i}static async fromImage(e,t){return m(e,t)}static fromTexture(e,t){return g(e,t)}static fromGpuBuffer(e,t){return y(e,t)}static fromPinnedBuffer(e,t,n){return b(e,t,n)}toDataURL(e){return c(this,e)}toImageData(e){return f(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return S(this,e)}}})),ee=U((()=>{J(),E=C})),te=U((()=>{q(),I=(e,t)=>{d.wasm.trace&&console.timeStamp(`${e}::ORT::${t}`)},T=(e,t)=>{let n=(new Error).stack?.split(/\r\n|\r|\n/g)||[],r=!1;for(let a=0;a<n.length;a++){if(r&&!n[a].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[a].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void I("CPU",r)}n[a].includes("TRACE_FUNC")&&(r=!0)}},A=e=>{d.wasm.trace&&T("BEGIN",e)},k=e=>{d.wasm.trace&&T("END",e)}})),ne=U((()=>{F(),ee(),te(),O=class e{constructor(e){this.handler=e}async run(e,t,n){A();let r={},a={};if("object"!=typeof e||null===e||e instanceof E||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,o=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==o.indexOf(n)){let a=t[n];(null===a||a instanceof E)&&(e=!0,i=!1,r[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(let e of this.outputNames)r[e]=null;let o=await this.handler.run(e,r,a),s={};for(let e in o)if(Object.hasOwnProperty.call(o,e)){let t=o[e];s[e]=t instanceof E?t:new E(t.type,t.data,t.dims)}return k(),s}async release(){return this.handler.dispose()}static async create(t,n,r,a){A();let i,o={};if("string"==typeof t){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof n&&null!==n)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,s=0,u=t.byteLength;if("object"==typeof n&&null!==n)o=n;else if("number"==typeof n){if(s=n,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(u=t.byteLength-s,"number"==typeof r){if(u=r,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||s+u>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-s}].`);if("object"==typeof a&&null!==a)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(e,s,u)}}let u=(o.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await(await s(u)).createInferenceSessionHandler(i,o);return k(),new e(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),re=U((()=>{ne(),R=O})),ae=U((()=>{})),ie=U((()=>{F(),ee(),z=class e{constructor(e,t,n){this.handler=e,this.hasOptimizerModel=t,this.hasEvalModel=n}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(t,n){let r=t.evalModel||"",a=t.optimizerModel||"",i=n||{},o=(i.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),u=await s(o);if(u.createTrainingSessionHandler){let n=await u.createTrainingSessionHandler(t.checkpointState,t.trainModel,r,a,i);return new e(n,!!t.optimizerModel,!!t.evalModel)}throw new Error("Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.")}typeNarrowingForRunStep(e,t,n,r,a){let i={},o={};if("object"!=typeof n||null===n||n instanceof E||Array.isArray(n))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if("object"==typeof r){if(null===r)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof E)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(0===r.length)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let e of r){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===t.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);i[e]=null}if("object"==typeof a&&null!==a)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,n=Object.getOwnPropertyNames(r);for(let a of t)if(-1!==n.indexOf(a)){let t=r[a];(null===t||t instanceof E)&&(e=!0,s=!1,i[a]=t)}if(e){if("object"==typeof a&&null!==a)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else o=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of e)if(typeof n[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(s)for(let e of t)i[e]=null;return[i,o]}convertHandlerReturnTypeToMapOfTensors(e){let t={};for(let n in e)if(Object.hasOwnProperty.call(e,n)){let r=e[n];t[n]=r instanceof E?r:new E(r.type,r.data,r.dims)}return t}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,t,n){let[r,a]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,t,n),i=await this.handler.runTrainStep(e,r,a);return this.convertHandlerReturnTypeToMapOfTensors(i)}async runOptimizerStep(e){if(!this.hasOptimizerModel)throw new Error("This TrainingSession has no OptimizerModel loaded.");await this.handler.runOptimizerStep(e||{})}async runEvalStep(e,t,n){if(this.hasEvalModel){let[r,a]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,t,n),i=await this.handler.runEvalStep(e,r,a);return this.convertHandlerReturnTypeToMapOfTensors(i)}throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,t=!0){let n=await this.getParametersSize(t);if(e.length!==4*n)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,t)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}})),oe=U((()=>{ie(),B=z})),se={};H(se,{InferenceSession:()=>R,TRACE:()=>I,TRACE_FUNC_BEGIN:()=>A,TRACE_FUNC_END:()=>k,Tensor:()=>E,TrainingSession:()=>B,env:()=>p,registerBackend:()=>o});var ue=U((()=>{G(),K(),re(),ee(),te(),ae(),oe()})),le={};H(le,{createReadStream:()=>ce,readFile:()=>de,readFileSync:()=>pe});var de,pe,ce,fe=U((()=>{de=void 0,pe=void 0,ce=void 0})),he={};H(he,{join:()=>me});var me,ge=U((()=>{me=void 0})),ye=V(((n,a)=>{var i,o=(i=(i=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||P,function(e={}){var t,n,r=e;r.ready=new Promise(((e,r)=>{t=e,n=r})),r.mountExternalData=(e,t)=>{(r.gb||(r.gb=new Map)).set(e,t)},r.unmountExternalData=()=>{delete r.gb},r.jsepInit=(e,t,n,a,i,o,s,u)=>{r.Fb=e,r.vb=t,r.xb=n,r.ob=a,r.wb=i,r.Sa=o,r.yb=s,r.zb=u,t=(e,t,n)=>(...r)=>{let a=ze,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),ze!=a?new Promise(((e,t)=>{We={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(r.fb)throw Error("Session already started");let a=r.fb={Ab:n[0],errors:[]},i=await t(...n);if(r.fb!==a)throw Error("Session mismatch");e.flush();let o=a.errors;if(0<o.length){let e=await Promise.all(o);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return i}finally{r.fb=null}},r._OrtCreateSession=t(r._OrtCreateSession,(()=>r._OrtCreateSession),(e=>r._OrtCreateSession=e)),r._OrtRun=n(t(r._OrtRun,(()=>r._OrtRun),(e=>r._OrtRun=e))),r._OrtRunWithBinding=n(t(r._OrtRunWithBinding,(()=>r._OrtRunWithBinding),(e=>r._OrtRunWithBinding=e))),r._OrtBindInput=t(r._OrtBindInput,(()=>r._OrtBindInput),(e=>r._OrtBindInput=e)),r.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),r.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},r.jsepGetBuffer=t=>e.getBuffer(t),r.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r),r.jsepOnRunStart=()=>e.onRunStart()};var a,o,s,u=Object.assign({},r),l="./this.program",d=(e,t)=>{throw t},p="object"==typeof window,c="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var m=(fe(),L(le)),g=(ge(),L(he));h=c?g.dirname(h)+"/":"//",a=(e,t)=>(e=H(e)?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),s=e=>((e=a(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n,r=!0)=>{e=H(e)?new URL(e):g.normalize(e),m.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!r.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),d=(e,t)=>{throw process.exitCode=e,t},r.inspect=()=>"[Emscripten Module object]"}else(p||c)&&(c?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),i&&(h=i),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},c&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y=console.log.bind(console),b=console.error.bind(console);Object.assign(r,u),u=null,"object"!=typeof WebAssembly&&W("no native wasm support detected");var w,v,$,_,x,S,C,E,I,T,A,k,O=!1;function R(){var e=w.buffer;r.HEAP8=$=new Int8Array(e),r.HEAP16=x=new Int16Array(e),r.HEAPU8=_=new Uint8Array(e),r.HEAPU16=S=new Uint16Array(e),r.HEAP32=C=new Int32Array(e),r.HEAPU32=E=new Uint32Array(e),r.HEAPF32=I=new Float32Array(e),r.HEAPF64=k=new Float64Array(e),r.HEAP64=T=new BigInt64Array(e),r.HEAPU64=A=new BigUint64Array(e)}var z=[],B=[],P=[],M=0,D=null,N=null;function W(e){throw b(e="Aborted("+e+")"),O=!0,v=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}var U,V=e=>e.startsWith("data:application/octet-stream;base64,"),H=e=>e.startsWith("file://");if(!V(U="ort-wasm-simd.wasm")){var F=U;U=r.locateFile?r.locateFile(F,h):h+F}function G(e){if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function j(e,t,n){return function(e){if(p||c){if("function"==typeof fetch&&!H(e))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>G(e)));if(o)return new Promise(((t,n)=>{o(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>G(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{b(`failed to asynchronously prepare wasm: ${e}`),W(e)}))}var q={945168:(e,t,n,a)=>{if(typeof r>"u"||!r.gb)return 1;if((e=ee(e>>>0)).startsWith("./")&&(e=e.substring(2)),!(e=r.gb.get(e)))return 2;if((t>>>=0)+(n>>>=0)>e.byteLength)return 3;try{return _.set(e.subarray(t,t+n),a>>>0>>>0),0}catch{return 4}},945669:e=>r.vb(e),945702:e=>r.xb(e),945734:(e,t,n)=>{r.ob(e,t,n,!0)},945773:(e,t,n)=>{r.ob(e,t,n)},945806:e=>{r.Sa("Abs",e,void 0)},945857:e=>{r.Sa("Neg",e,void 0)},945908:e=>{r.Sa("Floor",e,void 0)},945961:e=>{r.Sa("Ceil",e,void 0)},946013:e=>{r.Sa("Reciprocal",e,void 0)},946071:e=>{r.Sa("Sqrt",e,void 0)},946123:e=>{r.Sa("Exp",e,void 0)},946174:e=>{r.Sa("Erf",e,void 0)},946225:e=>{r.Sa("Sigmoid",e,void 0)},946280:(e,t,n)=>{r.Sa("HardSigmoid",e,{alpha:t,beta:n})},946359:e=>{r.Sa("Log",e,void 0)},946410:e=>{r.Sa("Sin",e,void 0)},946461:e=>{r.Sa("Cos",e,void 0)},946512:e=>{r.Sa("Tan",e,void 0)},946563:e=>{r.Sa("Asin",e,void 0)},946615:e=>{r.Sa("Acos",e,void 0)},946667:e=>{r.Sa("Atan",e,void 0)},946719:e=>{r.Sa("Sinh",e,void 0)},946771:e=>{r.Sa("Cosh",e,void 0)},946823:e=>{r.Sa("Asinh",e,void 0)},946876:e=>{r.Sa("Acosh",e,void 0)},946929:e=>{r.Sa("Atanh",e,void 0)},946982:e=>{r.Sa("Tanh",e,void 0)},947034:e=>{r.Sa("Not",e,void 0)},947085:(e,t,n)=>{r.Sa("Clip",e,{min:t,max:n})},947154:e=>{r.Sa("Clip",e,void 0)},947206:(e,t)=>{r.Sa("Elu",e,{alpha:t})},947264:e=>{r.Sa("Relu",e,void 0)},947316:(e,t)=>{r.Sa("LeakyRelu",e,{alpha:t})},947380:(e,t)=>{r.Sa("ThresholdedRelu",e,{alpha:t})},947450:(e,t)=>{r.Sa("Cast",e,{to:t})},947508:e=>{r.Sa("Add",e,void 0)},947559:e=>{r.Sa("Sub",e,void 0)},947610:e=>{r.Sa("Mul",e,void 0)},947661:e=>{r.Sa("Div",e,void 0)},947712:e=>{r.Sa("Pow",e,void 0)},947763:e=>{r.Sa("Equal",e,void 0)},947816:e=>{r.Sa("Greater",e,void 0)},947871:e=>{r.Sa("GreaterOrEqual",e,void 0)},947933:e=>{r.Sa("Less",e,void 0)},947985:e=>{r.Sa("LessOrEqual",e,void 0)},948044:(e,t,n,a,i)=>{r.Sa("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},948203:(e,t,n,a,i)=>{r.Sa("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},948361:(e,t,n,a,i)=>{r.Sa("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},948519:(e,t,n,a,i)=>{r.Sa("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},948678:(e,t,n,a,i)=>{r.Sa("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},948836:(e,t,n,a,i)=>{r.Sa("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},948993:(e,t,n,a,i)=>{r.Sa("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},949150:(e,t,n,a,i)=>{r.Sa("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},949311:(e,t,n,a,i)=>{r.Sa("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},949475:(e,t,n,a,i)=>{r.Sa("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},949639:e=>{r.Sa("Where",e,void 0)},949692:(e,t,n)=>{r.Sa("Transpose",e,{perm:t?Array.from(C.subarray(t>>>0,n>>>0)):[]})},949800:(e,t,n,a,i,o,s,u,l,d,p,c,f,h,m)=>{r.Sa("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!$[d>>>0],outputPadding:p?Array.from(C.subarray(p>>>0,c>>>0)):[],outputShape:f?Array.from(C.subarray(f>>>0,h>>>0)):[],activation:ee(m)})},950202:(e,t,n,a,i,o,s,u,l,d,p,c,f,h)=>{r.Sa("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(C.subarray(n>>>0,2+(n>>>0)>>>0)),group:a,kernelShape:Array.from(C.subarray(i>>>0,2+(i>>>0)>>>0)),pads:Array.from(C.subarray(o>>>0,4+(o>>>0)>>>0)),strides:Array.from(C.subarray(s>>>0,2+(s>>>0)>>>0)),wIsConst:()=>!!$[l>>>0],outputPadding:d?Array.from(C.subarray(d>>>0,p>>>0)):[],outputShape:c?Array.from(C.subarray(c>>>0,f>>>0)):[],activation:ee(h)})},950767:(e,t,n,a,i,o,s,u,l,d,p,c,f,h,m)=>{r.Sa("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:a,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!$[d>>>0],outputPadding:p?Array.from(C.subarray(p>>>0,c>>>0)):[],outputShape:f?Array.from(C.subarray(f>>>0,h>>>0)):[],activation:ee(m)})},951169:(e,t,n,a,i,o,s,u,l,d,p,c,f,h)=>{r.Sa("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(C.subarray(n>>>0,2+(n>>>0)>>>0)),group:a,kernelShape:Array.from(C.subarray(i>>>0,2+(i>>>0)>>>0)),pads:Array.from(C.subarray(o>>>0,4+(o>>>0)>>>0)),strides:Array.from(C.subarray(s>>>0,2+(s>>>0)>>>0)),wIsConst:()=>!!$[l>>>0],outputPadding:d?Array.from(C.subarray(d>>>0,p>>>0)):[],outputShape:c?Array.from(C.subarray(c>>>0,f>>>0)):[],activation:ee(h)})},951734:(e,t)=>{r.Sa("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},951825:(e,t,n,a,i,o,s,u,l,d,p,c,f,h,m,g)=>{r.Sa("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,p,c,f],strides:[h,m]})},952109:(e,t)=>{r.Sa("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},952200:(e,t,n,a,i,o,s,u,l,d,p,c,f,h,m,g)=>{r.Sa("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,p,c,f],strides:[h,m]})},952484:(e,t)=>{r.Sa("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},952571:(e,t,n,a,i,o,s,u,l,d,p,c,f,h,m,g)=>{r.Sa("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,p,c,f],strides:[h,m]})},952851:(e,t)=>{r.Sa("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},952938:(e,t,n,a,i,o,s,u,l,d,p,c,f,h,m,g)=>{r.Sa("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:a,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[d,p,c,f],strides:[h,m]})},953218:(e,t,n,a,i)=>{r.Sa("Gemm",e,{alpha:t,beta:n,transA:a,transB:i})},953322:e=>{r.Sa("MatMul",e,void 0)},953376:(e,t,n,a)=>{r.Sa("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},953484:(e,t,n,a)=>{r.Sa("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:a})},953592:(e,t)=>{r.Sa("Softmax",e,{axis:t})},953655:(e,t)=>{r.Sa("Concat",e,{axis:t})},953715:(e,t,n,a,i)=>{r.Sa("Split",e,{axis:t,numOutputs:n,splitSizes:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},953855:e=>{r.Sa("Expand",e,void 0)},953909:(e,t)=>{r.Sa("Gather",e,{axis:Number(t)})},953980:(e,t)=>{r.Sa("GatherElements",e,{axis:Number(t)})},954059:(e,t,n,a,i,o,s,u,l,d,p)=>{r.Sa("Resize",e,{antialias:t,axes:n?Array.from(C.subarray(n>>>0,a>>>0)):[],coordinateTransformMode:ee(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:ee(l),mode:ee(d),nearestMode:ee(p)})},954405:(e,t,n,a,i,o,s)=>{r.Sa("Slice",e,{starts:t?Array.from(C.subarray(t>>>0,n>>>0)):[],ends:a?Array.from(C.subarray(a>>>0,i>>>0)):[],axes:o?Array.from(C.subarray(o>>>0,s>>>0)):[]})},954621:e=>{r.Sa("Tile",e,void 0)},954673:(e,t,n)=>{r.Sa("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},954780:(e,t,n)=>{r.Sa("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},954894:(e,t,n)=>{r.Sa("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},955008:e=>{r.Sa("Range",e,void 0)},955061:(e,t)=>{r.Sa("Einsum",e,{equation:ee(t)})},955142:(e,t,n,a,i)=>{r.Sa("Pad",e,{mode:t,value:n,pads:a?Array.from(C.subarray(a>>>0,i>>>0)):[]})},955269:(e,t,n,a,i,o)=>{r.Sa("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!i,trainingMode:!!a,format:o?"NHWC":"NCHW"})},955438:(e,t,n,a,i,o)=>{r.Sa("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!i,trainingMode:!!a,format:o?"NHWC":"NCHW"})},955607:(e,t,n)=>{r.Sa("CumSum",e,{exclusive:Number(t),reverse:Number(n)})},955704:(e,t,n,a,i,o,s,u,l)=>{r.Sa("Attention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:a,scale:i,doRotary:o,qkvHiddenSizes:s?Array.from(C.subarray(Number(u)>>>0,Number(u)+s>>>0)):[],pastPresentShareBuffer:!!l})},955976:e=>{r.Sa("Gelu",e,void 0)},956028:(e,t,n,a,i,o)=>{r.Sa("MultiHeadAttention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:a,scale:i,doRotary:o})},956187:e=>{r.Sa("BiasAdd",e,void 0)},956242:e=>{r.Sa("BiasSplitGelu",e,void 0)},956303:(e,t)=>{r.Sa("SkipLayerNormalization",e,{epsilon:t})},956384:(e,t,n,a,i,o,s,u,l,d,p,c,f)=>{r.Sa("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:a,kernel_shape:[i],pads:o?Array.from(C.subarray(o>>>0,s>>>0)):[],strides:[u],w_is_const:()=>!!$[d>>>0],activation:ee(p),activation_params:c?Array.from(I.subarray(c>>>0,f>>>0)):[]})},956754:(e,t,n,a,i,o,s,u,l,d,p,c,f,h,m,g)=>{r.Sa("Conv",e,{format:c?"NHWC":"NCHW",auto_pad:t,dilations:[n,a],group:i,kernel_shape:[o,s],pads:u?Array.from(C.subarray(u>>>0,l>>>0)):[],strides:[d,p],w_is_const:()=>!!$[f>>>0],activation:ee(h),activation_params:m?Array.from(I.subarray(m>>>0,g>>>0)):[]})},957145:e=>{r.yb(e)},957179:(e,t)=>r.zb(e,t,r.fb.Ab,r.fb.errors)};function K(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function Y(e){this.cb=e-24,this.rb=function(e){E[this.cb+4>>>2>>>0]=e},this.qb=function(e){E[this.cb+8>>>2>>>0]=e},this.kb=function(e,t){this.jb(),this.rb(e),this.qb(t)},this.jb=function(){E[this.cb+16>>>2>>>0]=0}}var Z,Q,X=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,J=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&X)return X.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},ee=(e,t)=>(e>>>=0)?J(_,e,t):"",te=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},ne=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},re=e=>{if(null===e)return"null";var t=typeof e;return"object"===t||"array"===t||"function"===t?e.toString():""+e},ae=e=>{for(var t="";_[e>>>0];)t+=Z[_[e++>>>0]];return t},ie={},oe={},se={};function ue(e,t,n={}){if(!("argPackAdvance"in t))throw new TypeError("registerType registeredInstance requires argPackAdvance");!function(e,t,n={}){var r=t.name;if(!e)throw new Q(`type "${r}" must have a positive integer typeid pointer`);if(oe.hasOwnProperty(e)){if(n.tb)return;throw new Q(`Cannot register type '${r}' twice`)}oe[e]=t,delete se[e],ie.hasOwnProperty(e)&&(t=ie[e],delete ie[e],t.forEach((e=>e())))}(e,t,n)}var de=(e,t,n)=>{switch(t){case 1:return n?e=>$[e>>>0>>>0]:e=>_[e>>>0>>>0];case 2:return n?e=>x[e>>>1>>>0]:e=>S[e>>>1>>>0];case 4:return n?e=>C[e>>>2>>>0]:e=>E[e>>>2>>>0];case 8:return n?e=>T[e>>>3]:e=>A[e>>>3];default:throw new TypeError(`invalid integer width (${t}): ${e}`)}};function pe(){this.$a=[void 0],this.nb=[]}var ce=new pe;function me(e){(e>>>=0)>=ce.cb&&0==--ce.get(e).pb&&ce.jb(e)}var ye=e=>{if(!e)throw new Q("Cannot use deleted val. handle = "+e);return ce.get(e).value},be=e=>{switch(e){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return ce.kb({pb:1,value:e})}};function we(e){return this.fromWireType(C[e>>>2>>>0])}var ve=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(I[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(k[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function $e(e){return this.fromWireType(E[e>>>2>>>0])}var _e=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,xe=(e,t)=>{for(var n=e>>1,r=n+t/2;!(n>=r)&&S[n>>>0];)++n;if(32<(n<<=1)-e&&_e)return _e.decode(_.subarray(e>>>0,n>>>0));for(n="",r=0;!(r>=t/2);++r){var a=x[e+2*r>>>1>>>0];if(0==a)break;n+=String.fromCharCode(a)}return n},Se=(e,t,n)=>{if(n??=2147483647,2>n)return 0;var r=t;n=(n-=2)<2*e.length?n/2:e.length;for(var a=0;a<n;++a)x[t>>>1>>>0]=e.charCodeAt(a),t+=2;return x[t>>>1>>>0]=0,t-r},Ce=e=>2*e.length,Ee=(e,t)=>{for(var n=0,r="";!(n>=t/4);){var a=C[e+4*n>>>2>>>0];if(0==a)break;++n,65536<=a?(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a)):r+=String.fromCharCode(a)}return r},Ie=(e,t,n)=>{if(t>>>=0,n??=2147483647,4>n)return 0;var r=t;n=r+n-4;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),C[t>>>2>>>0]=i,(t+=4)+4>n)break}return C[t>>>2>>>0]=0,t-r},Te=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&++n,t+=4}return t},Ae=(e,t)=>{var n=oe[e];if(void 0===n)throw e=ht(e),n=ae(e),ft(e),new Q(t+" has unknown type "+n);return n},ke=(e,t,n)=>{var r=[];return e=e.toWireType(r,n),r.length&&(E[t>>>2>>>0]=be(r)),e},Oe=e=>{try{e()}catch(e){W(e)}},Re=0,ze=null,Be=0,Pe=[],Me={},De={},Ne=0,We=null,Ue=[];function Ve(e){return function(e){if(!O){if(0===Re){var t=!1,n=!1;e(((e=0)=>{if(!O&&(Be=e,t=!0,n)){Re=2,Oe((()=>vt(ze))),typeof Browser<"u"&&Browser.lb.sb&&Browser.lb.resume(),e=!1;try{var r=(0,lt[De[C[ze+8>>>2>>>0]]])()}catch(t){r=t,e=!0}var a=!1;if(!ze){var i=We;i&&(We=null,(e?i.reject:i.resolve)(r),a=!0)}if(e&&!a)throw r}})),n=!0,t||(Re=1,ze=function(){var e=ct(65548),t=e+12;E[e>>>2>>>0]=t,E[e+4>>>2>>>0]=t+65536,t=Pe[0];var n=Me[t];return void 0===n&&(n=Ne++,Me[t]=n,De[n]=t),C[e+8>>>2>>>0]=n,e}(),typeof Browser<"u"&&Browser.lb.sb&&Browser.lb.pause(),Oe((()=>bt(ze))))}else 2===Re?(Re=0,Oe($t),ft(ze),ze=null,Ue.forEach((e=>{if(!O)try{e();try{v=v=e=v,r.onExit?.(e),O=!0,d(e,new K(e))}catch(e){e instanceof K||"unwind"==e||d(1,e)}}catch(e){e instanceof K||"unwind"==e||d(1,e)}}))):W(`invalid state: ${Re}`);return Be}}((t=>{e().then(t)}))}var He,Le=[],Fe={},Ge=e=>{var t=Fe[e];return void 0===t?ae(e):t},je=()=>"object"==typeof globalThis?globalThis:Function("return this")(),qe=(e,t)=>Object.defineProperty(t,"name",{value:e}),Ke=e=>e%4==0&&(e%100!=0||e%400==0),Ye=[0,31,60,91,121,152,182,213,244,274,305,335],Ze=[0,31,59,90,120,151,181,212,243,273,304,334],Qe=e=>{var t=te(e)+1,n=ct(t);return n&&ne(e,_,n,t),n},Xe=[],Je=(e,t)=>{Xe.length=0;for(var n;n=_[e++>>>0];){var r=105!=n;t+=(r&=112!=n)&&t%8?4:0,Xe.push(112==n?E[t>>>2>>>0]:106==n?T[t>>>3]:105==n?C[t>>>2>>>0]:k[t>>>3>>>0]),t+=r?8:4}return Xe},et={},tt=()=>{if(!He){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"};for(e in et)void 0===et[e]?delete t[e]:t[e]=et[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);He=n}return He},nt=[null,[],[]],rt=[31,29,31,30,31,30,31,31,30,31,30,31],at=[31,28,31,30,31,30,31,31,30,31,30,31];function it(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return a(e,t,"0")}function o(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ab;for(e=new Date(new Date(e.bb+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Ke(e.getFullYear())?rt:at)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=o(t,e)?0>=o(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0;var l=E[40+(r>>>=0)>>>2>>>0];for(var d in r={Db:C[r>>>2>>>0],Cb:C[r+4>>>2>>>0],hb:C[r+8>>>2>>>0],mb:C[r+12>>>2>>>0],ib:C[r+16>>>2>>>0],bb:C[r+20>>>2>>>0],Wa:C[r+24>>>2>>>0],ab:C[r+28>>>2>>>0],Gb:C[r+32>>>2>>>0],Bb:C[r+36>>>2>>>0],Eb:l?ee(l):""},n=ee(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(d,"g"),l[d]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),c="January February March April May June July August September October November December".split(" ");for(d in l={"%a":e=>p[e.Wa].substring(0,3),"%A":e=>p[e.Wa],"%b":e=>c[e.ib].substring(0,3),"%B":e=>c[e.ib],"%C":e=>i((e.bb+1900)/100|0,2),"%d":e=>i(e.mb,2),"%e":e=>a(e.mb,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>i(e.hb,2),"%I":e=>(0==(e=e.hb)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.ib-1;t+=(Ke(e.bb+1900)?rt:at)[n++]);return i(e.mb+t,3)},"%m":e=>i(e.ib+1,2),"%M":e=>i(e.Cb,2),"%n":()=>"\n","%p":e=>0<=e.hb&&12>e.hb?"AM":"PM","%S":e=>i(e.Db,2),"%t":()=>"\t","%u":e=>e.Wa||7,"%U":e=>i(Math.floor((e.ab+7-e.Wa)/7),2),"%V":e=>{var t=Math.floor((e.ab+7-(e.Wa+6)%7)/7);if(2>=(e.Wa+371-e.ab-2)%7&&t++,t)53==t&&(4==(n=(e.Wa+371-e.ab)%7)||3==n&&Ke(e.bb)||(t=1));else{t=52;var n=(e.Wa+7-e.ab-1)%7;(4==n||5==n&&Ke(e.bb%400-1))&&t++}return i(t,2)},"%w":e=>e.Wa,"%W":e=>i(Math.floor((e.ab+7-(e.Wa+6)%7)/7),2),"%y":e=>(e.bb+1900).toString().substring(2),"%Y":e=>e.bb+1900,"%z":e=>(0<=(e=e.Bb)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.Eb,"%%":()=>"%"},n=n.replace(/%%/g,"\0\0"),l)n.includes(d)&&(n=n.replace(new RegExp(d,"g"),l[d](r)));return d=function(e){var t=Array(te(e)+1);return ne(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),d.length>t?0:($.set(d,e>>>0),d.length-1)}for(var ot=Array(256),st=0;256>st;++st)ot[st]=String.fromCharCode(st);Z=ot,Q=r.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},r.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},Object.assign(pe.prototype,{get(e){return this.$a[e]},has(e){return void 0!==this.$a[e]},kb(e){var t=this.nb.pop()||this.$a.length;return this.$a[t]=e,t},jb(e){this.$a[e]=void 0,this.nb.push(e)}}),ce.$a.push({value:void 0},{value:null},{value:!0},{value:!1}),ce.cb=ce.$a.length,r.count_emval_handles=()=>{for(var e=0,t=ce.cb;t<ce.$a.length;++t)void 0!==ce.$a[t]&&++e;return e};var ut={ia:function(e,t,n){return Ve((async()=>{await r.wb(e,t,n)}))},a:function(e,t,n){throw new Y(e>>>=0).kb(t>>>0,n>>>0),e},x:function(){return 0},ba:function(){},O:function(){},Q:function(){},ca:function(){return 0},$:function(){},W:function(){},_:function(){},D:function(){},P:function(){},M:function(){},aa:function(){},N:function(){},G:function(e,t,n,r,a){var i=-1!=(t=ae(t>>>=0)).indexOf("u");i&&(a=(1n<<64n)-1n),ue(e>>>0,{name:t,fromWireType:e=>e,toWireType:function(e,n){if("bigint"!=typeof n&&"number"!=typeof n)throw new TypeError(`Cannot convert "${re(n)}" to ${this.name}`);if(n<r||n>a)throw new TypeError(`Passing a number "${re(n)}" from JS side to C/C++ side to an argument of type "${t}", which is outside the valid range [${r}, ${a}]!`);return n},argPackAdvance:8,readValueFromPointer:de(t,n>>>0,!i),eb:null})},ga:function(e,t,n,r){ue(e>>>0,{name:t=ae(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?n:r},argPackAdvance:8,readValueFromPointer:function(e){return this.fromWireType(_[e>>>0])},eb:null})},fa:function(e,t){ue(e>>>0,{name:t=ae(t>>>0),fromWireType:e=>{var t=ye(e);return me(e),t},toWireType:(e,t)=>be(t),argPackAdvance:8,readValueFromPointer:we,eb:null})},F:function(e,t,n){ue(e>>>0,{name:t=ae(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,argPackAdvance:8,readValueFromPointer:ve(t,n>>>0),eb:null})},t:function(e,t,n,r,a){if(e>>>=0,n>>>=0,t=ae(t>>>0),-1===a&&(a=4294967295),a=e=>e,0===r){var i=32-8*n;a=e=>e<<i>>>i}var o=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};ue(e,{name:t,fromWireType:a,toWireType:o,argPackAdvance:8,readValueFromPointer:de(t,n,0!==r),eb:null})},n:function(e,t,n){function r(e){return new a($.buffer,E[e+4>>>2>>>0],E[e>>>2>>>0])}var a=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][t];ue(e>>>0,{name:n=ae(n>>>0),fromWireType:r,argPackAdvance:8,readValueFromPointer:r},{tb:!0})},H:function(e,t){var n="std::string"===(t=ae(t>>>0));ue(e>>>0,{name:t,fromWireType:function(e){var t=E[e>>>2>>>0],r=e+4;if(n)for(var a=r,i=0;i<=t;++i){var o=r+i;if(i==t||0==_[o>>>0]){if(a=ee(a,o-a),void 0===s)var s=a;else s+=String.fromCharCode(0),s+=a;a=o+1}}else{for(s=Array(t),i=0;i<t;++i)s[i]=String.fromCharCode(_[r+i>>>0]);s=s.join("")}return ft(e),s},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var r="string"==typeof t;if(!(r||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new Q("Cannot pass non-string to std::string");var a=n&&r?te(t):t.length,i=ct(4+a+1),o=i+4;if(E[i>>>2>>>0]=a,n&&r)ne(t,_,o,a+1);else if(r)for(r=0;r<a;++r){var s=t.charCodeAt(r);if(255<s)throw ft(o),new Q("String has UTF-16 code units that do not fit in 8 bits");_[o+r>>>0]=s}else for(r=0;r<a;++r)_[o+r>>>0]=t[r];return null!==e&&e.push(ft,i),i},argPackAdvance:8,readValueFromPointer:$e,eb(e){ft(e)}})},z:function(e,t,n){if(t>>>=0,n=ae(n>>>=0),2===t)var r=xe,a=Se,i=Ce,o=()=>S,s=1;else 4===t&&(r=Ee,a=Ie,i=Te,o=()=>E,s=2);ue(e>>>0,{name:n,fromWireType:e=>{for(var n,a=E[e>>>2>>>0],i=o(),u=e+4,l=0;l<=a;++l){var d=e+4+l*t;(l==a||0==i[d>>>s])&&(u=r(u,d-u),void 0===n?n=u:(n+=String.fromCharCode(0),n+=u),u=d+t)}return ft(e),n},toWireType:(e,r)=>{if("string"!=typeof r)throw new Q(`Cannot pass non-string to C++ string type ${n}`);var o=i(r),u=ct(4+o+t);return E[u>>>2]=o>>s,a(r,u+4,o+t),null!==e&&e.push(ft,u),u},argPackAdvance:8,readValueFromPointer:we,eb(e){ft(e)}})},ha:function(e,t){ue(e>>>0,{ub:!0,name:t=ae(t>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},da:()=>1,s:function(e,t,n){return t>>>=0,n>>>=0,e=ye(e>>>0),t=Ae(t,"emval::as"),ke(t,n,e)},w:function(e){return e>>>=0,Ve((()=>(e=ye(e)).then(be)))},o:function(e,t,n,r){return n>>>=0,r>>>=0,(e=Le[e>>>0])(null,t=ye(t>>>0),n,r)},k:function(e,t,n,r,a){return n>>>=0,r>>>=0,a>>>=0,(e=Le[e>>>0])(t=ye(t>>>0),t[n=Ge(n)],r,a)},b:me,A:function(e,t){return t>>>=0,(e=ye(e>>>0))==ye(t)},m:function(e){return 0==(e>>>=0)?be(je()):(e=Ge(e),be(je()[e]))},i:function(e,t,n){t=((e,t)=>{for(var n=Array(e),r=0;r<e;++r)n[r]=Ae(E[t+4*r>>>2>>>0],"parameter "+r);return n})(e,t>>>0);var r=t.shift();e--;var a="return function (obj, func, destructorsRef, args) {\n",i=0,o=[];0===n&&o.push("obj");for(var s=["retType"],u=[r],l=0;l<e;++l)o.push("arg"+l),s.push("argType"+l),u.push(t[l]),a+=`  var arg${l} = argType${l}.readValueFromPointer(args${i?"+"+i:""});\n`,i+=t[l].argPackAdvance;for(a+=`  var rv = ${1===n?"new func":"func.call"}(${o.join(", ")});\n`,l=0;l<e;++l)t[l].deleteObject&&(a+=`  argType${l}.deleteObject(arg${l});\n`);return r.ub||(s.push("emval_returnValue"),u.push(ke),a+="  return emval_returnValue(retType, destructorsRef, rv);\n"),s.push(a+"};\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var n=qe(t.name||"unknownFunctionName",(function(){}));return n.prototype=t.prototype,n=new n,(e=t.apply(n,e))instanceof Object?e:n}(s).apply(null,u),n=`methodCaller<(${t.map((e=>e.name)).join(", ")}) => ${r.name}>`,(e=>{var t=Le.length;return Le.push(e),t})(qe(n,e))},r:function(e,t){return t>>>=0,e=ye(e>>>0),t=ye(t),be(e[t])},e:function(e){4<(e>>>=0)&&(ce.get(e).pb+=1)},u:function(){return be([])},l:function(e){e=ye(e>>>0);for(var t=Array(e.length),n=0;n<e.length;n++)t[n]=e[n];return be(t)},d:function(e){return be(Ge(e>>>0))},j:function(){return be({})},h:function(e){for(var t=ye(e>>>=0);t.length;){var n=t.pop();t.pop()(n)}me(e)},g:function(e,t,n){t>>>=0,n>>>=0,e=ye(e>>>0),t=ye(t),n=ye(n),e[t]=n},c:function(e,t){return t>>>=0,e=(e=Ae(e>>>0,"_emval_take_value")).readValueFromPointer(t),be(e)},T:function(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),C[t>>>2>>>0]=e.getUTCSeconds(),C[t+4>>>2>>>0]=e.getUTCMinutes(),C[t+8>>>2>>>0]=e.getUTCHours(),C[t+12>>>2>>>0]=e.getUTCDate(),C[t+16>>>2>>>0]=e.getUTCMonth(),C[t+20>>>2>>>0]=e.getUTCFullYear()-1900,C[t+24>>>2>>>0]=e.getUTCDay(),C[t+28>>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},U:function(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),C[t>>>2>>>0]=e.getSeconds(),C[t+4>>>2>>>0]=e.getMinutes(),C[t+8>>>2>>>0]=e.getHours(),C[t+12>>>2>>>0]=e.getDate(),C[t+16>>>2>>>0]=e.getMonth(),C[t+20>>>2>>>0]=e.getFullYear()-1900,C[t+24>>>2>>>0]=e.getDay(),C[t+28>>>2>>>0]=(Ke(e.getFullYear())?Ye:Ze)[e.getMonth()]+e.getDate()-1|0,C[t+36>>>2>>>0]=-60*e.getTimezoneOffset();var n=new Date(e.getFullYear(),6,1).getTimezoneOffset(),r=new Date(e.getFullYear(),0,1).getTimezoneOffset();C[t+32>>>2>>>0]=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n))},V:function(e){e>>>=0;var t=new Date(C[e+20>>>2>>>0]+1900,C[e+16>>>2>>>0],C[e+12>>>2>>>0],C[e+8>>>2>>>0],C[e+4>>>2>>>0],C[e>>>2>>>0],0),n=C[e+32>>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,a);return 0>n?C[e+32>>>2>>>0]=+(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),C[e+24>>>2>>>0]=t.getDay(),C[e+28>>>2>>>0]=(Ke(t.getFullYear())?Ye:Ze)[t.getMonth()]+t.getDate()-1|0,C[e>>>2>>>0]=t.getSeconds(),C[e+4>>>2>>>0]=t.getMinutes(),C[e+8>>>2>>>0]=t.getHours(),C[e+12>>>2>>>0]=t.getDate(),C[e+16>>>2>>>0]=t.getMonth(),C[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),isNaN(e)?(C[pt()>>>2>>>0]=61,e=-1):e/=1e3,BigInt(e)},R:function(){return-52},S:function(){},K:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}n>>>=0;var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var s=o.getTimezoneOffset();E[e>>>0>>>2>>>0]=60*Math.max(a,s),C[t>>>0>>>2>>>0]=+(a!=s),e=r(i),t=r(o),e=Qe(e),t=Qe(t),s<a?(E[n>>>2>>>0]=e,E[n+4>>>2>>>0]=t):(E[n>>>2>>>0]=t,E[n+4>>>2>>>0]=e)},v:()=>{W("")},f:function(e,t,n){return e>>>=0,t=Je(t>>>0,n>>>0),q[e].apply(null,t)},I:function(e,t,n){return e>>>=0,t=Je(t>>>0,n>>>0),q[e].apply(null,t)},E:()=>Date.now(),L:function(){return 4294901760},q:()=>performance.now(),J:function(e){e>>>=0;var t=_.length;if(4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r);e:{a=(a.min.call(a,4294901760,r+(65536-r%65536)%65536)-w.buffer.byteLength+65535)/65536;try{w.grow(a),R();var i=1;break e}catch{}i=void 0}if(i)return!0}return!1},Y:function(e,t){e>>>=0,t>>>=0;var n=0;return tt().forEach(((r,a)=>{var i=t+n;for(a=E[e+4*a>>>2>>>0]=i,i=0;i<r.length;++i)$[a++>>>0>>>0]=r.charCodeAt(i);$[a>>>0>>>0]=0,n+=r.length+1})),0},Z:function(e,t){e>>>=0,t>>>=0;var n=tt();E[e>>>2>>>0]=n.length;var r=0;return n.forEach((e=>r+=e.length+1)),E[t>>>2>>>0]=r,0},y:()=>52,C:function(){return 52},X:function(){return 70},B:function(e,t,n,r){t>>>=0,n>>>=0,r>>>=0;for(var a=0,i=0;i<n;i++){var o=E[t>>>2>>>0],s=E[t+4>>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=_[o+u>>>0],d=nt[e];0===l||10===l?((1===e?y:b)(J(d,0)),d.length=0):d.push(l)}a+=s}return E[r>>>2>>>0]=a,0},ea:it,p:function(e,t,n,r){return it(e>>>0,t>>>0,n>>>0,r>>>0)}},lt=function(){function e(e){return lt=e.exports,lt=function(){var e=lt,t={};for(let[n,r]of Object.entries(e))t[n]="function"==typeof r?function(){Pe.push(n);try{return r.apply(null,arguments)}finally{O||(Pe.pop(),ze&&1===Re&&0===Pe.length&&(Re=0,Oe(wt),typeof Fibers<"u"&&Fibers.Hb()))}}:r;return t}(),lt=function(){var e=lt,t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).Oa=t(e.Oa),e.Pa=n(e.Pa),e.Ra=n(e.Ra),e.Ta=t(e.Ta),e.Va=n(e.Va),e}(),w=lt.ja,R(),B.unshift(lt.ka),0==--M&&(null!==D&&(clearInterval(D),D=null),N&&(e=N,N=null,e())),lt}var t={a:ut};if(M++,r.instantiateWasm)try{return r.instantiateWasm(t,e)}catch(e){b(`Module.instantiateWasm callback failed with error: ${e}`),n(e)}return function(e,t){var n=U;return"function"!=typeof WebAssembly.instantiateStreaming||V(n)||H(n)||f||"function"!=typeof fetch?j(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return b(`wasm streaming compile failed: ${r}`),b("falling back to ArrayBuffer instantiation"),j(n,e,t)}))))}(t,(function(t){e(t.instance)})).catch(n),{}}();r._OrtInit=(e,t)=>(r._OrtInit=lt.la)(e,t),r._OrtGetLastError=(e,t)=>(r._OrtGetLastError=lt.ma)(e,t),r._OrtCreateSessionOptions=(e,t,n,a,i,o,s,u,l,d)=>(r._OrtCreateSessionOptions=lt.na)(e,t,n,a,i,o,s,u,l,d),r._OrtAppendExecutionProvider=(e,t)=>(r._OrtAppendExecutionProvider=lt.oa)(e,t),r._OrtAddFreeDimensionOverride=(e,t,n)=>(r._OrtAddFreeDimensionOverride=lt.pa)(e,t,n),r._OrtAddSessionConfigEntry=(e,t,n)=>(r._OrtAddSessionConfigEntry=lt.qa)(e,t,n),r._OrtReleaseSessionOptions=e=>(r._OrtReleaseSessionOptions=lt.ra)(e),r._OrtCreateSession=(e,t,n)=>(r._OrtCreateSession=lt.sa)(e,t,n),r._OrtReleaseSession=e=>(r._OrtReleaseSession=lt.ta)(e),r._OrtGetInputOutputCount=(e,t,n)=>(r._OrtGetInputOutputCount=lt.ua)(e,t,n),r._OrtGetInputName=(e,t)=>(r._OrtGetInputName=lt.va)(e,t),r._OrtGetOutputName=(e,t)=>(r._OrtGetOutputName=lt.wa)(e,t),r._OrtFree=e=>(r._OrtFree=lt.xa)(e),r._OrtCreateTensor=(e,t,n,a,i,o)=>(r._OrtCreateTensor=lt.ya)(e,t,n,a,i,o),r._OrtGetTensorData=(e,t,n,a,i)=>(r._OrtGetTensorData=lt.za)(e,t,n,a,i),r._OrtReleaseTensor=e=>(r._OrtReleaseTensor=lt.Aa)(e),r._OrtCreateRunOptions=(e,t,n,a)=>(r._OrtCreateRunOptions=lt.Ba)(e,t,n,a),r._OrtAddRunConfigEntry=(e,t,n)=>(r._OrtAddRunConfigEntry=lt.Ca)(e,t,n),r._OrtReleaseRunOptions=e=>(r._OrtReleaseRunOptions=lt.Da)(e),r._OrtCreateBinding=e=>(r._OrtCreateBinding=lt.Ea)(e),r._OrtBindInput=(e,t,n)=>(r._OrtBindInput=lt.Fa)(e,t,n),r._OrtBindOutput=(e,t,n,a)=>(r._OrtBindOutput=lt.Ga)(e,t,n,a),r._OrtClearBoundOutputs=e=>(r._OrtClearBoundOutputs=lt.Ha)(e),r._OrtReleaseBinding=e=>(r._OrtReleaseBinding=lt.Ia)(e),r._OrtRunWithBinding=(e,t,n,a,i)=>(r._OrtRunWithBinding=lt.Ja)(e,t,n,a,i),r._OrtRun=(e,t,n,a,i,o,s,u)=>(r._OrtRun=lt.Ka)(e,t,n,a,i,o,s,u),r._OrtEndProfiling=e=>(r._OrtEndProfiling=lt.La)(e),r._JsepOutput=(e,t,n)=>(r._JsepOutput=lt.Ma)(e,t,n),r._JsepGetNodeName=e=>(r._JsepGetNodeName=lt.Na)(e);var dt,pt=()=>(pt=lt.Oa)(),ct=r._malloc=e=>(ct=r._malloc=lt.Pa)(e),ft=r._free=e=>(ft=r._free=lt.Qa)(e),ht=e=>(ht=lt.Ra)(e),mt=()=>(mt=lt.Ta)(),gt=e=>(gt=lt.Ua)(e),yt=e=>(yt=lt.Va)(e),bt=e=>(bt=lt.Xa)(e),wt=()=>(wt=lt.Ya)(),vt=e=>(vt=lt.Za)(e),$t=()=>($t=lt._a)();function _t(){if(!(0<M)){if(r.preRun)for("function"==typeof r.preRun&&(r.preRun=[r.preRun]);r.preRun.length;){var e=r.preRun.shift();z.unshift(e)}for(;0<z.length;)z.shift()(r);if(!(0<M||dt||(dt=!0,r.calledRun=!0,O))){for(;0<B.length;)B.shift()(r);for(t(r);0<P.length;)P.shift()(r)}}}return r.___start_em_js=957291,r.___stop_em_js=957452,r.stackAlloc=yt,r.stackSave=mt,r.stackRestore=gt,r.UTF8ToString=ee,r.stringToUTF8=(e,t,n)=>ne(e,_,t,n),r.lengthBytesUTF8=te,N=function e(){dt||_t(),dt||(N=e)},_t(),e.ready});"object"==typeof n&&"object"==typeof a?a.exports=o:void 0===(r=(()=>o).apply(t,[]))||(e.exports=r)})),be=V((()=>{})),we=V((()=>{})),ve={};H(ve,{cpus:()=>$e});var $e,_e,xe,Se,Ce,Ee,Ie,Te,Ae,ke,Oe,Re,ze,Be,Pe,Me,De,Ne,We,Ue,Ve,He,Le,Fe,Ge,je,qe,Ke,Ye,Ze,Qe,Xe,Je,et,tt,nt,rt,at,it,ot,st,ut,lt,dt,pt,ct,ft,ht,mt,gt,yt,bt,wt,vt,$t,_t,xt,St,Ct,Et,It,Tt,At,kt,Ot,Rt,zt,Bt,Pt,Mt,Dt,Nt,Wt,Ut,Vt,Ht,Lt,Ft,Gt,jt,qt,Kt,Yt,Zt,Qt,Xt,Jt,en,tn,nn,rn,an,on,sn,un,ln,dn,pn,cn,fn,hn,mn,gn,yn,bn,wn,vn,$n,_n,xn,Sn,Cn,En,In,Tn,An,kn,On,Rn,zn,Bn,Pn,Mn,Dn,Nn,Wn,Un,Vn,Hn,Ln,Fn,Gn,jn,qn,Kn,Yn,Zn,Qn,Xn,Jn,er,tr,nr,rr,ar,ir,or,sr,ur,lr,dr,pr,cr,fr,hr,mr,gr,yr,br,wr,vr,$r,_r,xr,Sr,Cr,Er,Ir,Tr,Ar,kr,Or,Rr,zr,Br,Pr,Mr,Dr,Nr,Wr,Ur,Vr,Hr,Lr,Fr,Gr,jr,qr,Kr,Yr,Zr,Qr,Xr,Jr,ea,ta,na,ra,aa,ia,oa,sa,ua,la,da,pa,ca,fa,ha,ma,ga,ya,ba,wa,va,$a,_a,xa,Sa,Ca,Ea,Ia,Ta,Aa,ka,Oa,Ra,za,Ba,Pa,Ma,Da,Na,Wa,Ua,Va,Ha,La,Fa,Ga,ja,qa,Ka,Ya,Za,Qa,Xa,Ja,ei,ti,ni,ri,ai,ii,oi,si,ui,li,di,pi,ci,fi,hi,mi,gi,yi,bi,wi,vi,$i,_i,xi,Si,Ci,Ei,Ii,Ti,Ai,ki,Oi,Ri,zi,Bi,Pi,Mi,Di,Ni,Wi,Ui,Vi,Hi,Li,Fi,Gi,ji,qi,Ki,Yi,Zi,Qi,Xi,Ji,eo,to,no,ro,ao,io,oo,so,uo,lo,po,co,fo,ho,mo,go,yo,bo,wo,vo,$o,_o,xo,So,Co,Eo,Io,To,Ao,ko,Oo,Ro,zo,Bo,Po,Mo,Do,No,Wo,Uo,Vo,Ho,Lo,Fo,Go,jo,qo,Ko,Yo,Zo,Qo,Xo,Jo,es,ts,ns,rs,as,is,os,ss,us,ls,ds,ps,cs,fs,hs=U((()=>{$e=void 0})),ms=V(((a,i)=>{var o,s=(o=(o=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||P,function(e={}){function t(){return R.buffer!=P.buffer&&q(),P}function r(){return R.buffer!=P.buffer&&q(),M}function a(){return R.buffer!=P.buffer&&q(),D}function i(){return R.buffer!=P.buffer&&q(),N}function s(){return R.buffer!=P.buffer&&q(),W}function u(){return R.buffer!=P.buffer&&q(),U}function l(){return R.buffer!=P.buffer&&q(),V}function d(){return R.buffer!=P.buffer&&q(),G}var p,c,f=e;f.ready=new Promise(((e,t)=>{p=e,c=t})),f.mountExternalData=(e,t)=>{(f.Fb||(f.Fb=new Map)).set(e,t)},f.unmountExternalData=()=>{delete f.Fb},f.jsepInit=(e,t,n,r,a,i,o,s)=>{f.rc=e,f.$b=t,f.bc=n,f.Ob=r,f.ac=a,f.eb=i,f.cc=o,f.dc=s,t=(e,t,n)=>(...r)=>{let a=At,i=t?.();r=e(...r);let o=t?.();return i!==o&&(e=o,n(i),t=n=null),At!=a?new Promise(((e,t)=>{Pt={resolve:e,reject:t}})):r},n=t=>async(...n)=>{try{if(f.Eb)throw Error("Session already started");let r=f.Eb={fc:n[0],errors:[]},a=await t(...n);if(f.Eb!==r)throw Error("Session mismatch");e.flush();let i=r.errors;if(0<i.length){let e=await Promise.all(i);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return a}finally{f.Eb=null}},f._OrtCreateSession=t(f._OrtCreateSession,(()=>f._OrtCreateSession),(e=>f._OrtCreateSession=e)),f._OrtRun=n(t(f._OrtRun,(()=>f._OrtRun),(e=>f._OrtRun=e))),f._OrtRunWithBinding=n(t(f._OrtRunWithBinding,(()=>f._OrtRunWithBinding),(e=>f._OrtRunWithBinding=e))),f._OrtBindInput=t(f._OrtBindInput,(()=>f._OrtBindInput),(e=>f._OrtBindInput=e)),f.jsepRegisterBuffer=(t,n,r,a)=>e.registerBuffer(t,n,r,a),f.jsepUnregisterBuffers=t=>{e.unregisterBuffers(t)},f.jsepGetBuffer=t=>e.getBuffer(t),f.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r),f.jsepOnRunStart=()=>e.onRunStart()};var h,m,g,y=Object.assign({},f),b="./this.program",w=(e,t)=>{throw t},v="object"==typeof window,$="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=f.ENVIRONMENT_IS_PTHREAD||!1,S="";function C(e){return f.locateFile?f.locateFile(e,S):S+e}if(_){var E=(fe(),L(le)),I=(ge(),L(he));let e;S=$?I.dirname(S)+"/":"//",h=(e,t)=>(e=ie(e)?new URL(e):I.normalize(e),E.readFileSync(e,t?void 0:"utf8")),g=e=>((e=h(e,!0)).buffer||(e=new Uint8Array(e)),e),m=(e,t,n,r=!0)=>{e=ie(e)?new URL(e):I.normalize(e),E.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!f.thisProgram&&1<process.argv.length&&(b=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),w=(e,t)=>{throw process.exitCode=e,t},f.inspect=()=>"[Emscripten Module object]";try{e=be()}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=e.Worker}else(v||$)&&($?S=self.location.href:typeof document<"u"&&document.currentScript&&(S=document.currentScript.src),typeof o<"u"&&o&&(S=o),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},$&&(g=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),m=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&typeof performance>"u"&&(n.g.performance=we().performance);var T=console.log.bind(console),A=console.error.bind(console);_&&(T=(...e)=>E.writeSync(1,e.join(" ")+"\n"),A=(...e)=>E.writeSync(2,e.join(" ")+"\n"));var k=T,O=A;Object.assign(f,y),y=null,"object"!=typeof WebAssembly&&ne("no native wasm support detected");var R,z,B,P,M,D,N,W,U,V,H,F,G,j=!1;function q(){var e=R.buffer;f.HEAP8=P=new Int8Array(e),f.HEAP16=D=new Int16Array(e),f.HEAPU8=M=new Uint8Array(e),f.HEAPU16=N=new Uint16Array(e),f.HEAP32=W=new Int32Array(e),f.HEAPU32=U=new Uint32Array(e),f.HEAPF32=V=new Float32Array(e),f.HEAPF64=G=new Float64Array(e),f.HEAP64=H=new BigInt64Array(e),f.HEAPU64=F=new BigUint64Array(e)}var K=16777216;if(x)R=f.wasmMemory;else if(f.wasmMemory)R=f.wasmMemory;else if(!((R=new WebAssembly.Memory({initial:K/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw O("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&O("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");q(),K=R.buffer.byteLength;var Y=[],Z=[],Q=[],X=0,J=null,ee=null;function te(){if(0==--X&&(null!==J&&(clearInterval(J),J=null),ee)){var e=ee;ee=null,e()}}function ne(e){throw O(e="Aborted("+e+")"),j=!0,B=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}var re,ae=e=>e.startsWith("data:application/octet-stream;base64,"),ie=e=>e.startsWith("file://");function oe(e){if(g)return g(e);throw"both async and sync fetching of the wasm failed"}function se(e,t,n){return function(e){if(v||$){if("function"==typeof fetch&&!ie(e))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at '"+e+"'";return t.arrayBuffer()})).catch((()=>oe(e)));if(m)return new Promise(((t,n)=>{m(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>oe(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{O(`failed to asynchronously prepare wasm: ${e}`),ne(e)}))}ae(re="ort-wasm-simd-threaded.wasm")||(re=C(re));var ue={946748:(e,t,n,a)=>{if(typeof f>"u"||!f.Fb)return 1;if((e=_e(e>>>0)).startsWith("./")&&(e=e.substring(2)),!(e=f.Fb.get(e)))return 2;if(a>>>=0,(t>>>=0)+(n>>>=0)>e.byteLength)return 3;try{return r().set(e.subarray(t,t+n),a>>>0),0}catch{return 4}},947249:e=>f.$b(e),947282:e=>f.bc(e),947314:(e,t,n)=>{f.Ob(e,t,n,!0)},947353:(e,t,n)=>{f.Ob(e,t,n)},947386:e=>{f.eb("Abs",e,void 0)},947437:e=>{f.eb("Neg",e,void 0)},947488:e=>{f.eb("Floor",e,void 0)},947541:e=>{f.eb("Ceil",e,void 0)},947593:e=>{f.eb("Reciprocal",e,void 0)},947651:e=>{f.eb("Sqrt",e,void 0)},947703:e=>{f.eb("Exp",e,void 0)},947754:e=>{f.eb("Erf",e,void 0)},947805:e=>{f.eb("Sigmoid",e,void 0)},947860:(e,t,n)=>{f.eb("HardSigmoid",e,{alpha:t,beta:n})},947939:e=>{f.eb("Log",e,void 0)},947990:e=>{f.eb("Sin",e,void 0)},948041:e=>{f.eb("Cos",e,void 0)},948092:e=>{f.eb("Tan",e,void 0)},948143:e=>{f.eb("Asin",e,void 0)},948195:e=>{f.eb("Acos",e,void 0)},948247:e=>{f.eb("Atan",e,void 0)},948299:e=>{f.eb("Sinh",e,void 0)},948351:e=>{f.eb("Cosh",e,void 0)},948403:e=>{f.eb("Asinh",e,void 0)},948456:e=>{f.eb("Acosh",e,void 0)},948509:e=>{f.eb("Atanh",e,void 0)},948562:e=>{f.eb("Tanh",e,void 0)},948614:e=>{f.eb("Not",e,void 0)},948665:(e,t,n)=>{f.eb("Clip",e,{min:t,max:n})},948734:e=>{f.eb("Clip",e,void 0)},948786:(e,t)=>{f.eb("Elu",e,{alpha:t})},948844:e=>{f.eb("Relu",e,void 0)},948896:(e,t)=>{f.eb("LeakyRelu",e,{alpha:t})},948960:(e,t)=>{f.eb("ThresholdedRelu",e,{alpha:t})},949030:(e,t)=>{f.eb("Cast",e,{to:t})},949088:e=>{f.eb("Add",e,void 0)},949139:e=>{f.eb("Sub",e,void 0)},949190:e=>{f.eb("Mul",e,void 0)},949241:e=>{f.eb("Div",e,void 0)},949292:e=>{f.eb("Pow",e,void 0)},949343:e=>{f.eb("Equal",e,void 0)},949396:e=>{f.eb("Greater",e,void 0)},949451:e=>{f.eb("GreaterOrEqual",e,void 0)},949513:e=>{f.eb("Less",e,void 0)},949565:e=>{f.eb("LessOrEqual",e,void 0)},949624:(e,t,n,r,a)=>{f.eb("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},949783:(e,t,n,r,a)=>{f.eb("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},949941:(e,t,n,r,a)=>{f.eb("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},950099:(e,t,n,r,a)=>{f.eb("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},950258:(e,t,n,r,a)=>{f.eb("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},950416:(e,t,n,r,a)=>{f.eb("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},950573:(e,t,n,r,a)=>{f.eb("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},950730:(e,t,n,r,a)=>{f.eb("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},950891:(e,t,n,r,a)=>{f.eb("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},951055:(e,t,n,r,a)=>{f.eb("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},951219:e=>{f.eb("Where",e,void 0)},951272:(e,t,n)=>{f.eb("Transpose",e,{perm:t?Array.from(s().subarray(t>>>0,n>>>0)):[]})},951380:(e,n,r,a,i,o,u,l,d,p,c,h,m,g,y)=>{f.eb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:a,kernel_shape:[i],pads:[o,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:c?Array.from(s().subarray(c>>>0,h>>>0)):[],outputShape:m?Array.from(s().subarray(m>>>0,g>>>0)):[],activation:_e(y)})},951782:(e,n,r,a,i,o,u,l,d,p,c,h,m,g)=>{f.eb("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(s().subarray(r>>>0,2+(r>>>0)>>>0)),group:a,kernelShape:Array.from(s().subarray(i>>>0,2+(i>>>0)>>>0)),pads:Array.from(s().subarray(o>>>0,4+(o>>>0)>>>0)),strides:Array.from(s().subarray(u>>>0,2+(u>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:p?Array.from(s().subarray(p>>>0,c>>>0)):[],outputShape:h?Array.from(s().subarray(h>>>0,m>>>0)):[],activation:_e(g)})},952347:(e,n,r,a,i,o,u,l,d,p,c,h,m,g,y)=>{f.eb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:a,kernel_shape:[i],pads:[o,u],strides:[l],wIsConst:()=>!!t()[p>>>0],outputPadding:c?Array.from(s().subarray(c>>>0,h>>>0)):[],outputShape:m?Array.from(s().subarray(m>>>0,g>>>0)):[],activation:_e(y)})},952749:(e,n,r,a,i,o,u,l,d,p,c,h,m,g)=>{f.eb("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:n,dilations:Array.from(s().subarray(r>>>0,2+(r>>>0)>>>0)),group:a,kernelShape:Array.from(s().subarray(i>>>0,2+(i>>>0)>>>0)),pads:Array.from(s().subarray(o>>>0,4+(o>>>0)>>>0)),strides:Array.from(s().subarray(u>>>0,2+(u>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:p?Array.from(s().subarray(p>>>0,c>>>0)):[],outputShape:h?Array.from(s().subarray(h>>>0,m>>>0)):[],activation:_e(g)})},953314:(e,t)=>{f.eb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},953405:(e,t,n,r,a,i,o,s,u,l,d,p,c,h,m,g)=>{f.eb("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,c],strides:[h,m]})},953689:(e,t)=>{f.eb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},953780:(e,t,n,r,a,i,o,s,u,l,d,p,c,h,m,g)=>{f.eb("AveragePool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,c],strides:[h,m]})},954064:(e,t)=>{f.eb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},954151:(e,t,n,r,a,i,o,s,u,l,d,p,c,h,m,g)=>{f.eb("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,c],strides:[h,m]})},954431:(e,t)=>{f.eb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},954518:(e,t,n,r,a,i,o,s,u,l,d,p,c,h,m,g)=>{f.eb("MaxPool",e,{format:g?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[l,d,p,c],strides:[h,m]})},954798:(e,t,n,r,a)=>{f.eb("Gemm",e,{alpha:t,beta:n,transA:r,transB:a})},954902:e=>{f.eb("MatMul",e,void 0)},954956:(e,t,n,r)=>{f.eb("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},955064:(e,t,n,r)=>{f.eb("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},955172:(e,t)=>{f.eb("Softmax",e,{axis:t})},955235:(e,t)=>{f.eb("Concat",e,{axis:t})},955295:(e,t,n,r,a)=>{f.eb("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},955435:e=>{f.eb("Expand",e,void 0)},955489:(e,t)=>{f.eb("Gather",e,{axis:Number(t)})},955560:(e,t)=>{f.eb("GatherElements",e,{axis:Number(t)})},955639:(e,t,n,r,a,i,o,u,l,d,p)=>{f.eb("Resize",e,{antialias:t,axes:n?Array.from(s().subarray(n>>>0,r>>>0)):[],coordinateTransformMode:_e(a),cubicCoeffA:i,excludeOutside:o,extrapolationValue:u,keepAspectRatioPolicy:_e(l),mode:_e(d),nearestMode:_e(p)})},955985:(e,t,n,r,a,i,o)=>{f.eb("Slice",e,{starts:t?Array.from(s().subarray(t>>>0,n>>>0)):[],ends:r?Array.from(s().subarray(r>>>0,a>>>0)):[],axes:i?Array.from(s().subarray(i>>>0,o>>>0)):[]})},956201:e=>{f.eb("Tile",e,void 0)},956253:(e,t,n)=>{f.eb("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},956360:(e,t,n)=>{f.eb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},956474:(e,t,n)=>{f.eb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},956588:e=>{f.eb("Range",e,void 0)},956641:(e,t)=>{f.eb("Einsum",e,{equation:_e(t)})},956722:(e,t,n,r,a)=>{f.eb("Pad",e,{mode:t,value:n,pads:r?Array.from(s().subarray(r>>>0,a>>>0)):[]})},956849:(e,t,n,r,a,i)=>{f.eb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!a,trainingMode:!!r,format:i?"NHWC":"NCHW"})},957018:(e,t,n,r,a,i)=>{f.eb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!a,trainingMode:!!r,format:i?"NHWC":"NCHW"})},957187:(e,t,n)=>{f.eb("CumSum",e,{exclusive:Number(t),reverse:Number(n)})},957284:(e,t,n,r,a,i,o,u,l)=>{f.eb("Attention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:a,doRotary:i,qkvHiddenSizes:o?Array.from(s().subarray(Number(u)>>>0,Number(u)+o>>>0)):[],pastPresentShareBuffer:!!l})},957556:e=>{f.eb("Gelu",e,void 0)},957608:(e,t,n,r,a,i)=>{f.eb("MultiHeadAttention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:a,doRotary:i})},957767:e=>{f.eb("BiasAdd",e,void 0)},957822:e=>{f.eb("BiasSplitGelu",e,void 0)},957883:(e,t)=>{f.eb("SkipLayerNormalization",e,{epsilon:t})},957964:(e,n,r,a,i,o,u,d,p,c,h,m,g)=>{f.eb("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:a,kernel_shape:[i],pads:o?Array.from(s().subarray(o>>>0,u>>>0)):[],strides:[d],w_is_const:()=>!!t()[c>>>0],activation:_e(h),activation_params:m?Array.from(l().subarray(m>>>0,g>>>0)):[]})},958334:(e,n,r,a,i,o,u,d,p,c,h,m,g,y,b,w)=>{f.eb("Conv",e,{format:m?"NHWC":"NCHW",auto_pad:n,dilations:[r,a],group:i,kernel_shape:[o,u],pads:d?Array.from(s().subarray(d>>>0,p>>>0)):[],strides:[c,h],w_is_const:()=>!!t()[g>>>0],activation:_e(y),activation_params:b?Array.from(l().subarray(b>>>0,w>>>0)):[]})},958725:e=>{f.cc(e)},958759:(e,t)=>f.dc(e,t,f.Eb.fc,f.Eb.errors)};function de(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var pe=e=>{e.terminate(),e.onmessage=()=>{}},ce=e=>{0==Ae.yb.length&&(Te(),Ae.Pb(Ae.yb[0]));var t=Ae.yb.pop();if(!t)return 6;Ae.zb.push(t),Ae.pb[e.xb]=t,t.xb=e.xb;var n={cmd:"run",start_routine:e.hc,arg:e.Vb,pthread_ptr:e.xb};return _&&t.unref(),t.postMessage(n,e.nc),0},me=0,ye=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,$e=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&ye)return ye.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},_e=(e,t)=>(e>>>=0)?$e(r(),e,t):"",xe=e=>{var t=Tn();return e=e(),An(t),e};function Se(e,t){var n=arguments.length-2,r=arguments;return xe((()=>{for(var a=2*n,i=kn(8*a),o=i>>>3,s=0;s<n;s++){var u=r[2+s];"bigint"==typeof u?(H[o+2*s]=1n,H[o+2*s+1]=u):(H[o+2*s]=0n,d()[o+2*s+1>>>0]=u)}return xn(e,a,i,t)}))}function Ce(e){if(x)return Se(0,1,e);B=e,0<me||(Ae.ic(),f.onExit?.(e),j=!0),w(e,new de(e))}var Ee=e=>{if(B=e,x)throw Oe(e),"unwind";Ce(e)},Ie=e=>{e instanceof de||"unwind"==e||w(1,e)};function Te(){var e=C("ort-wasm-simd-threaded.worker.js");e=new Worker(e),Ae.yb.push(e)}var Ae={yb:[],zb:[],Ub:[],pb:{},Ib(){x?(Ae.receiveObjectTransfer=Ae.ec,Ae.threadInitTLS=Ae.Tb,Ae.setExitStatus=Ae.Sb):function(){for(var e=f.numThreads;e--;)Te();Y.unshift((()=>{X++,function(e){x?e():Promise.all(Ae.yb.map(Ae.Pb)).then(e)}((()=>te()))}))}()},Sb:e=>B=e,sc:["$terminateWorker"],ic:()=>{for(var e of Ae.zb)pe(e);for(e of Ae.yb)pe(e);Ae.yb=[],Ae.zb=[],Ae.pb=[]},Rb:e=>{var t=e.xb;delete Ae.pb[t],Ae.yb.push(e),Ae.zb.splice(Ae.zb.indexOf(e),1),e.xb=0,Sn(t)},ec(){},Tb(){Ae.Ub.forEach((e=>e()))},Pb:e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=yn()){var a=Ae.pb[n.targetThread];a?a.postMessage(n,n.transferList):O(`Internal error! Worker sent a message "${r}" to target pthread ${n.targetThread}, but that thread no longer exists!`)}else"checkMailbox"===r?xt():"spawnThread"===r?ce(n):"cleanupThread"===r?Ae.Rb(Ae.pb[n.thread]):"killThread"===r?(n=n.thread,r=Ae.pb[n],delete Ae.pb[n],pe(r),Sn(n),Ae.zb.splice(Ae.zb.indexOf(r),1),r.xb=0):"cancelThread"===r?Ae.pb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,_&&!e.xb&&e.unref(),t(e)):"alert"===r?alert(`Thread ${n.threadId}: ${n.text}`):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?f[n.handler](...n.args):r&&O(`worker sent an unknown command ${r}`)},e.onerror=e=>{throw O(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e},_&&(e.on("message",(t=>e.onmessage({data:t}))),e.on("error",(t=>e.onerror(t))));var n,r=[];for(n of["onExit"])f.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,urlOrBlob:f.mainScriptUrlOrBlob||o,wasmMemory:R,wasmModule:z})}))};f.PThread=Ae;var ke=e=>{for(;0<e.length;)e.shift()(f)};function Oe(e){if(x)return Se(1,0,e);Ee(e)}function Re(e){this.Db=e-24,this.pc=function(e){u()[this.Db+4>>>2>>>0]=e},this.Mb=function(e){u()[this.Db+8>>>2>>>0]=e},this.Ib=function(e,t){this.Kb(),this.pc(e),this.Mb(t)},this.Kb=function(){u()[this.Db+16>>>2>>>0]=0}}function ze(e,t,n,r){return x?Se(2,1,e,t,n,r):Be(e,t,n,r)}function Be(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,typeof SharedArrayBuffer>"u")return O("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return x&&0===a.length?ze(e,t,n,r):(e={hc:n,xb:e,Vb:r,nc:a},x?(e.qc="spawnThread",postMessage(e,a),0):ce(e))}function Pe(e,t,n){return x?Se(3,1,e,t,n):0}function Me(e,t){if(x)return Se(4,1,e,t)}f.establishStackSpace=()=>{var e=yn(),t=u()[e+52>>>2>>>0];e=u()[e+56>>>2>>>0],In(t,t-e),An(t)},f.invokeEntryPoint=(e,t)=>{e=On.apply(null,[e,t]),0<me?Ae.Sb(e):Cn(e)};var De=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Ne=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},We=(e,t,n)=>Ne(e,r(),t,n);function Ue(e,t){if(x)return Se(5,1,e,t)}function Ve(e,t,n){if(x)return Se(6,1,e,t,n)}function He(e,t,n){return x?Se(7,1,e,t,n):0}function Le(e,t){if(x)return Se(8,1,e,t)}function Fe(e,t,n){if(x)return Se(9,1,e,t,n)}function Ge(e,t,n,r){if(x)return Se(10,1,e,t,n,r)}function je(e,t,n,r){if(x)return Se(11,1,e,t,n,r)}function qe(e,t,n,r){if(x)return Se(12,1,e,t,n,r)}function Ke(e){if(x)return Se(13,1,e)}function Ye(e,t){if(x)return Se(14,1,e,t)}function Ze(e,t,n){if(x)return Se(15,1,e,t,n)}var Qe,Xe,Je=e=>{if(null===e)return"null";var t=typeof e;return"object"===t||"array"===t||"function"===t?e.toString():""+e},et=e=>{for(var t="";r()[e>>>0];)t+=Qe[r()[e++>>>0]];return t},tt={},nt={},rt={};function at(e,t,n={}){if(!("argPackAdvance"in t))throw new TypeError("registerType registeredInstance requires argPackAdvance");!function(e,t,n={}){var r=t.name;if(!e)throw new Xe(`type "${r}" must have a positive integer typeid pointer`);if(nt.hasOwnProperty(e)){if(n.Yb)return;throw new Xe(`Cannot register type '${r}' twice`)}nt[e]=t,delete rt[e],tt.hasOwnProperty(e)&&(t=tt[e],delete tt[e],t.forEach((e=>e())))}(e,t,n)}var it=(e,n,o)=>{switch(n){case 1:return o?e=>t()[e>>>0>>>0]:e=>r()[e>>>0>>>0];case 2:return o?e=>a()[e>>>1>>>0]:e=>i()[e>>>1>>>0];case 4:return o?e=>s()[e>>>2>>>0]:e=>u()[e>>>2>>>0];case 8:return o?e=>H[e>>>3]:e=>F[e>>>3];default:throw new TypeError(`invalid integer width (${n}): ${e}`)}};function ot(){this.wb=[void 0],this.Nb=[]}var st=new ot;function ut(e){(e>>>=0)>=st.Db&&0==--st.get(e).Qb&&st.Mb(e)}var lt=e=>{if(!e)throw new Xe("Cannot use deleted val. handle = "+e);return st.get(e).value},dt=e=>{switch(e){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return st.Kb({Qb:1,value:e})}};function pt(e){return this.fromWireType(s()[e>>>2>>>0])}var ct=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(l()[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(d()[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function ft(e){return this.fromWireType(u()[e>>>2>>>0])}var ht=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,mt=(e,t)=>{for(var n=e>>1,o=n+t/2;!(n>=o)&&i()[n>>>0];)++n;if(32<(n<<=1)-e&&ht)return ht.decode(r().slice(e,n));for(n="",o=0;!(o>=t/2);++o){var s=a()[e+2*o>>>1>>>0];if(0==s)break;n+=String.fromCharCode(s)}return n},gt=(e,t,n)=>{if(n??=2147483647,2>n)return 0;var r=t;n=(n-=2)<2*e.length?n/2:e.length;for(var i=0;i<n;++i){var o=e.charCodeAt(i);a()[t>>>1>>>0]=o,t+=2}return a()[t>>>1>>>0]=0,t-r},yt=e=>2*e.length,bt=(e,t)=>{for(var n=0,r="";!(n>=t/4);){var a=s()[e+4*n>>>2>>>0];if(0==a)break;++n,65536<=a?(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a)):r+=String.fromCharCode(a)}return r},wt=(e,t,n)=>{if(t>>>=0,n??=2147483647,4>n)return 0;var r=t;n=r+n-4;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),s()[t>>>2>>>0]=i,(t+=4)+4>n)break}return s()[t>>>2>>>0]=0,t-r},vt=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&++n,t+=4}return t},$t=()=>{if(!(0<me))try{x?Cn(B):Ee(B)}catch(e){Ie(e)}};function _t(e){e>>>=0,"function"==typeof Atomics.oc&&(Atomics.oc(s(),e>>>2,e).value.then(xt),e+=128,Atomics.store(s(),e>>>2,1))}f.__emscripten_thread_mailbox_await=_t;var xt=()=>{var e=yn();if(e&&(_t(e),!j))try{En(),$t()}catch(e){Ie(e)}};f.checkMailbox=xt;var St=[],Ct=(e,t)=>{var n=nt[e];if(void 0===n)throw e=vn(e),n=et(e),wn(e),new Xe(t+" has unknown type "+n);return n},Et=(e,t,n)=>{var r=[];return e=e.toWireType(r,n),r.length&&(u()[t>>>2>>>0]=dt(r)),e},It=e=>{try{e()}catch(e){ne(e)}},Tt=0,At=null,kt=0,Ot=[],Rt={},zt={},Bt=0,Pt=null,Mt=[];function Dt(e){return function(e){if(!j){if(0===Tt){var t=!1,n=!1;e(((e=0)=>{if(!j&&(kt=e,t=!0,n)){Tt=2,It((()=>Bn(At))),typeof Browser<"u"&&Browser.Jb.Xb&&Browser.Jb.resume(),e=!1;try{var r=function(){var e=s()[At+8>>>2>>>0];return e=mn[zt[e]],--me,e()}()}catch(t){r=t,e=!0}var a=!1;if(!At){var i=Pt;i&&(Pt=null,(e?i.reject:i.resolve)(r),a=!0)}if(e&&!a)throw r}})),n=!0,t||(Tt=1,At=function(){var e=bn(65548),t=e+12;u()[e>>>2>>>0]=t,u()[e+4>>>2>>>0]=t+65536,t=Ot[0];var n=Rt[t];return void 0===n&&(n=Bt++,Rt[t]=n,zt[n]=t),t=n,s()[e+8>>>2>>>0]=t,e}(),typeof Browser<"u"&&Browser.Jb.Xb&&Browser.Jb.pause(),It((()=>Rn(At))))}else 2===Tt?(Tt=0,It(Pn),wn(At),At=null,Mt.forEach((e=>{if(!j)try{e(),$t()}catch(e){Ie(e)}}))):ne(`invalid state: ${Tt}`);return kt}}((t=>{e().then(t)}))}var Nt=[],Wt={},Ut=e=>{var t=Wt[e];return void 0===t?et(e):t},Vt=()=>"object"==typeof globalThis?globalThis:Function("return this")(),Ht=(e,t)=>Object.defineProperty(t,"name",{value:e}),Lt=e=>e%4==0&&(e%100!=0||e%400==0),Ft=[0,31,60,91,121,152,182,213,244,274,305,335],Gt=[0,31,59,90,120,151,181,212,243,273,304,334];function jt(e,t,n,r,a,i,o){return x?Se(16,1,e,t,n,r,a,i,o):-52}function qt(e,t,n,r,a,i){if(x)return Se(17,1,e,t,n,r,a,i)}var Kt,Yt=e=>{var t=De(e)+1,n=bn(t);return n&&We(e,n,t),n},Zt=[],Qt=(e,t)=>{Zt.length=0;for(var n;n=r()[e++>>>0];){var a=105!=n;t+=(a&=112!=n)&&t%8?4:0,Zt.push(112==n?u()[t>>>2>>>0]:106==n?H[t>>>3]:105==n?s()[t>>>2>>>0]:d()[t>>>3>>>0]),t+=a?8:4}return Zt},Xt={},Jt=()=>{if(!Kt){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"};for(e in Xt)void 0===Xt[e]?delete t[e]:t[e]=Xt[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Kt=n}return Kt};function en(e,n){if(x)return Se(18,1,e,n);e>>>=0,n>>>=0;var r=0;return Jt().forEach(((a,i)=>{var o=n+r;for(i=u()[e+4*i>>>2>>>0]=o,o=0;o<a.length;++o)t()[i++>>>0>>>0]=a.charCodeAt(o);t()[i>>>0>>>0]=0,r+=a.length+1})),0}function tn(e,t){if(x)return Se(19,1,e,t);e>>>=0,t>>>=0;var n=Jt();u()[e>>>2>>>0]=n.length;var r=0;return n.forEach((e=>r+=e.length+1)),u()[t>>>2>>>0]=r,0}function nn(e){return x?Se(20,1,e):52}function rn(e,t,n,r){return x?Se(21,1,e,t,n,r):52}function an(e,t,n,r){return x?Se(22,1,e,t,n,r):70}var on=[null,[],[]];function sn(e,t,n,a){if(x)return Se(23,1,e,t,n,a);t>>>=0,n>>>=0,a>>>=0;for(var i=0,o=0;o<n;o++){var s=u()[t>>>2>>>0],l=u()[t+4>>>2>>>0];t+=8;for(var d=0;d<l;d++){var p=r()[s+d>>>0],c=on[e];0===p||10===p?((1===e?k:O)($e(c,0)),c.length=0):c.push(p)}i+=l}return u()[a>>>2>>>0]=i,0}var un=[31,29,31,30,31,30,31,31,30,31,30,31],ln=[31,28,31,30,31,30,31,31,30,31,30,31];function dn(e,n,r,a){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return i(e,t,"0")}function l(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function d(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function p(e){var t=e.Ab;for(e=new Date(new Date(e.Bb+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Lt(e.getFullYear())?un:ln)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=d(new Date(e.getFullYear(),0,4)),n=d(n),0>=l(t,e)?0>=l(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,n>>>=0,r>>>=0,a>>>=0;var c=u()[a+40>>>2>>>0];for(var f in a={lc:s()[a>>>2>>>0],kc:s()[a+4>>>2>>>0],Gb:s()[a+8>>>2>>>0],Lb:s()[a+12>>>2>>>0],Hb:s()[a+16>>>2>>>0],Bb:s()[a+20>>>2>>>0],vb:s()[a+24>>>2>>>0],Ab:s()[a+28>>>2>>>0],tc:s()[a+32>>>2>>>0],jc:s()[a+36>>>2>>>0],mc:c?_e(c):""},r=_e(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),c[f]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(f in c={"%a":e=>h[e.vb].substring(0,3),"%A":e=>h[e.vb],"%b":e=>m[e.Hb].substring(0,3),"%B":e=>m[e.Hb],"%C":e=>o((e.Bb+1900)/100|0,2),"%d":e=>o(e.Lb,2),"%e":e=>i(e.Lb,2," "),"%g":e=>p(e).toString().substring(2),"%G":e=>p(e),"%H":e=>o(e.Gb,2),"%I":e=>(0==(e=e.Gb)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Hb-1;t+=(Lt(e.Bb+1900)?un:ln)[n++]);return o(e.Lb+t,3)},"%m":e=>o(e.Hb+1,2),"%M":e=>o(e.kc,2),"%n":()=>"\n","%p":e=>0<=e.Gb&&12>e.Gb?"AM":"PM","%S":e=>o(e.lc,2),"%t":()=>"\t","%u":e=>e.vb||7,"%U":e=>o(Math.floor((e.Ab+7-e.vb)/7),2),"%V":e=>{var t=Math.floor((e.Ab+7-(e.vb+6)%7)/7);if(2>=(e.vb+371-e.Ab-2)%7&&t++,t)53==t&&(4==(n=(e.vb+371-e.Ab)%7)||3==n&&Lt(e.Bb)||(t=1));else{t=52;var n=(e.vb+7-e.Ab-1)%7;(4==n||5==n&&Lt(e.Bb%400-1))&&t++}return o(t,2)},"%w":e=>e.vb,"%W":e=>o(Math.floor((e.Ab+7-(e.vb+6)%7)/7),2),"%y":e=>(e.Bb+1900).toString().substring(2),"%Y":e=>e.Bb+1900,"%z":e=>(0<=(e=e.jc)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.mc,"%%":()=>"%"},r=r.replace(/%%/g,"\0\0"),c)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),c[f](a)));return f=function(e){var t=Array(De(e)+1);return Ne(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),f.length>n?0:(((e,n)=>{t().set(e,n>>>0)})(f,e),f.length-1)}Ae.Ib();for(var pn=Array(256),cn=0;256>cn;++cn)pn[cn]=String.fromCharCode(cn);Qe=pn,Xe=f.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},f.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},Object.assign(ot.prototype,{get(e){return this.wb[e]},has(e){return void 0!==this.wb[e]},Kb(e){var t=this.Nb.pop()||this.wb.length;return this.wb[t]=e,t},Mb(e){this.wb[e]=void 0,this.Nb.push(e)}}),st.wb.push({value:void 0},{value:null},{value:!0},{value:!1}),st.Db=st.wb.length,f.count_emval_handles=()=>{for(var e=0,t=st.Db;t<st.wb.length;++t)void 0!==st.wb[t]&&++e;return e};var fn=[Ce,Oe,ze,Pe,Me,Ue,Ve,He,Le,Fe,Ge,je,qe,Ke,Ye,Ze,jt,qt,en,tn,nn,rn,an,sn],hn={ua:function(e,t,n){return Dt((async()=>{await f.ac(e,t,n)}))},b:function(e,t,n){throw new Re(e>>>=0).Ib(t>>>0,n>>>0),e},fa:function(e){$n(e>>>0,!$,1,!v,131072,!1),Ae.Tb()},D:function(e){e>>>=0,x?postMessage({cmd:"cleanupThread",thread:e}):Ae.Rb(Ae.pb[e])},X:Be,z:Pe,la:Me,T:Ue,V:Ve,ma:He,ja:Le,ca:Fe,ia:Ge,H:je,U:qe,R:Ke,ka:Ye,S:Ze,K:function(e,t,n,r,a){e>>>=0,n>>>=0;var i=-1!=(t=et(t>>>=0)).indexOf("u");i&&(a=(1n<<64n)-1n),at(e,{name:t,fromWireType:e=>e,toWireType:function(e,n){if("bigint"!=typeof n&&"number"!=typeof n)throw new TypeError(`Cannot convert "${Je(n)}" to ${this.name}`);if(n<r||n>a)throw new TypeError(`Passing a number "${Je(n)}" from JS side to C/C++ side to an argument of type "${t}", which is outside the valid range [${r}, ${a}]!`);return n},argPackAdvance:8,readValueFromPointer:it(t,n,!i),Cb:null})},sa:function(e,t,n,a){at(e>>>=0,{name:t=et(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?n:a},argPackAdvance:8,readValueFromPointer:function(e){return this.fromWireType(r()[e>>>0])},Cb:null})},ra:function(e,t){at(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>{var t=lt(e);return ut(e),t},toWireType:(e,t)=>dt(t),argPackAdvance:8,readValueFromPointer:pt,Cb:null})},J:function(e,t,n){n>>>=0,at(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,argPackAdvance:8,readValueFromPointer:ct(t,n),Cb:null})},v:function(e,t,n,r,a){if(e>>>=0,n>>>=0,t=et(t>>>0),-1===a&&(a=4294967295),a=e=>e,0===r){var i=32-8*n;a=e=>e<<i>>>i}var o=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};at(e,{name:t,fromWireType:a,toWireType:o,argPackAdvance:8,readValueFromPointer:it(t,n,0!==r),Cb:null})},o:function(e,n,r){function a(e){var n=u()[e>>>2>>>0];return e=u()[e+4>>>2>>>0],new i(t().buffer,e,n)}var i=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][n];at(e>>>=0,{name:r=et(r>>>0),fromWireType:a,argPackAdvance:8,readValueFromPointer:a},{Yb:!0})},L:function(e,t){e>>>=0;var n="std::string"===(t=et(t>>>0));at(e,{name:t,fromWireType:function(e){var t=u()[e>>>2>>>0],a=e+4;if(n)for(var i=a,o=0;o<=t;++o){var s=a+o;if(o==t||0==r()[s>>>0]){if(i=_e(i,s-i),void 0===l)var l=i;else l+=String.fromCharCode(0),l+=i;i=s+1}}else{for(l=Array(t),o=0;o<t;++o)l[o]=String.fromCharCode(r()[a+o>>>0]);l=l.join("")}return wn(e),l},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var a="string"==typeof t;if(!(a||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new Xe("Cannot pass non-string to std::string");var i=n&&a?De(t):t.length,o=bn(4+i+1),s=o+4;if(u()[o>>>2>>>0]=i,n&&a)We(t,s,i+1);else if(a)for(a=0;a<i;++a){var l=t.charCodeAt(a);if(255<l)throw wn(s),new Xe("String has UTF-16 code units that do not fit in 8 bits");r()[s+a>>>0]=l}else for(a=0;a<i;++a)r()[s+a>>>0]=t[a];return null!==e&&e.push(wn,o),o},argPackAdvance:8,readValueFromPointer:ft,Cb(e){wn(e)}})},B:function(e,t,n){if(e>>>=0,t>>>=0,n=et(n>>>=0),2===t)var r=mt,a=gt,o=yt,s=()=>i(),l=1;else 4===t&&(r=bt,a=wt,o=vt,s=()=>u(),l=2);at(e,{name:n,fromWireType:e=>{for(var n,a=u()[e>>>2>>>0],i=s(),o=e+4,d=0;d<=a;++d){var p=e+4+d*t;(d==a||0==i[p>>>l])&&(o=r(o,p-o),void 0===n?n=o:(n+=String.fromCharCode(0),n+=o),o=p+t)}return wn(e),n},toWireType:(e,r)=>{if("string"!=typeof r)throw new Xe(`Cannot pass non-string to C++ string type ${n}`);var i=o(r),s=bn(4+i+t);return u()[s>>>2]=i>>l,a(r,s+4,i+t),null!==e&&e.push(wn,s),s},argPackAdvance:8,readValueFromPointer:pt,Cb(e){wn(e)}})},ta:function(e,t){at(e>>>=0,{Zb:!0,name:t=et(t>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},qa:()=>1,P:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>xt())):x?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=Ae.pb[e])&&e.postMessage({cmd:"checkMailbox"})},Y:function(e,t,n,r){t>>>=0,n/=2,St.length=n,r=r>>>0>>>3;for(var a=0;a<n;a++)St[a]=H[r+2*a]?H[r+2*a+1]:d()[r+2*a+1>>>0];return e=0>e?ue[-e-1]:fn[e],Ae.Wb=t,t=e.apply(null,St),Ae.Wb=0,t},ea:_t,pa:function(e){_&&Ae.pb[e>>>0].ref()},t:function(e,t,n){return t>>>=0,n>>>=0,e=lt(e>>>0),t=Ct(t,"emval::as"),Et(t,n,e)},y:function(e){return e>>>=0,Dt((()=>(e=lt(e)).then(dt)))},p:function(e,t,n,r){return n>>>=0,r>>>=0,(e=Nt[e>>>0])(null,t=lt(t>>>0),n,r)},k:function(e,t,n,r,a){return n>>>=0,r>>>=0,a>>>=0,(e=Nt[e>>>0])(t=lt(t>>>0),t[n=Ut(n)],r,a)},c:ut,C:function(e,t){return t>>>=0,(e=lt(e>>>0))==lt(t)},n:function(e){return 0==(e>>>=0)?dt(Vt()):(e=Ut(e),dt(Vt()[e]))},j:function(e,t,n){t=((e,t)=>{for(var n=Array(e),r=0;r<e;++r)n[r]=Ct(u()[t+4*r>>>2>>>0],"parameter "+r);return n})(e,t>>>0);var r=t.shift();e--;var a="return function (obj, func, destructorsRef, args) {\n",i=0,o=[];0===n&&o.push("obj");for(var s=["retType"],l=[r],d=0;d<e;++d)o.push("arg"+d),s.push("argType"+d),l.push(t[d]),a+=`  var arg${d} = argType${d}.readValueFromPointer(args${i?"+"+i:""});\n`,i+=t[d].argPackAdvance;for(a+=`  var rv = ${1===n?"new func":"func.call"}(${o.join(", ")});\n`,d=0;d<e;++d)t[d].deleteObject&&(a+=`  argType${d}.deleteObject(arg${d});\n`);return r.Zb||(s.push("emval_returnValue"),l.push(Et),a+="  return emval_returnValue(retType, destructorsRef, rv);\n"),s.push(a+"};\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var n=Ht(t.name||"unknownFunctionName",(function(){}));return n.prototype=t.prototype,n=new n,(e=t.apply(n,e))instanceof Object?e:n}(s).apply(null,l),n=`methodCaller<(${t.map((e=>e.name)).join(", ")}) => ${r.name}>`,(e=>{var t=Nt.length;return Nt.push(e),t})(Ht(n,e))},s:function(e,t){return t>>>=0,e=lt(e>>>0),t=lt(t),dt(e[t])},e:function(e){4<(e>>>=0)&&(st.get(e).Qb+=1)},w:function(){return dt([])},m:function(e){e=lt(e>>>0);for(var t=Array(e.length),n=0;n<e.length;n++)t[n]=e[n];return dt(t)},f:function(e){return dt(Ut(e>>>0))},l:function(){return dt({})},i:function(e){for(var t=lt(e>>>=0);t.length;){var n=t.pop();t.pop()(n)}ut(e)},h:function(e,t,n){t>>>=0,n>>>=0,e=lt(e>>>0),t=lt(t),n=lt(n),e[t]=n},d:function(e,t){return t>>>=0,e=(e=Ct(e>>>0,"_emval_take_value")).readValueFromPointer(t),dt(e)},$:function(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),s()[t>>>2>>>0]=e.getUTCSeconds(),s()[t+4>>>2>>>0]=e.getUTCMinutes(),s()[t+8>>>2>>>0]=e.getUTCHours(),s()[t+12>>>2>>>0]=e.getUTCDate(),s()[t+16>>>2>>>0]=e.getUTCMonth(),s()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,s()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[t+28>>>2>>>0]=e},aa:function(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),s()[t>>>2>>>0]=e.getSeconds(),s()[t+4>>>2>>>0]=e.getMinutes(),s()[t+8>>>2>>>0]=e.getHours(),s()[t+12>>>2>>>0]=e.getDate(),s()[t+16>>>2>>>0]=e.getMonth(),s()[t+20>>>2>>>0]=e.getFullYear()-1900,s()[t+24>>>2>>>0]=e.getDay();var n=(Lt(e.getFullYear())?Ft:Gt)[e.getMonth()]+e.getDate()-1|0;s()[t+28>>>2>>>0]=n,s()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n)),s()[t+32>>>2>>>0]=e},ba:function(e){e>>>=0;var t=new Date(s()[e+20>>>2>>>0]+1900,s()[e+16>>>2>>>0],s()[e+12>>>2>>>0],s()[e+8>>>2>>>0],s()[e+4>>>2>>>0],s()[e>>>2>>>0],0),n=s()[e+32>>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,a);return 0>n?s()[e+32>>>2>>>0]=+(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),s()[e+24>>>2>>>0]=t.getDay(),n=(Lt(t.getFullYear())?Ft:Gt)[t.getMonth()]+t.getDate()-1|0,s()[e+28>>>2>>>0]=n,s()[e>>>2>>>0]=t.getSeconds(),s()[e+4>>>2>>>0]=t.getMinutes(),s()[e+8>>>2>>>0]=t.getHours(),s()[e+12>>>2>>>0]=t.getDate(),s()[e+16>>>2>>>0]=t.getMonth(),s()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),isNaN(e)?(s()[gn()>>>2>>>0]=61,e=-1):e/=1e3,BigInt(e)},Z:jt,_:qt,O:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var l=o.getTimezoneOffset(),d=Math.max(a,l);u()[e>>>2>>>0]=60*d,s()[t>>>2>>>0]=+(a!=l),e=r(i),t=r(o),e=Yt(e),t=Yt(t),l<a?(u()[n>>>2>>>0]=e,u()[n+4>>>2>>>0]=t):(u()[n>>>2>>>0]=t,u()[n+4>>>2>>>0]=e)},q:()=>{ne("")},g:function(e,t,n){return e>>>=0,t=Qt(t>>>0,n>>>0),ue[e].apply(null,t)},M:function(e,t,n){return e>>>=0,t=Qt(t>>>0,n>>>0),ue[e].apply(null,t)},E:()=>{},I:()=>Date.now(),oa:()=>{throw me+=1,"unwind"},Q:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>_?(hs(),L(ve)).cpus().length:navigator.hardwareConcurrency,N:function(e){e>>>=0;var t=r().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var i=Math;a=Math.max(e,a);e:{i=(i.min.call(i,4294901760,a+(65536-a%65536)%65536)-R.buffer.byteLength+65535)/65536;try{R.grow(i),q();var o=1;break e}catch{}o=void 0}if(o)return!0}return!1},ga:en,ha:tn,W:Ee,A:nn,G:rn,da:an,F:sn,a:R||f.wasmMemory,na:dn,r:function(e,t,n,r){return dn(e>>>0,t>>>0,n>>>0,r>>>0)}},mn=function(){function e(e,t){return mn=e.exports,mn=function(){var e=mn,t={};for(let[n,r]of Object.entries(e))t[n]="function"==typeof r?function(){Ot.push(n);try{return r.apply(null,arguments)}finally{j||(Ot.pop(),At&&1===Tt&&0===Ot.length&&(Tt=0,me+=1,It(zn),typeof Fibers<"u"&&Fibers.uc()))}}:r;return t}(),mn=function(){var e=mn,t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).Za=t(e.Za),e._a=t(e._a),e.$a=n(e.$a),e.cb=n(e.cb),e.emscripten_main_runtime_thread_id=t(e.emscripten_main_runtime_thread_id),e.mb=t(e.mb),e.ob=n(e.ob),e}(),Ae.Ub.push(mn.bb),Z.unshift(mn.va),z=t,te(),mn}var t={a:hn};if(X++,f.instantiateWasm)try{return f.instantiateWasm(t,e)}catch(e){O(`Module.instantiateWasm callback failed with error: ${e}`),c(e)}return function(e,t){var n=re;return"function"!=typeof WebAssembly.instantiateStreaming||ae(n)||ie(n)||_||"function"!=typeof fetch?se(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return O(`wasm streaming compile failed: ${r}`),O("falling back to ArrayBuffer instantiation"),se(n,e,t)}))))}(t,(function(t){e(t.instance,t.module)})).catch(c),{}}();f._OrtInit=(e,t)=>(f._OrtInit=mn.wa)(e,t),f._OrtGetLastError=(e,t)=>(f._OrtGetLastError=mn.xa)(e,t),f._OrtCreateSessionOptions=(e,t,n,r,a,i,o,s,u,l)=>(f._OrtCreateSessionOptions=mn.ya)(e,t,n,r,a,i,o,s,u,l),f._OrtAppendExecutionProvider=(e,t)=>(f._OrtAppendExecutionProvider=mn.za)(e,t),f._OrtAddFreeDimensionOverride=(e,t,n)=>(f._OrtAddFreeDimensionOverride=mn.Aa)(e,t,n),f._OrtAddSessionConfigEntry=(e,t,n)=>(f._OrtAddSessionConfigEntry=mn.Ba)(e,t,n),f._OrtReleaseSessionOptions=e=>(f._OrtReleaseSessionOptions=mn.Ca)(e),f._OrtCreateSession=(e,t,n)=>(f._OrtCreateSession=mn.Da)(e,t,n),f._OrtReleaseSession=e=>(f._OrtReleaseSession=mn.Ea)(e),f._OrtGetInputOutputCount=(e,t,n)=>(f._OrtGetInputOutputCount=mn.Fa)(e,t,n),f._OrtGetInputName=(e,t)=>(f._OrtGetInputName=mn.Ga)(e,t),f._OrtGetOutputName=(e,t)=>(f._OrtGetOutputName=mn.Ha)(e,t),f._OrtFree=e=>(f._OrtFree=mn.Ia)(e),f._OrtCreateTensor=(e,t,n,r,a,i)=>(f._OrtCreateTensor=mn.Ja)(e,t,n,r,a,i),f._OrtGetTensorData=(e,t,n,r,a)=>(f._OrtGetTensorData=mn.Ka)(e,t,n,r,a),f._OrtReleaseTensor=e=>(f._OrtReleaseTensor=mn.La)(e),f._OrtCreateRunOptions=(e,t,n,r)=>(f._OrtCreateRunOptions=mn.Ma)(e,t,n,r),f._OrtAddRunConfigEntry=(e,t,n)=>(f._OrtAddRunConfigEntry=mn.Na)(e,t,n),f._OrtReleaseRunOptions=e=>(f._OrtReleaseRunOptions=mn.Oa)(e),f._OrtCreateBinding=e=>(f._OrtCreateBinding=mn.Pa)(e),f._OrtBindInput=(e,t,n)=>(f._OrtBindInput=mn.Qa)(e,t,n),f._OrtBindOutput=(e,t,n,r)=>(f._OrtBindOutput=mn.Ra)(e,t,n,r),f._OrtClearBoundOutputs=e=>(f._OrtClearBoundOutputs=mn.Sa)(e),f._OrtReleaseBinding=e=>(f._OrtReleaseBinding=mn.Ta)(e),f._OrtRunWithBinding=(e,t,n,r,a)=>(f._OrtRunWithBinding=mn.Ua)(e,t,n,r,a),f._OrtRun=(e,t,n,r,a,i,o,s)=>(f._OrtRun=mn.Va)(e,t,n,r,a,i,o,s),f._OrtEndProfiling=e=>(f._OrtEndProfiling=mn.Wa)(e),f._JsepOutput=(e,t,n)=>(f._JsepOutput=mn.Xa)(e,t,n),f._JsepGetNodeName=e=>(f._JsepGetNodeName=mn.Ya)(e);var gn=()=>(gn=mn.Za)(),yn=f._pthread_self=()=>(yn=f._pthread_self=mn._a)(),bn=f._malloc=e=>(bn=f._malloc=mn.$a)(e),wn=f._free=e=>(wn=f._free=mn.ab)(e);f.__emscripten_tls_init=()=>(f.__emscripten_tls_init=mn.bb)();var vn=e=>(vn=mn.cb)(e);f.__embind_initialize_bindings=()=>(f.__embind_initialize_bindings=mn.db)();var $n=f.__emscripten_thread_init=(e,t,n,r,a,i)=>($n=f.__emscripten_thread_init=mn.fb)(e,t,n,r,a,i);f.__emscripten_thread_crashed=()=>(f.__emscripten_thread_crashed=mn.gb)();var _n,xn=(e,t,n,r)=>(xn=mn.hb)(e,t,n,r),Sn=e=>(Sn=mn.ib)(e),Cn=f.__emscripten_thread_exit=e=>(Cn=f.__emscripten_thread_exit=mn.jb)(e),En=()=>(En=mn.kb)(),In=(e,t)=>(In=mn.lb)(e,t),Tn=()=>(Tn=mn.mb)(),An=e=>(An=mn.nb)(e),kn=e=>(kn=mn.ob)(e),On=f.dynCall_ii=(e,t)=>(On=f.dynCall_ii=mn.qb)(e,t),Rn=e=>(Rn=mn.rb)(e),zn=()=>(zn=mn.sb)(),Bn=e=>(Bn=mn.tb)(e),Pn=()=>(Pn=mn.ub)();function Mn(){if(!(0<X))if(x)p(f),x||ke(Z),startWorker(f);else{if(f.preRun)for("function"==typeof f.preRun&&(f.preRun=[f.preRun]);f.preRun.length;)Y.unshift(f.preRun.shift());ke(Y),0<X||_n||(_n=!0,f.calledRun=!0,j||(x||ke(Z),p(f),x||ke(Q)))}}return f.___start_em_js=958871,f.___stop_em_js=959032,f.wasmMemory=R,f.stackAlloc=kn,f.stackSave=Tn,f.stackRestore=An,f.keepRuntimeAlive=()=>0<me,f.UTF8ToString=_e,f.stringToUTF8=We,f.lengthBytesUTF8=De,f.ExitStatus=de,f.PThread=Ae,ee=function e(){_n||Mn(),_n||(ee=e)},Mn(),e.ready});"object"==typeof a&&"object"==typeof i?i.exports=s:void 0===(r=(()=>s).apply(t,[]))||(e.exports=r)})),gs=V(((e,t)=>{t.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\n'})),ys=U((()=>{_e=ye(),xe=ms(),Ce=!1,Ee=!1,Ie=!1,Te=e=>{if(1===e)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+e+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+e+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Ae=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},ke=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Oe=async e=>{if(Ce)return Promise.resolve();if(Ee)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ie)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ee=!0;let t=e.initTimeout,n=e.numThreads,r=e.simd,a=Te(n),i=r&&Ae(),o=e.wasmPaths,s="string"==typeof o?o:void 0,u=ke(i,a),l="object"==typeof o?o[u]:void 0,d=!1,p=[];if(t>0&&p.push(new Promise((e=>{setTimeout((()=>{d=!0,e()}),t)}))),p.push(new Promise(((e,t)=>{let r=a?xe:_e,i={locateFile:(e,t)=>{if(a&&e.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([gs()],{type:"text/javascript"}));if(e.endsWith(".wasm")){if(l)return l;let e=s??t;return"ort-wasm-simd.wasm"===u?e+"ort-wasm-simd.jsep.wasm":"ort-wasm-simd-threaded.wasm"===u?e+"ort-wasm-simd-threaded.jsep.wasm":e+u}return t+e}};if(a)if(i.numThreads=n,typeof Blob>"u")i.mainScriptUrlOrBlob=(void 0)("/","ort-wasm-threaded.js");else{let e=`var ortWasmThreaded=${r.toString()};`;i.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(i).then((t=>{Ee=!1,Ce=!0,Se=t,e()}),(e=>{Ee=!1,Ie=!0,t(e)}))}))),await Promise.race(p),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(Ce&&Se)return Se;throw new Error("WebAssembly is not initialized yet.")}})),bs=U((()=>{ys(),ze=(e,t)=>{let n=Re(),r=n.lengthBytesUTF8(e)+1,a=n._malloc(r);return n.stringToUTF8(e,a,r),t.push(a),a},Be=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,a])=>{let i=t?t+e:e;if("object"==typeof a)Be(a,i+".",n,r);else if("string"==typeof a||"number"==typeof a)r(i,a.toString());else{if("boolean"!=typeof a)throw new Error("Can't handle extra config type: "+typeof a);r(i,a?"1":"0")}}))},Pe=e=>{let t=Re(),n=t.stackSave();try{let n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);let r=t.HEAP32[n/4],a=t.HEAPU32[n/4+1],i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}})),ws=U((()=>{ys(),bs(),Me=e=>{let t=Re(),n=0,r=[],a=e||{};try{if(void 0===e?.logSeverityLevel)a.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)a.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(a.terminate=!1);let i=0;return void 0!==e?.tag&&(i=ze(e.tag,r)),n=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,i),0===n&&Pe("Can't create run options."),void 0!==e?.extra&&Be(e.extra,"",new WeakSet,((e,a)=>{let i=ze(e,r),o=ze(a,r);0!==t._OrtAddRunConfigEntry(n,i,o)&&Pe(`Can't set a run config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),vs=U((()=>{ys(),bs(),De=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ne=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},We=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},Ue=(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name;switch(t){case"webnn":if(t="WEBNN","string"!=typeof r){let t=r;if(t?.deviceType){let r=ze("deviceType",n),a=ze(t.deviceType,n);0!==Re()._OrtAddSessionConfigEntry(e,r,a)&&Pe(`Can't set a session config entry: 'deviceType' - ${t.deviceType}.`)}if(t?.numThreads){let r=t.numThreads;("number"!=typeof r||!Number.isInteger(r)||r<0)&&(r=0);let a=ze("numThreads",n),i=ze(r.toString(),n);0!==Re()._OrtAddSessionConfigEntry(e,a,i)&&Pe(`Can't set a session config entry: 'numThreads' - ${t.numThreads}.`)}if(t?.powerPreference){let r=ze("powerPreference",n),a=ze(t.powerPreference,n);0!==Re()._OrtAddSessionConfigEntry(e,r,a)&&Pe(`Can't set a session config entry: 'powerPreference' - ${t.powerPreference}.`)}}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);let r=ze("preferredLayout",n),a=ze(t.preferredLayout,n);0!==Re()._OrtAddSessionConfigEntry(e,r,a)&&Pe(`Can't set a session config entry: 'preferredLayout' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=ze(t,n);0!==Re()._OrtAppendExecutionProvider(e,a)&&Pe(`Can't append execution provider: ${t}.`)}},Ve=e=>{let t=Re(),n=0,r=[],a=e||{};We(a);try{let e=De(a.graphOptimizationLevel??"all"),i=Ne(a.executionMode??"sequential"),o="string"==typeof a.logId?ze(a.logId,r):0,s=a.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw new Error(`log serverity level is not valid: ${s}`);let u=a.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let l="string"==typeof a.optimizedModelFilePath?ze(a.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!a.enableCpuMemArena,!!a.enableMemPattern,i,!!a.enableProfiling,0,o,s,u,l),0===n&&Pe("Can't create session options."),a.executionProviders&&Ue(n,a.executionProviders,r),a.freeDimensionOverrides)for(let[e,i]of Object.entries(a.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof i||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let a=ze(e,r);0!==t._OrtAddFreeDimensionOverride(n,a,i)&&Pe(`Can't set a free dimension override: ${e} - ${i}.`)}return void 0!==a.extra&&Be(a.extra,"",new WeakSet,((e,a)=>{let i=ze(e,r),o=ze(a,r);0!==t._OrtAddSessionConfigEntry(n,i,o)&&Pe(`Can't set a session config entry: ${e} - ${a}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseSessionOptions(n),r.forEach((e=>t._free(e))),e}}})),$s=U((()=>{He=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Le=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Fe=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Ge=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},je=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},qe=e=>"float32"===e||"int32"===e||"int64"===e||"bool"===e||"float16"===e||"uint32"===e,Ke=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}})),_s=U((()=>{Ye=async e=>{if("string"!=typeof e)return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e);if(!(typeof process<"u"&&process.versions&&process.versions.node)){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,a=t.body.getReader();try{n=new ArrayBuffer(r)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(r/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let i=0;for(;;){let{done:e,value:t}=await a.read();if(e)break;let r=t.byteLength;new Uint8Array(n,i,r).set(t),i+=r}return new Uint8Array(n,0,r)}}try{return new Uint8Array(await(void 0)(e))}catch(t){if("ERR_FS_FILE_TOO_LARGE"===t.code){let t=(void 0)(e),n=[];for await(let e of t)n.push(e);return new Uint8Array(Buffer.concat(n))}throw t}}})),xs=U((()=>{$s(),Ze=["V","I","W","E","F"],Qe=(e,t)=>{console.log(`[${Ze[e]},${(new Date).toISOString()}]${t}`)},et=(e,t)=>{Xe=e,Je=t},tt=(e,t)=>{let n=je(e);n>=je(Xe)&&Qe(n,"function"==typeof t?t():t)},nt=(...e)=>{Je&&tt(...e)}})),Ss=U((()=>{$s(),rt=(e,t)=>new(Ge(t))(e)})),Cs=U((()=>{})),Es=U((()=>{xs(),Cs(),at=e=>16*Math.ceil(e/16),it=1,ot=()=>it++,st=async(e,t,n,r)=>{let a=at(n),i=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=e.getCommandEncoder();e.endComputePass(),o.copyBufferToBuffer(t,0,i,0,a),e.flush(),await i.mapAsync(GPUMapMode.READ);let s=i.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(s,0,n)),e}return new Uint8Array(s.slice(0,n))}finally{i.destroy()}},ut=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,t){let n=t.buffer,r=t.byteOffset,a=t.byteLength,i=at(a),o=this.storageCache.get(e);if(!o)throw new Error("gpu data for uploading does not exist");if(o.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${a}`);let s=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),u=s.getMappedRange();new Uint8Array(u).set(new Uint8Array(n,r,a)),s.unmap();let l=this.backend.getCommandEncoder();this.backend.endComputePass(),l.copyBufferToBuffer(s,0,o.gpuData.buffer,0,i),nt("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(s)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=at(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}registerExternalBuffer(e,t,n){let r;if(n){if(r=this.externalBuffers.get(n),void 0===r)throw new Error("previous buffer is not registered");if(e===n)return nt("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;this.externalBuffers.delete(n)}else r=ot();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),this.externalBuffers.set(e,r),nt("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){let t=this.externalBuffers.get(e);void 0!==t&&(this.storageCache.delete(t),this.externalBuffers.delete(e),nt("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=at(e),a=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||i){let e=a?this.freeBuffers:this.freeUniformBuffers,i=e.get(r);i||(i=[],e.set(r,i)),n=i.length>0?i.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let o={id:ot(),type:0,buffer:n};return this.storageCache.set(o.id,{gpuData:o,originalSize:e}),nt("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${o.id}`)),o}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return nt("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");await st(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},lt=(...e)=>new ut(...e)})),Is=U((()=>{dt=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this.key}},pt=e=>new dt(e)})),Ts=U((()=>{ct=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},ft=class{static calcShape(e,t,n=!1){let r=e.length,a=t.length;if(0===r)return t;if(0===a)return e;let i=Math.max(e.length,t.length),o=new Array(i);if(n){if(r<2||a<2)return;let n=ct.calcMatMulShape([e[r-2],e[r-1]],[t[a-2],t[a-1]]);if(void 0===n)return;[o[i-2],o[i-1]]=n}for(let s=n?3:1;s<=i;s++){let n=r-s<0?1:e[r-s],u=a-s<0?1:t[a-s];if(n!==u&&n>1&&u>1)return;o[i-s]=Math.max(n,u)}return o}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(1!==e[n-a]&&e[n-a]!==t[r-a])return!1;return!0}},ht=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let a=t;a<n;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=e[a]}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},mt=class e{static adjustPoolAttributes(e,t,n,r,a,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,a,i,o,s){if(s){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<t.length-2;u++)e.adjustPadAndReturnShape(t[u+(o?1:2)],n[u],r[u],a[u],i,u,u+t.length-2,s)}}static computePoolOutputShape(t,n,r,a,i,o,s){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return e.computeShapeHelper(t,n,u,r,a,i,o,s),u}static computeConvOutputShape(t,n,r,a,i,o,s){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[t[0],n[0]];return e.computeShapeHelper(!1,t,u,r,a,i,o,s),u}static computeShapeHelper(t,n,r,a,i,o,s,u){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],a[t],i[t],o[t],s,t,t+n.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,a,i,o,s){let u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[i]+a[o]-u)/t+1);switch(s){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return a[i]=Math.floor("SAME_LOWER"===s?(n+1)/2:n/2),a[o]=n-a[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},gt=class{static getShapeOfGemmResult(e,t,n,r,a){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,o,s;t?(i=e[1],o=e[0]):(i=e[0],o=e[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==o)throw new Error("dimension mismatch");if(i<=0||s<=0||o<=0)throw new Error("invalid shape specified");if(a&&!ft.isValidBroadcast(a,[i,s]))throw new Error("gemm: invalid bias shape for broadcast");return[i,s,o]}},yt=-34028234663852886e22,bt=34028234663852886e22})),As=U((()=>{$s(),Ts(),wt=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},vt=(e,t=1)=>{let n=wt(e,t);return"string"==typeof n?n:n[0]},$t=(e,t=1)=>{let n=wt(e,t);return"string"==typeof n?n:n[1]},_t=e=>0===e.length?[]:[{type:"uint32",data:e},{type:"uint32",data:ht.computeStrides(e)}],xt=e=>e%4==0?4:e%2==0?2:1,St=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,Ct=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}f(${n})`,Et=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,It=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===r?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===r?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Tt=(e,t,n,r,a)=>{let i="number"==typeof n,o=i?n:n.length,s=[...new Array(o).keys()],u=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,l=wt(t,a),d="string"==typeof l?l:l[1],p="string"==typeof l?l:l[0],c={indices:u,value:d,storage:p,tensor:t},f=e=>"string"==typeof e?e:`${e}u`,h={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=i?"uniforms.":"",g=`${m}${e}_shape`,y=`${m}${e}_strides`,b="";for(let e=0;e<o-1;e++)b+=`\n    let dim${e} = current / ${It(y,e,o)};\n    let rest${e} = current % ${It(y,e,o)};\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;b+=`indices[${o-1}] = current;`;let w=o<2?"":`\n  fn o2i_${e}(offset: u32) -> ${c.indices} {\n    var indices: ${c.indices};\n    var current = offset;\n    ${b}\n    return indices;\n  }`,v=[];if(o>=2)for(let e=o-1;e>=0;e--)v.push(`${It(y,e,o)} * (indices[${e}])`);let $=o<2?"":`\n  fn i2o_${e}(indices: ${c.indices}) -> u32 {\n    return ${v.join("+")};\n  }`,_=(...e)=>0===o?"0u":`${c.indices}(${e.map(f).join(",")})`,x=(e,t)=>o<2?`${e}`:`${It(e,t,o)}`,S={},C=(t,n)=>(()=>{if(c.storage===c.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===c.storage&&"i32"===c.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===c.storage&&"u32"===c.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===c.storage&&"vec4<bool>"===c.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${c.storage} and value type ${c.value} yet`)})(),E=t=>(()=>{if(c.storage===c.value)return`${e}[${t}]`;if("vec2<u32>"===c.storage&&"i32"===c.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===c.storage&&"u32"===c.value)return`u32(${e}[${t}].x)`;if("u32"===c.storage&&"vec4<bool>"===c.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${c.storage} and value type ${c.value} yet`)})(),I=o<2?"":`\n  fn get_${e}ByIndices(indices: ${c.indices}) -> ${d} {\n    return ${E(`i2o_${e}(indices)`)};\n  }`,T=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn get_${e}(${t}) -> ${d} {\n    return get_${e}ByIndices(${_(n)});\n  }`})(),A=o<2?"":`\n  fn set_${e}ByIndices(indices: ${c.indices}, value: ${d}) {\n    ${C(`i2o_${e}(indices)`,"value")}\n  }`,k=o<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),n=s.map((e=>`d${e}`)).join(", ");return`\n  fn set_${e}(${t}, value: ${d}) {\n    set_${e}ByIndices(${_(n)}, value);\n  }`})();return{impl:()=>{let e=[],t=!1;return h.offsetToIndices&&(e.push(w),t=!0),h.indicesToOffset&&(e.push($),t=!0),h.broadcastedIndicesToOffset&&(Object.values(S).forEach((t=>e.push(t))),t=!0),h.set&&(e.push(k),t=!0),h.setByIndices&&(e.push(A),t=!0),h.get&&(e.push(T),t=!0),h.getByIndices&&(e.push(I),t=!0),!i&&t&&e.unshift(`const ${g} = ${c.indices}(${n.join(",")});`,`const ${y} = ${c.indices}(${ht.computeStrides(n).join(",")});`),e.join("\n")},type:c,offsetToIndices:t=>(h.offsetToIndices=!0,o<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(h.indicesToOffset=!0,o<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{h.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in S)return`${r}(${t})`;let a=[];for(let e=o-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-o);a.push(`${x(y,e)} * (${t} % ${x(g,e)})`)}return S[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${a.length>0?a.join("+"):"0u"};\n           }`,`${r}(${t})`},indices:_,indicesGet:x,indicesSet:(e,t,n)=>o<2?`${e}=${n};`:`${It(e,t,o)}=${n};`,set:(...t)=>{if(t.length!==o+1)throw new Error(`indices length must be ${o}`);let n=t[o];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,o).map(f).join(",");return 0===o?C("0u",n):1===o?C(r[0],n):(h.set=!0,h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:C,setByIndices:(t,n)=>o<2?C(t,n):(h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==o)throw new Error(`indices length must be ${o}`);let n=t.map(f).join(",");return 0===o?E("0u"):1===o?E(n[0]):(h.get=!0,h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:E,getByIndices:t=>o<2?E(t):(h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r,name:e,strides:y,shape:g,rank:o}},At=(e,t,n,r=1)=>Tt(e,t,n,"input",r),kt=(e,t,n,r=1)=>Tt(e,t,n,"output",r),Ot=(e,t,n,r=1)=>Tt(e,t,n,"internal",r),Rt=class{constructor(e){this.normalizedDispatchGroup=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=64){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2],a=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\n  fn main(${a?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\n    ${a?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${t*n*r}u + local_idx;`}\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",r=e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach((e=>this.registerInternalVariable(e))),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let a=null==r||1===r?n:`vec${r}<${n}>`;e.push(`${t}:${a}`)}return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((e=>e.impl())).join("\n")+this.internalVariables.map((e=>e.impl())).join("\n")}},zt=e=>new Rt(e),Bt=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;a++){let i=n-1-a,o=e[i]||1;(t[t.length-1-a]||1)>1&&1===o&&r.unshift(i)}return r}})),ks=U((()=>{Ts(),Is(),As(),Pt=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.")},Mt=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Dt=(e,t)=>ht.sortBasedOnPerm(e,Mt(e.length,t)),Nt=(e,t,n,r)=>{let a=[];a.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)a.push(n.indicesSet("a",e[r],`i[${r}]`));return a.push("return a;}"),a.join("\n")},Wt=(e,t)=>{let n=e.dataType,r=e.dims.length,a=Mt(r,t),i=Dt(e.dims,a),o=kt("output",n,i.length),s=At("a",n,r);return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:e=>{let t=ht.size(i);return{outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:"uint32",data:t},..._t(e[0].dims),..._t(i)]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(s,o)}\n\n  ${Nt(a,r,s,o)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${o.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${o.setByOffset("global_idx",s.getByIndices("aIndices"))}\n  }`}},Ut=(e,t)=>{Pt(e.inputs),e.compute(Wt(e.inputs[0],t.perm))},Vt=e=>pt({perm:e.perm})})),Os=U((()=>{Ts(),As(),Rs(),ks(),Ht={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Lt={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ft={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Gt={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},jt=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},qt=(e,t)=>{let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]},Kt=(e,t)=>{let n=e.length+t.length,r=[],a=0;for(let i=0;i<n;i++)-1===t.indexOf(i)?r.push(e[a++]):r.push(1);return r},Yt=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Zt=(e,t)=>{let n=[];if(!Yt(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},Qt=(e,t,n,r,a,i,o)=>{let s=n[0].dims,u=ht.size(i),l=ht.size(o),d=At("_A",n[0].dataType,s),p=kt("output",a,i),c=`\n          var<workgroup> aBestValues : array<${p.type.storage}, 32>;\n       `;return{name:e,shaderCache:t,getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,p)}\n        ${c}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(32)}\n\n          let outputIndex = global_idx / 32;\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${p.type.storage}(${Ft[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + 32) {\n           let candidate = ${p.type.storage}(${d.getByOffset("offset + k")});\n           bestValue = ${Ht[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, 32u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${Lt[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${p.setByOffset("outputIndex","mean"===r?`bestValue / ${p.type.storage}(uniforms.reduceSize)`:`${Gt[r]}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:u},programUniforms:[{type:"uint32",data:l}]})}},Xt=(e,t,n,r)=>{let a=1===e.inputs.length?n:fn(e.inputs,n),i=a.axes;0===i.length&&!a.noopWithEmptyAxes&&(i=e.inputs[0].dims.map(((e,t)=>t)));let o=ht.normalizeAxes(i,e.inputs[0].dims.length),s=o,u=e.inputs[0],l=Zt(s,e.inputs[0].dims.length);l.length>0&&(u=e.compute(Wt(e.inputs[0],l),{inputs:[0],outputs:[-1]})[0],s=jt(s.length,u.dims.length));let[d,p]=qt(u.dims,s),c=d;a.keepDims&&(c=Kt(d,o)),e.compute(Qt(t,{hint:a.cacheKey,inputDependencies:["type"]},[u],r,e.inputs[0].dataType,c,p),{inputs:[u]})},Jt=(e,t)=>{Xt(e,"ReduceMeanShared",t,"mean")},en=(e,t)=>{Xt(e,"ReduceL1Shared",t,"l1")},tn=(e,t)=>{Xt(e,"ReduceL2Shared",t,"l2")},nn=(e,t)=>{Xt(e,"ReduceLogSumExpShared",t,"logSumExp")},rn=(e,t)=>{Xt(e,"ReduceMaxShared",t,"max")},an=(e,t)=>{Xt(e,"ReduceMinShared",t,"min")},on=(e,t)=>{Xt(e,"ReduceProdShared",t,"prod")},sn=(e,t)=>{Xt(e,"ReduceSumShared",t,"sum")},un=(e,t)=>{Xt(e,"ReduceSumSquareShared",t,"sumSquare")},ln=(e,t)=>{Xt(e,"ReduceLogSumShared",t,"logSum")}})),Rs=U((()=>{Ts(),Is(),As(),Os(),dn=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},pn=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],cn=(e,t,n,r,a,i,o=!1,s=!1)=>{let u=[],l=n[0].dims,d=l.length,p=ht.normalizeAxes(a,d),c=!s&&0===p.length;l.forEach(((e,t)=>{c||p.indexOf(t)>=0?o&&u.push(1):u.push(e)}));let f=u.length,h=ht.size(u);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],a=At("_A",n[0].dataType,d),s=kt("output",i,f),u=r(a,s,p),h=u[2];for(let e=0,n=0;e<d;e++)c||p.indexOf(e)>=0?(o&&n++,h=`for(var j${e}: u32 = 0; j${e} < ${l[e]}; j${e}++) {\n                  ${u[2].includes("last_index")?`let last_index = j${e};`:""}\n                  ${a.indicesSet("input_indices",e,`j${e}`)}\n                  ${h}\n                }`):(t.push(`${a.indicesSet("input_indices",e,s.indicesGet("output_indices",n))};`),n++);return`\n\n        ${e.registerUniform("output_size","u32").declareVariables(a,s)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${a.type.indices};\n          let output_indices = ${s.offsetToIndices("global_idx")};\n\n          ${t.join("\n")}\n          ${u[0]}       // init ops for reduce max/min\n          ${u[1]}\n          ${h}\n          ${u[3]}\n          ${4===u.length?s.setByOffset("global_idx","value"):u.slice(4).join("\n")}\n        }`},getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:"uint32",data:h},..._t(l),..._t(u)]})}},fn=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),pt({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},hn=(e,t,n,r)=>{let a=e.inputs,i=1===a.length?n:fn(a,n);e.compute(cn(t,{hint:i.cacheKey,inputDependencies:["rank"]},[a[0]],i.noopWithEmptyAxes&&0===i.axes.length?pn:r,i.axes,a[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},mn=(e,t)=>{dn(e.inputs),hn(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"]))},gn=(e,t)=>{dn(e.inputs),hn(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""]))},yn=(e,t)=>{dn(e.inputs),hn(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"]))},bn=(e,t)=>{dn(e.inputs),hn(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"]))},wn=(e,t)=>{dn(e.inputs),hn(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("input_indices",t,0));return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]}))},vn=(e,t)=>{dn(e.inputs),hn(e,"ReduceMean",t,((t,n,r)=>{let a=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(a*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${a});`]}))},$n=(e,t)=>{dn(e.inputs),hn(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]}))},_n=(e,t)=>{dn(e.inputs),hn(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""]))},xn=(e,t)=>{dn(e.inputs),hn(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""]))},Sn=(e,t)=>{dn(e.inputs),hn(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""]))},Cn=(e,t,n)=>{if(0===t.length)return n;let r=1,a=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:a*=e[n];return a<32&&r>1024},En=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vn(e,t):Jt(e,t)},In=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gn(e,t):en(e,t)},Tn=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yn(e,t):tn(e,t)},An=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bn(e,t):nn(e,t)},kn=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wn(e,t):rn(e,t)},On=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$n(e,t):an(e,t)},Rn=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_n(e,t):on(e,t)},zn=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xn(e,t):sn(e,t)},Bn=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sn(e,t):un(e,t)},Pn=(e,t)=>{Cn(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?mn(e,t):ln(e,t)}})),zs=U((()=>{$s(),Is(),Rs(),Mn=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},Dn=(e,t)=>{Mn(e.inputs),e.compute(cn("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`input_indices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},Nn=(e,t)=>{Mn(e.inputs),e.compute(cn("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let a=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`input_indices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},Wn=e=>pt(e)})),Bs=U((()=>{$s(),Cs(),As(),Un=(e,t)=>{let n=e[0],r=e[1],a=e[2],i=e[3],o=e[4],s=e[5];if(o&&s)throw new Error("Attention cannot have both past and relative_position_bias");if(3!==n.dims.length)throw new Error('Input "input" must have 3 dimensions');let u=n.dims[0],l=n.dims[1],d=n.dims[2];if(1!==a.dims.length)throw new Error('Input "bias" is expected to have 1 dimensions');if(2!==r.dims.length)throw new Error('Input "weights" is expected to have 2 dimensions');if(r.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(a.dims[0]!==r.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let p=a.dims[0]/3,c=p,f=c;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!=0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");p=t.qkvHiddenSizes[0],c=t.qkvHiddenSizes[1],f=t.qkvHiddenSizes[2]}let h=l;if(p!==c)throw new Error("qkv_hidden_sizes first element should be same as the second");if(a.dims[0]!==p+c+f)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let m=0;if(o){if(c!==f)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(5!==o.dims.length)throw new Error('Input "past" must have 5 dimensions');if(2!==o.dims[0])throw new Error('Input "past" first dimension must be 2');if(o.dims[1]!==u)throw new Error('Input "past" second dimension must be batch_size');if(o.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(o.dims[4]!==c/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(m=o.dims[3])}let g=h+m;if(i)throw new Error("Mask not supported");if(o)throw new Error("past is not supported");if(s)throw new Error("relativePositionBias is not supported");return{batchSize:u,sequenceLength:l,pastSequenceLength:m,kvSequenceLength:h,totalSequenceLength:g,maxSequenceLength:-1,inputHiddenSize:d,hiddenSize:p,vHiddenSize:f,headSize:Math.floor(p/t.numHeads),vHeadSize:Math.floor(f/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Vn=(e,t,n,r)=>{let a=xt(r),i=64,o=r/a;o<i?i=1:o/8<64&&(i=Math.ceil(o/8));let s=Math.ceil(r/a/i),u=[{type:Le(t.dataType),data:1/r},{type:"uint32",data:o},{type:"uint32",data:s}],l=vt(t.dataType,a);e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${i};${l};${a}`},getShaderSource:e=>{let n=kt("x",t.dataType,t.dims,a),r="thread_max_vector";2===a?r="max(thread_max_vector.x, thread_max_vector.y)":4===a&&(r="max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))");let o=$t(t.dataType),s=[{name:"d_inv",type:o},{name:"d_comp",type:"u32"},{name:"elements_per_wg",type:"u32"}];return`\n  var<workgroup> wgMax: array<f32, ${i}>;\n  var<workgroup> wgSum: array<f32, ${i}>;\n  ${e.registerUniforms(s).declareVariables(n)}\n  ${e.mainStart([i,1,1])}\n    let localOffset = local_idx * uniforms.elements_per_wg;\n    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;\n\n    var thread_max_vector = ${St("f32",a,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${Ct(o,a,"x[offset + i]")}, thread_max_vector);\n    }\n    wgMax[local_idx] = ${r};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${i}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${St("f32",a,"0")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      sumVector += exp(${Ct(o,a,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_idx] = ${Et("sumVector",a)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${i}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        x[offset + i] = ${St(o,a,"uniforms.d_inv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        let f32input = ${Ct(o,a,"x[offset + i]")};\n        x[offset + i] = ${n.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:n},programUniforms:u})},{inputs:[t],outputs:[]})},Hn=(e,t,n,r,a,i)=>{let o=[a.batchSize,a.numHeads,a.sequenceLength,a.kvSequenceLength+a.pastSequenceLength],s=0===i.scale?1/Math.sqrt(a.headSize):i.scale,u=xt(a.headSize),l=a.headSize/u,d={x:Math.ceil(a.totalSequenceLength/12),y:Math.ceil(a.sequenceLength/12),z:a.batchSize*a.numHeads},p=Le(t.dataType),c=[{type:"uint32",data:a.sequenceLength},{type:"uint32",data:l},{type:"uint32",data:a.totalSequenceLength},{type:"uint32",data:a.kvSequenceLength},{type:p,data:s}],f=[t,n],h=e.compute({name:"AttentionProbs",shaderCache:{hint:`${u}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:c}),getShaderSource:e=>{let r=At("q",t.dataType,t.dims,u),a=At("key",n.dataType,n.dims,u),i=kt("output",t.dataType,o),s=vt(t.dataType),l=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"alpha",type:s}];return`\n  const beta: ${s} = 1.0;\n  const TILE_SIZE = 12u;\n\n  var<workgroup> tileQ: array<${r.type.storage}, 144>;\n  var<workgroup> tileK: array<${r.type.storage}, 144>;\n  ${e.registerUniforms(l).declareVariables(r,a,i)}\n  ${e.mainStart([12,12,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${St(s,u)};\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (lm < uniforms.M && ln < uniforms.N) {\n      let outputIdx = headOffset + lm * uniforms.N + ln;\n      output[outputIdx] = ${Et("value",u)} * uniforms.alpha;\n    }\n  }`}},{inputs:f,outputs:[-1]})[0];return Vn(e,h,a.batchSize*a.numHeads*a.sequenceLength,a.totalSequenceLength),h},Ln=(e,t,n,r)=>{let a=[r.batchSize,r.sequenceLength,r.vHiddenSize],i={x:Math.ceil(r.vHeadSize/12),y:Math.ceil(r.sequenceLength/12),z:r.batchSize*r.numHeads},o=[{type:"uint32",data:r.sequenceLength},{type:"uint32",data:r.totalSequenceLength},{type:"uint32",data:r.vHeadSize},{type:"uint32",data:r.numHeads},{type:"uint32",data:r.vHiddenSize}];return e.compute({name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:i,programUniforms:o}),getShaderSource:e=>{let r=At("probs",t.dataType,t.dims),i=At("v",n.dataType,n.dims),o=kt("output",t.dataType,a);return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileQ: array<${r.type.value}, 144>;\n  var<workgroup> tileK: array<${r.type.value}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}]).declareVariables(r,i,o)}\n  ${e.mainStart([12,12,1])}\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${r.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}},{inputs:[t,n],outputs:[0]})[0]},Fn=(e,t,n,r,a,i,o,s,u,l,d)=>{let p=Hn(e,t,n,0,l,d);Ln(e,p,r,l)},Gn=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,a=t.inputHiddenSize,i=t.headSize,o={x:Math.ceil(t.headSize/12),y:Math.ceil(t.sequenceLength/12),z:t.batchSize*t.numHeads},s=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:"uint32",data:r},{type:"uint32",data:a},{type:"uint32",data:i},{type:"uint32",data:t.numHeads},{type:"uint32",data:t.headSize},{type:"uint32",data:t.hiddenSize},{type:"uint32",data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:u}),getShaderSource:e=>{let t=kt("output_q",s[0].dataType,n),r=kt("output_k",s[0].dataType,n),a=kt("output_v",s[0].dataType,n),i=At("input",s[0].dataType,s[0].dims),o=At("weight",s[1].dataType,s[1].dims),u=At("bias",s[2].dataType,s[2].dims),l=i.type.storage;return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileInput: array<${l}, 144>;\n  var<workgroup> tileWeightQ: array<${l}, 144>;\n  var<workgroup> tileWeightK: array<${l}, 144>;\n  var<workgroup> tileWeightV: array<${l}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(i,o,u,t,r,a)}\n  ${e.mainStart([12,12,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${l}(0);\n    var valueK = ${l}(0);\n    var valueV = ${l}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`}},{inputs:s,outputs:[-1,-1,-1]})},jn=(e,t)=>{let n=Un(e.inputs,t),[r,a,i]=Gn(e,n);return Fn(e,r,a,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n,t)}})),Ps=U((()=>{ue(),Ts(),Is(),As(),qn=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let r=t.length;if(r!==e.length)throw new Error(`${n}: num dimensions != ${r}`);t.forEach(((t,r)=>{if(t!==e[r])throw new Error(`${n}: dim[${r}] do not match`)}))};if(e[0].dims.length>1){let r="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},Kn=(e,t)=>{let{epsilon:n,spatial:r,format:a}=t,i=e[0].dims,o=r?xt(i[i.length-1]):1,s="NHWC"===a&&i.length>1?o:1,u=ht.size(i)/o,l=r,d=l?i.length:i,p=At("x",e[0].dataType,e[0].dims,o),c=At("scale",e[1].dataType,e[1].dims,s),f=At("bias",e[2].dataType,e[2].dims,s),h=At("inputMean",e[3].dataType,e[3].dims,s),m=At("inputVar",e[4].dataType,e[4].dims,s),g=kt("y",e[0].dataType,d,o);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${o}`,inputDependencies:l?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\n  const epsilon = ${n};\n  ${e.registerUniform("outputSize","u32").declareVariables(p,c,f,h,m,g)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${g.offsetToIndices(`global_idx * ${o}`)};\n    ${(()=>{let e="";if(r)e=`let cOffset = ${1===i.length?"0u":"NHWC"===a?`outputIndices[${i.length-1}] / ${o}`:"outputIndices[1]"};`;else if("NCHW"===a)e=`\n            ${g.indicesSet("outputIndices","0","0")}\n            let cOffset = ${g.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${c.type.indices}(0);\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let t=1;t<c.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${c.indicesToOffset("cIndices")};`}return e})()}\n    let scale = ${c.getByOffset("cOffset")};\n    let bias = ${f.getByOffset("cOffset")};\n    let inputMean = ${h.getByOffset("cOffset")};\n    let inputVar = ${m.getByOffset("cOffset")};\n    let x = ${p.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${g.setByOffset("global_idx","value")}\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l?[{type:"uint32",data:u},..._t(i)]:[{type:"uint32",data:u}]})}},Yn=e=>pt(e),Zn=(e,t)=>{let{inputs:n,outputCount:r}=e,a=Yn({...t,outputCount:r});if(p.webgpu.validateInputContent&&qn(n,a),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Kn(n,a))}})),Ms=U((()=>{Ts(),As(),Qn=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Xn=e=>{let t=e[0].dims,n=e[0].dims[2],r=ht.size(t)/4,a=e[0].dataType,i=At("input",a,t,4),o=At("bias",a,[n],4),s=At("residual",a,t,4),u=kt("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(i,o,s,u)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${i.getByOffset("global_idx")}\n      + ${o.getByOffset("global_idx % channels")} + ${s.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx","value")}\n  }`}},Jn=e=>{Qn(e.inputs),e.compute(Xn(e.inputs))}})),Ds=U((()=>{$s(),Ts(),Is(),As(),er=(e,t,n,r,a,i)=>{let o=Math.ceil(t/4),s="";s="string"==typeof a?`${a}(a)`:a("a");let u=At("inputData",n,[o],4),l=kt("outputData",r,[o],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(u,l)}\n\n  ${i??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${u.getByOffset("global_idx")};\n    ${l.setByOffset("global_idx",s)}\n  }`},tr=(e,t,n,r,a,i=e.dataType)=>({name:t,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:t=>er(t,ht.size(e.dims),e.dataType,i,n,r),getRunData:t=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(ht.size(t[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(ht.size(e.dims)/4)}]})}),nr=e=>{e.compute(tr(e.inputs[0],"Abs","abs"))},rr=e=>{e.compute(tr(e.inputs[0],"Acos","acos"))},ar=e=>{e.compute(tr(e.inputs[0],"Acosh","acosh"))},ir=e=>{e.compute(tr(e.inputs[0],"Asin","asin"))},or=e=>{e.compute(tr(e.inputs[0],"Asinh","asinh"))},sr=e=>{e.compute(tr(e.inputs[0],"Atan","atan"))},ur=e=>{e.compute(tr(e.inputs[0],"Atanh","atanh"))},lr=e=>pt(e),dr=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(tr(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},pr=e=>{let t=e.length>=2&&0!==e[1].data?e[1].getFloat32Array()[0]:yt,n=e.length>=3&&0!==e[2].data?e[2].getFloat32Array()[0]:bt;return pt({min:t,max:n})},cr=(e,t)=>{let n=1===e.inputs.length?t:pr(e.inputs),r=$t(e.inputs[0].dataType);e.compute(tr(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<${r}> = vec4(${r}(${n.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${n.max}));\n`,n.cacheKey),{inputs:[0]})},fr=e=>{e.compute(tr(e.inputs[0],"Ceil","ceil"))},hr=e=>{e.compute(tr(e.inputs[0],"Cos","cos"))},mr=e=>{e.compute(tr(e.inputs[0],"Cosh","cosh"))},gr=e=>pt(e),yr=(e,t)=>{let n=$t(e.inputs[0].dataType);e.compute(tr(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},br=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,wr=e=>{let t=$t(e.inputs[0].dataType);e.compute(tr(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),br(`vec4<${t}>`,t)))},vr=e=>{e.compute(tr(e.inputs[0],"Exp","exp"))},$r=e=>{e.compute(tr(e.inputs[0],"Floor","floor"))},_r=e=>{let t=$t(e.inputs[0].dataType);e.compute(tr(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),br(`vec4<${t}>`,t)))},xr=(e,t)=>{let n=$t(e.inputs[0].dataType);e.compute(tr(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`),`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},Sr=e=>{e.compute(tr(e.inputs[0],"Not",(e=>`!${e}`)))},Cr=e=>{e.compute(tr(e.inputs[0],"Neg",(e=>`-${e}`)))},Er=e=>{e.compute(tr(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},Ir=e=>{let t=$t(e.inputs[0].dataType);e.compute(tr(e.inputs[0],"Relu",(e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`)))},Tr=e=>{e.compute(tr(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},Ar=e=>pt(e),kr=(e,t)=>{let n=$t(e.inputs[0].dataType);e.compute(tr(e.inputs[0],"HardSigmoid",(e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`),void 0,t.cacheKey))},Or=e=>{e.compute(tr(e.inputs[0],"Sin","sin"))},Rr=e=>{e.compute(tr(e.inputs[0],"Sinh","sinh"))},zr=e=>{e.compute(tr(e.inputs[0],"Sqrt","sqrt"))},Br=e=>{e.compute(tr(e.inputs[0],"Tan","tan"))},Pr=e=>{e.compute(tr(e.inputs[0],"Tanh",(e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`)))},Mr=(e,t)=>{let n=$t(e.inputs[0].dataType);return e.compute(tr(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},Dr=e=>{e.compute(tr(e.inputs[0],"Log","log"))}})),Ns=U((()=>{Ts(),As(),Ds(),Nr=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Wr=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=At("input",e[0].dataType,e[0].dims,4),r=At("bias",e[0].dataType,[e[0].dims[2]],4),a=kt("output",e[0].dataType,t,4),i=ht.size(t)/4,o=vt(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,r,a)}\n\n  ${br(`vec4<${o}>`,o)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ur=e=>{Nr(e.inputs),e.compute(Wr(e.inputs))}})),Ws=U((()=>{$s(),Ts(),As(),Vr=(e,t,n,r,a,i,o,s,u,l,d,p)=>{let c,f;"string"==typeof s?c=f=(e,t)=>`${s}((${e}),(${t}))`:"function"==typeof s?c=f=s:(c=s.scalar,f=s.vector);let h,m=kt("outputData",d,r.length,4),g=At("aData",u,t.length,4),y=At("bData",l,n.length,4);if(a)if(i){let e=1===ht.size(t),r=1===ht.size(n),a=t.length>0&&t[t.length-1]%4==0,i=n.length>0&&n[n.length-1]%4==0;h=e||r?m.setByOffset("global_idx",f(e?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"),r?`${y.type.value}(${y.getByOffset("0")}.x)`:y.getByOffset("global_idx"))):`\n            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${g.broadcastedIndicesToOffset("outputIndices",m)};\n            let offsetB = ${y.broadcastedIndicesToOffset("outputIndices",m)};\n            ${m.setByOffset("global_idx",f(o||a?g.getByOffset("offsetA / 4u"):`${g.type.value}(${g.getByOffset("offsetA / 4u")}[offsetA % 4u])`,o||i?y.getByOffset("offsetB / 4u"):`${y.type.value}(${y.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else h=m.setByOffset("global_idx",f(g.getByOffset("global_idx"),y.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${m.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${g.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let offsetB${t} = ${y.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${c(r,a)});\n          `};h=9===d?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(g,y,m)}\n\n        ${p??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${h}\n      }`},Hr=(e,t,n,r,a,i,o=n.dataType)=>{let s=!ht.areEqual(n.dims,r.dims),u=n.dims,l=ht.size(n.dims),d=!1,p=!1,c=[s];if(s){let e=ft.calcShape(n.dims,r.dims,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");u=e,l=ht.size(u);let t=1===ht.size(n.dims),a=1===ht.size(r.dims),i=n.dims.length>0&&n.dims[n.dims.length-1]%4==0,o=r.dims.length>0&&r.dims[r.dims.length-1]%4==0;c.push(t),c.push(a),c.push(i),c.push(o);let s=1;for(let e=1;e<u.length;e++){let t=n.dims[n.dims.length-e]??1;if(t!==(r.dims[r.dims.length-e]??1))break;s*=t}s%4==0?(p=!0,d=!0):(t||a||i||o)&&(d=!0)}else d=!0;return c.push(d),{name:e,shaderCache:{hint:t+c.map((e=>e.toString())).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>Vr(e,n.dims,r.dims,u,d,s,p,a,n.dataType,r.dataType,o,i),getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(l/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(ht.size(u)/4)},..._t(n.dims),..._t(r.dims),..._t(u)]})}},Lr=(e,t,n,r,a,i)=>{e.compute(Hr(t,a??"",e.inputs[0],e.inputs[1],n,r,i))},Fr=e=>{Lr(e,"Add",((e,t)=>`${e}+${t}`))},Gr=e=>{Lr(e,"Div",((e,t)=>`${e}/${t}`))},jr=e=>{Lr(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},qr=e=>{Lr(e,"Mul",((e,t)=>`${e}*${t}`))},Kr=e=>{let t=At("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Lr(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Yr=e=>{Lr(e,"Sub",((e,t)=>`${e}-${t}`))},Zr=e=>{Lr(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Qr=e=>{Lr(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},Xr=e=>{Lr(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Jr=e=>{Lr(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),Us=U((()=>{Ts(),Is(),As(),ea=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,n=e[0].dims.length;for(let r of e){if(r.dataType!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}},ta=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,na=(e,t)=>{let n=e.length,r=[];for(let a=0;a<n;++a){let i=t.setByOffset("global_idx",e[a].getByIndices("indices"));1===n?r.push(i):0===a?r.push(`if (inputIndex == ${a}u) { ${i} }`):a===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${a}) { ${i} }`)}return r.join("\n")},ra=(e,t)=>{let n=e[0].dims.slice();if(t>=n.length||t<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");let r=t<0?n.length+t:t,a=n.slice(0);for(let t=1;t<e.length;t++){let i=e[t].dims.slice();for(let e=0;e<n.length;e++)if(e===r)a[r]+=i[e];else if(n[e]!==i[e])throw new Error("non concat dimensions must match")}let i=ht.size(a),o=new Array(e.length),s=new Array(e.length),u=e[0].dataType,l=0,d=[],p=[],c=[{type:"uint32",data:i}];for(let t=0;t<e.length;++t)l+=e[t].dims[r],o[t]=l,p.push(e[t].dims.length),s[t]=At(`input${t}`,u,p[t]),d.push("rank"),c.push({type:"uint32",data:o[t]});for(let t=0;t<e.length;++t)c.push(..._t(e[t].dims));c.push(..._t(a));let f=kt("output",u,a.length),h=f.indicesGet("indices",r),m=Array.from(Array(o.length).keys()).map((e=>`uniforms.sizeInConcatAxis${e}`)).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:c}),getShaderSource:t=>`\n\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...s,f)})()}\n\n  ${ta(o.length,m)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${f.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${o.length}u>(${m});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${na(s,f)}\n  }`}},aa=(e,t)=>{ea(e.inputs),e.compute(ra(e.inputs,t.axis))},ia=e=>pt({axis:e.axis})})),Vs=U((()=>{Ts(),oa=(e,t)=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(uniforms.clip_min), ${t}(uniforms.clip_max));`;default:return""}},sa=e=>{let t=e?.activation||"";if("Clip"===t){let[n,r]=e?.activation_params||[yt,bt];return{activation:t,clipMax:r,clipMin:n}}return{activation:t}}})),Hs=U((()=>{ua=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},la=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `})),Ls=U((()=>{da=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`})),Fs=U((()=>{Ts(),As(),Vs(),Hs(),pa=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,ca=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,fa=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32)=>{let u=t[1]*e[1],l=t[0]*e[0],d=a?u:i,p=a?i:u,c=d/t[0],f=i/t[1];if((!a||4!==c||4!==e[1])&&(a||3!==c&&4!==c)||d%t[0]!=0||i%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${a} is true, innerElementSize ${c} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${c} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${c}<${n}>, ${d/c}>, ${p}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/e[0]}>, ${i}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${c};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${o?"0":"i32(globalId.z)"};\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let num_tiles = ${o?`${Math.ceil(s/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${f};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${pa(a,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===c?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${ca(a,c)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},ha=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,ma=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",ga=(e,t,n="f32",r,a=!1,i=32,o=!1,s=32,u=!1)=>{let l=e[1]*t[1],d=e[0]*t[0],p=a?l:i,c=a?i:l;if(c%t[1]!=0||p%t[0]!=0||i%t[1]!=0)throw new Error(`tileAHight ${c} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${p} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let f=c/t[1],h=p/t[0],m=i/t[1],g=u?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${l};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${t[0]}) {\n          ${ha(a,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${l};\n\nlet tileRowA = i32(localId.y) * ${f};\nlet tileColA = i32(localId.x) * ${h};\nlet tileRowB = i32(localId.y) * ${m};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${h}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${ha(a,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${ma(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${p}>, ${c}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${o?"0":"i32(globalId.z)"};\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${o?`${Math.ceil(s/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${g}\n  }\n`},ya=(e,t,n,r,a,i=!1)=>{let[o,s,u]=a,[l,d,p,c]=r,f=Bt(o,u),h=Bt(s,u),m=vt(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${ua(e,m)} {\n      var value = ${ua(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        ${(()=>{let e=d.rank,t=l.rank,n=`var aIndices: ${d.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\naIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return f.forEach((e=>{n+=`\naIndices[${e}] = 0;`})),n+=`\naIndices[${e-2}] = u32(row);\n                   aIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${ua(e,m)} {\n      var value = ${ua(e,m)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        ${(()=>{let e=p.rank,t=l.rank,n=`var bIndices: ${p.type.indices};`;for(let r=e-2-1,a=t-1;r>=0;r--,a--)n+=`\nbIndices[${r}] = ${t>1?`batchIndices[${a}]`:"batchIndices"};`;return h.forEach((e=>{n+=`\nbIndices[${e}] = 0;`})),n+=`\nbIndices[${e-2}] = u32(row);\n                   bIndices[${e-1}] = u32(colIn);`,n})()}\n        value = ${p.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ua(e,m)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${i?"bias[colIn]":`${ua(e,m)}(bias[row])`};`:""}\n        ${n}\n        ${c.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},ba=(e,t,n,r,a=!1)=>{let i=e[0].dims,o=e[1].dims,s=i.slice(0,-2),u=o.slice(0,-2),l=r?r.slice(0,-2):n.slice(0,-2),d=ht.size(l),p=i[i.length-2],c=i[i.length-1],f=o[o.length-1],h=c%4==0&&f%4==0,m=p<=8?[4,1,1]:[4,4,1],g=[8,8,1],y=[Math.ceil(f/g[0]/m[0]),Math.ceil(p/g[1]/m[1]),Math.ceil(d/g[2]/m[2])],b=h?4:1,w=[...s,p,c/b],v=w.length,$=[...u,c,f/b],_=$.length,x=[d,p,f/b],S=[{type:"int32",data:p},{type:"int32",data:f},{type:"int32",data:c}];"Clip"===t.activation&&S.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),S.push(..._t(l),..._t(w),..._t($));let C=["rank","rank"],E=e.length>2;return E&&(S.push(..._t(e[2].dims)),C.push("rank")),S.push(..._t(x)),{name:"MatMul",shaderCache:{hint:`${m};${t.activation};${h};${a}`,inputDependencies:C},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:y[0],y:y[1],z:y[2]},programUniforms:S}),getShaderSource:n=>{let r=l.length,i=Ot("batchDims",e[0].dataType,r,1),o=vt(e[0].dataType),d=At("a",e[0].dataType,v,b),p=At("b",e[1].dataType,_,b),c=kt("result",e[0].dataType,x.length,b),f=[d,p];if(E){let t=a?b:1;f.push(At("bias",e[2].dataType,e[2].dims.length,t))}let y=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];"Clip"===t.activation&&y.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"});let w=oa(t,c.type.value),$=ya(b,E,w,[i,d,p,c],[s,u,l],a);return`\n  ${n.registerUniforms(y).registerInternalVariables(i).declareVariables(...f,c)}\n  ${$}\n  ${h?fa(m,g,o,i):ga(m,g,o,i)}\n                   `}}}})),Gs=U((()=>{xs(),As(),Vs(),Hs(),Ls(),Fs(),wa=(e,t,n,r,a=!1,i,o=4,s=4,u=4,l="f32")=>{let d=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",p=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",c=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",f=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",h=e?"row":"col",m=e?"col":"row",g=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${h} / outWidth;\n    let outCol = ${h} % outWidth;\n\n    let WRow = ${m} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${m} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${m} % inChannels;\n    var resData = ${ua(o,l)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${c} && xCol >= 0 && xCol < ${f}) {\n      ${d}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${l}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n    }\n    return resData;`,y=e?t&&r?`\n    let col = colIn * ${o};\n    ${g}`:`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${g}\n    }\n    return ${ua(o,l)}(0.0);`:r&&n?`\n    let col = colIn * ${o};\n    ${g}`:`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${g}\n    }\n    return ${ua(o,l)}(0.0);`,b=`${(e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(s)}`,w=ua(u,l),v=ua(e?o:s,l),$=ua(e?s:o,l),_=oa(i,w);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${v} {\n      ${e?y:b}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${$} {\n      ${e?b:y}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n      let col = colIn * ${u};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${p}\n      ${la(a)}\n      ${_}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},va=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],p=u?n[2]:n[3],c=u?n[1]:n[2],f=u?n[3]:n[1],h=u&&(l%4==0||l%3==0)&&f%4==0,m=u?f:p*c,g=u?p*c:f,y=[8,8,1],b=r<=8?[4,1,1]:[4,4,1],w=[Math.ceil(m/y[0]/b[0]),Math.ceil(g/y[1]/b[1]),Math.ceil(d/y[2]/b[2])];nt("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${w}`));let v=h?u&&l%4!=0?3:4:1,$=y[1]*b[1],_=y[0]*b[0],x=Math.max(y[0]*v,y[1]),S=r%$==0,C=a%_==0,E=i%x==0,I=h?[v,4,4]:[1,1,1],T=[{type:"int32",data:r},{type:"int32",data:a},{type:"int32",data:i},{type:"int32",data:[t.pads[0],t.pads[1]]},{type:"int32",data:t.strides},{type:"int32",data:t.dilations}];"Clip"===t.activation&&T.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),T.push(..._t(e[0].dims),..._t(e[1].dims));let A=["rank","rank"];return o&&(T.push(..._t(e[2].dims)),A.push("rank")),T.push(..._t(n)),{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${v};${h};${S};${C};${E};${$};${_};${x}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:T}),getShaderSource:r=>{let a=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];"Clip"===t.activation&&a.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"});let i=h?4:1,l=vt(e[0].dataType),d=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${h?`vec4<${l}>`:l}) {\n        result[flatIndex] = ${h?`vec4<${l}>`:l}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${h?`vec4<${l}>`:l}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${h?"/ 4":""}, value);\n      }`,p=[At("x",e[0].dataType,e[0].dims.length,3===v?1:v),At("w",e[1].dataType,e[1].dims.length,i)],c=kt("result",e[0].dataType,n.length,i);if(o){let t=At("bias",e[2].dataType,e[2].dims.length,i);p.push(t),d+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?`vec4<${l}>`:l} {\n          return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n        }`}return`\n        ${da("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${r.registerUniforms(a).declareVariables(...p,c)}\n        ${d}\n        ${wa(u,S,C,E,o,t,I[0],I[1],I[2],l)}\n        ${h?fa(b,y,l,void 0,!u,x):ga(b,y,l,void 0,!u,x,!1,void 0,s)}`}}}})),js=U((()=>{Ts(),As(),Ks(),Vs(),$a=(e,t,n)=>{let r=e.length>2,a=r?"value += b[output_channel];":"",i=e[0].dims,o=e[1].dims,s=o[0]/t.group,u="NHWC"===t.format,l=Ca(i,o,t.dilations,t.pads,t.strides,u),d=ht.size(l),p=[{type:"uint32",data:d},{type:"uint32",data:t.dilations},{type:"uint32",data:[t.strides[0],t.strides[1]]},{type:"uint32",data:[t.pads[0],t.pads[1]]},{type:"uint32",data:s}];"Clip"===t.activation&&p.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),p.push(..._t(i),..._t(o),..._t(l));let c=["rank","rank"];return r&&(p.push(..._t(e[2].dims)),c.push("rank")),p.push(..._t(l)),{name:"GroupedConv",shaderCache:{hint:t.cacheKey,inputDependencies:c},getRunData:()=>({outputs:[{dims:n?n(l):l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:p}),getShaderSource:n=>{let s=kt("output",e[0].dataType,l.length),d=oa(t,s.type.value),p=At("x",e[0].dataType,i.length),c=At("w",e[1].dataType,o.length),f=[p,c];r&&f.push(At("b",e[2].dataType,e[2].dims));let h=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return"Clip"===t.activation&&h.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}),`\n  ${n.registerUniforms(h).declareVariables(...f,s)}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${s.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${u?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel / uniforms.output_channels_per_group;\n\n    var value: ${s.type.value} = ${s.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[${u?1:2}]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[${u?2:3}]) {\n            continue;\n          }\n\n          let xVal = ${u?p.get("batch","xHeight","xWidth","input_channel"):p.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${c.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${a}\n    ${d}\n    ${s.setByOffset("global_idx","value")}\n  }`}}}})),qs=U((()=>{Ts(),Fs(),As(),Vs(),_a=(e,t,n,r,a=!1)=>{let i=e[0].dims,o=e[1].dims,s=i[i.length-2],u=o[o.length-1],l=i[i.length-1],d=xt(u),p=xt(l),c=xt(s),f=ht.size(n)/d/c,h=e.length>2,m=r?r.slice(0,-2):n.slice(0,-2),g=[ht.size(m),s,u],y=[{type:"uint32",data:f},{type:"uint32",data:s},{type:"uint32",data:u},{type:"uint32",data:l}];return"Clip"===t.activation&&y.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),y.push(..._t(m),..._t(i),..._t(o)),h&&y.push(..._t(e[2].dims)),y.push(..._t(g)),{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${d};${p};${c};${a}`,inputDependencies:h?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:y}),getShaderSource:r=>{let s=Ot("batch_dims",e[0].dataType,m.length),u=At("a",e[0].dataType,i.length,p),l=At("b",e[1].dataType,o.length,d),f=kt("output",e[0].dataType,g.length,d),y=oa(t,f.type.value),b=[u,l],w="";if(h){let t=a?d:1;b.push(At("bias",e[2].dataType,e[2].dims.length,t)),w=a?`value += bias[col / ${t}];`:`value += ${f.type.value}(bias[row + i]);`}let v=i.slice(0,-2),$=o.slice(0,-2),_=Bt(v,m),x=Bt($,m),S=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];"Clip"===t.activation&&S.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"});let C=(e,t)=>{let n=e.rank,r=e.name;if(2===n)return`var ${r}_indices = ${e.type.indices}(0u, 0u);`;let a=s.rank,i=`var ${r}_indices: ${e.type.indices};`;for(let e=n-2-1,t=a-1;e>=0;e--,t--)i+=`\n${r}_indices[${e}] = ${a>1?`batch_indices[${t}]`:"batch_indices"};`;return t.forEach((e=>{i+=`\n${r}_indices[${e}] = 0;`})),i+=`${r}_indices[${n-2}] = 0u;\n                     ${r}_indices[${n-1}] = 0u;`,i};return`\n  ${r.registerUniforms(S).registerInternalVariables(s).declareVariables(...b,f)}\n  ${r.mainStart()}\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${d})) * ${d};\n    var index1 = global_idx / (uniforms.N / ${d});\n    let stride1 = uniforms.M / ${c};\n    let row = (index1 % stride1) * ${c};\n    let batch = index1 / stride1;\n\n    ${2===n.length?"":`let batch_indices = ${s.offsetToIndices("batch")};`}\n    ${C(u,_)}\n    let a_offset = ${u.indicesToOffset("a_indices")};\n    ${C(l,x)}\n    let b_offset = ${l.indicesToOffset("b_indices")};\n    var values: array<${f.type.value}, ${c}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${p}) {\n      ${(()=>{let e=`var a_data: ${u.type.value};`;for(let t=0;t<p;t++)e+=`\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${d}];`;for(let t=0;t<c;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${p}];`;for(let n=0;n<p;n++)e+=`\n            values[${t}] = fma(${l.type.value}(a_data${1===p?"":`[${n}]`}), b_data${n}, values[${t}]);\n`}return e})()}\n    }\n    for (var i = 0u; i < ${c}u; i++) {\n      var value = values[i];\n      ${w}\n      ${y}\n      let cur_indices = ${f.type.indices}(batch, row + i, col);\n      let offset = ${f.indicesToOffset("cur_indices")};\n      ${f.setByOffset(`offset / ${d}`,"value")};\n    }\n  }\n  `}}},xa=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Sa=e=>{xa(e.inputs);let t=ft.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];n<8&&r<8?e.compute(_a(e.inputs,{activation:""},t)):e.compute(ba(e.inputs,{activation:""},t))}})),Ks=U((()=>{Ts(),Gs(),Fs(),js(),Vs(),qs(),ks(),Ca=(e,t,n,r,a,i)=>{let o=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),p=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-d[t]+a[t])/a[t])));return p.splice(0,0,o),p.splice(i?3:1,0,l),p},Ea=[2,3,1,0],Ia=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Ta=(e,t)=>{let n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();mt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r}),a},Aa=e=>{let t=sa(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},ka=(e,t,n)=>{let r=Ta(n,t),a="NHWC"===n.format;if(1!==n.group)return void e.compute($a(t,r));let i=3===t.length,o=t[0].dims[a?1:2],s=t[0].dims[a?2:3],u=t[0].dims[a?3:1],l=t[1].dims[2],d=t[1].dims[3],p=Ca(t[0].dims,t[1].dims,n.dilations,r.pads,n.strides,a),c=p[a?1:2],f=p[a?2:3],h=p[a?3:1],m=a&&l===o&&d===s&&0===n.pads[0]&&0===n.pads[1];if(m||1===l&&1===d&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let l,d,g,y=p[0],b=[];if(a){let r=e.kernelCustomData.wT??e.compute(Wt(t[1],Ea),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*s*u;l=t[0].reshape([1,y,e]),d=r.reshape([1,e,h]),g=[1,y,h]}else l=t[0].reshape([y,o*s,u]),d=r.reshape([1,u,h]),g=[y,c*f,h];b.push(l),b.push(d)}else l=t[0].reshape([y,u,o*s]),d=t[1].reshape([1,h,u]),g=[y,h,c*f],b.push(d),b.push(l);i&&b.push(t[2]);let w=g[2],v=b[0].dims[b[0].dims.length-1];return void(w<8&&v<8?e.compute(_a(b,r,p,g,a),{inputs:b}):e.compute(ba(b,r,p,g,a),{inputs:b}))}let g=e.kernelCustomData.wT??e.compute(Wt(t[1],Ea),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let y=[t[0],g];i&&y.push(t[2]);let b=a?c*f:h,w=a?h:c*f,v=l*d*u;e.compute(va(y,r,p,b,w,v,i,!0),{inputs:y})},Oa=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),o=[1].concat(t.dilations),s=[1].concat(t.kernelShape),u=Ta({...t,pads:a,strides:i,dilations:o,kernelShape:s},r);e.compute($a(r,u,(e=>n?[e[0],e[2],e[3]]:[])))},Ra=(e,t)=>{Ia(e.inputs,t),3===e.inputs[0].dims.length?Oa(e,t):ka(e,e.inputs,t)}})),Ys=U((()=>{xs(),As(),Vs(),Hs(),Ls(),Fs(),za=(e,t=!1,n,r=4)=>{let a=ua(r,"f32"),i=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",o=e?"row":"col",s=e?"col":"row",u=`\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${o} / outWidth;\n      let outCol = ${o} % outWidth;\n\n      let WRow = ${s} / (uniforms.filter_dims[1] * inChannels);\n      let WCol = ${s} / inChannels % uniforms.filter_dims[1];\n      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(${e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])"}) || fract(xR) > 0.0) {\n        return ${a}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])"}) || fract(xC) > 0.0) {\n        return ${a}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${s} % inChannels;\n      ${e?"\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      "}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${r}];`,l=e?`\n      let col = colIn * ${r};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n        ${u}\n      }\n      return ${a}(0.0);`:`\n      let col = colIn * ${r};\n      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n        ${u}\n      }\n      return ${a}(0.0);`,d=`\n      let col = colIn * ${r};\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);\n      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];\n      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${(e=>{switch(e){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(r)}\n      }\n      return ${a}(0.0);\n      `,p=oa(n,a);return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?l:d}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?d:l}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {\n    let col = colIn * ${r};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${i}\n      ${la(t)}\n      ${p}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${r}] = value;\n    }\n  }`},Ba=(e,t,n,r,a,i,o,s)=>{let u="NHWC"===t.format,l=u?e[0].dims[3]:e[0].dims[1],d=n[0],p=u?n[2]:n[3],c=u?n[1]:n[2],f=u?n[3]:n[1],h=u?l%4==0&&f%4==0:p%4==0&&f%4==0,m=u?f:p*c,g=u?p*c:f,y=h?[8,8,1]:[m<=4||g<=4?4:16,m>4&&g<=4?4:16,1],b=h?[4,4,1]:[m<=4?1:4,m>4&&g<=4?1:4,1],w=[Math.ceil(m/y[0]/b[0]),Math.ceil(g/y[1]/b[1]),Math.ceil(d/y[2]/b[2])];nt("verbose",(()=>`[conv_backprop_mm_webgpu] dispatch = ${w}`));let v=h?4:1,$=Math.max(y[0]*v,y[1]),_=h?4:1,x=[t.kernelShape[u?1:2],t.kernelShape[u?2:3]],S=[x[0]+(t.dilations[0]<=1?0:(x[0]-1)*(t.dilations[0]-1)),x[1]+(t.dilations[1]<=1?0:(x[1]-1)*(t.dilations[1]-1))],C=[S[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),S[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],E=[{type:"int32",data:r},{type:"int32",data:a},{type:"int32",data:i},{type:"int32",data:t.strides},{type:"int32",data:t.dilations},{type:"int32",data:x},{type:"int32",data:C}];"Clip"===t.activation&&E.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),E.push(..._t(e[0].dims),..._t(e[1].dims));let I=["rank","rank"];return o&&(E.push(..._t(e[2].dims)),I.push("rank")),E.push(..._t(n)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${t.cacheKey};${b};${y};${h}`,inputDependencies:I},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:E}),getShaderSource:r=>{let a=At("x",e[0].dataType,e[0].dims.length,_),i=At("w",e[1].dataType,e[1].dims.length,1),l=kt("result",e[0].dataType,n.length,_),d=[a,i],p="";if(o){let t=At("bias",e[2].dataType,e[2].dims.length,_);d.push(t),p+=`\n          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?"vec4<f32>":"f32"} {\n            return bias[coords.${u?"w":"y"}${h?"/ 4":""}];\n          }`}let c=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:x.length},{name:"pads",type:"i32",length:C.length}];return"Clip"===t.activation&&c.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}),`\n        ${da("uniforms.result_strides")}\n        ${r.registerUniforms(c).declareVariables(...d,l)};\n        ${p}\n        ${za(u,o,t,v)}\n        ${h?fa(b,y,"f32",void 0,!u,$):ga(b,y,"f32",void 0,!u,$,!1,void 0,s)}`}}}})),Zs=U((()=>{xs(),Ts(),As(),Pa=(e,t,n,r,a,i=!1,o,s,u=!1)=>{let l=u?1:2,d=u?2:3,p=u?3:1,c=i?2:1,f=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${i?`vec4<${o}>`:o}) {\n    result[flatIndex] = ${i?`vec4<${o}>`:o}(value);\n  }`;r&&(f+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${i?`vec4<${o}>`:o} {\n      return bias[coords.${u?"w":"y"}${i?"/ 4":""}];\n    }`);let h=i?4:1,m=At("W",t[1].dataType,t[1].dims.length,h),g=At("Dy",t[0].dataType,t[0].dims.length,h),y=[g,m];r&&y.push(At("bias",t[2].dataType,[n[p]].length,h));let b=kt("result",t[0].dataType,n.length,h),w=`{\n        let batch: u32 = ${a?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];\n        let r = ${a?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];\n        let c = ${a?"global_id.y":"workgroup_id.y"} * ${c};\n        let d1: u32 = ${a?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${o}>, ${c}>;\n        for (var i = 0; i < ${c}; i++) {\n          dotProd[i] = vec4<${o}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {\n          var dyR = (${o}(dyCorner.x) + ${o}(wR)) / ${o}(uniforms.strides.x);\n          let wRPerm = uniforms.filter_dims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${o}(uniforms.Dy_shape[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {\n            let dyC = (${o}(dyCorner.y) + ${o}(wC)) / ${o}(uniforms.strides.y);\n            let dyC2 = (${o}(dyCorner.y) + 1.0 + ${o}(wC)) / ${o}(uniforms.strides.y);\n            let wCPerm = uniforms.filter_dims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${o}(uniforms.Dy_shape[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${o}(uniforms.Dy_shape[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${g.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${o}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${g.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${o}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = uniforms.Dy_shape[${p}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${g.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${o}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${m.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${g.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${o}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${c}; i = i + 1) {\n          let value = dotProd[i] + ${r?"bias[c+i]":`vec4<${o}>(0.0)`};\n          ${b.set("batch","r","c + i","d1","value")};\n        }\n      }`,v=`\n          let outputIndices = ${b.offsetToIndices("global_idx")};\n          let batch = ${b.indicesGet("outputIndices",0)};\n          let d1 = ${b.indicesGet("outputIndices",p)};\n          let r = ${b.indicesGet("outputIndices",l)};\n          let c = ${b.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / uniforms.output_channels_per_group;\n          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${o}(0.0);\n          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n            if (wR % uniforms.dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${o}(dyRCorner) + ${o}(wR)) / ${o}(uniforms.strides[0]);\n            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n            if (dyR < 0.0 || dyR >= ${o}(uniforms.Dy_shape[${l}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n              if (wC % uniforms.dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${o}(dyCCorner) + ${o}(wC)) / ${o}(uniforms.strides.y);\n              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n              if (dyC < 0.0 || dyC >= ${o}(uniforms.Dy_shape[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * uniforms.input_channels_per_group;\n              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\n                let xValue = ${u?g.get("batch","idyR","idyC","inputChannel"):g.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${m.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${r?"bias[d1]":`${o}(0.0)`};\n          ${b.setByOffset("global_idx","value")};\n        `;return`\n  ${e.registerUniforms(s).declareVariables(...y,b)}\n  ${f}\n\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n  ${i?w:v}}`},Ma=(e,t,n)=>{let r=e.length>2,a=t.outputShape,i=ht.size(a),o=[Math.ceil(i/64),1,1];nt("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${o}`));let s="NHWC"===t.format,u=["rank","rank"],l=[t.strides[0],t.strides[1]],d=[t.kernelShape[s?1:2],t.kernelShape[s?2:3]],p=[t.dilations[0],t.dilations[1]],c=[d[0]+(t.dilations[0]<=1?0:(t.kernelShape[s?1:2]-1)*(t.dilations[0]-1)),d[1]+(t.dilations[1]<=1?0:(t.kernelShape[s?2:3]-1)*(t.dilations[1]-1))],f=[c[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),c[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],h=t.group,m=e[1].dims,g=m[0]/h,y=m[1],b=[{type:"int32",data:i},{type:"uint32",data:l},{type:"uint32",data:d},{type:"uint32",data:p},{type:"uint32",data:c},{type:"int32",data:f},{type:"uint32",data:g},{type:"uint32",data:y},..._t(e[0].dims),..._t(e[1].dims)];r&&(b.push(..._t(e[2].dims)),u.push("rank")),b.push(..._t(a));let w=1===o[1]&&1===o[2];return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:u},getRunData:()=>({dispatchGroup:{x:o[0],y:o[1],z:o[2]},outputs:[{dims:n?n(a):a,dataType:e[0].dataType}],programUniforms:b}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:l.length},{name:"filter_dims",type:"u32",length:d.length},{name:"dilations",type:"u32",length:d.length},{name:"effective_filter_dims",type:"u32",length:c.length},{name:"pads",type:"i32",length:f.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],i=vt(e[0].dataType);return`${Pa(t,e,a,r,w,!1,i,n,s)}`}}}})),Qs=U((()=>{Ys(),Zs(),Vs(),ks(),Da=(e,t,n,r,a,i)=>(e-1)*t+n+(r-1)*a+1-i,Na=(e,t,n,r,a)=>{let i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[a]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[a]=i)},Wa=(e,t,n,r,a,i,o,s,u,l)=>{let d=e.length-2,p=0===l.length;if(0===u.length)for(let e=0;e<d;++e)u.push(0);let c=e[0],f=t[s?3:1]*a;for(let a=0,c=e.length-d-(s?1:0);a<d;++a,++c){let s=e[c],f=p?s*o[a]:l[a],h=Da(s,o[a],i[a],t[c],n[a],f);Na(h,r,i,a,a+d),p&&l.push(o[a]*(s-1)+u[a]+(t[c]-1)*n[a]+1-i[a]-i[a+d])}l.splice(0,0,c),l.splice(s?3:1,0,f)},Ua=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let a=e.pads.slice(),i=e.outputShape.slice(),o=e.outputPadding.slice(),s=t[0].dims,u=e.dilations.slice();if(0===u.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}let l=e.strides.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}Wa(s,n,u,e.autoPad,e.group,a,l,r,o,i);let d=Object.assign({},e);return Object.assign(d,{kernelShape:n,pads:a,outputPadding:o,outputShape:i,dilations:u,strides:l}),d},Va=e=>{let t=sa(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,i=e.group,o=e.kernelShape,s=e.pads,u=e.strides,l=e.wIsConst();return{autoPad:r,format:n,dilations:a,group:i,kernelShape:o,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:s,strides:u,wIsConst:l,...t,cacheKey:`${e.format};${t.activation};`}},Ha=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},La=[2,3,1,0],Fa=(e,t,n)=>{let r=Ua(n,t),a="NHWC"===n.format,i=r.outputShape,o=i[a?3:1],s=t[0].dims[a?3:1];if(1!==r.group||1===o&&1===s)return void e.compute(Ma(t,r));let u=i[a?1:2],l=i[a?2:3],d=a?u*l:o,p=a?o:u*l,c=t[1].dims[2]*t[1].dims[3]*s,f=e.kernelCustomData.wT??e.compute(Wt(t[1],La),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=f);let h=[t[0],f],m=3===t.length;m&&(a||1!==t[2].dims.length?h.push(t[2]):h.push(t[2].reshape([t[2].dims[0],1,1]))),e.compute(Ba(h,r,i,d,p,c,m,!0),{inputs:h})},Ga=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===r.length&&r.push(e.inputs[2]);let a=t.kernelShape;(0===a.length||0===a[0])&&(a=[e.inputs[1].dims[2]]);let i=t.dilations;(0===i.length||0===i[0])&&(i=[1]);let o=t.strides;(0===o.length||0===o[0])&&(o=[1]);let s=t.pads;0===s.length&&(s=[0,0]),s=[0,s[0],0,s[1]],o=[1].concat(o),i=[1].concat(i),a=[1].concat(a);let u=Ua({...t,pads:s,strides:o,dilations:i,kernelShape:a},r);e.compute(Ma(r,u,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])))},ja=(e,t)=>{Ha(e.inputs,t),3===e.inputs[0].dims.length?Ga(e,t):Fa(e,e.inputs,t)}})),Xs=U((()=>{$s(),Ts(),Is(),As(),qa=(e,t,n,r)=>{let a=ht.size(t),i=t.length,o=At("input",e,i),s=kt("output",e,i),u=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),l=ht.normalizeAxis(u,i);return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:"uint32",data:a},{type:"int32",data:l},..._t(t),..._t(t)]}),getShaderSource:e=>{let t=` i32(${o.indicesGet("inputIndices","uniforms.axis")}) `,n=It("uniforms.input_shape","uniforms.axis",i),a=r.reverse?t+(r.exclusive?" + 1":""):"0",u=r.reverse?n:t+(r.exclusive?"":" + 1");return`\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(o,s)}\n                ${e.mainStart()}\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${s.offsetToIndices("global_idx")};\n                  var sum = ${s.type.value}(0);\n                  let first : i32 = ${a};\n                  let last : i32 = ${u};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${o.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${o.getByIndices("inputIndices")};\n                  }\n                  ${s.setByOffset("global_idx","sum")};\n                }`}}},Ka=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,a=e.inputs[1];e.compute(qa(r,n,a,t),{inputs:[0]})},Ya=e=>{let t=1===e.exclusive,n=1===e.reverse;return pt({exclusive:t,reverse:n})}})),Js=U((()=>{Ts(),Is(),As(),Xa="^"+(Qa="("+(Za="[a-zA-Z]|\\.\\.\\.")+")+")+"$",Ja="^("+Qa+",)*"+Qa+"$",ei=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},ti=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(Ja)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(Xa)))throw new Error("Invalid LHS term");let a=this.processTerm(t,!0,r,n);this.lhs.push(a)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(Qa)))throw new Error("Invalid RHS");r.match(RegExp(Za,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let a=n.length,i=!1,o=[],s=0;if(!e.match(RegExp(Xa))&&!t&&""!==e)throw new Error("Invalid LHS term");let u=e.match(RegExp(Za,"g")),l=new ei(r);return u?.forEach(((e,d)=>{if("..."===e){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let e=a-u.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(o=n.slice(s,s+e),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=o}for(let e=0;e<o.length;e++){let t=String.fromCharCode("0".charCodeAt(0)+e);l.addSymbol(t,d+e),this.addSymbol(t,n[s++],r)}}else l.addSymbol(e,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[s++],r)})),l}},ni=e=>e+"_max",ri=(e,t,n,r)=>{let a=e.map((e=>e.length)).map(((e,n)=>At(`input${n}`,t,e))),i=ht.size(r),o=kt("output",t,r.length),s=[...n.symbolToInfo.keys()].filter((e=>!n.rhs.symbolToIndices.has(e)));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map((()=>"rank"))},getRunData:()=>{let a=s.filter((e=>n.symbolToInfo.has(e))).map((e=>({type:"uint32",data:n.symbolToInfo.get(e)?.dimValue||0})));a.push({type:"uint32",data:i});let o=e.map(((e,t)=>[..._t(e)])).reduce(((e,t)=>e.concat(t)),a);return o.push(..._t(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:o}},getShaderSource:e=>{let t=[],r=[],i=[],u=[],l=[],d=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach(((e,s)=>{if(n.rhs.symbolToIndices.has(s)){let r=n.rhs.symbolToIndices.get(s)?.[0];void 0!==r&&n.lhs.forEach(((n,i)=>{if(e.inputIndices.includes(i)){let e=n.symbolToIndices.get(s);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{t.push(`${a[i].indicesSet(`input${i}Indices`,e,o.indicesGet("outputIndices",r))}`)}))}}))}else n.lhs.forEach(((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(s);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{r.push(`${a[n].indicesSet(`input${n}Indices`,e,`${s}`)}`)})),l.push(`prod *= ${a[n].getByIndices(`input${n}Indices`)};`)}})),i.push(`for(var ${s}: u32 = 0; ${s} < uniforms.${ni(s)}; ${s}++) {`),u.push("}")}));let p=d?[...t,`let sum = ${a.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...t,"var sum = 0.0;",...i,...r,"var prod = 1.0;",...l,"sum += prod;",...u];return`\n            ${e.registerUniforms(s.map((e=>({name:`${ni(e)}`,type:"u32"})))).registerUniform("outputSize","u32").declareVariables(...a,o)}\n\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${o.offsetToIndices("global_idx")};\n            ${a.map(((e,t)=>`var input${t}Indices: ${a[t].type.indices};`)).join("\n")}\n            ${p.join("\n")};\n            ${o.setByOffset("global_idx","sum")};\n          }`}}},ai=(e,t)=>{let n=new ti(e.inputs,t.equation),r=n.outputDims,a=e.inputs.map(((e,t)=>e.dims));e.compute(ri(a,e.inputs[0].dataType,n,r))},ii=e=>{let t=e.equation.replace(/\s+/g,"");return pt({equation:t})}})),eu=U((()=>{$s(),Ts(),As(),oi=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,a=t.length<n.length?0:t.length-n.length;for(;r<n.length&&a<t.length;++r,++a)if(n[r]!==t[a]&&1!==n[r]&&1!==t[a])throw new Error("Expand requires shape to be broadcastable to input")},si=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let a=0;a<t.length;++a)r.push(1===t[a]?e[a+n]:t[a]);return r},ui=(e,t)=>e.length>t.length?si(e,t):si(t,e),li=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=ui(t,n),a=e[0].dataType,i=9===a?4:1,o=Math.ceil(ht.size(r)/i),s=[{type:"uint32",data:o},..._t(t),..._t(r)];return{name:"Expand",shaderCache:{hint:`${r.length}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,o=At("input",a,t.length,i),s=kt("output",a,r.length,i);if(9===a){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${s.offsetToIndices(`outputOffset + ${t}u`)};\n          let offset${t} = ${o.broadcastedIndicesToOffset(`outputIndices${t}`,s)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${o.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${i};\n        var data = vec4<u32>(0);\n        ${e("data",0,"u32")}\n        ${e("data",1,"u32")}\n        ${e("data",2,"u32")}\n        ${e("data",3,"u32")}\n        ${s.setByOffset("global_idx","data")}\n      }`}else n=`\n        let outputIndices = ${s.offsetToIndices("global_idx")};\n        let inputOffset = ${o.broadcastedIndicesToOffset("outputIndices",s)};\n        ${s.setByOffset("global_idx",o.getByOffset("inputOffset"))}\n      }`;return`\n    ${e.registerUniform("vec_size","u32").declareVariables(o,s)}\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:s})}},di=e=>{oi(e.inputs),e.compute(li(e.inputs),{inputs:[0]})}})),tu=U((()=>{$s(),Ts(),Is(),As(),pi=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},ci=(e,t)=>{let n=e[0].dims,r=e[1].dims,a=n.length,i=ht.normalizeAxis(t.axis,a),o=n.slice(0);o.splice(i,1,...r);let s=n[i],u=9===e[0].dataType?4:1,l=Math.ceil(ht.size(o)/u),d=[{type:"uint32",data:l},{type:"int32",data:s},{type:"uint32",data:i},..._t(e[0].dims),..._t(e[1].dims),..._t(o)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:t=>{let n,s=At("data",e[0].dataType,e[0].dims.length,u),l=At("inputIndices",e[1].dataType,e[1].dims.length),d=kt("output",e[0].dataType,o.length,u),p=e=>{let t=r.length,n=`var indicesIndices${e}  = ${l.type.indices}(0);`;for(let r=0;r<t;r++)n+=`${t>1?`indicesIndices${e}[${r}]`:`indicesIndices${e}`} = ${o.length>1?`outputIndices${e}[uniforms.axis + ${r}]`:`outputIndices${e}`};`;n+=`\n          var idx${e} = ${l.getByIndices(`indicesIndices${e}`)};\n          if (idx${e} < 0) {\n            idx${e} = idx${e} + uniforms.axisDimLimit;\n          }\n          var dataIndices${e} = ${s.type.indices}(0);\n        `;for(let r=0,s=0;r<a;r++)r===i?(n+=`${a>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = u32(idx${e});`,s+=t):(n+=`${a>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = ${o.length>1?`outputIndices${e}[${s}]`:`outputIndices${e}`};`,s++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${d.offsetToIndices(`outputOffset + ${t}u`)};\n          ${p(t)};\n          let offset${t} = ${s.indicesToOffset(`dataIndices${t}`)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${s.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${u};\n        var value = vec4<u32>(0);\n        ${e("value",0,"u32")}\n        ${e("value",1,"u32")}\n        ${e("value",2,"u32")}\n        ${e("value",3,"u32")}\n        ${d.setByOffset("global_idx","value")}\n      `}else n=`\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      ${p("")};\n      let value = ${s.getByIndices("dataIndices")};\n      ${d.setByOffset("global_idx","value")};\n      `;return`\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(s,l,d)}\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${n}\n      }`}}},fi=e=>pt({axis:e.axis}),hi=(e,t)=>{let n=e.inputs;pi(n),e.compute(ci(e.inputs,t))}})),nu=U((()=>{Ts(),Is(),As(),mi=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},gi=(e,t)=>{let n=e[0].dims,r=e[0].dataType,a=n.length,i=e[1].dims,o=e[1].dataType,s=ht.normalizeAxis(t.axis,a),u=n[s],l=i.slice(0),d=ht.size(l),p=At("input",r,a),c=At("indicesInput",o,i.length),f=kt("output",r,l.length),h=[{type:"uint32",data:d},{type:"int32",data:u},{type:"uint32",data:s}];return h.push(..._t(n)),h.push(..._t(i)),h.push(..._t(l)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:e=>`\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,c,f)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${f.offsetToIndices("global_idx")};\n\n      var idx = ${c.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${p.type.indices}(outputIndices);\n      ${p.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${p.getByIndices("inputIndices")};\n\n      ${f.setByOffset("global_idx","value")};\n  }`}},yi=e=>pt({axis:e.axis}),bi=(e,t)=>{let n=e.inputs;mi(n),e.compute(gi(e.inputs,t))}})),ru=U((()=>{Ts(),As(),wi=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},vi=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[a,i,o]=gt.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),s=[a,i];if(!s)throw new Error("Can't use gemm on the given tensors");let u=ht.size(s),l=[{type:"uint32",data:u},{type:"uint32",data:a},{type:"uint32",data:i},{type:"uint32",data:o},{type:"float32",data:t.alpha},{type:"float32",data:t.beta}],d=["type","type"];return 3===e.length&&(l.push(..._t(e[2].dims)),d.push("rank")),l.push(..._t(s)),{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l}),getShaderSource:n=>{let r="";t.transA&&t.transB?r="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?r="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?r="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(r="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let a=1===t.alpha?"":"value *= uniforms.alpha;",i=At("a",e[0].dataType,e[0].dims),o=At("b",e[1].dataType,e[1].dims),u=i.type.value,l=null,d=[i,o];3===e.length&&(l=At("c",e[2].dataType,e[2].dims.length),d.push(l));let p=kt("output",e[0].dataType,s.length);return d.push(p),`\n  ${n.registerUniforms([{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...d)}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${u}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${r}\n    }\n\n    ${a}\n    ${null!=l?`let cOffset = ${l.broadcastedIndicesToOffset("vec2(m, n)",p)}; value += ${u}(uniforms.beta) * ${l.getByOffset("cOffset")};`:""}\n    output[global_idx] = value;\n  }`}}},$i=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),_i=(e,t)=>{wi(e.inputs),e.compute(vi(e.inputs,t))}})),au=U((()=>{$s(),Ts(),As(),xi=(e,t)=>{let n=e[0].dims,r=n,a=ht.sizeToDimension(n,2),i=ht.sizeFromDimension(n,2),o=xt(i),s=i/o,u=[n[0],n[1],s],l=[{type:"uint32",data:i},{type:"uint32",data:s}];return l.push(..._t(u),..._t(u)),{name:"InstanceNormalization",shaderCache:{hint:`${t.epsilon};${o}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:a},programUniforms:l}),getShaderSource:n=>{let r=At("x",e[0].dataType,u.length,o),a=At("scale",e[1].dataType,e[1].dims),i=At("bias",e[2].dataType,e[2].dims),s=kt("output",e[0].dataType,u.length,o),l=[r,a,i,s],d=r.type.value,p=1===o?"f32":`vec${o}<f32>`;return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${p}, 64>;\n  const workgroupSize = 64u;\n  ${n.registerUniforms([{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}]).declareVariables(...l)}\n  ${n.mainStart(64)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${p}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${p}(${r.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${Et("workgroupShared[0]",o)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${p}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${p}(${r.get("batch","channel","h")}) - ${p}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${Et("workgroupShared[0]",o)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${a.getByOffset("channel")});\n    let channelShift = f32(${i.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${r.get("batch","channel","h")} * ${d}(${p}(channelScale)) + ${d}(${p}(channelShift));\n      ${s.set("batch","channel","h","value")};\n    }\n  }`}}},Si=(e,t,n,r,a,i,o,s)=>{let u=xt(o),l=1===u?"vec2f":`mat2x${u}f`,d=1===u?"f32":`vec${u}f`,p=(e,t)=>`${l}(${e}, ${t})`,c=a*o/u,f=[{type:"uint32",data:Math.ceil(i/64)},{type:"uint32",data:i},{type:"uint32",data:Math.floor(o/u)},{type:"uint32",data:Math.floor(i*o/u)}],h=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${u}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:[a,o,64,2],dataType:1}],dispatchGroup:{x:a*o/u},programUniforms:f}),getShaderSource:e=>{let n=At("input",t.dataType,t.dims,u);return`\n  ${e.declareVariables(n)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${l}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart(64)}\n    let currentImageNumber = global_idx / 64 / uniforms.C;\n    let currentChannelNumber = (global_idx / 64) % uniforms.C;\n    let wgId = global_idx % 64;\n    let wgOffset = wgId * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${St("f32",u)};\n    var squaredSum = ${St("f32",u)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${d}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${p("sum","squaredSum")};\n  }`}},{inputs:[t],outputs:[-1]})[0],m=[{type:"uint32",data:c},{type:"uint32",data:i},{type:"uint32",data:Math.floor(o/u)},{type:"uint32",data:Math.floor(64*o/u)}];return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${u};${s}`,inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:[a,o,2],dataType:1}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:m}),getShaderSource:e=>{let t=At("scale",n.dataType,n.dims,u),a=At("bias",r.dataType,r.dims,u);return`\n  @group(0) @binding(0) var<storage, read> input : array<${l}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${t.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${a.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${l}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${St("f32",u)};\n    var squaredSum = ${St("f32",u)};\n    for (var i: u32 = 0; i < 64; i++) {\n        let value = input[offset + i + currentChannelNumber * 64];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${s}));\n    let channelScale = invStdDev * ${d}(scale[currentChannelNumber]);\n    let channelShift = ${d}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${p("channelScale","channelShift")};\n  }`}},{inputs:[h,n,r],outputs:[-1]})[0]},Ci=(e,t,n)=>{let r=t[0].dims,a=r,i=r[0],o=r[r.length-1],s=ht.sizeFromDimension(r,1)/o,u=xt(o),l=ht.size(a)/u,d=[{type:"uint32",data:s},{type:"uint32",data:Math.floor(o/u)}],p=Si(e,t[0],t[1],t[2],i,s,o,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${u}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:e=>{let n=vt(t[0].dataType),r=1===u?"vec2f":`mat2x${u}f`,i=1===u?n:`vec${u}<${n}>`,o=At("input",t[0].dataType,t[0].dims,u),s=kt("output",t[0].dataType,a,u);return`\n  @group(0) @binding(0) var<storage, read> input : array<${o.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${r}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${s.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${i}(scale[0]), ${i}(scale[1]));\n  }`}},{inputs:[t[0],p]})},Ei=(e,t)=>{"NHWC"===t.format?Ci(e,e.inputs,t):e.compute(xi(e.inputs,t))}})),iu=U((()=>{$s(),Ts(),As(),Ii=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Ti=(e,t,n)=>{let r=e[0].dims,a=e[1],i=e[2],o=r,s=ht.normalizeAxis(t.axis,r.length),u=ht.sizeToDimension(r,s),l=ht.sizeFromDimension(r,s),d=ht.size(a.dims),p=i?ht.size(i.dims):0;if(d!==l||i&&p!==l)throw new Error(`Size of X.shape()[axis:] == ${l}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${d} and bias size of ${p}`);let c=[];for(let e=0;e<r.length;++e)e<s?c.push(r[e]):c.push(1);let f=xt(l),h=["type","type"],m=[{type:"uint32",data:u},{type:"float32",data:l},{type:"uint32",data:Math.floor(l/f)},{type:"float32",data:t.epsilon}];i&&h.push("type");let g=n>1,y=n>2,b=[{dims:o,dataType:e[0].dataType}];return g&&b.push({dims:c,dataType:1}),y&&b.push({dims:c,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n}`,inputDependencies:h},getRunData:()=>({outputs:b,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:m}),getShaderSource:t=>{let n=vt(e[0].dataType),r=[At("x",e[0].dataType,e[0].dims,f),At("scale",a.dataType,a.dims,f)];return i&&r.push(At("bias",i.dataType,i.dims,f)),r.push(kt("output",e[0].dataType,o,f)),g&&r.push(kt("mean_data_output",1,c)),y&&r.push(kt("inv_std_output",1,c)),`\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...r)}\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var meanVector = ${St("f32",f)};\n    var meanSquareVector = ${St("f32",f)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Ct(n,f,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${Et("meanVector",f)} / uniforms.norm_size;\n    let invStdDev =\n        inverseSqrt(${Et("meanSquareVector",f)} / uniforms.norm_size - mean * mean + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Ct(n,f,"x[j + offset]")};\n      let f32scale = ${Ct(n,f,"scale[j]")};\n      output[j + offset] = ${r[0].type.value}((f32input - mean) * invStdDev * f32scale\n        ${i?`+ ${Ct(n,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${g?"mean_data_output[global_idx] = mean":""};\n    ${y?"inv_std_output[global_idx] = invStdDev":""};\n  }`}}},Ai=(e,t)=>{Ii(e.inputs),e.compute(Ti(e.inputs,t,e.outputCount))}})),ou=U((()=>{Ts(),Is(),Cs(),Bs(),As(),ks(),ki=(e,t)=>{let n=e[0],r=e[1],a=e[2],i=e[3],o=e[4],s=e[5],u=e[6],l=e[7];if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let d,p=n.dims[0],c=n.dims[1],f=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],h=c,m=0,g=0,y=Math.floor(f/t.numHeads);if(u&&l){if(4!==u.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(4!==l.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');m=u.dims[2],g=u.dims[2]}else if(u||l)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');if(r){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===r.dims.length){if(r.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');d=2,h=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==y)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');d=5,h=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==y)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');d=0,h=r.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');d=3}if(i){if(1!==i.dims.length)throw new Error('Input "bias" is expected to have 1 dimension');if(a&&5===n.dims.length&&2===n.dims[3])throw new Error("bias is not allowed for packed kv.")}let b=0;if(o){b=8;let e=o.dims;throw 1===e.length?e[0]===p?b=1:e[0]===3*p+2&&(b=3):2===e.length&&e[0]===p&&e[1]===h&&(b=5),8===b?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let w=!1,v=f;if(a){if(3!==a.dims.length&&4!==a.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===a.dims.length){if(h!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');v=a.dims[2]}else{if(h!==a.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');v=a.dims[1]*a.dims[3],w=!0}}let $=m+h;if(o)throw new Error("Key padding mask is not supported");if(s)throw new Error("extraAddQk is not supported");if(u)throw new Error("pastKey is not supported");if(l)throw new Error("pastValue is not supported");return{batchSize:p,sequenceLength:c,pastSequenceLength:m,kvSequenceLength:h,totalSequenceLength:$,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:f,vHiddenSize:v,headSize:y,vHeadSize:Math.floor(v/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:b,scale:t.scale,broadcastResPosBias:!1,passPastInKv:w,qkvFormat:d}},Oi=e=>pt({...e}),Ri=pt({perm:[0,2,1,3]}),zi=(e,t,n,r,a,i,o)=>{let s=[r,a,i],u=ht.size(s),l=[{type:"uint32",data:u},{type:"uint32",data:o},{type:"uint32",data:i}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l}),getShaderSource:e=>{let r=kt("qkv_with_bias",t.dataType,s),a=At("qkv",t.dataType,s),i=At("bias",n.dataType,s);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(a,i,r)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},Bi=(e,t,n,r,a,i,o,s)=>{let u=i;if(o){if(1===r)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return u=zi(e,i,o,t,r,n*a,s),u=u.reshape([t,r,n,a]),e.compute(Wt(u,Ri.perm),{inputs:[u],outputs:[-1]})[0]}return 3===i.dims.length&&(u=i.reshape([t,r,n,a])),e.compute(Wt(u,Ri.perm),{inputs:[u],outputs:[-1]})[0]},Pi=(e,t)=>{let n=ki(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let r=e.inputs[1]&&e.inputs[2]&&4===e.inputs[1].dims.length&&4===e.inputs[2].dims.length,a=Bi(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,e.inputs[0],e.inputs[3],0);if(r)return Fn(e,a,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],n,t);let i=Bi(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,e.inputs[1],e.inputs[3],n.hiddenSize),o=Bi(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,e.inputs[2],e.inputs[3],2*n.hiddenSize);Fn(e,a,i,o,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],n,t)}})),su=U((()=>{$s(),Ts(),As(),Mi=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Di=(e,t,n)=>{let r="";for(let a=t-1;a>=0;--a)r+=`\n            k = i32(${e.indicesGet("indices",a)}) - ${It("uniforms.pads",a,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${It("uniforms.x_shape",a,t)})) {\n              break;\n            }\n            offset += k * i32(${It("uniforms.x_strides",a,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${r}\n            value = x[offset];\n          }\n      `},Ni=(e,t,n)=>{let r="";for(let a=t-1;a>=0;--a)r+=`\n                k = i32(${e.indicesGet("indices",a)}) - ${It("uniforms.pads",a,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${It("uniforms.x_shape",a,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${It("uniforms.x_shape",a,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${It("uniforms.x_strides",a,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},Wi=(e,t,n)=>{let r="";for(let a=t-1;a>=0;--a)r+=`\n                k = i32(${e.indicesGet("indices",a)}) - ${It("uniforms.pads",a,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${It("uniforms.x_shape",a,t)})) {\n                  k = i32(${It("uniforms.x_shape",a,t)}) - 1;\n                }\n                offset += k * i32(${It("uniforms.x_strides",a,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},Ui=(e,t,n)=>{let r="";for(let a=t-1;a>=0;--a)r+=`\n                k = i32(${e.indicesGet("indices",a)}) - ${It("uniforms.pads",a,n)};\n                if (k < 0)  {\n                  k += i32(${It("uniforms.x_shape",a,t)}]);\n                }\n                if (k >= i32(${It("uniforms.x_shape",a,t)})) {\n                  k -= i32(${It("uniforms.x_shape",a,t)});\n                }\n                offset += k * i32(${It("uniforms.x_strides",a,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},Vi=(e,t,n)=>{switch(n.mode){case 0:return Di(e,t,n.pads.length);case 1:return Ni(e,t,n.pads.length);case 2:return Wi(e,t,n.pads.length);case 3:return Ui(e,t,n.pads.length);default:throw new Error("Invalid mode")}},Hi=(e,t)=>{let n=ht.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,a=[{type:"uint32",data:ht.size(n)},{type:"uint32",data:t.pads}];if(0===t.mode){let n=Le(e[0].dataType);a.push({type:n,data:t.value})}return a.push(..._t(e[0].dims),..._t(n)),{name:"Pad",shaderCache:{hint:`${t.mode}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(ht.size(n)/64)},programUniforms:a}),getShaderSource:a=>{let i=kt("output",e[0].dataType,n.length),o=At("x",e[0].dataType,r.length),s=o.type.value,u=Vi(i,r.length,t),l=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&l.push({name:"constant_value",type:s}),`\n            ${a.registerUniforms(l).declareVariables(o,i)}\n            ${a.mainStart()}\n            ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${i.offsetToIndices("global_idx")};\n\n            var value = ${s}(0);\n            ${u}\n            output[global_idx] = value;\n        }`}}},Li=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,i=new Int32Array(2*a).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)i[Number(t[e])]=Number(n[e]),i[Number(t[e])+a]=Number(n[e+t.length])}else n.forEach(((e,t)=>i[Number(t)]=Number(e)));let o=[];return i.forEach((e=>o.push(e))),{mode:t.mode,value:r,pads:o}}return t},Fi=(e,t)=>{Mi(e.inputs);let n=Li(e.inputs,t);e.compute(Hi(e.inputs,n),{inputs:[0]})}})),uu=U((()=>{ue(),Ts(),As(),Gi=e=>{if(p.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},ji=(e,t,n)=>{let r="NHWC"===t.format,a=e.dims.slice();r&&a.splice(1,0,a.pop());let i=Object.hasOwnProperty.call(t,"dilations"),o=t.kernelShape.slice(),s=t.strides.slice(),u=i?t.dilations.slice():[],l=t.pads.slice();mt.adjustPoolAttributes(n,a,o,s,u,l);let d=mt.computePoolOutputShape(n,a,s,u,o,l,t.autoPad),p=Object.assign({},t);i?Object.assign(p,{kernelShape:o,strides:s,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:o,strides:s,pads:l,cacheKey:t.cacheKey});let c=d.slice();return c.push(c.splice(1,1)[0]),[p,r?c:d]},qi=(e,t)=>{let n="NHWC"===t.format,r=[{type:"uint32",data:ht.size(e)},{type:"uint32",data:ht.size(t.kernelShape)}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],i=t.pads[t.pads.length/2-1],o=t.pads[t.pads.length-1],s=!!(i+o);r.push({type:"uint32",data:e},{type:"uint32",data:n},{type:"uint32",data:i},{type:"uint32",data:o}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let u=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],i=t.pads[t.pads.length/2-2],o=t.pads[t.pads.length-2];u=!!(i+o),r.push({type:"uint32",data:e},{type:"uint32",data:n},{type:"uint32",data:i},{type:"uint32",data:o}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[r,a,!0,s,u]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=ht.computeStrides(t.kernelShape);return r.push({type:"uint32",data:e},{type:"uint32",data:t.pads},{type:"uint32",data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length}),[r,a,!!t.pads.reduce(((e,t)=>e+t)),!1,!1]}},Ki=(e,t,n,r,a,i,o,s,u,l,d,p)=>{let c="NHWC"===a.format,f=t.type.value,h=kt("output",t.type.tensor,r);if(a.kernelShape.length<=2){let r="",l="",m="",g=n-(c?2:1);if(r=d?`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${g}] < 0 || xIndices[${g}]\n                      >= uniforms.x_shape[${g}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`:`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${i}\n                }`,2===a.kernelShape.length){let e=n-(c?3:2);l=p?`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                `,m="\n              }\n            "}return`\n            ${e.registerUniforms(u).declareVariables(t,h)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${h.offsetToIndices("global_idx")};\n              var xIndices = ${h.offsetToIndices("global_idx")};\n\n              var value = ${f}(${s});\n              var pad = 0;\n              ${l}\n              ${r}\n              ${m}\n              ${o}\n\n              output[global_idx] = value;\n            }`}{if(c)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let r=a.kernelShape.length,d=a.pads.length,p="";return p=l?`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${i}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${i}\n            `,`\n            ${e.registerUniforms(u).declareVariables(t,h)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${h.offsetToIndices("global_idx")};\n              var xIndices = ${h.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${r}>;\n\n              var value = ${f}(${s});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${r-1}u; j++) {\n                  offsets[j] = offset / ${It("uniforms.kernelStrides","j",r)};\n                  offset -= offsets[j] * ${It("uniforms.kernelStrides","j",r)};\n                }\n                offsets[${r-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-r}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${It("uniforms.strides",`j - ${n-r}u`,r)}\n                    + offsets[j - ${n-r}u] - ${It("uniforms.pads","j - 2u",d)};\n                  ${p}\n              }\n              ${o}\n\n              output[global_idx] = value;\n            }`}},Yi=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Zi=e=>`${Yi(e)};${e.countIncludePad}`,Qi=e=>`${Yi(e)};${e.storageOrder};${e.dilations}`,Xi=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ji=(e,t,n,r)=>{let[a,i]=ji(t,r,n),o=At("x",t.dataType,t.dims.length),s=o.type.value,u="";a.countIncludePad?u+=`value /= ${s}(uniforms.kernelSize);`:u+=`value /= ${s}(i32(uniforms.kernelSize) - pad);`;let[l,d,p,c,f]=qi(i,a);return l.push(..._t(t.dims),..._t(i)),{name:e,shaderCache:{hint:`${r.cacheKey};${p};${c};${f}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ht.size(i)/64)},programUniforms:l}),getShaderSource:e=>Ki(e,o,t.dims.length,i.length,a,"value += x_val;",u,0,d,p,c,f)}},eo=e=>{let t=0!==e.count_include_pad,n=Xi(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:Zi(r)}},to=(e,t)=>{Gi(e.inputs),e.compute(Ji("AveragePool",e.inputs[0],!1,t))},no={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},ro=e=>{let t=e.format;return{format:t,...no,cacheKey:t}},ao=(e,t)=>{Gi(e.inputs),e.compute(Ji("GlobalAveragePool",e.inputs[0],!0,t))},io=(e,t,n,r)=>{let[a,i]=ji(t,r,n),o=At("x",t.dataType,t.dims.length),[s,u,l,d,p]=qi(i,a);return s.push(..._t(t.dims),..._t(i)),{name:e,shaderCache:{hint:`${r.cacheKey};${l};${d};${p}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(ht.size(i)/64)},programUniforms:s}),getShaderSource:e=>Ki(e,o,t.dims.length,i.length,a,"\n      value = max(x_val, value);\n    ","",-1e5,u,l,d,p)}},oo=(e,t)=>{Gi(e.inputs),e.compute(io("MaxPool",e.inputs[0],!1,t))},so=e=>{let t=e.storage_order,n=e.dilations,r=Xi(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let a={storageOrder:t,dilations:n,...r,cacheKey:""};return{...a,cacheKey:Qi(a)}},uo=e=>{let t=e.format;return{format:t,...no,cacheKey:t}},lo=(e,t)=>{Gi(e.inputs),e.compute(io("GlobalMaxPool",e.inputs[0],!0,t))}})),lu=U((()=>{ue(),$s(),As(),po=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},co=(e,t,n,r)=>{let a=Math.abs(Math.ceil((t-e)/n)),i=[a],o=a,s=Le(r),u=[{type:"uint32",data:o},{type:s,data:e},{type:s,data:n},..._t(i)];return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:e=>{let t=kt("output",r,i.length),n=t.type.value,a=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\n        ${e.registerUniforms(a).declareVariables(t)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\n      }`},getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:u})}},fo=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),p.webgpu.validateInputContent&&po(t,n,r),e.compute(co(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),du=U((()=>{Ts(),Is(),As(),ho=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},mo=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},go=(e,t,n,r,a,i)=>{let[o,s,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(s>0&&e.length>s&&e[s].dims.length>0){if(e[s].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ho(r,t),t.axes.length>0&&mo(r,t.axes,l).forEach(((e,t)=>r[t]=e))}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach((e=>a.push(Number(e)))),a.length!==l||n>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof a<"u"&&r.length>0&&a.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},yo=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",bo=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",wo=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),a=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=a[i],r[i+n]=a[t.length+i]})),r):a},vo=(e,t,n,r)=>{let a=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>a.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>a[e]=n[t]))}else n.forEach((e=>a.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");a=e.map(((e,n)=>Math.round(e*t[n])))}return a},$o=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map((e=>t[e])),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map((e=>t[e])),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let a=e.slice();return n.axes.length>0?(n.axes.forEach((e=>t[e]=r)),n.axes.forEach((n=>a[n]=Math.round(e[n]*t[n])))):(t.fill(r,0,t.length),a.forEach(((e,n)=>a[n]=Math.round(e*t[n])))),a},_o=(e,t,n,r,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${It("uniforms.scales","i",r)};\n        var roi_low = ${It("uniforms.roi","i",a)};\n        var roi_hi = ${It("uniforms.roi",`i + ${t.length}`,a)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${It("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${It("uniforms.output_shape","i",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,xo=(e,t,n,r,a,i,o)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${It("uniforms.scales","i",a)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${It("uniforms.roi","i",i)};\n          var roi_hi = ${It("uniforms.roi",`i + ${n.length}`,i)};\n          var input_shape_i = ${It("uniforms.input_shape","i",n.length)};\n          var output_shape_i = ${It("uniforms.output_shape","i",r.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${o} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,So=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${It("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,Co=(e,t,n,r)=>e.rank>r?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",n,"batch")};\n`:"",Eo=(e,t,n,r,a)=>{let[i,o,s,u]=2===n.length?[-1,0,1,-1]:[0,2,3,1],l=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${l} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",o,`max(0, min(row, ${n[o]} - 1))`)};\n      ${e.indicesSet("input_indices",s,`max(0, min(col, ${n[s]} - 1))`)};\n      ${Co(e,u,i,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${l} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${l} = originalIndices[${o}];\n      var col:${l} = originalIndices[${s}];\n      ${r?`if (row < 0 || row > (${n[o]} - 1) || col < 0 || col > (${n[s]} - 1)) {\n        return ${a};\n      }`:""};\n      row = max(0, min(row, ${n[o]} - 1));\n      col = max(0, min(col, ${n[s]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${u}])`:"0"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${i}])`:"0"};\n      var x11: ${l} = getInputValue(batch, channel, row1, col1);\n      var x12: ${l} = getInputValue(batch, channel, row1, col2);\n      var x21: ${l} = getInputValue(batch, channel, row2, col1);\n      var x22: ${l} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${l} = abs(row - ${l}(row1));\n      var dx2: ${l} = abs(${l}(row2) - row);\n      var dy1: ${l} = abs(col - ${l}(col1));\n      var dy2: ${l} = abs(${l}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Io=(e,t,n,r,a,i,o,s,u,l)=>{let d=2===n.length,[p,c]=d?[0,1]:[2,3],f=e.type.value,h=o=>{let d=o===p?"row":"col";return`\n      fn ${d}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${f} {\n        var output_index = ${t.indicesGet("output_indices",o)};\n        var originalIdx: ${f} = getOriginalCoordinateFromResizedCoordinate(output_index, ${a[o]},\n        ${r[o]}, ${n[o]}, ${i[o]}, ${i[o]} + ${n.length});\n        var fractOriginalIdx: ${f} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${s} && (originalIdx < 0 || originalIdx > (${n[o]} - 1))) {\n          return ${u};\n        }\n        var data: array<${f}, 4> = array<${f}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${d}: ${f} = originalIdx + ${f}(i);\n          if (${d} < 0 || ${d} >= ${n[o]}) {\n            ${l?"coefs[i + 1] = 0.0;\n                        continue;":s?`return ${u};`:`${d} = max(0, min(${d}, ${n[o]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",o,`u32(${d})`)};\n          data[i + 1] = ${o===p?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${h(p)};\n    ${h(c)};\n  fn getCubicInterpolationCoefs(s: ${f}) -> array<${f}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${f}, 4> = array<${f}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${f} = 1.0 - absS;\n    var twoMinusAbsS: ${f} = 2.0 - absS;\n    var onePlusAbsS: ${f} = 1.0 + absS;\n    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};\n    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${f}, 4>, coefs: array<${f}, 4>) -> ${f} {\n    var coefsSum: ${f} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${f} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},To=(e,t,n,r,a)=>{let[i,o,s,u,l]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",o,`max(0, min(depth, ${n[o]} - 1))`)};\n      ${e.indicesSet("input_indices",s,`max(0, min(height, ${n[s]} - 1))`)};\n      ${e.indicesSet("input_indices",u,`max(0, min(width, ${n[u]} - 1))`)};\n      ${Co(e,l,i,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${d} = originalIndices[${o}];\n      var height:${d} = originalIndices[${s}];\n      var width:${d} = originalIndices[${u}];\n      ${r?`if (depth < 0 || depth > (${n[o]} - 1) || height < 0 || height > (${n[s]} - 1) || width < 0 || (width > ${n[u]} - 1)) {\n      return ${a};\n        }`:""};\n\n    depth = max(0, min(depth, ${n[o]} - 1));\n      height = max(0, min(height, ${n[s]} - 1));\n      width = max(0, min(width, ${n[u]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${l}])`:"0"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${i}])`:"0"};\n\n      var x111: ${d} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${d} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${d} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${d} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${d} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${d} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${d} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${d} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${d} = abs(depth - ${d}(depth1));\n      var dx2: ${d} = abs(${d}(depth2) - depth);\n      var dy1: ${d} = abs(height - ${d}(height1));\n      var dy2: ${d} = abs(${d}(height2) - height);\n      var dz1: ${d} = abs(width - ${d}(width1));\n      var dz2: ${d} = abs(${d}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Ao=(e,t,n,r,a,i)=>{let o=e.dims,s=wo(i,t.axes,o.length),u=vo(o,r,a,t.axes),l=r.slice();0===r.length&&(l=o.map(((e,t)=>0===e?1:u[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(u=$o(o,l,t)));let d=kt("output",e.dataType,u.length),p=At("input",e.dataType,o.length),c=ht.size(u),f=o.length===u.length&&o.every(((e,t)=>e===u[t])),h="tf_crop_and_resize"===t.coordinateTransformMode,m=t.extrapolationValue,g=p.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${l.length>0?l:""}|${a.length>0?a:""}|${s.length>0?s:""}|${f}|${o}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${f?"":`\n      ${yo(t.coordinateTransformMode,g)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${So(p,o)};\n              ${bo(t.nearestMode,n,g)};\n              ${xo(p,d,o,u,l.length,s.length,h)};\n              `;case"linear":return`\n              ${_o(d,o,u,l.length,s.length)};\n              ${(()=>{if(2===o.length||4===o.length)return`${Eo(p,d,o,h,m)}`;if(3===o.length||5===o.length)return`${To(p,d,o,h,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(2===o.length||4===o.length)return`${Io(p,d,o,u,l,s,t.cubicCoeffA,h,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",l.length).registerUniform("roi","f32",s.length).declareVariables(p,d)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${f?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var input_indices: ${p.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${p.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${2===o.length||4===o.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`,getRunData:()=>({outputs:[{dims:u,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:"uint32",data:c},{type:"float32",data:l},{type:"float32",data:s},..._t(o),..._t(u)]})}},ko=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Oo=(e,t)=>{let n=[],r=[],a=[],i=ko(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");go(e.inputs,t,i,n,r,a),e.compute(Ao(e.inputs[0],t,i,n,r,a),{inputs:[0]})},Ro=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,a=e.cubicCoeffA,i=0!==e.excludeOutside,o=e.extrapolationValue,s=e.keepAspectRatioPolicy,u=e.mode,l=""===e.nearestMode?"simple":e.nearestMode;return pt({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:a,excludeOutside:i,extrapolationValue:o,keepAspectRatioPolicy:s,mode:u,nearestMode:l})}})),pu=U((()=>{$s(),Ts(),As(),zo=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},Bo=(e,t,n,r)=>{let a=e[0].dims,i=ht.size(a),o=a,s=i,u=a.slice(-1)[0],l=r?a.slice(0,-1).concat(1):[],d=e.length>3,p=e.length>4,c=r&&n>1,f=r&&n>2,h=n>3,m=xt(u),g=[{type:"uint32",data:s},{type:"uint32",data:m},{type:"uint32",data:u},{type:"float32",data:t.epsilon}],y=[{dims:o,dataType:e[0].dataType}];return n>1&&y.push({dims:l,dataType:1}),n>2&&y.push({dims:l,dataType:1}),n>3&&y.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${m};${c};${f};${h}`,inputDependencies:e.map(((e,t)=>"type"))},getShaderSource:t=>{let n=[At("x",e[0].dataType,e[0].dims,m),At("skip",e[1].dataType,e[1].dims,m),At("gamma",e[2].dataType,e[2].dims,m)];d&&n.push(At("beta",e[3].dataType,e[3].dims,m)),p&&n.push(At("bias",e[4].dataType,e[4].dims,m)),n.push(kt("output",e[0].dataType,o,m)),c&&n.push(kt("mean_output",1,l)),f&&n.push(kt("inv_std_output",1,l)),h&&n.push(kt("input_skip_bias_sum",e[0].dataType,o,m));let r=vt(e[0].dataType);return`\n\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\n\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size / uniforms.hidden_size")}\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        let offset = global_idx * hidden_size_vectorized;\n        var sum = ${St("f32",m)};\n        var squareSum = ${St("f32",m)};\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${p?"bias[i]":"0.0"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${h?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${Ct(r,m,"value")};\n          sum += f32_value;\n          squareSum += f32_value * f32_value;\n        }\n        let mean = ${Et("sum",m)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Et("squareSum",m)} / f32(uniforms.hidden_size) - mean * mean + uniforms.epsilon);\n        ${c?"mean_output[global_idx] = mean;":""}\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${r}(mean)) * ${r}(inv_std_dev) * gamma[i] + ${d?"beta[i]":"0.0"};\n        }\n      }`},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(s/u/64)},programUniforms:g})}},Po=(e,t)=>{zo(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Bo(e.inputs,t,e.outputCount,!1),{outputs:n})}})),cu=U((()=>{$s(),Ts(),Is(),As(),Mo=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},Do=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},No=(e,t)=>{if(e.length>1){let t=Do(e,1),n=Do(e,2),r=Do(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),pt({starts:t,ends:n,axes:r})}return t},Wo=(e,t,n,r,a)=>{let i=e;return e<0&&(i+=n[r[t]]),a[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},Uo=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            let input_shape_i = ${It("uniforms.input_shape","i",n.length)};\n            let steps_i = ${It("uniforms.steps","i",n.length)};\n            let signs_i = ${It("uniforms.signs","i",n.length)};\n            let starts_i = ${It("uniforms.starts","i",n.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Vo=(e,t)=>{let n=e[0].dims,r=ht.size(n),a=t.axes.length>0?ht.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=Do(e,4);i.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===i.length&&(i=Array(a.length).fill(1));let o=t.starts.map(((e,t)=>Wo(e,t,n,a,i))),s=t.ends.map(((e,t)=>Wo(e,t,n,a,i)));if(a.length!==o.length||a.length!==s.length)throw new Error("start, ends and axes should have the same number of elements");if(a.length!==n.length)for(let e=0;e<n.length;++e)a.includes(e)||(o.splice(e,0,0),s.splice(e,0,n[e]),i.splice(e,0,1));let u=i.map((e=>Math.sign(e)));i.forEach(((e,t,n)=>{if(e<0){let r=(s[t]-o[t])/e,a=o[t],u=a+r*i[t];o[t]=u,s[t]=a,n[t]=-e}}));let l=n.slice(0);a.forEach(((e,t)=>{l[e]=Math.ceil((s[e]-o[e])/i[e])}));let d={dims:l,dataType:e[0].dataType},p=kt("output",e[0].dataType,l.length),c=At("input",e[0].dataType,e[0].dims.length),f=ht.size(l),h=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:o.length},{name:"signs",type:"i32",length:u.length},{name:"steps",type:"u32",length:i.length}],m=[{type:"uint32",data:f},{type:"uint32",data:o},{type:"int32",data:u},{type:"uint32",data:i},..._t(e[0].dims),..._t(l)];return{name:"Slice",shaderCache:{hint:`${u.length}_${o.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${e.registerUniforms(h).declareVariables(c,p)}\n        ${Uo(c,p,n)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${p.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${p.setByOffset("global_idx",c.getByIndices("input_indices"))}\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:m})}},Ho=(e,t)=>{Mo(e.inputs,t);let n=No(e.inputs,t);e.compute(Vo(e.inputs,n),{inputs:[0]})},Lo=e=>{let t=e.starts,n=e.ends,r=e.axes;return pt({starts:t,ends:n,axes:r})}})),fu=U((()=>{Ts(),Is(),As(),Fo=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},Go=(e,t)=>{let n=e.dims,r=ht.size(n),a=t.axis;if(a<0&&(a=n.length+a),a<n.length-1)throw new Error("softmax only supports last axis for now.");let i=n[a],o=r/i,s=xt(i),u=i/s,l=At("x",e.dataType,e.dims,s),d=kt("result",e.dataType,e.dims,s),p=l.type.value,c="f32"===vt(e.dataType)?`var threadMax = ${p}(-3.402823e+38f);`:`var threadMax = ${p}(-65504.0h);`;return{name:"Softmax",shaderCache:{hint:`${s}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.dataType}],dispatchGroup:{x:o},programUniforms:[{type:"uint32",data:u}]}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${p};\n      var<workgroup> rowSumShared : ${p};\n      var<workgroup> threadShared : array<${p}, 64>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${p} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${p}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${e.registerUniform("packedCols","i32").declareVariables(l,d)}\n      ${e.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = 64;\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${c}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${p}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",s)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${p}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${p}(${Et("threadShared[0]",s)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},jo=(e,t)=>{Fo(e.inputs),e.compute(Go(e.inputs[0],t))},qo=e=>pt({axis:e.axis})})),hu=U((()=>{Ts(),Is(),As(),Ko=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Yo=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),pt({numOutputs:r,axis:t.axis,splitSizes:n})},Zo=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${It("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Qo=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let a=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(a):0===r?n.push(`if (output_number == ${r}u) { ${a} }`):r===t-1?n.push(`else { ${a} }`):n.push(`else if (output_number == ${r}) { ${a} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},Xo=(e,t)=>{let n=e[0].dims,r=ht.size(n),a=e[0].dataType,i=ht.normalizeAxis(t.axis,n.length),o=new Array(t.numOutputs),s=At("input",a,n),u=new Array(t.numOutputs),l=[],d=[],p=0,c=[{type:"uint32",data:r}];for(let r=0;r<t.numOutputs;r++){p+=t.splitSizes[r],u[r]=p;let i=n.slice();i[t.axis]=t.splitSizes[r],d.push(i),o[r]=kt(`output${r}`,a,i),l.push({dims:d[r],dataType:e[0].dataType})}return c.push({type:"uint32",data:u}),c.push(..._t(n)),d.forEach((e=>c.push(..._t(e)))),{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",u.length).declareVariables(s,...o)}\n  ${Zo(u.length)}\n  ${Qo(o)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${s.offsetToIndices("global_idx")};\n    var index = ${s.indicesGet("indices",i)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${It("uniforms.size_in_split_axis","output_number - 1u",u.length)};\n      ${s.indicesSet("indices",i,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`,getRunData:()=>({outputs:l,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:c})}},Jo=(e,t)=>{Ko(e.inputs);let n=1===e.inputs.length?t:Yo(e.inputs,t);e.compute(Xo(e.inputs,n),{inputs:[0]})},es=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return pt({axis:t,numOutputs:r,splitSizes:n})}})),mu=U((()=>{$s(),Ts(),As(),ts=e=>Array.from(e.getBigInt64Array(),Number),ns=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(ts(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},rs=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},as=e=>{let t=e[0].dims,n=ts(e[1]),r=rs(t,n),a=ht.size(r),i=e[0].dataType,o=At("input",i,t.length),s=kt("output",i,r.length);return{name:"Tile",shaderCache:{hint:`${n}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:"uint32",data:a},..._t(e[0].dims),..._t(r)]}),getShaderSource:e=>`\n      const inputShape = ${o.indices(...t)};\n      ${e.registerUniform("output_size","u32").declareVariables(o,s)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${s.offsetToIndices("global_idx")};\n      var input_indices: ${o.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${s.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${o.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${s.setByOffset("global_idx",o.getByIndices("input_indices"))}\n    }`}},is=e=>{ns(e.inputs),e.compute(as(e.inputs),{inputs:[0]})}})),gu=U((()=>{$s(),Ts(),As(),os=(e,t,n,r,a)=>{let i,o=kt("output_data",a,n.length,4),s=At("a_data",t[1].dataType,t[1].dims.length,4),u=At("b_data",t[2].dataType,t[2].dims.length,4),l=At("c_data",t[0].dataType,t[0].dims.length,4),d=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`a_data[index_a${t}][component_a${t}]`,a=`b_data[index_b${t}][component_b${t}]`,i=`bool(c_data[index_c${t}] & ${4278190080>>>8*(3-t)}u)`;return`\n            let output_indices${t} = ${o.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offset_a${t} = ${s.broadcastedIndicesToOffset(`output_indices${t}`,o)};\n            let offset_b${t} = ${u.broadcastedIndicesToOffset(`output_indices${t}`,o)};\n            let offset_c${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,o)};\n            let index_a${t} = offset_a${t} / 4u;\n            let index_b${t} = offset_b${t} / 4u;\n            let index_c${t} = offset_c${t} / 4u;\n            let component_a${t} = offset_a${t} % 4u;\n            let component_b${t} = offset_b${t} % 4u;\n            ${e}[${t}] = ${n}(${d(r,a,i)});\n          `};i=9===a?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("output_data[global_idx]",0)}\n            ${e("output_data[global_idx]",1)}\n            ${e("output_data[global_idx]",2)}\n            ${e("output_data[global_idx]",3)}\n          `}else i=o.setByOffset("global_idx",d(s.getByOffset("global_idx"),u.getByOffset("global_idx"),l.getByOffset("global_idx")));return`\n        ${e.registerUniform("vec_size","u32").declareVariables(l,s,u,o)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${i}\n      }`},ss=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,a=e[1].dataType,i=!(ht.areEqual(t,n)&&ht.areEqual(n,r)),o=t,s=ht.size(t);if(i){let e=ft.calcShape(ft.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can't perform where op on the given tensors");o=e,s=ht.size(o)}let u=Math.ceil(s/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>os(t,e,o,i,a),getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:Math.ceil(s/64/4)},programUniforms:[{type:"uint32",data:u},..._t(r),..._t(t),..._t(n),..._t(o)]})}},us=e=>{e.compute(ss(e.inputs))}})),yu=U((()=>{zs(),Bs(),Ps(),Ms(),Ns(),Ws(),Us(),Ks(),Qs(),Xs(),Js(),eu(),tu(),nu(),ru(),au(),iu(),qs(),ou(),su(),uu(),lu(),Rs(),du(),pu(),cu(),fu(),hu(),mu(),ks(),Ds(),gu(),ls=new Map([["Abs",[nr]],["Acos",[rr]],["Acosh",[ar]],["Add",[Fr]],["ArgMax",[Nn,Wn]],["ArgMin",[Dn,Wn]],["Asin",[ir]],["Asinh",[or]],["Atan",[sr]],["Atanh",[ur]],["Attention",[jn]],["AveragePool",[to,eo]],["BatchNormalization",[Zn]],["BiasAdd",[Jn]],["BiasSplitGelu",[Ur]],["Cast",[dr,lr]],["Ceil",[fr]],["Clip",[cr]],["Concat",[aa,ia]],["Conv",[Ra,Aa]],["ConvTranspose",[ja,Va]],["Cos",[hr]],["Cosh",[mr]],["CumSum",[Ka,Ya]],["Div",[Gr]],["Einsum",[ai,ii]],["Elu",[yr,gr]],["Equal",[jr]],["Erf",[wr]],["Exp",[vr]],["Expand",[di]],["Floor",[$r]],["FusedConv",[Ra,Aa]],["Gather",[hi,fi]],["GatherElements",[bi,yi]],["Gelu",[_r]],["Gemm",[_i,$i]],["GlobalAveragePool",[ao,ro]],["GlobalMaxPool",[lo,uo]],["Greater",[Zr]],["GreaterOrEqual",[Xr]],["HardSigmoid",[kr,Ar]],["InstanceNormalization",[Ei]],["LayerNormalization",[Ai]],["LeakyRelu",[xr,gr]],["Less",[Qr]],["LessOrEqual",[Jr]],["Log",[Dr]],["MatMul",[Sa]],["MaxPool",[oo,so]],["Mul",[qr]],["MultiHeadAttention",[Pi,Oi]],["Neg",[Cr]],["Not",[Sr]],["Pad",[Fi]],["Pow",[Kr]],["Range",[fo]],["Reciprocal",[Er]],["ReduceMin",[On]],["ReduceMean",[En]],["ReduceMax",[kn]],["ReduceSum",[zn]],["ReduceProd",[Rn]],["ReduceL1",[In]],["ReduceL2",[Tn]],["ReduceLogSum",[Pn]],["ReduceLogSumExp",[An]],["ReduceSumSquare",[Bn]],["Relu",[Ir]],["Resize",[Oo,Ro]],["Sigmoid",[Tr]],["Sin",[Or]],["Sinh",[Rr]],["Slice",[Ho,Lo]],["SkipLayerNormalization",[Po]],["Split",[Jo,es]],["Sqrt",[zr]],["Softmax",[jo,qo]],["Sub",[Yr]],["Tan",[Br]],["Tanh",[Pr]],["ThresholdedRelu",[Mr,gr]],["Tile",[is]],["Transpose",[Ut,Vt]],["Where",[us]]])})),bu=U((()=>{ue(),xs(),As(),ds=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,a){A(e.programInfo.name);let i=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber),o.setPipeline(e.computePipeline);let s=[];for(let e of t)s.push({binding:s.length,resource:{buffer:e.buffer}});for(let e of n)s.push({binding:s.length,resource:{buffer:e.buffer}});a&&s.push({binding:s.length,resource:a});let u=i.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:s,label:e.programInfo.name});o.setBindGroup(0,u),o.dispatchWorkgroups(...r),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),k(e.programInfo.name)}dispose(){}build(e,t){A(e.name);let n=this.backend.device,r=[];n.features.has("shader-f16")&&r.push("enable f16;");let a=zt(t),i=e.getShaderSource(a),o=`${r.join("\n")}\n${a.additionalImplementations}\n${i}`,s=n.createShaderModule({code:o,label:e.name});nt("verbose",(()=>`[WebGPU] ${e.name} shader code: ${o}`));let u=n.createComputePipeline({compute:{module:s,entryPoint:"main"},layout:"auto",label:e.name});return k(e.name),{programInfo:e,computePipeline:u}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&n<=a&&r<=a)return[t,n,r];let i=t*n*r,o=Math.ceil(Math.sqrt(i));if(o>a){if(o=Math.ceil(Math.cbrt(i)),o>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}return[o,o,1]}}})),wu=U((()=>{ue(),$s(),xs(),Ss(),Es(),yu(),bu(),ps=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let a=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${a}`);break;case"rank":{let t=e[r].dims.length;n.push(`${a};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${a};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},cs=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${ps(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},fs=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n};t.features.has("chromium-experimental-timestamp-query-inside-passes")?n.push("chromium-experimental-timestamp-query-inside-passes"):t.features.has("timestamp-query")&&n.push("timestamp-query"),t.features.has("shader-f16")&&n.push("shader-f16"),this.device=await t.requestDevice(r),this.gpuDataManager=lt(this),this.programManager=new ds(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,et(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e={};"at-passes"===this.queryType&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;A(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then((()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let r=n[e],a=r.kernelId,i=this.kernels.get(a),o=i.kernelType,s=i.kernelName,u=r.programName,l=r.inputTensorViews,d=r.outputTensorViews,p=t[2*e],c=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=p);let f=Number(p-this.queryTimeBase),h=Number(c-this.queryTimeBase);if(!Number.isSafeInteger(f)||!Number.isSafeInteger(h))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:l.map((e=>({dims:e.dims,dataType:Le(e.dataType)}))),outputsMetadata:d.map((e=>({dims:e.dims,dataType:Le(e.dataType)}))),kernelId:a,kernelType:o,kernelName:s,programName:u,startTime:f,endTime:h});else{let e="";l.forEach(((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${Le(t.dataType)}, `}));let t="";d.forEach(((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${Le(e.dataType)}, `})),console.log(`[profiling] kernel "${a}|${o}|${s}|${u}" ${e}${t}execution time: ${h-f} ns`)}I("GPU",`${u}::${p}::${c}`)}e.unmap(),this.pendingQueries.delete(e)})),k()}run(e,t,n,r,a){A(e.name);let i=[];for(let e=0;e<t.length;++e){let n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);i[e]=n}let{outputs:o,dispatchGroup:s,programUniforms:u}=e.getRunData(t),l=0===n.length?o.map(((e,t)=>t)):n;if(l.length!==o.length)throw new Error(`Output size ${l.length} must be equal to ${o.length}.`);let d,p=[],c=[];for(let e=0;e<o.length;++e){if(!Number.isInteger(l[e])||l[e]<-3||l[e]>=o.length)throw new Error(`Invalid output index: ${l[e]}`);if(-3===l[e])continue;let t=-1===l[e],n=-2===l[e],i=t||n?a(o[e].dataType,o[e].dims):r(l[e],o[e].dataType,o[e].dims),s=this.gpuDataManager.get(i.data);if(!s)throw new Error(`no GPU data for output: ${i.data}`);if(t&&this.temporaryData.push(s),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(s)}p.push(i),c.push(s)}if(u){let e=0,t=[];u.forEach((n=>{let r="number"==typeof n.data?[n.data]:n.data;if(0===r.length)return;let a,i,o="float16"===n.type?2:4;"float16"===n.type?(i=r.length>4?16:r.length>2?8:r.length*o,a=r.length>4?16:o*r.length):(i=r.length<=2?r.length*o:16,a=16),e=Math.ceil(e/i)*i,t.push(e);let s="float16"===n.type?8:4;e+=r.length>4?Math.ceil(r.length/s)*a:r.length*o}));let n=16;e=Math.ceil(e/n)*n;let r=new ArrayBuffer(e);u.forEach(((e,n)=>{let a=t[n],i="number"==typeof e.data?[e.data]:e.data;"int32"===e.type?new Int32Array(r,a,i.length).set(i):"uint32"===e.type?new Uint32Array(r,a,i.length).set(i):"float16"===e.type?new Uint16Array(r,a,i.length).set(i):new Float32Array(r,a,i.length).set(i)}));let a=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(a.buffer,0,r,0,e),this.gpuDataManager.release(a.id),d={offset:0,size:e,buffer:a.buffer}}let f=this.programManager.normalizeDispatchGroupSize(s),h=1===f[1]&&1===f[2],m=cs(e,t,h),g=this.programManager.getArtifact(m);if(g||(g=this.programManager.build(e,f),this.programManager.setArtifact(m,g),nt("info",(()=>`[artifact] key: ${m}, programName: ${e.name}`))),nt("info",(()=>`[ProgramManager] run "${e.name}" (key=${m}) with ${f[0]}x${f[1]}x${f[2]}`)),"none"!==this.queryType){let e={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:t,outputTensorViews:p};this.pendingKernels.push(e)}return this.programManager.run(g,i,c,f,d),k(e.name),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let a=ls.get(e);if(!a)throw new Error(`kernel not implemented: ${e}`);let i={kernelType:e,kernelName:r,kernelEntry:a[0],attributes:[a[1],n]};this.kernels.set(t,i)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let a=r.kernelType,i=r.kernelName,o=r.kernelEntry,s=r.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${a}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,s[0]&&(s[1]=s[0](s[1]),s[0]=void 0),nt("info",(()=>`[WebGPU] Start to run kernel "[${a}] ${i}"...`));let u=this.env.debug;this.temporaryData=[];try{return u&&this.device.pushErrorScope("validation"),o(t,s[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${i}" failed. ${e}`)),1}finally{u&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${a}] ${i}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let a=this.sessionExternalDataMapping.get(e);a||(a=new Map,this.sessionExternalDataMapping.set(e,a));let i=a.get(t),o=this.gpuDataManager.registerExternalBuffer(n,r,i?.[1]);return a.set(t,[o,n]),o}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[1]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await st(this,e,t);return rt(r.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||this.env.wasm.trace)&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}onRunStart(){this.setQueryType()}}})),vu={};H(vu,{init:()=>xu});var $u,_u,xu,Su,Cu,Eu,Iu,Tu,Au,ku,Ou,Ru,zu,Bu,Pu,Mu,Du,Nu,Wu,Uu,Vu,Hu,Lu,Fu,Gu,ju,qu,Ku,Yu,Zu,Qu,Xu,Ju,el,tl,nl,rl,al,il=U((()=>{$s(),wu(),xs(),Ts(),$u=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=ht.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=ht.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=ht.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(ht.size(t)!==ht.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},_u=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0;let r=e.HEAPU32,a=n>>>2;this.opKernelContext=r[a++];let i=r[a++];this.outputCount=r[a++],this.customDataOffset=r[a++],this.customDataSize=r[a++];let o=[];for(let t=0;t<i;t++){let t=r[a++],n=r[a++],i=r[a++],s=[];for(let e=0;e<i;e++)s.push(r[a++]);o.push(new $u(e,t,n,s))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new $u(this.module,t,this.output(e,n),n)),((e,t)=>{let n=Fe(e);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n*ht.size(t);return new $u(this.module,e,this.backend.gpuDataManager.create(r).id,t)}))}output(e,t){let n=this.module.stackSave();try{let n=this.module.stackAlloc(4*(1+t.length)),r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},xu=async(e,t,n)=>{let r=e.jsepInit;if(!r)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");let a=new fs;await a.initialize(t,n),r(a,(e=>a.alloc(e)),(e=>a.free(e)),((t,n,r,i=!1)=>{if(i)nt("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${r}`)),a.memcpy(t,n);else{nt("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${r}`));let i=e.HEAPU8.subarray(t>>>0,(t>>>0)+r);a.upload(n,i)}}),(async(t,n,r)=>{nt("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${r}`)),await a.download(t,(()=>e.HEAPU8.subarray(n>>>0,(n>>>0)+r)))}),((t,n,r)=>a.createKernel(t,n,r,e.UTF8ToString(e._JsepGetNodeName(n)))),(e=>a.releaseKernel(e)),((t,n,r,i)=>{nt("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${r}, kernel=${t}, contextDataOffset=${n}`));let o=new _u(e,a,n);return a.computeKernel(t,o,i)}))}})),ol=U((()=>{ws(),vs(),$s(),ys(),bs(),_s(),Su=(e,t)=>{0!==Re()._OrtInit(e,t)&&Pe("Can't initialize onnxruntime.")},Cu=async e=>{Su(e.wasm.numThreads,je(e.logLevel))},Eu=async(e,t)=>{if("webgpu"===t||"webnn"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let t=await navigator.gpu.requestAdapter();if(!t)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.');if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");let n=(il(),L(vu)).init;await n(Re(),e,t)}},Iu=new Map,Tu=e=>{let t=Re(),n=t.stackSave();try{let n=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,n,n+4)&&Pe("Can't get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(n)}},Au=e=>{let t=Re(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},ku=async(e,t)=>{let n,r,a=Re();Array.isArray(e)?[n,r]=e:e.buffer===a.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Au(e);let i=0,o=0,s=0,u=[],l=[],d=[];try{if([o,u]=Ve(t),t?.externalData&&a.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(Ye("string"==typeof n?n:n.data).then((e=>{a.mountExternalData(t,e)})))}await Promise.all(e)}i=await a._OrtCreateSession(n,r,o),0===i&&Pe("Can't create a session.");let[e,p]=Tu(i),c=[],f=[],h=[];for(let t=0;t<e;t++){let e=a._OrtGetInputName(i,t);0===e&&Pe("Can't get an input name."),l.push(e),c.push(a.UTF8ToString(e))}for(let e=0;e<p;e++){let n=a._OrtGetOutputName(i,e);0===n&&Pe("Can't get an output name."),d.push(n);let r=a.UTF8ToString(n);f.push(r);{let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[r]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}.`);h.push(e)}}let m=null;return h.some((e=>"gpu-buffer"===e))&&(s=a._OrtCreateBinding(i),0===s&&Pe("Can't create IO binding."),m={handle:s,outputPreferredLocations:h,outputPreferredLocationsEncoded:h.map((e=>Ke(e)))}),Iu.set(i,[i,l,d,m]),[i,c,f]}catch(e){throw l.forEach((e=>a._OrtFree(e))),d.forEach((e=>a._OrtFree(e))),0!==s&&a._OrtReleaseBinding(s),0!==i&&a._OrtReleaseSession(i),e}finally{a._free(n),0!==o&&a._OrtReleaseSessionOptions(o),u.forEach((e=>a._free(e))),a.unmountExternalData?.()}},Ou=e=>{let t=Re(),n=Iu.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,a,i,o]=n;o&&t._OrtReleaseBinding(o.handle),t.jsepUnregisterBuffers?.(e),a.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(r),Iu.delete(e)},Ru=(e,t,n,r,a)=>{if(!e)return void t.push(0);let i,o,s=Re(),u=e[0],l=e[1],d=e[3];if("string"===u&&"gpu-buffer"===d)throw new Error("String tensor is not supported on GPU.");if("gpu-buffer"===d){let t=e[2].gpuBuffer,n=Fe(He(u));o=l.reduce(((e,t)=>e*t),1)*n,i=s.jsepRegisterBuffer(r,a,t,o)}else{let t=e[2];if(Array.isArray(t)){o=4*t.length,i=s._malloc(o),n.push(i);let e=i/4;for(let r=0;r<t.length;r++){if("string"!=typeof t[r])throw new TypeError(`tensor data at index ${r} is not a string`);s.HEAPU32[e++]=ze(t[r],n)}}else o=t.byteLength,i=s._malloc(o),n.push(i),s.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),i)}let p=s.stackSave(),c=s.stackAlloc(4*l.length);try{let e=c/4;l.forEach((t=>s.HEAP32[e++]=t));let n=s._OrtCreateTensor(He(u),i,o,c,l.length,Ke(d));0===n&&Pe(`Can't create tensor for input/output. session=${r}, index=${a}.`),t.push(n)}finally{s.stackRestore(p)}},zu=async(e,t,n,r,a,i)=>{let o=Re(),s=Iu.get(e);if(!s)throw new Error(`cannot run inference. invalid session id: ${e}`);let[u,l,d,p]=s,c=t.length,f=r.length,h=0,m=[],g=[],y=[],b=[],w=o.stackSave(),v=o.stackAlloc(4*c),$=o.stackAlloc(4*c),_=o.stackAlloc(4*f),x=o.stackAlloc(4*f);try{[h,m]=Me(i);for(let r=0;r<c;r++)Ru(n[r],g,b,e,t[r]);for(let t=0;t<f;t++)Ru(a[t],y,b,e,c+r[t]);let s,w=v/4,S=$/4,C=_/4,E=x/4;for(let e=0;e<c;e++)o.HEAPU32[w++]=g[e],o.HEAPU32[S++]=l[t[e]];for(let e=0;e<f;e++)o.HEAPU32[C++]=y[e],o.HEAPU32[E++]=d[r[e]];if(p){let{handle:n,outputPreferredLocations:i,outputPreferredLocationsEncoded:s}=p;if(l.length!==c)throw new Error(`input count from feeds (${c}) is expected to be always equal to model's input count (${l.length}).`);for(let r=0;r<c;r++){let a=t[r];0!==await o._OrtBindInput(n,l[a],g[r])&&Pe(`Can't bind input[${r}] for session=${e}.`)}for(let t=0;t<f;t++){let u=r[t];a[t]?.[3]?0!==o._OrtBindOutput(n,d[u],y[t],0)&&Pe(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==o._OrtBindOutput(n,d[u],0,s[u])&&Pe(`Can't bind output[${t}] to ${i[t]} for session=${e}.`)}}o.jsepOnRunStart?.(),s=p?await o._OrtRunWithBinding(u,p.handle,f,_,h):await o._OrtRun(u,$,v,c,x,f,_,h),0!==s&&Pe("failed to call OrtRun().");let I=[];for(let e=0;e<f;e++){let t=o.HEAPU32[_/4+e];if(t===y[e]){I.push(a[e]);continue}let n,i=o.stackSave(),s=o.stackAlloc(16),u=!1,l=0;try{0!==o._OrtGetTensorData(t,s,s+4,s+8,s+12)&&Pe(`Can't access output tensor data on index ${e}.`);let a=s/4,i=o.HEAPU32[a++];l=o.HEAPU32[a++];let d=o.HEAPU32[a++],c=o.HEAPU32[a++],f=[];for(let e=0;e<c;e++)f.push(o.HEAPU32[d/4+e]);o._OrtFree(d);let h=f.reduce(((e,t)=>e*t),1);n=Le(i);let m=p?.outputPreferredLocations[r[e]];if("string"===n){if("gpu-buffer"===m)throw new Error("String tensor is not supported on GPU.");let e=[],t=l/4;for(let n=0;n<h;n++){let r=o.HEAPU32[t++],a=n===h-1?void 0:o.HEAPU32[t]-r;e.push(o.UTF8ToString(r,a))}I.push([n,f,e,"cpu"])}else if("gpu-buffer"===m&&h>0){let e=o.jsepGetBuffer(l),r=Fe(i);if(void 0===r||!qe(n))throw new Error(`Unsupported data type: ${n}`);u=!0,I.push([n,f,{gpuBuffer:e,download:o.jsepCreateDownloader(e,h*r,n),dispose:()=>{o._OrtReleaseTensor(t)}},"gpu-buffer"])}else{let e=new(Ge(n))(h);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(o.HEAPU8.subarray(l,l+e.byteLength)),I.push([n,f,e,"cpu"])}}finally{o.stackRestore(i),"string"===n&&l&&o._free(l),u||o._OrtReleaseTensor(t)}}return p&&o._OrtClearBoundOutputs(p.handle),I}finally{o.stackRestore(w),g.forEach((e=>o._OrtReleaseTensor(e))),y.forEach((e=>o._OrtReleaseTensor(e))),b.forEach((e=>o._free(e))),0!==h&&o._OrtReleaseRunOptions(h),m.forEach((e=>o._free(e)))}},Bu=e=>{let t=Re(),n=Iu.get(e);if(!n)throw new Error("invalid session id");let r=n[0],a=t._OrtEndProfiling(r);0===a&&Pe("Can't get an profile file name."),t._OrtFree(a)},Pu=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),sl=V(((e,t)=>{t.exports='/*!\n * ONNX Runtime Web v1.18.0-dev.20240130-9f68a27c7a\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var eo=Object.defineProperty;var kl=Object.getOwnPropertyDescriptor;var Rl=Object.getOwnPropertyNames;var Bl=Object.prototype.hasOwnProperty;var Q=(e,t)=>()=>(e&&(t=e(e=0)),t);var Br=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),hn=(e,t)=>{for(var r in t)eo(e,r,{get:t[r],enumerable:!0})},Dl=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Rl(t))!Bl.call(e,i)&&i!==r&&eo(e,i,{get:()=>t[i],enumerable:!(o=kl(t,i))||o.enumerable});return e};var ur=e=>Dl(eo({},"__esModule",{value:!0}),e);var to={};hn(to,{createReadStream:()=>yi,readFile:()=>Ml,readFileSync:()=>zl});var Ml,zl,yi,ro=Q(()=>{Ml=void 0,zl=void 0,yi=void 0});var no={};hn(no,{join:()=>Ul});var Ul,oo=Q(()=>{Ul=void 0});var vi=Br((wi,io)=>{"use strict";var bi=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,i;r.ready=new Promise((s,c)=>{o=s,i=c}),r.mountExternalData=(s,c)=>{(r.gb||(r.gb=new Map)).set(s,c)},r.unmountExternalData=()=>{delete r.gb},r.jsepInit=(s,c,g,$,I,D,H,X)=>{r.Fb=s,r.vb=c,r.xb=g,r.ob=$,r.wb=I,r.Sa=D,r.yb=H,r.zb=X,c=(q,j,ne)=>(...fe)=>{let $e=Je,k=j?.();fe=q(...fe);let ae=j?.();return k!==ae&&(q=ae,ne(k),j=ne=null),Je!=$e?Zr():fe},g=q=>async(...j)=>{try{if(r.fb)throw Error("Session already started");let ne=r.fb={Ab:j[0],errors:[]},fe=await q(...j);if(r.fb!==ne)throw Error("Session mismatch");s.flush();let $e=ne.errors;if(0<$e.length){let k=await Promise.all($e);if(k=k.filter(ae=>ae),0<k.length)throw Error(k.join(`\n`))}return fe}finally{r.fb=null}},r._OrtCreateSession=c(r._OrtCreateSession,()=>r._OrtCreateSession,q=>r._OrtCreateSession=q),r._OrtRun=g(c(r._OrtRun,()=>r._OrtRun,q=>r._OrtRun=q)),r._OrtRunWithBinding=g(c(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,q=>r._OrtRunWithBinding=q)),r._OrtBindInput=c(r._OrtBindInput,()=>r._OrtBindInput,q=>r._OrtBindInput=q),r.jsepRegisterBuffer=(q,j,ne,fe)=>s.registerBuffer(q,j,ne,fe),r.jsepUnregisterBuffers=q=>{s.unregisterBuffers(q)},r.jsepGetBuffer=q=>s.getBuffer(q),r.jsepCreateDownloader=(q,j,ne)=>s.createDownloader(q,j,ne),r.jsepOnRunStart=()=>s.onRunStart()};var u=Object.assign({},r),a="./this.program",p=(s,c)=>{throw c},m=typeof window=="object",h=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",y="",w,_,v;if(d){var x=(ro(),ur(to)),T=(oo(),ur(no));y=h?T.dirname(y)+"/":__dirname+"/",w=(s,c)=>(s=ie(s)?new URL(s):T.normalize(s),x.readFileSync(s,c?void 0:"utf8")),v=s=>(s=w(s,!0),s.buffer||(s=new Uint8Array(s)),s),_=(s,c,g,$=!0)=>{s=ie(s)?new URL(s):T.normalize(s),x.readFile(s,$?void 0:"utf8",(I,D)=>{I?g(I):c($?D.buffer:D)})},!r.thisProgram&&1<process.argv.length&&(a=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),p=(s,c)=>{throw process.exitCode=s,c},r.inspect=()=>"[Emscripten Module object]"}else(m||h)&&(h?y=self.location.href:typeof document<"u"&&document.currentScript&&(y=document.currentScript.src),e&&(y=e),y.indexOf("blob:")!==0?y=y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):y="",w=s=>{var c=new XMLHttpRequest;return c.open("GET",s,!1),c.send(null),c.responseText},h&&(v=s=>{var c=new XMLHttpRequest;return c.open("GET",s,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),_=(s,c,g)=>{var $=new XMLHttpRequest;$.open("GET",s,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?c($.response):g()},$.onerror=g,$.send(null)});var C=console.log.bind(console),S=console.error.bind(console);Object.assign(r,u),u=null,typeof WebAssembly!="object"&&Ge("no native wasm support detected");var E,O=!1,U,M,N,Y,se,B,te,Pe,Ee,ee,be;function Me(){var s=E.buffer;r.HEAP8=M=new Int8Array(s),r.HEAP16=Y=new Int16Array(s),r.HEAPU8=N=new Uint8Array(s),r.HEAPU16=se=new Uint16Array(s),r.HEAP32=B=new Int32Array(s),r.HEAPU32=te=new Uint32Array(s),r.HEAPF32=Pe=new Float32Array(s),r.HEAPF64=be=new Float64Array(s),r.HEAP64=Ee=new BigInt64Array(s),r.HEAPU64=ee=new BigUint64Array(s)}var pe=[],ye=[],de=[],we=0,ze=null,Re=null;function Ge(s){throw s="Aborted("+s+")",S(s),O=!0,U=1,s=new WebAssembly.RuntimeError(s+". Build with -sASSERTIONS for more info."),i(s),s}var F=s=>s.startsWith("data:application/octet-stream;base64,"),ie=s=>s.startsWith("file://"),he;if(he="ort-wasm-simd.wasm",!F(he)){var Xe=he;he=r.locateFile?r.locateFile(Xe,y):y+Xe}function nt(s){if(v)return v(s);throw"both async and sync fetching of the wasm failed"}function ke(s){if(m||h){if(typeof fetch=="function"&&!ie(s))return fetch(s,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+s+"\'";return c.arrayBuffer()}).catch(()=>nt(s));if(_)return new Promise((c,g)=>{_(s,$=>c(new Uint8Array($)),g)})}return Promise.resolve().then(()=>nt(s))}function Le(s,c,g){return ke(s).then($=>WebAssembly.instantiate($,c)).then($=>$).then(g,$=>{S(`failed to asynchronously prepare wasm: ${$}`),Ge($)})}function It(s,c){var g=he;return typeof WebAssembly.instantiateStreaming!="function"||F(g)||ie(g)||d||typeof fetch!="function"?Le(g,s,c):fetch(g,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,s).then(c,function(I){return S(`wasm streaming compile failed: ${I}`),S("falling back to ArrayBuffer instantiation"),Le(g,s,c)}))}var Tt={945168:(s,c,g,$)=>{if(typeof r>"u"||!r.gb)return 1;if(s=Fe(s>>>0),s.startsWith("./")&&(s=s.substring(2)),s=r.gb.get(s),!s)return 2;if(c>>>=0,g>>>=0,c+g>s.byteLength)return 3;try{return N.set(s.subarray(c,c+g),$>>>0>>>0),0}catch{return 4}},945669:s=>r.vb(s),945702:s=>r.xb(s),945734:(s,c,g)=>{r.ob(s,c,g,!0)},945773:(s,c,g)=>{r.ob(s,c,g)},945806:s=>{r.Sa("Abs",s,void 0)},945857:s=>{r.Sa("Neg",s,void 0)},945908:s=>{r.Sa("Floor",s,void 0)},945961:s=>{r.Sa("Ceil",s,void 0)},946013:s=>{r.Sa("Reciprocal",s,void 0)},946071:s=>{r.Sa("Sqrt",s,void 0)},946123:s=>{r.Sa("Exp",s,void 0)},946174:s=>{r.Sa("Erf",s,void 0)},946225:s=>{r.Sa("Sigmoid",s,void 0)},946280:(s,c,g)=>{r.Sa("HardSigmoid",s,{alpha:c,beta:g})},946359:s=>{r.Sa("Log",s,void 0)},946410:s=>{r.Sa("Sin",s,void 0)},946461:s=>{r.Sa("Cos",s,void 0)},946512:s=>{r.Sa("Tan",s,void 0)},946563:s=>{r.Sa("Asin",s,void 0)},946615:s=>{r.Sa("Acos",s,void 0)},946667:s=>{r.Sa("Atan",s,void 0)},946719:s=>{r.Sa("Sinh",s,void 0)},946771:s=>{r.Sa("Cosh",s,void 0)},946823:s=>{r.Sa("Asinh",s,void 0)},946876:s=>{r.Sa("Acosh",s,void 0)},946929:s=>{r.Sa("Atanh",s,void 0)},946982:s=>{r.Sa("Tanh",s,void 0)},947034:s=>{r.Sa("Not",s,void 0)},947085:(s,c,g)=>{r.Sa("Clip",s,{min:c,max:g})},947154:s=>{r.Sa("Clip",s,void 0)},947206:(s,c)=>{r.Sa("Elu",s,{alpha:c})},947264:s=>{r.Sa("Relu",s,void 0)},947316:(s,c)=>{r.Sa("LeakyRelu",s,{alpha:c})},947380:(s,c)=>{r.Sa("ThresholdedRelu",s,{alpha:c})},947450:(s,c)=>{r.Sa("Cast",s,{to:c})},947508:s=>{r.Sa("Add",s,void 0)},947559:s=>{r.Sa("Sub",s,void 0)},947610:s=>{r.Sa("Mul",s,void 0)},947661:s=>{r.Sa("Div",s,void 0)},947712:s=>{r.Sa("Pow",s,void 0)},947763:s=>{r.Sa("Equal",s,void 0)},947816:s=>{r.Sa("Greater",s,void 0)},947871:s=>{r.Sa("GreaterOrEqual",s,void 0)},947933:s=>{r.Sa("Less",s,void 0)},947985:s=>{r.Sa("LessOrEqual",s,void 0)},948044:(s,c,g,$,I)=>{r.Sa("ReduceMean",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},948203:(s,c,g,$,I)=>{r.Sa("ReduceMax",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},948361:(s,c,g,$,I)=>{r.Sa("ReduceMin",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},948519:(s,c,g,$,I)=>{r.Sa("ReduceProd",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},948678:(s,c,g,$,I)=>{r.Sa("ReduceSum",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},948836:(s,c,g,$,I)=>{r.Sa("ReduceL1",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},948993:(s,c,g,$,I)=>{r.Sa("ReduceL2",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},949150:(s,c,g,$,I)=>{r.Sa("ReduceLogSum",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},949311:(s,c,g,$,I)=>{r.Sa("ReduceSumSquare",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},949475:(s,c,g,$,I)=>{r.Sa("ReduceLogSumExp",s,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},949639:s=>{r.Sa("Where",s,void 0)},949692:(s,c,g)=>{r.Sa("Transpose",s,{perm:c?Array.from(B.subarray(c>>>0,g>>>0)):[]})},949800:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k,ae)=>{r.Sa("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:c,dilations:[g],group:$,kernel_shape:[I],pads:[D,H],strides:[X],wIsConst:()=>!!M[j>>>0],outputPadding:ne?Array.from(B.subarray(ne>>>0,fe>>>0)):[],outputShape:$e?Array.from(B.subarray($e>>>0,k>>>0)):[],activation:Fe(ae)})},950202:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k)=>{r.Sa("ConvTranspose",s,{format:X?"NHWC":"NCHW",autoPad:c,dilations:Array.from(B.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(B.subarray(I>>>0,(I>>>0)+2>>>0)),pads:Array.from(B.subarray(D>>>0,(D>>>0)+4>>>0)),strides:Array.from(B.subarray(H>>>0,(H>>>0)+2>>>0)),wIsConst:()=>!!M[q>>>0],outputPadding:j?Array.from(B.subarray(j>>>0,ne>>>0)):[],outputShape:fe?Array.from(B.subarray(fe>>>0,$e>>>0)):[],activation:Fe(k)})},950767:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k,ae)=>{r.Sa("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:c,dilations:[g],group:$,kernel_shape:[I],pads:[D,H],strides:[X],wIsConst:()=>!!M[j>>>0],outputPadding:ne?Array.from(B.subarray(ne>>>0,fe>>>0)):[],outputShape:$e?Array.from(B.subarray($e>>>0,k>>>0)):[],activation:Fe(ae)})},951169:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k)=>{r.Sa("ConvTranspose",s,{format:X?"NHWC":"NCHW",autoPad:c,dilations:Array.from(B.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(B.subarray(I>>>0,(I>>>0)+2>>>0)),pads:Array.from(B.subarray(D>>>0,(D>>>0)+4>>>0)),strides:Array.from(B.subarray(H>>>0,(H>>>0)+2>>>0)),wIsConst:()=>!!M[q>>>0],outputPadding:j?Array.from(B.subarray(j>>>0,ne>>>0)):[],outputShape:fe?Array.from(B.subarray(fe>>>0,$e>>>0)):[],activation:Fe(k)})},951734:(s,c)=>{r.Sa("GlobalAveragePool",s,{format:c?"NHWC":"NCHW"})},951825:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k,ae,Ae)=>{r.Sa("AveragePool",s,{format:Ae?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:$,storage_order:I,dilations:[D,H],kernel_shape:[X,q],pads:[j,ne,fe,$e],strides:[k,ae]})},952109:(s,c)=>{r.Sa("GlobalAveragePool",s,{format:c?"NHWC":"NCHW"})},952200:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k,ae,Ae)=>{r.Sa("AveragePool",s,{format:Ae?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:$,storage_order:I,dilations:[D,H],kernel_shape:[X,q],pads:[j,ne,fe,$e],strides:[k,ae]})},952484:(s,c)=>{r.Sa("GlobalMaxPool",s,{format:c?"NHWC":"NCHW"})},952571:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k,ae,Ae)=>{r.Sa("MaxPool",s,{format:Ae?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:$,storage_order:I,dilations:[D,H],kernel_shape:[X,q],pads:[j,ne,fe,$e],strides:[k,ae]})},952851:(s,c)=>{r.Sa("GlobalMaxPool",s,{format:c?"NHWC":"NCHW"})},952938:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k,ae,Ae)=>{r.Sa("MaxPool",s,{format:Ae?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:$,storage_order:I,dilations:[D,H],kernel_shape:[X,q],pads:[j,ne,fe,$e],strides:[k,ae]})},953218:(s,c,g,$,I)=>{r.Sa("Gemm",s,{alpha:c,beta:g,transA:$,transB:I})},953322:s=>{r.Sa("MatMul",s,void 0)},953376:(s,c,g,$)=>{r.Sa("ArgMax",s,{keepDims:!!c,selectLastIndex:!!g,axis:$})},953484:(s,c,g,$)=>{r.Sa("ArgMin",s,{keepDims:!!c,selectLastIndex:!!g,axis:$})},953592:(s,c)=>{r.Sa("Softmax",s,{axis:c})},953655:(s,c)=>{r.Sa("Concat",s,{axis:c})},953715:(s,c,g,$,I)=>{r.Sa("Split",s,{axis:c,numOutputs:g,splitSizes:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},953855:s=>{r.Sa("Expand",s,void 0)},953909:(s,c)=>{r.Sa("Gather",s,{axis:Number(c)})},953980:(s,c)=>{r.Sa("GatherElements",s,{axis:Number(c)})},954059:(s,c,g,$,I,D,H,X,q,j,ne)=>{r.Sa("Resize",s,{antialias:c,axes:g?Array.from(B.subarray(g>>>0,$>>>0)):[],coordinateTransformMode:Fe(I),cubicCoeffA:D,excludeOutside:H,extrapolationValue:X,keepAspectRatioPolicy:Fe(q),mode:Fe(j),nearestMode:Fe(ne)})},954405:(s,c,g,$,I,D,H)=>{r.Sa("Slice",s,{starts:c?Array.from(B.subarray(c>>>0,g>>>0)):[],ends:$?Array.from(B.subarray($>>>0,I>>>0)):[],axes:D?Array.from(B.subarray(D>>>0,H>>>0)):[]})},954621:s=>{r.Sa("Tile",s,void 0)},954673:(s,c,g)=>{r.Sa("LayerNormalization",s,{axis:Number(c),epsilon:Number(g)})},954780:(s,c,g)=>{r.Sa("InstanceNormalization",s,{epsilon:c,format:g?"NHWC":"NCHW"})},954894:(s,c,g)=>{r.Sa("InstanceNormalization",s,{epsilon:c,format:g?"NHWC":"NCHW"})},955008:s=>{r.Sa("Range",s,void 0)},955061:(s,c)=>{r.Sa("Einsum",s,{equation:Fe(c)})},955142:(s,c,g,$,I)=>{r.Sa("Pad",s,{mode:c,value:g,pads:$?Array.from(B.subarray($>>>0,I>>>0)):[]})},955269:(s,c,g,$,I,D)=>{r.Sa("BatchNormalization",s,{epsilon:c,momentum:g,spatial:!!I,trainingMode:!!$,format:D?"NHWC":"NCHW"})},955438:(s,c,g,$,I,D)=>{r.Sa("BatchNormalization",s,{epsilon:c,momentum:g,spatial:!!I,trainingMode:!!$,format:D?"NHWC":"NCHW"})},955607:(s,c,g)=>{r.Sa("CumSum",s,{exclusive:Number(c),reverse:Number(g)})},955704:(s,c,g,$,I,D,H,X,q)=>{r.Sa("Attention",s,{numHeads:c,isUnidirectional:g,maskFilterValue:$,scale:I,doRotary:D,qkvHiddenSizes:H?Array.from(B.subarray(Number(X)>>>0,Number(X)+H>>>0)):[],pastPresentShareBuffer:!!q})},955976:s=>{r.Sa("Gelu",s,void 0)},956028:(s,c,g,$,I,D)=>{r.Sa("MultiHeadAttention",s,{numHeads:c,isUnidirectional:g,maskFilterValue:$,scale:I,doRotary:D})},956187:s=>{r.Sa("BiasAdd",s,void 0)},956242:s=>{r.Sa("BiasSplitGelu",s,void 0)},956303:(s,c)=>{r.Sa("SkipLayerNormalization",s,{epsilon:c})},956384:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e)=>{r.Sa("Conv",s,{format:q?"NHWC":"NCHW",auto_pad:c,dilations:[g],group:$,kernel_shape:[I],pads:D?Array.from(B.subarray(D>>>0,H>>>0)):[],strides:[X],w_is_const:()=>!!M[j>>>0],activation:Fe(ne),activation_params:fe?Array.from(Pe.subarray(fe>>>0,$e>>>0)):[]})},956754:(s,c,g,$,I,D,H,X,q,j,ne,fe,$e,k,ae,Ae)=>{r.Sa("Conv",s,{format:fe?"NHWC":"NCHW",auto_pad:c,dilations:[g,$],group:I,kernel_shape:[D,H],pads:X?Array.from(B.subarray(X>>>0,q>>>0)):[],strides:[j,ne],w_is_const:()=>!!M[$e>>>0],activation:Fe(k),activation_params:ae?Array.from(Pe.subarray(ae>>>0,Ae>>>0)):[]})},957145:s=>{r.yb(s)},957179:(s,c)=>r.zb(s,c,r.fb.Ab,r.fb.errors)};function Vt(s){this.name="ExitStatus",this.message=`Program terminated with exit(${s})`,this.status=s}function Rt(s){this.cb=s-24,this.rb=function(c){te[this.cb+4>>>2>>>0]=c},this.qb=function(c){te[this.cb+8>>>2>>>0]=c},this.kb=function(c,g){this.jb(),this.rb(c),this.qb(g)},this.jb=function(){te[this.cb+16>>>2>>>0]=0}}var Jt=0,Wt=0,mr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Bt=(s,c,g)=>{c>>>=0;var $=c+g;for(g=c;s[g]&&!(g>=$);)++g;if(16<g-c&&s.buffer&&mr)return mr.decode(s.subarray(c,g));for($="";c<g;){var I=s[c++];if(I&128){var D=s[c++]&63;if((I&224)==192)$+=String.fromCharCode((I&31)<<6|D);else{var H=s[c++]&63;I=(I&240)==224?(I&15)<<12|D<<6|H:(I&7)<<18|D<<12|H<<6|s[c++]&63,65536>I?$+=String.fromCharCode(I):(I-=65536,$+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else $+=String.fromCharCode(I)}return $},Fe=(s,c)=>(s>>>=0)?Bt(N,s,c):"",Et=s=>{for(var c=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);127>=$?c++:2047>=$?c+=2:55296<=$&&57343>=$?(c+=4,++g):c+=3}return c},bt=(s,c,g,$)=>{if(g>>>=0,!(0<$))return 0;var I=g;$=g+$-1;for(var D=0;D<s.length;++D){var H=s.charCodeAt(D);if(55296<=H&&57343>=H){var X=s.charCodeAt(++D);H=65536+((H&1023)<<10)|X&1023}if(127>=H){if(g>=$)break;c[g++>>>0]=H}else{if(2047>=H){if(g+1>=$)break;c[g++>>>0]=192|H>>6}else{if(65535>=H){if(g+2>=$)break;c[g++>>>0]=224|H>>12}else{if(g+3>=$)break;c[g++>>>0]=240|H>>18,c[g++>>>0]=128|H>>12&63}c[g++>>>0]=128|H>>6&63}c[g++>>>0]=128|H&63}}return c[g>>>0]=0,g-I},fr=s=>{if(s===null)return"null";var c=typeof s;return c==="object"||c==="array"||c==="function"?s.toString():""+s},Gr,ot=s=>{for(var c="";N[s>>>0];)c+=Gr[N[s++>>>0]];return c},hr={},Nt={},gr={},ct;function Lr(s,c,g={}){var $=c.name;if(!s)throw new ct(`type "${$}" must have a positive integer typeid pointer`);if(Nt.hasOwnProperty(s)){if(g.tb)return;throw new ct(`Cannot register type \'${$}\' twice`)}Nt[s]=c,delete gr[s],hr.hasOwnProperty(s)&&(c=hr[s],delete hr[s],c.forEach(I=>I()))}function qe(s,c,g={}){if(!("argPackAdvance"in c))throw new TypeError("registerType registeredInstance requires argPackAdvance");Lr(s,c,g)}var yr=(s,c,g)=>{switch(c){case 1:return g?$=>M[$>>>0>>>0]:$=>N[$>>>0>>>0];case 2:return g?$=>Y[$>>>1>>>0]:$=>se[$>>>1>>>0];case 4:return g?$=>B[$>>>2>>>0]:$=>te[$>>>2>>>0];case 8:return g?$=>Ee[$>>>3]:$=>ee[$>>>3];default:throw new TypeError(`invalid integer width (${c}): ${s}`)}};function br(){this.$a=[void 0],this.nb=[]}var Oe=new br;function wr(s){s>>>=0,s>=Oe.cb&&--Oe.get(s).pb===0&&Oe.jb(s)}var ve=s=>{if(!s)throw new ct("Cannot use deleted val. handle = "+s);return Oe.get(s).value},it=s=>{switch(s){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return Oe.kb({pb:1,value:s})}};function Qt(s){return this.fromWireType(B[s>>>2>>>0])}var vr=(s,c)=>{switch(c){case 4:return function(g){return this.fromWireType(Pe[g>>>2>>>0])};case 8:return function(g){return this.fromWireType(be[g>>>3>>>0])};default:throw new TypeError(`invalid float width (${c}): ${s}`)}};function Hn(s){return this.fromWireType(te[s>>>2>>>0])}var $r=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Gn=(s,c)=>{for(var g=s>>1,$=g+c/2;!(g>=$)&&se[g>>>0];)++g;if(g<<=1,32<g-s&&$r)return $r.decode(N.subarray(s>>>0,g>>>0));for(g="",$=0;!($>=c/2);++$){var I=Y[s+2*$>>>1>>>0];if(I==0)break;g+=String.fromCharCode(I)}return g},me=(s,c,g)=>{if(g??=2147483647,2>g)return 0;g-=2;var $=c;g=g<2*s.length?g/2:s.length;for(var I=0;I<g;++I)Y[c>>>1>>>0]=s.charCodeAt(I),c+=2;return Y[c>>>1>>>0]=0,c-$},er=s=>2*s.length,Fr=(s,c)=>{for(var g=0,$="";!(g>=c/4);){var I=B[s+4*g>>>2>>>0];if(I==0)break;++g,65536<=I?(I-=65536,$+=String.fromCharCode(55296|I>>10,56320|I&1023)):$+=String.fromCharCode(I)}return $},Ln=(s,c,g)=>{if(c>>>=0,g??=2147483647,4>g)return 0;var $=c;g=$+g-4;for(var I=0;I<s.length;++I){var D=s.charCodeAt(I);if(55296<=D&&57343>=D){var H=s.charCodeAt(++I);D=65536+((D&1023)<<10)|H&1023}if(B[c>>>2>>>0]=D,c+=4,c+4>g)break}return B[c>>>2>>>0]=0,c-$},jr=s=>{for(var c=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);55296<=$&&57343>=$&&++g,c+=4}return c},_r=(s,c)=>{var g=Nt[s];if(g===void 0)throw s=Ft(s),g=ot(s),at(s),new ct(c+" has unknown type "+g);return g},Sr=(s,c,g)=>{var $=[];return s=s.toWireType($,g),$.length&&(te[c>>>2>>>0]=it($)),s},Ht=s=>{try{s()}catch(c){Ge(c)}};function qr(){var s=ue,c={};for(let[g,$]of Object.entries(s))c[g]=typeof $=="function"?function(){Dt.push(g);try{return $.apply(null,arguments)}finally{O||(Dt.pop(),Je&&mt===1&&Dt.length===0&&(mt=0,Ht(ln),typeof Fibers<"u"&&Fibers.Hb()))}}:$;return c}var mt=0,Je=null,xr=0,Dt=[],Cr={},Ar={},Kr=0,tr=null,Yr=[];function Zr(){return new Promise((s,c)=>{tr={resolve:s,reject:c}})}function Xr(){var s=Mt(65548),c=s+12;te[s>>>2>>>0]=c,te[s+4>>>2>>>0]=c+65536,c=Dt[0];var g=Cr[c];return g===void 0&&(g=Kr++,Cr[c]=g,Ar[g]=c),B[s+8>>>2>>>0]=g,s}function Jr(s){if(!O){if(mt===0){var c=!1,g=!1;s(($=0)=>{if(!O&&(xr=$,c=!0,g)){mt=2,Ht(()=>ft(Je)),typeof Browser<"u"&&Browser.lb.sb&&Browser.lb.resume(),$=!1;try{var I=(0,ue[Ar[B[Je+8>>>2>>>0]]])()}catch(X){I=X,$=!0}var D=!1;if(!Je){var H=tr;H&&(tr=null,($?H.reject:H.resolve)(I),D=!0)}if($&&!D)throw I}}),g=!0,c||(mt=1,Je=Xr(),typeof Browser<"u"&&Browser.lb.sb&&Browser.lb.pause(),Ht(()=>jt(Je)))}else mt===2?(mt=0,Ht(dt),at(Je),Je=null,Yr.forEach($=>{if(!O)try{$();try{U=U=$=U,r.onExit?.($),O=!0,p($,new Vt($))}catch(I){I instanceof Vt||I=="unwind"||p(1,I)}}catch(I){I instanceof Vt||I=="unwind"||p(1,I)}})):Ge(`invalid state: ${mt}`);return xr}}function Ir(s){return Jr(c=>{s().then(c)})}var Gt=[],Qr={},rr=s=>{var c=Qr[s];return c===void 0?ot(s):c},Tr=()=>typeof globalThis=="object"?globalThis:Function("return this")(),lt=s=>{var c=Gt.length;return Gt.push(s),c},Er=(s,c)=>{for(var g=Array(s),$=0;$<s;++$)g[$]=_r(te[c+4*$>>>2>>>0],"parameter "+$);return g},nr=(s,c)=>Object.defineProperty(c,"name",{value:s});function Fn(s){var c=Function;if(!(c instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof c} which is not a function`);var g=nr(c.name||"unknownFunctionName",function(){});return g.prototype=c.prototype,g=new g,s=c.apply(g,s),s instanceof Object?s:g}var Qe=s=>s%4===0&&(s%100!==0||s%400===0),en=[0,31,60,91,121,152,182,213,244,274,305,335],pt=[0,31,59,90,120,151,181,212,243,273,304,334],Pr=s=>{var c=Et(s)+1,g=Mt(c);return g&&bt(s,N,g,c),g},or=[],et=(s,c)=>{or.length=0;for(var g;g=N[s++>>>0];){var $=g!=105;$&=g!=112,c+=$&&c%8?4:0,or.push(g==112?te[c>>>2>>>0]:g==106?Ee[c>>>3]:g==105?B[c>>>2>>>0]:be[c>>>3>>>0]),c+=$?8:4}return or},Lt={},Ke=()=>{if(!tt){var s={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:a||"./this.program"},c;for(c in Lt)Lt[c]===void 0?delete s[c]:s[c]=Lt[c];var g=[];for(c in s)g.push(`${c}=${s[c]}`);tt=g}return tt},tt,tn=[null,[],[]],rn=[31,29,31,30,31,30,31,31,30,31,30,31],nn=[31,28,31,30,31,30,31,31,30,31,30,31];function on(s){var c=Array(Et(s)+1);return bt(s,c,0,c.length),c}function an(s,c,g,$){function I(k,ae,Ae){for(k=typeof k=="number"?k.toString():k||"";k.length<ae;)k=Ae[0]+k;return k}function D(k,ae){return I(k,ae,"0")}function H(k,ae){function Ae(kt){return 0>kt?-1:0<kt?1:0}var Ot;return(Ot=Ae(k.getFullYear()-ae.getFullYear()))===0&&(Ot=Ae(k.getMonth()-ae.getMonth()))===0&&(Ot=Ae(k.getDate()-ae.getDate())),Ot}function X(k){switch(k.getDay()){case 0:return new Date(k.getFullYear()-1,11,29);case 1:return k;case 2:return new Date(k.getFullYear(),0,3);case 3:return new Date(k.getFullYear(),0,2);case 4:return new Date(k.getFullYear(),0,1);case 5:return new Date(k.getFullYear()-1,11,31);case 6:return new Date(k.getFullYear()-1,11,30)}}function q(k){var ae=k.ab;for(k=new Date(new Date(k.bb+1900,0,1).getTime());0<ae;){var Ae=k.getMonth(),Ot=(Qe(k.getFullYear())?rn:nn)[Ae];if(ae>Ot-k.getDate())ae-=Ot-k.getDate()+1,k.setDate(1),11>Ae?k.setMonth(Ae+1):(k.setMonth(0),k.setFullYear(k.getFullYear()+1));else{k.setDate(k.getDate()+ae);break}}return Ae=new Date(k.getFullYear()+1,0,4),ae=X(new Date(k.getFullYear(),0,4)),Ae=X(Ae),0>=H(ae,k)?0>=H(Ae,k)?k.getFullYear()+1:k.getFullYear():k.getFullYear()-1}s>>>=0,c>>>=0,g>>>=0,$>>>=0;var j=te[$+40>>>2>>>0];$={Db:B[$>>>2>>>0],Cb:B[$+4>>>2>>>0],hb:B[$+8>>>2>>>0],mb:B[$+12>>>2>>>0],ib:B[$+16>>>2>>>0],bb:B[$+20>>>2>>>0],Wa:B[$+24>>>2>>>0],ab:B[$+28>>>2>>>0],Gb:B[$+32>>>2>>>0],Bb:B[$+36>>>2>>>0],Eb:j?Fe(j):""},g=Fe(g),j={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ne in j)g=g.replace(new RegExp(ne,"g"),j[ne]);var fe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),$e="January February March April May June July August September October November December".split(" ");j={"%a":k=>fe[k.Wa].substring(0,3),"%A":k=>fe[k.Wa],"%b":k=>$e[k.ib].substring(0,3),"%B":k=>$e[k.ib],"%C":k=>D((k.bb+1900)/100|0,2),"%d":k=>D(k.mb,2),"%e":k=>I(k.mb,2," "),"%g":k=>q(k).toString().substring(2),"%G":k=>q(k),"%H":k=>D(k.hb,2),"%I":k=>(k=k.hb,k==0?k=12:12<k&&(k-=12),D(k,2)),"%j":k=>{for(var ae=0,Ae=0;Ae<=k.ib-1;ae+=(Qe(k.bb+1900)?rn:nn)[Ae++]);return D(k.mb+ae,3)},"%m":k=>D(k.ib+1,2),"%M":k=>D(k.Cb,2),"%n":()=>`\n`,"%p":k=>0<=k.hb&&12>k.hb?"AM":"PM","%S":k=>D(k.Db,2),"%t":()=>"\t","%u":k=>k.Wa||7,"%U":k=>D(Math.floor((k.ab+7-k.Wa)/7),2),"%V":k=>{var ae=Math.floor((k.ab+7-(k.Wa+6)%7)/7);if(2>=(k.Wa+371-k.ab-2)%7&&ae++,ae)ae==53&&(Ae=(k.Wa+371-k.ab)%7,Ae==4||Ae==3&&Qe(k.bb)||(ae=1));else{ae=52;var Ae=(k.Wa+7-k.ab-1)%7;(Ae==4||Ae==5&&Qe(k.bb%400-1))&&ae++}return D(ae,2)},"%w":k=>k.Wa,"%W":k=>D(Math.floor((k.ab+7-(k.Wa+6)%7)/7),2),"%y":k=>(k.bb+1900).toString().substring(2),"%Y":k=>k.bb+1900,"%z":k=>{k=k.Bb;var ae=0<=k;return k=Math.abs(k)/60,(ae?"+":"-")+("0000"+(k/60*100+k%60)).slice(-4)},"%Z":k=>k.Eb,"%%":()=>"%"},g=g.replace(/%%/g,"\\0\\0");for(ne in j)g.includes(ne)&&(g=g.replace(new RegExp(ne,"g"),j[ne]($)));return g=g.replace(/\\0\\0/g,"%"),ne=on(g),ne.length>c?0:(M.set(ne,s>>>0),ne.length-1)}for(var sn=Array(256),ir=0;256>ir;++ir)sn[ir]=String.fromCharCode(ir);Gr=sn,ct=r.BindingError=class extends Error{constructor(s){super(s),this.name="BindingError"}},r.InternalError=class extends Error{constructor(s){super(s),this.name="InternalError"}},Object.assign(br.prototype,{get(s){return this.$a[s]},has(s){return this.$a[s]!==void 0},kb(s){var c=this.nb.pop()||this.$a.length;return this.$a[c]=s,c},jb(s){this.$a[s]=void 0,this.nb.push(s)}}),Oe.$a.push({value:void 0},{value:null},{value:!0},{value:!1}),Oe.cb=Oe.$a.length,r.count_emval_handles=()=>{for(var s=0,c=Oe.cb;c<Oe.$a.length;++c)Oe.$a[c]!==void 0&&++s;return s};var jn={ia:function(s,c,g){return Ir(async()=>{await r.wb(s,c,g)})},a:function(s,c,g){throw s>>>=0,new Rt(s).kb(c>>>0,g>>>0),Jt=s,Wt++,Jt},x:function(){return 0},ba:function(){},O:function(){},Q:function(){},ca:function(){return 0},$:function(){},W:function(){},_:function(){},D:function(){},P:function(){},M:function(){},aa:function(){},N:function(){},G:function(s,c,g,$,I){c>>>=0,c=ot(c);var D=c.indexOf("u")!=-1;D&&(I=(1n<<64n)-1n),qe(s>>>0,{name:c,fromWireType:H=>H,toWireType:function(H,X){if(typeof X!="bigint"&&typeof X!="number")throw new TypeError(`Cannot convert "${fr(X)}" to ${this.name}`);if(X<$||X>I)throw new TypeError(`Passing a number "${fr(X)}" from JS side to C/C++ side to an argument of type "${c}", which is outside the valid range [${$}, ${I}]!`);return X},argPackAdvance:8,readValueFromPointer:yr(c,g>>>0,!D),eb:null})},ga:function(s,c,g,$){c=ot(c>>>0),qe(s>>>0,{name:c,fromWireType:function(I){return!!I},toWireType:function(I,D){return D?g:$},argPackAdvance:8,readValueFromPointer:function(I){return this.fromWireType(N[I>>>0])},eb:null})},fa:function(s,c){c=ot(c>>>0),qe(s>>>0,{name:c,fromWireType:g=>{var $=ve(g);return wr(g),$},toWireType:(g,$)=>it($),argPackAdvance:8,readValueFromPointer:Qt,eb:null})},F:function(s,c,g){c=ot(c>>>0),qe(s>>>0,{name:c,fromWireType:$=>$,toWireType:($,I)=>I,argPackAdvance:8,readValueFromPointer:vr(c,g>>>0),eb:null})},t:function(s,c,g,$,I){if(s>>>=0,g>>>=0,c=ot(c>>>0),I===-1&&(I=4294967295),I=X=>X,$===0){var D=32-8*g;I=X=>X<<D>>>D}var H=c.includes("unsigned")?function(X,q){return q>>>0}:function(X,q){return q};qe(s,{name:c,fromWireType:I,toWireType:H,argPackAdvance:8,readValueFromPointer:yr(c,g,$!==0),eb:null})},n:function(s,c,g){function $(D){return new I(M.buffer,te[D+4>>>2>>>0],te[D>>>2>>>0])}var I=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][c];g=ot(g>>>0),qe(s>>>0,{name:g,fromWireType:$,argPackAdvance:8,readValueFromPointer:$},{tb:!0})},H:function(s,c){c=ot(c>>>0);var g=c==="std::string";qe(s>>>0,{name:c,fromWireType:function($){var I=te[$>>>2>>>0],D=$+4;if(g)for(var H=D,X=0;X<=I;++X){var q=D+X;if(X==I||N[q>>>0]==0){if(H=Fe(H,q-H),j===void 0)var j=H;else j+=String.fromCharCode(0),j+=H;H=q+1}}else{for(j=Array(I),X=0;X<I;++X)j[X]=String.fromCharCode(N[D+X>>>0]);j=j.join("")}return at($),j},toWireType:function($,I){I instanceof ArrayBuffer&&(I=new Uint8Array(I));var D=typeof I=="string";if(!(D||I instanceof Uint8Array||I instanceof Uint8ClampedArray||I instanceof Int8Array))throw new ct("Cannot pass non-string to std::string");var H=g&&D?Et(I):I.length,X=Mt(4+H+1),q=X+4;if(te[X>>>2>>>0]=H,g&&D)bt(I,N,q,H+1);else if(D)for(D=0;D<H;++D){var j=I.charCodeAt(D);if(255<j)throw at(q),new ct("String has UTF-16 code units that do not fit in 8 bits");N[q+D>>>0]=j}else for(D=0;D<H;++D)N[q+D>>>0]=I[D];return $!==null&&$.push(at,X),X},argPackAdvance:8,readValueFromPointer:Hn,eb($){at($)}})},z:function(s,c,g){if(c>>>=0,g>>>=0,g=ot(g),c===2)var $=Gn,I=me,D=er,H=()=>se,X=1;else c===4&&($=Fr,I=Ln,D=jr,H=()=>te,X=2);qe(s>>>0,{name:g,fromWireType:q=>{for(var j=te[q>>>2>>>0],ne=H(),fe,$e=q+4,k=0;k<=j;++k){var ae=q+4+k*c;(k==j||ne[ae>>>X]==0)&&($e=$($e,ae-$e),fe===void 0?fe=$e:(fe+=String.fromCharCode(0),fe+=$e),$e=ae+c)}return at(q),fe},toWireType:(q,j)=>{if(typeof j!="string")throw new ct(`Cannot pass non-string to C++ string type ${g}`);var ne=D(j),fe=Mt(4+ne+c);return te[fe>>>2]=ne>>X,I(j,fe+4,ne+c),q!==null&&q.push(at,fe),fe},argPackAdvance:8,readValueFromPointer:Qt,eb(q){at(q)}})},ha:function(s,c){c=ot(c>>>0),qe(s>>>0,{ub:!0,name:c,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},da:()=>1,s:function(s,c,g){return c>>>=0,g>>>=0,s=ve(s>>>0),c=_r(c,"emval::as"),Sr(c,g,s)},w:function(s){return s>>>=0,Ir(()=>(s=ve(s),s.then(it)))},o:function(s,c,g,$){return g>>>=0,$>>>=0,s=Gt[s>>>0],c=ve(c>>>0),s(null,c,g,$)},k:function(s,c,g,$,I){return g>>>=0,$>>>=0,I>>>=0,s=Gt[s>>>0],c=ve(c>>>0),g=rr(g),s(c,c[g],$,I)},b:wr,A:function(s,c){return c>>>=0,s=ve(s>>>0),c=ve(c),s==c},m:function(s){return s>>>=0,s===0?it(Tr()):(s=rr(s),it(Tr()[s]))},i:function(s,c,g){c=Er(s,c>>>0);var $=c.shift();s--;var I=`return function (obj, func, destructorsRef, args) {\n`,D=0,H=[];g===0&&H.push("obj");for(var X=["retType"],q=[$],j=0;j<s;++j)H.push("arg"+j),X.push("argType"+j),q.push(c[j]),I+=`  var arg${j} = argType${j}.readValueFromPointer(args${D?"+"+D:""});\n`,D+=c[j].argPackAdvance;for(I+=`  var rv = ${g===1?"new func":"func.call"}(${H.join(", ")});\n`,j=0;j<s;++j)c[j].deleteObject&&(I+=`  argType${j}.deleteObject(arg${j});\n`);return $.ub||(X.push("emval_returnValue"),q.push(Sr),I+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),X.push(I+`};\n`),s=Fn(X).apply(null,q),g=`methodCaller<(${c.map(ne=>ne.name).join(", ")}) => ${$.name}>`,lt(nr(g,s))},r:function(s,c){return c>>>=0,s=ve(s>>>0),c=ve(c),it(s[c])},e:function(s){s>>>=0,4<s&&(Oe.get(s).pb+=1)},u:function(){return it([])},l:function(s){s=ve(s>>>0);for(var c=Array(s.length),g=0;g<s.length;g++)c[g]=s[g];return it(c)},d:function(s){return it(rr(s>>>0))},j:function(){return it({})},h:function(s){s>>>=0;for(var c=ve(s);c.length;){var g=c.pop();c.pop()(g)}wr(s)},g:function(s,c,g){c>>>=0,g>>>=0,s=ve(s>>>0),c=ve(c),g=ve(g),s[c]=g},c:function(s,c){return c>>>=0,s=_r(s>>>0,"_emval_take_value"),s=s.readValueFromPointer(c),it(s)},T:function(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),B[c>>>2>>>0]=s.getUTCSeconds(),B[c+4>>>2>>>0]=s.getUTCMinutes(),B[c+8>>>2>>>0]=s.getUTCHours(),B[c+12>>>2>>>0]=s.getUTCDate(),B[c+16>>>2>>>0]=s.getUTCMonth(),B[c+20>>>2>>>0]=s.getUTCFullYear()-1900,B[c+24>>>2>>>0]=s.getUTCDay(),B[c+28>>>2>>>0]=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},U:function(s,c){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),c>>>=0,s=new Date(1e3*s),B[c>>>2>>>0]=s.getSeconds(),B[c+4>>>2>>>0]=s.getMinutes(),B[c+8>>>2>>>0]=s.getHours(),B[c+12>>>2>>>0]=s.getDate(),B[c+16>>>2>>>0]=s.getMonth(),B[c+20>>>2>>>0]=s.getFullYear()-1900,B[c+24>>>2>>>0]=s.getDay(),B[c+28>>>2>>>0]=(Qe(s.getFullYear())?en:pt)[s.getMonth()]+s.getDate()-1|0,B[c+36>>>2>>>0]=-(60*s.getTimezoneOffset());var g=new Date(s.getFullYear(),6,1).getTimezoneOffset(),$=new Date(s.getFullYear(),0,1).getTimezoneOffset();B[c+32>>>2>>>0]=(g!=$&&s.getTimezoneOffset()==Math.min($,g))|0},V:function(s){s>>>=0;var c=new Date(B[s+20>>>2>>>0]+1900,B[s+16>>>2>>>0],B[s+12>>>2>>>0],B[s+8>>>2>>>0],B[s+4>>>2>>>0],B[s>>>2>>>0],0),g=B[s+32>>>2>>>0],$=c.getTimezoneOffset(),I=new Date(c.getFullYear(),6,1).getTimezoneOffset(),D=new Date(c.getFullYear(),0,1).getTimezoneOffset(),H=Math.min(D,I);return 0>g?B[s+32>>>2>>>0]=+(I!=D&&H==$):0<g!=(H==$)&&(I=Math.max(D,I),c.setTime(c.getTime()+6e4*((0<g?H:I)-$))),B[s+24>>>2>>>0]=c.getDay(),B[s+28>>>2>>>0]=(Qe(c.getFullYear())?en:pt)[c.getMonth()]+c.getDate()-1|0,B[s>>>2>>>0]=c.getSeconds(),B[s+4>>>2>>>0]=c.getMinutes(),B[s+8>>>2>>>0]=c.getHours(),B[s+12>>>2>>>0]=c.getDate(),B[s+16>>>2>>>0]=c.getMonth(),B[s+20>>>2>>>0]=c.getYear(),s=c.getTime(),isNaN(s)?(B[un()>>>2>>>0]=61,s=-1):s/=1e3,BigInt(s)},R:function(){return-52},S:function(){},K:function(s,c,g){function $(q){return(q=q.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?q[1]:"GMT"}g>>>=0;var I=new Date().getFullYear(),D=new Date(I,0,1),H=new Date(I,6,1);I=D.getTimezoneOffset();var X=H.getTimezoneOffset();te[s>>>0>>>2>>>0]=60*Math.max(I,X),B[c>>>0>>>2>>>0]=+(I!=X),s=$(D),c=$(H),s=Pr(s),c=Pr(c),X<I?(te[g>>>2>>>0]=s,te[g+4>>>2>>>0]=c):(te[g>>>2>>>0]=c,te[g+4>>>2>>>0]=s)},v:()=>{Ge("")},f:function(s,c,g){return s>>>=0,c=et(c>>>0,g>>>0),Tt[s].apply(null,c)},I:function(s,c,g){return s>>>=0,c=et(c>>>0,g>>>0),Tt[s].apply(null,c)},E:()=>Date.now(),L:function(){return 4294901760},q:()=>performance.now(),J:function(s){s>>>=0;var c=N.length;if(4294901760<s)return!1;for(var g=1;4>=g;g*=2){var $=c*(1+.2/g);$=Math.min($,s+100663296);var I=Math;$=Math.max(s,$);e:{I=(I.min.call(I,4294901760,$+(65536-$%65536)%65536)-E.buffer.byteLength+65535)/65536;try{E.grow(I),Me();var D=1;break e}catch{}D=void 0}if(D)return!0}return!1},Y:function(s,c){s>>>=0,c>>>=0;var g=0;return Ke().forEach(($,I)=>{var D=c+g;for(I=te[s+4*I>>>2>>>0]=D,D=0;D<$.length;++D)M[I++>>>0>>>0]=$.charCodeAt(D);M[I>>>0>>>0]=0,g+=$.length+1}),0},Z:function(s,c){s>>>=0,c>>>=0;var g=Ke();te[s>>>2>>>0]=g.length;var $=0;return g.forEach(I=>$+=I.length+1),te[c>>>2>>>0]=$,0},y:()=>52,C:function(){return 52},X:function(){return 70},B:function(s,c,g,$){c>>>=0,g>>>=0,$>>>=0;for(var I=0,D=0;D<g;D++){var H=te[c>>>2>>>0],X=te[c+4>>>2>>>0];c+=8;for(var q=0;q<X;q++){var j=N[H+q>>>0],ne=tn[s];j===0||j===10?((s===1?C:S)(Bt(ne,0)),ne.length=0):ne.push(j)}I+=X}return te[$>>>2>>>0]=I,0},ea:an,p:function(s,c,g,$){return an(s>>>0,c>>>0,g>>>0,$>>>0)}},ue=function(){function s(g){return ue=g.exports,ue=qr(),ue=dn(),E=ue.ja,Me(),ye.unshift(ue.ka),we--,we==0&&(ze!==null&&(clearInterval(ze),ze=null),Re&&(g=Re,Re=null,g())),ue}var c={a:jn};if(we++,r.instantiateWasm)try{return r.instantiateWasm(c,s)}catch(g){S(`Module.instantiateWasm callback failed with error: ${g}`),i(g)}return It(c,function(g){s(g.instance)}).catch(i),{}}();r._OrtInit=(s,c)=>(r._OrtInit=ue.la)(s,c),r._OrtGetLastError=(s,c)=>(r._OrtGetLastError=ue.ma)(s,c),r._OrtCreateSessionOptions=(s,c,g,$,I,D,H,X,q,j)=>(r._OrtCreateSessionOptions=ue.na)(s,c,g,$,I,D,H,X,q,j),r._OrtAppendExecutionProvider=(s,c)=>(r._OrtAppendExecutionProvider=ue.oa)(s,c),r._OrtAddFreeDimensionOverride=(s,c,g)=>(r._OrtAddFreeDimensionOverride=ue.pa)(s,c,g),r._OrtAddSessionConfigEntry=(s,c,g)=>(r._OrtAddSessionConfigEntry=ue.qa)(s,c,g),r._OrtReleaseSessionOptions=s=>(r._OrtReleaseSessionOptions=ue.ra)(s),r._OrtCreateSession=(s,c,g)=>(r._OrtCreateSession=ue.sa)(s,c,g),r._OrtReleaseSession=s=>(r._OrtReleaseSession=ue.ta)(s),r._OrtGetInputOutputCount=(s,c,g)=>(r._OrtGetInputOutputCount=ue.ua)(s,c,g),r._OrtGetInputName=(s,c)=>(r._OrtGetInputName=ue.va)(s,c),r._OrtGetOutputName=(s,c)=>(r._OrtGetOutputName=ue.wa)(s,c),r._OrtFree=s=>(r._OrtFree=ue.xa)(s),r._OrtCreateTensor=(s,c,g,$,I,D)=>(r._OrtCreateTensor=ue.ya)(s,c,g,$,I,D),r._OrtGetTensorData=(s,c,g,$,I)=>(r._OrtGetTensorData=ue.za)(s,c,g,$,I),r._OrtReleaseTensor=s=>(r._OrtReleaseTensor=ue.Aa)(s),r._OrtCreateRunOptions=(s,c,g,$)=>(r._OrtCreateRunOptions=ue.Ba)(s,c,g,$),r._OrtAddRunConfigEntry=(s,c,g)=>(r._OrtAddRunConfigEntry=ue.Ca)(s,c,g),r._OrtReleaseRunOptions=s=>(r._OrtReleaseRunOptions=ue.Da)(s),r._OrtCreateBinding=s=>(r._OrtCreateBinding=ue.Ea)(s),r._OrtBindInput=(s,c,g)=>(r._OrtBindInput=ue.Fa)(s,c,g),r._OrtBindOutput=(s,c,g,$)=>(r._OrtBindOutput=ue.Ga)(s,c,g,$),r._OrtClearBoundOutputs=s=>(r._OrtClearBoundOutputs=ue.Ha)(s),r._OrtReleaseBinding=s=>(r._OrtReleaseBinding=ue.Ia)(s),r._OrtRunWithBinding=(s,c,g,$,I)=>(r._OrtRunWithBinding=ue.Ja)(s,c,g,$,I),r._OrtRun=(s,c,g,$,I,D,H,X)=>(r._OrtRun=ue.Ka)(s,c,g,$,I,D,H,X),r._OrtEndProfiling=s=>(r._OrtEndProfiling=ue.La)(s),r._JsepOutput=(s,c,g)=>(r._JsepOutput=ue.Ma)(s,c,g),r._JsepGetNodeName=s=>(r._JsepGetNodeName=ue.Na)(s);var un=()=>(un=ue.Oa)(),Mt=r._malloc=s=>(Mt=r._malloc=ue.Pa)(s),at=r._free=s=>(at=r._free=ue.Qa)(s),Ft=s=>(Ft=ue.Ra)(s),ar=()=>(ar=ue.Ta)(),sr=s=>(sr=ue.Ua)(s),Or=s=>(Or=ue.Va)(s),jt=s=>(jt=ue.Xa)(s),ln=()=>(ln=ue.Ya)(),ft=s=>(ft=ue.Za)(s),dt=()=>(dt=ue._a)();r.___start_em_js=957291,r.___stop_em_js=957452;function dn(){var s=ue;s=Object.assign({},s);var c=$=>()=>$()>>>0,g=$=>I=>$(I)>>>0;return s.Oa=c(s.Oa),s.Pa=g(s.Pa),s.Ra=g(s.Ra),s.Ta=c(s.Ta),s.Va=g(s.Va),s}r.stackAlloc=Or,r.stackSave=ar,r.stackRestore=sr,r.UTF8ToString=Fe,r.stringToUTF8=(s,c,g)=>bt(s,N,c,g),r.lengthBytesUTF8=Et;var Pt;Re=function s(){Pt||kr(),Pt||(Re=s)};function kr(){if(!(0<we)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;){var s=r.preRun.shift();pe.unshift(s)}for(;0<pe.length;)pe.shift()(r);if(!(0<we||Pt||(Pt=!0,r.calledRun=!0,O))){for(;0<ye.length;)ye.shift()(r);for(o(r);0<de.length;)de.shift()(r)}}}return kr(),t.ready}})();typeof wi=="object"&&typeof io=="object"?io.exports=bi:typeof define=="function"&&define.amd&&define([],()=>bi)});var $i=Br(()=>{});var _i=Br(()=>{});var Si={};hn(Si,{cpus:()=>Vl});var Vl,xi=Q(()=>{Vl=void 0});var Ii=Br((Ai,ao)=>{"use strict";var Ci=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return be.buffer!=de.buffer&&ke(),de}function o(){return be.buffer!=de.buffer&&ke(),we}function i(){return be.buffer!=de.buffer&&ke(),ze}function u(){return be.buffer!=de.buffer&&ke(),Re}function a(){return be.buffer!=de.buffer&&ke(),Ge}function p(){return be.buffer!=de.buffer&&ke(),F}function m(){return be.buffer!=de.buffer&&ke(),ie}function h(){return be.buffer!=de.buffer&&ke(),nt}var d=t,y,w;d.ready=new Promise((n,l)=>{y=n,w=l}),d.mountExternalData=(n,l)=>{(d.Fb||(d.Fb=new Map)).set(n,l)},d.unmountExternalData=()=>{delete d.Fb},d.jsepInit=(n,l,f,b,A,P,z,L)=>{d.rc=n,d.$b=l,d.bc=f,d.Ob=b,d.ac=A,d.eb=P,d.cc=z,d.dc=L,l=(Z,K,oe)=>(...ge)=>{let Se=dt,R=K?.();ge=Z(...ge);let le=K?.();return R!==le&&(Z=le,oe(R),K=oe=null),dt!=Se?I():ge},f=Z=>async(...K)=>{try{if(d.Eb)throw Error("Session already started");let oe=d.Eb={fc:K[0],errors:[]},ge=await Z(...K);if(d.Eb!==oe)throw Error("Session mismatch");n.flush();let Se=oe.errors;if(0<Se.length){let R=await Promise.all(Se);if(R=R.filter(le=>le),0<R.length)throw Error(R.join(`\n`))}return ge}finally{d.Eb=null}},d._OrtCreateSession=l(d._OrtCreateSession,()=>d._OrtCreateSession,Z=>d._OrtCreateSession=Z),d._OrtRun=f(l(d._OrtRun,()=>d._OrtRun,Z=>d._OrtRun=Z)),d._OrtRunWithBinding=f(l(d._OrtRunWithBinding,()=>d._OrtRunWithBinding,Z=>d._OrtRunWithBinding=Z)),d._OrtBindInput=l(d._OrtBindInput,()=>d._OrtBindInput,Z=>d._OrtBindInput=Z),d.jsepRegisterBuffer=(Z,K,oe,ge)=>n.registerBuffer(Z,K,oe,ge),d.jsepUnregisterBuffers=Z=>{n.unregisterBuffers(Z)},d.jsepGetBuffer=Z=>n.getBuffer(Z),d.jsepCreateDownloader=(Z,K,oe)=>n.createDownloader(Z,K,oe),d.jsepOnRunStart=()=>n.onRunStart()};var _=Object.assign({},d),v="./this.program",x=(n,l)=>{throw l},T=typeof window=="object",C=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",E=d.ENVIRONMENT_IS_PTHREAD||!1,O="";function U(n){return d.locateFile?d.locateFile(n,O):O+n}var M,N,Y;if(S){var se=(ro(),ur(to)),B=(oo(),ur(no));O=C?B.dirname(O)+"/":__dirname+"/",M=(l,f)=>(l=Et(l)?new URL(l):B.normalize(l),se.readFileSync(l,f?void 0:"utf8")),Y=l=>(l=M(l,!0),l.buffer||(l=new Uint8Array(l)),l),N=(l,f,b,A=!0)=>{l=Et(l)?new URL(l):B.normalize(l),se.readFile(l,A?void 0:"utf8",(P,z)=>{P?b(P):f(A?z.buffer:z)})},!d.thisProgram&&1<process.argv.length&&(v=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),x=(l,f)=>{throw process.exitCode=l,f},d.inspect=()=>"[Emscripten Module object]";let n;try{n=$i()}catch(l){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),l}global.Worker=n.Worker}else(T||C)&&(C?O=self.location.href:typeof document<"u"&&document.currentScript&&(O=document.currentScript.src),typeof e<"u"&&e&&(O=e),O.indexOf("blob:")!==0?O=O.substr(0,O.replace(/[?#].*/,"").lastIndexOf("/")+1):O="",S||(M=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.send(null),l.responseText},C&&(Y=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.responseType="arraybuffer",l.send(null),new Uint8Array(l.response)}),N=(n,l,f)=>{var b=new XMLHttpRequest;b.open("GET",n,!0),b.responseType="arraybuffer",b.onload=()=>{b.status==200||b.status==0&&b.response?l(b.response):f()},b.onerror=f,b.send(null)}));S&&typeof performance>"u"&&(global.performance=_i().performance);var te=console.log.bind(console),Pe=console.error.bind(console);S&&(te=(...n)=>se.writeSync(1,n.join(" ")+`\n`),Pe=(...n)=>se.writeSync(2,n.join(" ")+`\n`));var Ee=te,ee=Pe;Object.assign(d,_),_=null,typeof WebAssembly!="object"&&Bt("no native wasm support detected");var be,Me,pe=!1,ye,de,we,ze,Re,Ge,F,ie,he,Xe,nt;function ke(){var n=be.buffer;d.HEAP8=de=new Int8Array(n),d.HEAP16=ze=new Int16Array(n),d.HEAPU8=we=new Uint8Array(n),d.HEAPU16=Re=new Uint16Array(n),d.HEAP32=Ge=new Int32Array(n),d.HEAPU32=F=new Uint32Array(n),d.HEAPF32=ie=new Float32Array(n),d.HEAPF64=nt=new Float64Array(n),d.HEAP64=he=new BigInt64Array(n),d.HEAPU64=Xe=new BigUint64Array(n)}var Le=16777216;if(E)be=d.wasmMemory;else if(d.wasmMemory)be=d.wasmMemory;else if(be=new WebAssembly.Memory({initial:Le/65536,maximum:65536,shared:!0}),!(be.buffer instanceof SharedArrayBuffer))throw ee("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&ee("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ke(),Le=be.buffer.byteLength;var It=[],Tt=[],Vt=[],Rt=0,Jt=null,Wt=null;function mr(){if(Rt--,Rt==0&&(Jt!==null&&(clearInterval(Jt),Jt=null),Wt)){var n=Wt;Wt=null,n()}}function Bt(n){throw n="Aborted("+n+")",ee(n),pe=!0,ye=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),w(n),n}var Fe=n=>n.startsWith("data:application/octet-stream;base64,"),Et=n=>n.startsWith("file://"),bt;bt="ort-wasm-simd-threaded.wasm",Fe(bt)||(bt=U(bt));function fr(n){if(Y)return Y(n);throw"both async and sync fetching of the wasm failed"}function Gr(n){if(T||C){if(typeof fetch=="function"&&!Et(n))return fetch(n,{credentials:"same-origin"}).then(l=>{if(!l.ok)throw"failed to load wasm binary file at \'"+n+"\'";return l.arrayBuffer()}).catch(()=>fr(n));if(N)return new Promise((l,f)=>{N(n,b=>l(new Uint8Array(b)),f)})}return Promise.resolve().then(()=>fr(n))}function ot(n,l,f){return Gr(n).then(b=>WebAssembly.instantiate(b,l)).then(b=>b).then(f,b=>{ee(`failed to asynchronously prepare wasm: ${b}`),Bt(b)})}function hr(n,l){var f=bt;return typeof WebAssembly.instantiateStreaming!="function"||Fe(f)||Et(f)||S||typeof fetch!="function"?ot(f,n,l):fetch(f,{credentials:"same-origin"}).then(b=>WebAssembly.instantiateStreaming(b,n).then(l,function(A){return ee(`wasm streaming compile failed: ${A}`),ee("falling back to ArrayBuffer instantiation"),ot(f,n,l)}))}var Nt={946748:(n,l,f,b)=>{if(typeof d>"u"||!d.Fb)return 1;if(n=Oe(n>>>0),n.startsWith("./")&&(n=n.substring(2)),n=d.Fb.get(n),!n)return 2;if(l>>>=0,f>>>=0,b>>>=0,l+f>n.byteLength)return 3;try{return o().set(n.subarray(l,l+f),b>>>0),0}catch{return 4}},947249:n=>d.$b(n),947282:n=>d.bc(n),947314:(n,l,f)=>{d.Ob(n,l,f,!0)},947353:(n,l,f)=>{d.Ob(n,l,f)},947386:n=>{d.eb("Abs",n,void 0)},947437:n=>{d.eb("Neg",n,void 0)},947488:n=>{d.eb("Floor",n,void 0)},947541:n=>{d.eb("Ceil",n,void 0)},947593:n=>{d.eb("Reciprocal",n,void 0)},947651:n=>{d.eb("Sqrt",n,void 0)},947703:n=>{d.eb("Exp",n,void 0)},947754:n=>{d.eb("Erf",n,void 0)},947805:n=>{d.eb("Sigmoid",n,void 0)},947860:(n,l,f)=>{d.eb("HardSigmoid",n,{alpha:l,beta:f})},947939:n=>{d.eb("Log",n,void 0)},947990:n=>{d.eb("Sin",n,void 0)},948041:n=>{d.eb("Cos",n,void 0)},948092:n=>{d.eb("Tan",n,void 0)},948143:n=>{d.eb("Asin",n,void 0)},948195:n=>{d.eb("Acos",n,void 0)},948247:n=>{d.eb("Atan",n,void 0)},948299:n=>{d.eb("Sinh",n,void 0)},948351:n=>{d.eb("Cosh",n,void 0)},948403:n=>{d.eb("Asinh",n,void 0)},948456:n=>{d.eb("Acosh",n,void 0)},948509:n=>{d.eb("Atanh",n,void 0)},948562:n=>{d.eb("Tanh",n,void 0)},948614:n=>{d.eb("Not",n,void 0)},948665:(n,l,f)=>{d.eb("Clip",n,{min:l,max:f})},948734:n=>{d.eb("Clip",n,void 0)},948786:(n,l)=>{d.eb("Elu",n,{alpha:l})},948844:n=>{d.eb("Relu",n,void 0)},948896:(n,l)=>{d.eb("LeakyRelu",n,{alpha:l})},948960:(n,l)=>{d.eb("ThresholdedRelu",n,{alpha:l})},949030:(n,l)=>{d.eb("Cast",n,{to:l})},949088:n=>{d.eb("Add",n,void 0)},949139:n=>{d.eb("Sub",n,void 0)},949190:n=>{d.eb("Mul",n,void 0)},949241:n=>{d.eb("Div",n,void 0)},949292:n=>{d.eb("Pow",n,void 0)},949343:n=>{d.eb("Equal",n,void 0)},949396:n=>{d.eb("Greater",n,void 0)},949451:n=>{d.eb("GreaterOrEqual",n,void 0)},949513:n=>{d.eb("Less",n,void 0)},949565:n=>{d.eb("LessOrEqual",n,void 0)},949624:(n,l,f,b,A)=>{d.eb("ReduceMean",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},949783:(n,l,f,b,A)=>{d.eb("ReduceMax",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},949941:(n,l,f,b,A)=>{d.eb("ReduceMin",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},950099:(n,l,f,b,A)=>{d.eb("ReduceProd",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},950258:(n,l,f,b,A)=>{d.eb("ReduceSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},950416:(n,l,f,b,A)=>{d.eb("ReduceL1",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},950573:(n,l,f,b,A)=>{d.eb("ReduceL2",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},950730:(n,l,f,b,A)=>{d.eb("ReduceLogSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},950891:(n,l,f,b,A)=>{d.eb("ReduceSumSquare",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},951055:(n,l,f,b,A)=>{d.eb("ReduceLogSumExp",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},951219:n=>{d.eb("Where",n,void 0)},951272:(n,l,f)=>{d.eb("Transpose",n,{perm:l?Array.from(a().subarray(l>>>0,f>>>0)):[]})},951380:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R,le)=>{d.eb("ConvTranspose",n,{format:Z?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernel_shape:[A],pads:[P,z],strides:[L],wIsConst:()=>!!r()[K>>>0],outputPadding:oe?Array.from(a().subarray(oe>>>0,ge>>>0)):[],outputShape:Se?Array.from(a().subarray(Se>>>0,R>>>0)):[],activation:Oe(le)})},951782:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R)=>{d.eb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(A>>>0,(A>>>0)+2>>>0)),pads:Array.from(a().subarray(P>>>0,(P>>>0)+4>>>0)),strides:Array.from(a().subarray(z>>>0,(z>>>0)+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:K?Array.from(a().subarray(K>>>0,oe>>>0)):[],outputShape:ge?Array.from(a().subarray(ge>>>0,Se>>>0)):[],activation:Oe(R)})},952347:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R,le)=>{d.eb("ConvTranspose",n,{format:Z?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernel_shape:[A],pads:[P,z],strides:[L],wIsConst:()=>!!r()[K>>>0],outputPadding:oe?Array.from(a().subarray(oe>>>0,ge>>>0)):[],outputShape:Se?Array.from(a().subarray(Se>>>0,R>>>0)):[],activation:Oe(le)})},952749:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R)=>{d.eb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(A>>>0,(A>>>0)+2>>>0)),pads:Array.from(a().subarray(P>>>0,(P>>>0)+4>>>0)),strides:Array.from(a().subarray(z>>>0,(z>>>0)+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:K?Array.from(a().subarray(K>>>0,oe>>>0)):[],outputShape:ge?Array.from(a().subarray(ge>>>0,Se>>>0)):[],activation:Oe(R)})},953314:(n,l)=>{d.eb("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},953405:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R,le,Ie)=>{d.eb("AveragePool",n,{format:Ie?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:A,dilations:[P,z],kernel_shape:[L,Z],pads:[K,oe,ge,Se],strides:[R,le]})},953689:(n,l)=>{d.eb("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},953780:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R,le,Ie)=>{d.eb("AveragePool",n,{format:Ie?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:A,dilations:[P,z],kernel_shape:[L,Z],pads:[K,oe,ge,Se],strides:[R,le]})},954064:(n,l)=>{d.eb("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},954151:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R,le,Ie)=>{d.eb("MaxPool",n,{format:Ie?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:A,dilations:[P,z],kernel_shape:[L,Z],pads:[K,oe,ge,Se],strides:[R,le]})},954431:(n,l)=>{d.eb("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},954518:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R,le,Ie)=>{d.eb("MaxPool",n,{format:Ie?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:A,dilations:[P,z],kernel_shape:[L,Z],pads:[K,oe,ge,Se],strides:[R,le]})},954798:(n,l,f,b,A)=>{d.eb("Gemm",n,{alpha:l,beta:f,transA:b,transB:A})},954902:n=>{d.eb("MatMul",n,void 0)},954956:(n,l,f,b)=>{d.eb("ArgMax",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},955064:(n,l,f,b)=>{d.eb("ArgMin",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},955172:(n,l)=>{d.eb("Softmax",n,{axis:l})},955235:(n,l)=>{d.eb("Concat",n,{axis:l})},955295:(n,l,f,b,A)=>{d.eb("Split",n,{axis:l,numOutputs:f,splitSizes:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},955435:n=>{d.eb("Expand",n,void 0)},955489:(n,l)=>{d.eb("Gather",n,{axis:Number(l)})},955560:(n,l)=>{d.eb("GatherElements",n,{axis:Number(l)})},955639:(n,l,f,b,A,P,z,L,Z,K,oe)=>{d.eb("Resize",n,{antialias:l,axes:f?Array.from(a().subarray(f>>>0,b>>>0)):[],coordinateTransformMode:Oe(A),cubicCoeffA:P,excludeOutside:z,extrapolationValue:L,keepAspectRatioPolicy:Oe(Z),mode:Oe(K),nearestMode:Oe(oe)})},955985:(n,l,f,b,A,P,z)=>{d.eb("Slice",n,{starts:l?Array.from(a().subarray(l>>>0,f>>>0)):[],ends:b?Array.from(a().subarray(b>>>0,A>>>0)):[],axes:P?Array.from(a().subarray(P>>>0,z>>>0)):[]})},956201:n=>{d.eb("Tile",n,void 0)},956253:(n,l,f)=>{d.eb("LayerNormalization",n,{axis:Number(l),epsilon:Number(f)})},956360:(n,l,f)=>{d.eb("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},956474:(n,l,f)=>{d.eb("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},956588:n=>{d.eb("Range",n,void 0)},956641:(n,l)=>{d.eb("Einsum",n,{equation:Oe(l)})},956722:(n,l,f,b,A)=>{d.eb("Pad",n,{mode:l,value:f,pads:b?Array.from(a().subarray(b>>>0,A>>>0)):[]})},956849:(n,l,f,b,A,P)=>{d.eb("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!A,trainingMode:!!b,format:P?"NHWC":"NCHW"})},957018:(n,l,f,b,A,P)=>{d.eb("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!A,trainingMode:!!b,format:P?"NHWC":"NCHW"})},957187:(n,l,f)=>{d.eb("CumSum",n,{exclusive:Number(l),reverse:Number(f)})},957284:(n,l,f,b,A,P,z,L,Z)=>{d.eb("Attention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:A,doRotary:P,qkvHiddenSizes:z?Array.from(a().subarray(Number(L)>>>0,Number(L)+z>>>0)):[],pastPresentShareBuffer:!!Z})},957556:n=>{d.eb("Gelu",n,void 0)},957608:(n,l,f,b,A,P)=>{d.eb("MultiHeadAttention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:A,doRotary:P})},957767:n=>{d.eb("BiasAdd",n,void 0)},957822:n=>{d.eb("BiasSplitGelu",n,void 0)},957883:(n,l)=>{d.eb("SkipLayerNormalization",n,{epsilon:l})},957964:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se)=>{d.eb("Conv",n,{format:Z?"NHWC":"NCHW",auto_pad:l,dilations:[f],group:b,kernel_shape:[A],pads:P?Array.from(a().subarray(P>>>0,z>>>0)):[],strides:[L],w_is_const:()=>!!r()[K>>>0],activation:Oe(oe),activation_params:ge?Array.from(m().subarray(ge>>>0,Se>>>0)):[]})},958334:(n,l,f,b,A,P,z,L,Z,K,oe,ge,Se,R,le,Ie)=>{d.eb("Conv",n,{format:ge?"NHWC":"NCHW",auto_pad:l,dilations:[f,b],group:A,kernel_shape:[P,z],pads:L?Array.from(a().subarray(L>>>0,Z>>>0)):[],strides:[K,oe],w_is_const:()=>!!r()[Se>>>0],activation:Oe(R),activation_params:le?Array.from(m().subarray(le>>>0,Ie>>>0)):[]})},958725:n=>{d.cc(n)},958759:(n,l)=>d.dc(n,l,d.Eb.fc,d.Eb.errors)};function gr(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var ct=n=>{n.terminate(),n.onmessage=()=>{}},Lr=n=>{me.yb.length==0&&($r(),me.Pb(me.yb[0]));var l=me.yb.pop();if(!l)return 6;me.zb.push(l),me.pb[n.xb]=l,l.xb=n.xb;var f={cmd:"run",start_routine:n.hc,arg:n.Vb,pthread_ptr:n.xb};return S&&l.unref(),l.postMessage(f,n.nc),0},qe=0,yr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,br=(n,l,f)=>{l>>>=0;var b=l+f;for(f=l;n[f]&&!(f>=b);)++f;if(16<f-l&&n.buffer&&yr)return yr.decode(n.buffer instanceof SharedArrayBuffer?n.slice(l,f):n.subarray(l,f));for(b="";l<f;){var A=n[l++];if(A&128){var P=n[l++]&63;if((A&224)==192)b+=String.fromCharCode((A&31)<<6|P);else{var z=n[l++]&63;A=(A&240)==224?(A&15)<<12|P<<6|z:(A&7)<<18|P<<12|z<<6|n[l++]&63,65536>A?b+=String.fromCharCode(A):(A-=65536,b+=String.fromCharCode(55296|A>>10,56320|A&1023))}}else b+=String.fromCharCode(A)}return b},Oe=(n,l)=>(n>>>=0)?br(o(),n,l):"",wr=n=>{var l=Jn();return n=n(),mn(l),n};function ve(n,l){var f=arguments.length-2,b=arguments;return wr(()=>{for(var A=2*f,P=Qn(8*A),z=P>>>3,L=0;L<f;L++){var Z=b[2+L];typeof Z=="bigint"?(he[z+2*L]=1n,he[z+2*L+1]=Z):(he[z+2*L]=0n,h()[z+2*L+1>>>0]=Z)}return si(n,A,P,l)})}function it(n){if(E)return ve(0,1,n);ye=n,0<qe||(me.ic(),d.onExit?.(n),pe=!0),x(n,new gr(n))}var Qt=n=>{if(ye=n,E)throw Fr(n),"unwind";it(n)},vr=n=>{n instanceof gr||n=="unwind"||x(1,n)};function Hn(){for(var n=d.numThreads;n--;)$r();It.unshift(()=>{Rt++,Gn(()=>mr())})}function $r(){var n=U("ort-wasm-simd-threaded.worker.js");n=new Worker(n),me.yb.push(n)}function Gn(n){E?n():Promise.all(me.yb.map(me.Pb)).then(n)}var me={yb:[],zb:[],Ub:[],pb:{},Ib(){E?(me.receiveObjectTransfer=me.ec,me.threadInitTLS=me.Tb,me.setExitStatus=me.Sb):Hn()},Sb:n=>ye=n,sc:["$terminateWorker"],ic:()=>{for(var n of me.zb)ct(n);for(n of me.yb)ct(n);me.yb=[],me.zb=[],me.pb=[]},Rb:n=>{var l=n.xb;delete me.pb[l],me.yb.push(n),me.zb.splice(me.zb.indexOf(n),1),n.xb=0,Zn(l)},ec(){},Tb(){me.Ub.forEach(n=>n())},Pb:n=>new Promise(l=>{n.onmessage=P=>{P=P.data;var z=P.cmd;if(P.targetThread&&P.targetThread!=pn()){var L=me.pb[P.targetThread];L?L.postMessage(P,P.transferList):ee(`Internal error! Worker sent a message "${z}" to target pthread ${P.targetThread}, but that thread no longer exists!`)}else z==="checkMailbox"?Ft():z==="spawnThread"?Lr(P):z==="cleanupThread"?me.Rb(me.pb[P.thread]):z==="killThread"?(P=P.thread,z=me.pb[P],delete me.pb[P],ct(z),Zn(P),me.zb.splice(me.zb.indexOf(z),1),z.xb=0):z==="cancelThread"?me.pb[P.thread].postMessage({cmd:"cancel"}):z==="loaded"?(n.loaded=!0,S&&!n.xb&&n.unref(),l(n)):z==="alert"?alert(`Thread ${P.threadId}: ${P.text}`):P.target==="setimmediate"?n.postMessage(P):z==="callHandler"?d[P.handler](...P.args):z&&ee(`worker sent an unknown command ${z}`)},n.onerror=P=>{throw ee(`worker sent an error! ${P.filename}:${P.lineno}: ${P.message}`),P},S&&(n.on("message",P=>n.onmessage({data:P})),n.on("error",P=>n.onerror(P)));var f=[],b=["onExit"],A;for(A of b)d.hasOwnProperty(A)&&f.push(A);n.postMessage({cmd:"load",handlers:f,urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:be,wasmModule:Me})})};d.PThread=me;var er=n=>{for(;0<n.length;)n.shift()(d)};d.establishStackSpace=()=>{var n=pn(),l=p()[n+52>>>2>>>0];n=p()[n+56>>>2>>>0],li(l,l-n),mn(l)};function Fr(n){if(E)return ve(1,0,n);Qt(n)}d.invokeEntryPoint=(n,l)=>{n=di.apply(null,[n,l]),0<qe?me.Sb(n):Xn(n)};function Ln(n){this.Db=n-24,this.pc=function(l){p()[this.Db+4>>>2>>>0]=l},this.Mb=function(l){p()[this.Db+8>>>2>>>0]=l},this.Ib=function(l,f){this.Kb(),this.pc(l),this.Mb(f)},this.Kb=function(){p()[this.Db+16>>>2>>>0]=0}}var jr=0,_r=0;function Sr(n,l,f,b){return E?ve(2,1,n,l,f,b):Ht(n,l,f,b)}function Ht(n,l,f,b){if(n>>>=0,l>>>=0,f>>>=0,b>>>=0,typeof SharedArrayBuffer>"u")return ee("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var A=[];return E&&A.length===0?Sr(n,l,f,b):(n={hc:f,xb:n,Vb:b,nc:A},E?(n.qc="spawnThread",postMessage(n,A),0):Lr(n))}function qr(n,l,f){return E?ve(3,1,n,l,f):0}function mt(n,l){if(E)return ve(4,1,n,l)}var Je=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);127>=b?l++:2047>=b?l+=2:55296<=b&&57343>=b?(l+=4,++f):l+=3}return l},xr=(n,l,f,b)=>{if(f>>>=0,!(0<b))return 0;var A=f;b=f+b-1;for(var P=0;P<n.length;++P){var z=n.charCodeAt(P);if(55296<=z&&57343>=z){var L=n.charCodeAt(++P);z=65536+((z&1023)<<10)|L&1023}if(127>=z){if(f>=b)break;l[f++>>>0]=z}else{if(2047>=z){if(f+1>=b)break;l[f++>>>0]=192|z>>6}else{if(65535>=z){if(f+2>=b)break;l[f++>>>0]=224|z>>12}else{if(f+3>=b)break;l[f++>>>0]=240|z>>18,l[f++>>>0]=128|z>>12&63}l[f++>>>0]=128|z>>6&63}l[f++>>>0]=128|z&63}}return l[f>>>0]=0,f-A},Dt=(n,l,f)=>xr(n,o(),l,f);function Cr(n,l){if(E)return ve(5,1,n,l)}function Ar(n,l,f){if(E)return ve(6,1,n,l,f)}function Kr(n,l,f){return E?ve(7,1,n,l,f):0}function tr(n,l){if(E)return ve(8,1,n,l)}function Yr(n,l,f){if(E)return ve(9,1,n,l,f)}function Zr(n,l,f,b){if(E)return ve(10,1,n,l,f,b)}function Xr(n,l,f,b){if(E)return ve(11,1,n,l,f,b)}function Jr(n,l,f,b){if(E)return ve(12,1,n,l,f,b)}function Ir(n){if(E)return ve(13,1,n)}function Gt(n,l){if(E)return ve(14,1,n,l)}function Qr(n,l,f){if(E)return ve(15,1,n,l,f)}var rr=n=>{if(n===null)return"null";var l=typeof n;return l==="object"||l==="array"||l==="function"?n.toString():""+n},Tr,lt=n=>{for(var l="";o()[n>>>0];)l+=Tr[o()[n++>>>0]];return l},Er={},nr={},Fn={},Qe;function en(n,l,f={}){var b=l.name;if(!n)throw new Qe(`type "${b}" must have a positive integer typeid pointer`);if(nr.hasOwnProperty(n)){if(f.Yb)return;throw new Qe(`Cannot register type \'${b}\' twice`)}nr[n]=l,delete Fn[n],Er.hasOwnProperty(n)&&(l=Er[n],delete Er[n],l.forEach(A=>A()))}function pt(n,l,f={}){if(!("argPackAdvance"in l))throw new TypeError("registerType registeredInstance requires argPackAdvance");en(n,l,f)}var Pr=(n,l,f)=>{switch(l){case 1:return f?b=>r()[b>>>0>>>0]:b=>o()[b>>>0>>>0];case 2:return f?b=>i()[b>>>1>>>0]:b=>u()[b>>>1>>>0];case 4:return f?b=>a()[b>>>2>>>0]:b=>p()[b>>>2>>>0];case 8:return f?b=>he[b>>>3]:b=>Xe[b>>>3];default:throw new TypeError(`invalid integer width (${l}): ${n}`)}};function or(){this.wb=[void 0],this.Nb=[]}var et=new or;function Lt(n){n>>>=0,n>=et.Db&&--et.get(n).Qb===0&&et.Mb(n)}var Ke=n=>{if(!n)throw new Qe("Cannot use deleted val. handle = "+n);return et.get(n).value},tt=n=>{switch(n){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return et.Kb({Qb:1,value:n})}};function tn(n){return this.fromWireType(a()[n>>>2>>>0])}var rn=(n,l)=>{switch(l){case 4:return function(f){return this.fromWireType(m()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(h()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${l}): ${n}`)}};function nn(n){return this.fromWireType(p()[n>>>2>>>0])}var on=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,an=(n,l)=>{for(var f=n>>1,b=f+l/2;!(f>=b)&&u()[f>>>0];)++f;if(f<<=1,32<f-n&&on)return on.decode(o().slice(n,f));for(f="",b=0;!(b>=l/2);++b){var A=i()[n+2*b>>>1>>>0];if(A==0)break;f+=String.fromCharCode(A)}return f},sn=(n,l,f)=>{if(f??=2147483647,2>f)return 0;f-=2;var b=l;f=f<2*n.length?f/2:n.length;for(var A=0;A<f;++A){var P=n.charCodeAt(A);i()[l>>>1>>>0]=P,l+=2}return i()[l>>>1>>>0]=0,l-b},ir=n=>2*n.length,jn=(n,l)=>{for(var f=0,b="";!(f>=l/4);){var A=a()[n+4*f>>>2>>>0];if(A==0)break;++f,65536<=A?(A-=65536,b+=String.fromCharCode(55296|A>>10,56320|A&1023)):b+=String.fromCharCode(A)}return b},ue=(n,l,f)=>{if(l>>>=0,f??=2147483647,4>f)return 0;var b=l;f=b+f-4;for(var A=0;A<n.length;++A){var P=n.charCodeAt(A);if(55296<=P&&57343>=P){var z=n.charCodeAt(++A);P=65536+((P&1023)<<10)|z&1023}if(a()[l>>>2>>>0]=P,l+=4,l+4>f)break}return a()[l>>>2>>>0]=0,l-b},un=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);55296<=b&&57343>=b&&++f,l+=4}return l},Mt=()=>{if(!(0<qe))try{E?Xn(ye):Qt(ye)}catch(n){vr(n)}};function at(n){n>>>=0,typeof Atomics.oc=="function"&&(Atomics.oc(a(),n>>>2,n).value.then(Ft),n+=128,Atomics.store(a(),n>>>2,1))}d.__emscripten_thread_mailbox_await=at;var Ft=()=>{var n=pn();if(n&&(at(n),!pe))try{ui(),Mt()}catch(l){vr(l)}};d.checkMailbox=Ft;var ar=[],sr=(n,l)=>{var f=nr[n];if(f===void 0)throw n=ii(n),f=lt(n),wt(n),new Qe(l+" has unknown type "+f);return f},Or=(n,l,f)=>{var b=[];return n=n.toWireType(b,f),b.length&&(p()[l>>>2>>>0]=tt(b)),n},jt=n=>{try{n()}catch(l){Bt(l)}};function ln(){var n=re,l={};for(let[f,b]of Object.entries(n))l[f]=typeof b=="function"?function(){Pt.push(f);try{return b.apply(null,arguments)}finally{pe||(Pt.pop(),dt&&ft===1&&Pt.length===0&&(ft=0,qe+=1,jt(pi),typeof Fibers<"u"&&Fibers.uc()))}}:b;return l}var ft=0,dt=null,dn=0,Pt=[],kr={},s={},c=0,g=null,$=[];function I(){return new Promise((n,l)=>{g={resolve:n,reject:l}})}function D(){var n=Rr(65548),l=n+12;p()[n>>>2>>>0]=l,p()[n+4>>>2>>>0]=l+65536,l=Pt[0];var f=kr[l];return f===void 0&&(f=c++,kr[l]=f,s[f]=l),l=f,a()[n+8>>>2>>>0]=l,n}function H(){var n=a()[dt+8>>>2>>>0];return n=re[s[n]],--qe,n()}function X(n){if(!pe){if(ft===0){var l=!1,f=!1;n((b=0)=>{if(!pe&&(dn=b,l=!0,f)){ft=2,jt(()=>mi(dt)),typeof Browser<"u"&&Browser.Jb.Xb&&Browser.Jb.resume(),b=!1;try{var A=H()}catch(L){A=L,b=!0}var P=!1;if(!dt){var z=g;z&&(g=null,(b?z.reject:z.resolve)(A),P=!0)}if(b&&!P)throw A}}),f=!0,l||(ft=1,dt=D(),typeof Browser<"u"&&Browser.Jb.Xb&&Browser.Jb.pause(),jt(()=>ci(dt)))}else ft===2?(ft=0,jt(fi),wt(dt),dt=null,$.forEach(b=>{if(!pe)try{b(),Mt()}catch(A){vr(A)}})):Bt(`invalid state: ${ft}`);return dn}}function q(n){return X(l=>{n().then(l)})}var j=[],ne={},fe=n=>{var l=ne[n];return l===void 0?lt(n):l},$e=()=>typeof globalThis=="object"?globalThis:Function("return this")(),k=n=>{var l=j.length;return j.push(n),l},ae=(n,l)=>{for(var f=Array(n),b=0;b<n;++b)f[b]=sr(p()[l+4*b>>>2>>>0],"parameter "+b);return f},Ae=(n,l)=>Object.defineProperty(l,"name",{value:n});function Ot(n){var l=Function;if(!(l instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof l} which is not a function`);var f=Ae(l.name||"unknownFunctionName",function(){});return f.prototype=l.prototype,f=new f,n=l.apply(f,n),n instanceof Object?n:f}var kt=n=>n%4===0&&(n%100!==0||n%400===0),No=[0,31,60,91,121,152,182,213,244,274,305,335],Ho=[0,31,59,90,120,151,181,212,243,273,304,334];function Go(n,l,f,b,A,P,z){return E?ve(16,1,n,l,f,b,A,P,z):-52}function Lo(n,l,f,b,A,P){if(E)return ve(17,1,n,l,f,b,A,P)}var Fo=n=>{var l=Je(n)+1,f=Rr(l);return f&&Dt(n,f,l),f},qn=[],jo=(n,l)=>{qn.length=0;for(var f;f=o()[n++>>>0];){var b=f!=105;b&=f!=112,l+=b&&l%8?4:0,qn.push(f==112?p()[l>>>2>>>0]:f==106?he[l>>>3]:f==105?a()[l>>>2>>>0]:h()[l>>>3>>>0]),l+=b?8:4}return qn},Kn={},qo=()=>{if(!Yn){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:v||"./this.program"},l;for(l in Kn)Kn[l]===void 0?delete n[l]:n[l]=Kn[l];var f=[];for(l in n)f.push(`${l}=${n[l]}`);Yn=f}return Yn},Yn;function Ko(n,l){if(E)return ve(18,1,n,l);n>>>=0,l>>>=0;var f=0;return qo().forEach((b,A)=>{var P=l+f;for(A=p()[n+4*A>>>2>>>0]=P,P=0;P<b.length;++P)r()[A++>>>0>>>0]=b.charCodeAt(P);r()[A>>>0>>>0]=0,f+=b.length+1}),0}function Yo(n,l){if(E)return ve(19,1,n,l);n>>>=0,l>>>=0;var f=qo();p()[n>>>2>>>0]=f.length;var b=0;return f.forEach(A=>b+=A.length+1),p()[l>>>2>>>0]=b,0}function Zo(n){return E?ve(20,1,n):52}function Xo(n,l,f,b){return E?ve(21,1,n,l,f,b):52}function Jo(n,l,f,b){return E?ve(22,1,n,l,f,b):70}var Al=[null,[],[]];function Qo(n,l,f,b){if(E)return ve(23,1,n,l,f,b);l>>>=0,f>>>=0,b>>>=0;for(var A=0,P=0;P<f;P++){var z=p()[l>>>2>>>0],L=p()[l+4>>>2>>>0];l+=8;for(var Z=0;Z<L;Z++){var K=o()[z+Z>>>0],oe=Al[n];K===0||K===10?((n===1?Ee:ee)(br(oe,0)),oe.length=0):oe.push(K)}A+=L}return p()[b>>>2>>>0]=A,0}var ei=[31,29,31,30,31,30,31,31,30,31,30,31],ti=[31,28,31,30,31,30,31,31,30,31,30,31];function Il(n){var l=Array(Je(n)+1);return xr(n,l,0,l.length),l}var Tl=(n,l)=>{r().set(n,l>>>0)};function ri(n,l,f,b){function A(R,le,Ie){for(R=typeof R=="number"?R.toString():R||"";R.length<le;)R=Ie[0]+R;return R}function P(R,le){return A(R,le,"0")}function z(R,le){function Ie(gi){return 0>gi?-1:0<gi?1:0}var qt;return(qt=Ie(R.getFullYear()-le.getFullYear()))===0&&(qt=Ie(R.getMonth()-le.getMonth()))===0&&(qt=Ie(R.getDate()-le.getDate())),qt}function L(R){switch(R.getDay()){case 0:return new Date(R.getFullYear()-1,11,29);case 1:return R;case 2:return new Date(R.getFullYear(),0,3);case 3:return new Date(R.getFullYear(),0,2);case 4:return new Date(R.getFullYear(),0,1);case 5:return new Date(R.getFullYear()-1,11,31);case 6:return new Date(R.getFullYear()-1,11,30)}}function Z(R){var le=R.Ab;for(R=new Date(new Date(R.Bb+1900,0,1).getTime());0<le;){var Ie=R.getMonth(),qt=(kt(R.getFullYear())?ei:ti)[Ie];if(le>qt-R.getDate())le-=qt-R.getDate()+1,R.setDate(1),11>Ie?R.setMonth(Ie+1):(R.setMonth(0),R.setFullYear(R.getFullYear()+1));else{R.setDate(R.getDate()+le);break}}return Ie=new Date(R.getFullYear()+1,0,4),le=L(new Date(R.getFullYear(),0,4)),Ie=L(Ie),0>=z(le,R)?0>=z(Ie,R)?R.getFullYear()+1:R.getFullYear():R.getFullYear()-1}n>>>=0,l>>>=0,f>>>=0,b>>>=0;var K=p()[b+40>>>2>>>0];b={lc:a()[b>>>2>>>0],kc:a()[b+4>>>2>>>0],Gb:a()[b+8>>>2>>>0],Lb:a()[b+12>>>2>>>0],Hb:a()[b+16>>>2>>>0],Bb:a()[b+20>>>2>>>0],vb:a()[b+24>>>2>>>0],Ab:a()[b+28>>>2>>>0],tc:a()[b+32>>>2>>>0],jc:a()[b+36>>>2>>>0],mc:K?Oe(K):""},f=Oe(f),K={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var oe in K)f=f.replace(new RegExp(oe,"g"),K[oe]);var ge="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Se="January February March April May June July August September October November December".split(" ");K={"%a":R=>ge[R.vb].substring(0,3),"%A":R=>ge[R.vb],"%b":R=>Se[R.Hb].substring(0,3),"%B":R=>Se[R.Hb],"%C":R=>P((R.Bb+1900)/100|0,2),"%d":R=>P(R.Lb,2),"%e":R=>A(R.Lb,2," "),"%g":R=>Z(R).toString().substring(2),"%G":R=>Z(R),"%H":R=>P(R.Gb,2),"%I":R=>(R=R.Gb,R==0?R=12:12<R&&(R-=12),P(R,2)),"%j":R=>{for(var le=0,Ie=0;Ie<=R.Hb-1;le+=(kt(R.Bb+1900)?ei:ti)[Ie++]);return P(R.Lb+le,3)},"%m":R=>P(R.Hb+1,2),"%M":R=>P(R.kc,2),"%n":()=>`\n`,"%p":R=>0<=R.Gb&&12>R.Gb?"AM":"PM","%S":R=>P(R.lc,2),"%t":()=>"\t","%u":R=>R.vb||7,"%U":R=>P(Math.floor((R.Ab+7-R.vb)/7),2),"%V":R=>{var le=Math.floor((R.Ab+7-(R.vb+6)%7)/7);if(2>=(R.vb+371-R.Ab-2)%7&&le++,le)le==53&&(Ie=(R.vb+371-R.Ab)%7,Ie==4||Ie==3&&kt(R.Bb)||(le=1));else{le=52;var Ie=(R.vb+7-R.Ab-1)%7;(Ie==4||Ie==5&&kt(R.Bb%400-1))&&le++}return P(le,2)},"%w":R=>R.vb,"%W":R=>P(Math.floor((R.Ab+7-(R.vb+6)%7)/7),2),"%y":R=>(R.Bb+1900).toString().substring(2),"%Y":R=>R.Bb+1900,"%z":R=>{R=R.jc;var le=0<=R;return R=Math.abs(R)/60,(le?"+":"-")+("0000"+(R/60*100+R%60)).slice(-4)},"%Z":R=>R.mc,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(oe in K)f.includes(oe)&&(f=f.replace(new RegExp(oe,"g"),K[oe](b)));return f=f.replace(/\\0\\0/g,"%"),oe=Il(f),oe.length>l?0:(Tl(oe,n),oe.length-1)}me.Ib();for(var ni=Array(256),cn=0;256>cn;++cn)ni[cn]=String.fromCharCode(cn);Tr=ni,Qe=d.BindingError=class extends Error{constructor(n){super(n),this.name="BindingError"}},d.InternalError=class extends Error{constructor(n){super(n),this.name="InternalError"}},Object.assign(or.prototype,{get(n){return this.wb[n]},has(n){return this.wb[n]!==void 0},Kb(n){var l=this.Nb.pop()||this.wb.length;return this.wb[l]=n,l},Mb(n){this.wb[n]=void 0,this.Nb.push(n)}}),et.wb.push({value:void 0},{value:null},{value:!0},{value:!1}),et.Db=et.wb.length,d.count_emval_handles=()=>{for(var n=0,l=et.Db;l<et.wb.length;++l)et.wb[l]!==void 0&&++n;return n};var El=[it,Fr,Sr,qr,mt,Cr,Ar,Kr,tr,Yr,Zr,Xr,Jr,Ir,Gt,Qr,Go,Lo,Ko,Yo,Zo,Xo,Jo,Qo],Pl={ua:function(n,l,f){return q(async()=>{await d.ac(n,l,f)})},b:function(n,l,f){throw n>>>=0,new Ln(n).Ib(l>>>0,f>>>0),jr=n,_r++,jr},fa:function(n){ai(n>>>0,!C,1,!T,131072,!1),me.Tb()},D:function(n){n>>>=0,E?postMessage({cmd:"cleanupThread",thread:n}):me.Rb(me.pb[n])},X:Ht,z:qr,la:mt,T:Cr,V:Ar,ma:Kr,ja:tr,ca:Yr,ia:Zr,H:Xr,U:Jr,R:Ir,ka:Gt,S:Qr,K:function(n,l,f,b,A){n>>>=0,l>>>=0,f>>>=0,l=lt(l);var P=l.indexOf("u")!=-1;P&&(A=(1n<<64n)-1n),pt(n,{name:l,fromWireType:z=>z,toWireType:function(z,L){if(typeof L!="bigint"&&typeof L!="number")throw new TypeError(`Cannot convert "${rr(L)}" to ${this.name}`);if(L<b||L>A)throw new TypeError(`Passing a number "${rr(L)}" from JS side to C/C++ side to an argument of type "${l}", which is outside the valid range [${b}, ${A}]!`);return L},argPackAdvance:8,readValueFromPointer:Pr(l,f,!P),Cb:null})},sa:function(n,l,f,b){n>>>=0,l=lt(l>>>0),pt(n,{name:l,fromWireType:function(A){return!!A},toWireType:function(A,P){return P?f:b},argPackAdvance:8,readValueFromPointer:function(A){return this.fromWireType(o()[A>>>0])},Cb:null})},ra:function(n,l){n>>>=0,l=lt(l>>>0),pt(n,{name:l,fromWireType:f=>{var b=Ke(f);return Lt(f),b},toWireType:(f,b)=>tt(b),argPackAdvance:8,readValueFromPointer:tn,Cb:null})},J:function(n,l,f){n>>>=0,f>>>=0,l=lt(l>>>0),pt(n,{name:l,fromWireType:b=>b,toWireType:(b,A)=>A,argPackAdvance:8,readValueFromPointer:rn(l,f),Cb:null})},v:function(n,l,f,b,A){if(n>>>=0,f>>>=0,l=lt(l>>>0),A===-1&&(A=4294967295),A=L=>L,b===0){var P=32-8*f;A=L=>L<<P>>>P}var z=l.includes("unsigned")?function(L,Z){return Z>>>0}:function(L,Z){return Z};pt(n,{name:l,fromWireType:A,toWireType:z,argPackAdvance:8,readValueFromPointer:Pr(l,f,b!==0),Cb:null})},o:function(n,l,f){function b(P){var z=p()[P>>>2>>>0];return P=p()[P+4>>>2>>>0],new A(r().buffer,P,z)}n>>>=0;var A=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][l];f=lt(f>>>0),pt(n,{name:f,fromWireType:b,argPackAdvance:8,readValueFromPointer:b},{Yb:!0})},L:function(n,l){n>>>=0,l=lt(l>>>0);var f=l==="std::string";pt(n,{name:l,fromWireType:function(b){var A=p()[b>>>2>>>0],P=b+4;if(f)for(var z=P,L=0;L<=A;++L){var Z=P+L;if(L==A||o()[Z>>>0]==0){if(z=Oe(z,Z-z),K===void 0)var K=z;else K+=String.fromCharCode(0),K+=z;z=Z+1}}else{for(K=Array(A),L=0;L<A;++L)K[L]=String.fromCharCode(o()[P+L>>>0]);K=K.join("")}return wt(b),K},toWireType:function(b,A){A instanceof ArrayBuffer&&(A=new Uint8Array(A));var P=typeof A=="string";if(!(P||A instanceof Uint8Array||A instanceof Uint8ClampedArray||A instanceof Int8Array))throw new Qe("Cannot pass non-string to std::string");var z=f&&P?Je(A):A.length,L=Rr(4+z+1),Z=L+4;if(p()[L>>>2>>>0]=z,f&&P)Dt(A,Z,z+1);else if(P)for(P=0;P<z;++P){var K=A.charCodeAt(P);if(255<K)throw wt(Z),new Qe("String has UTF-16 code units that do not fit in 8 bits");o()[Z+P>>>0]=K}else for(P=0;P<z;++P)o()[Z+P>>>0]=A[P];return b!==null&&b.push(wt,L),L},argPackAdvance:8,readValueFromPointer:nn,Cb(b){wt(b)}})},B:function(n,l,f){if(n>>>=0,l>>>=0,f>>>=0,f=lt(f),l===2)var b=an,A=sn,P=ir,z=()=>u(),L=1;else l===4&&(b=jn,A=ue,P=un,z=()=>p(),L=2);pt(n,{name:f,fromWireType:Z=>{for(var K=p()[Z>>>2>>>0],oe=z(),ge,Se=Z+4,R=0;R<=K;++R){var le=Z+4+R*l;(R==K||oe[le>>>L]==0)&&(Se=b(Se,le-Se),ge===void 0?ge=Se:(ge+=String.fromCharCode(0),ge+=Se),Se=le+l)}return wt(Z),ge},toWireType:(Z,K)=>{if(typeof K!="string")throw new Qe(`Cannot pass non-string to C++ string type ${f}`);var oe=P(K),ge=Rr(4+oe+l);return p()[ge>>>2]=oe>>L,A(K,ge+4,oe+l),Z!==null&&Z.push(wt,ge),ge},argPackAdvance:8,readValueFromPointer:tn,Cb(Z){wt(Z)}})},ta:function(n,l){n>>>=0,l=lt(l>>>0),pt(n,{Zb:!0,name:l,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},qa:()=>1,P:function(n,l){n>>>=0,n==l>>>0?setTimeout(()=>Ft()):E?postMessage({targetThread:n,cmd:"checkMailbox"}):(n=me.pb[n])&&n.postMessage({cmd:"checkMailbox"})},Y:function(n,l,f,b){l>>>=0,f/=2,ar.length=f,b=b>>>0>>>3;for(var A=0;A<f;A++)ar[A]=he[b+2*A]?he[b+2*A+1]:h()[b+2*A+1>>>0];return n=0>n?Nt[-n-1]:El[n],me.Wb=l,l=n.apply(null,ar),me.Wb=0,l},ea:at,pa:function(n){S&&me.pb[n>>>0].ref()},t:function(n,l,f){return l>>>=0,f>>>=0,n=Ke(n>>>0),l=sr(l,"emval::as"),Or(l,f,n)},y:function(n){return n>>>=0,q(()=>(n=Ke(n),n.then(tt)))},p:function(n,l,f,b){return f>>>=0,b>>>=0,n=j[n>>>0],l=Ke(l>>>0),n(null,l,f,b)},k:function(n,l,f,b,A){return f>>>=0,b>>>=0,A>>>=0,n=j[n>>>0],l=Ke(l>>>0),f=fe(f),n(l,l[f],b,A)},c:Lt,C:function(n,l){return l>>>=0,n=Ke(n>>>0),l=Ke(l),n==l},n:function(n){return n>>>=0,n===0?tt($e()):(n=fe(n),tt($e()[n]))},j:function(n,l,f){l=ae(n,l>>>0);var b=l.shift();n--;var A=`return function (obj, func, destructorsRef, args) {\n`,P=0,z=[];f===0&&z.push("obj");for(var L=["retType"],Z=[b],K=0;K<n;++K)z.push("arg"+K),L.push("argType"+K),Z.push(l[K]),A+=`  var arg${K} = argType${K}.readValueFromPointer(args${P?"+"+P:""});\n`,P+=l[K].argPackAdvance;for(A+=`  var rv = ${f===1?"new func":"func.call"}(${z.join(", ")});\n`,K=0;K<n;++K)l[K].deleteObject&&(A+=`  argType${K}.deleteObject(arg${K});\n`);return b.Zb||(L.push("emval_returnValue"),Z.push(Or),A+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),L.push(A+`};\n`),n=Ot(L).apply(null,Z),f=`methodCaller<(${l.map(oe=>oe.name).join(", ")}) => ${b.name}>`,k(Ae(f,n))},s:function(n,l){return l>>>=0,n=Ke(n>>>0),l=Ke(l),tt(n[l])},e:function(n){n>>>=0,4<n&&(et.get(n).Qb+=1)},w:function(){return tt([])},m:function(n){n=Ke(n>>>0);for(var l=Array(n.length),f=0;f<n.length;f++)l[f]=n[f];return tt(l)},f:function(n){return tt(fe(n>>>0))},l:function(){return tt({})},i:function(n){n>>>=0;for(var l=Ke(n);l.length;){var f=l.pop();l.pop()(f)}Lt(n)},h:function(n,l,f){l>>>=0,f>>>=0,n=Ke(n>>>0),l=Ke(l),f=Ke(f),n[l]=f},d:function(n,l){return l>>>=0,n=sr(n>>>0,"_emval_take_value"),n=n.readValueFromPointer(l),tt(n)},$:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getUTCSeconds(),a()[l+4>>>2>>>0]=n.getUTCMinutes(),a()[l+8>>>2>>>0]=n.getUTCHours(),a()[l+12>>>2>>>0]=n.getUTCDate(),a()[l+16>>>2>>>0]=n.getUTCMonth(),a()[l+20>>>2>>>0]=n.getUTCFullYear()-1900,a()[l+24>>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[l+28>>>2>>>0]=n},aa:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getSeconds(),a()[l+4>>>2>>>0]=n.getMinutes(),a()[l+8>>>2>>>0]=n.getHours(),a()[l+12>>>2>>>0]=n.getDate(),a()[l+16>>>2>>>0]=n.getMonth(),a()[l+20>>>2>>>0]=n.getFullYear()-1900,a()[l+24>>>2>>>0]=n.getDay();var f=(kt(n.getFullYear())?No:Ho)[n.getMonth()]+n.getDate()-1|0;a()[l+28>>>2>>>0]=f,a()[l+36>>>2>>>0]=-(60*n.getTimezoneOffset()),f=new Date(n.getFullYear(),6,1).getTimezoneOffset();var b=new Date(n.getFullYear(),0,1).getTimezoneOffset();n=(f!=b&&n.getTimezoneOffset()==Math.min(b,f))|0,a()[l+32>>>2>>>0]=n},ba:function(n){n>>>=0;var l=new Date(a()[n+20>>>2>>>0]+1900,a()[n+16>>>2>>>0],a()[n+12>>>2>>>0],a()[n+8>>>2>>>0],a()[n+4>>>2>>>0],a()[n>>>2>>>0],0),f=a()[n+32>>>2>>>0],b=l.getTimezoneOffset(),A=new Date(l.getFullYear(),6,1).getTimezoneOffset(),P=new Date(l.getFullYear(),0,1).getTimezoneOffset(),z=Math.min(P,A);return 0>f?a()[n+32>>>2>>>0]=+(A!=P&&z==b):0<f!=(z==b)&&(A=Math.max(P,A),l.setTime(l.getTime()+6e4*((0<f?z:A)-b))),a()[n+24>>>2>>>0]=l.getDay(),f=(kt(l.getFullYear())?No:Ho)[l.getMonth()]+l.getDate()-1|0,a()[n+28>>>2>>>0]=f,a()[n>>>2>>>0]=l.getSeconds(),a()[n+4>>>2>>>0]=l.getMinutes(),a()[n+8>>>2>>>0]=l.getHours(),a()[n+12>>>2>>>0]=l.getDate(),a()[n+16>>>2>>>0]=l.getMonth(),a()[n+20>>>2>>>0]=l.getYear(),n=l.getTime(),isNaN(n)?(a()[oi()>>>2>>>0]=61,n=-1):n/=1e3,BigInt(n)},Z:Go,_:Lo,O:function(n,l,f){function b(K){return(K=K.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?K[1]:"GMT"}n>>>=0,l>>>=0,f>>>=0;var A=new Date().getFullYear(),P=new Date(A,0,1),z=new Date(A,6,1);A=P.getTimezoneOffset();var L=z.getTimezoneOffset(),Z=Math.max(A,L);p()[n>>>2>>>0]=60*Z,a()[l>>>2>>>0]=+(A!=L),n=b(P),l=b(z),n=Fo(n),l=Fo(l),L<A?(p()[f>>>2>>>0]=n,p()[f+4>>>2>>>0]=l):(p()[f>>>2>>>0]=l,p()[f+4>>>2>>>0]=n)},q:()=>{Bt("")},g:function(n,l,f){return n>>>=0,l=jo(l>>>0,f>>>0),Nt[n].apply(null,l)},M:function(n,l,f){return n>>>=0,l=jo(l>>>0,f>>>0),Nt[n].apply(null,l)},E:()=>{},I:()=>Date.now(),oa:()=>{throw qe+=1,"unwind"},Q:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>S?(xi(),ur(Si)).cpus().length:navigator.hardwareConcurrency,N:function(n){n>>>=0;var l=o().length;if(n<=l||4294901760<n)return!1;for(var f=1;4>=f;f*=2){var b=l*(1+.2/f);b=Math.min(b,n+100663296);var A=Math;b=Math.max(n,b);e:{A=(A.min.call(A,4294901760,b+(65536-b%65536)%65536)-be.buffer.byteLength+65535)/65536;try{be.grow(A),ke();var P=1;break e}catch{}P=void 0}if(P)return!0}return!1},ga:Ko,ha:Yo,W:Qt,A:Zo,G:Xo,da:Jo,F:Qo,a:be||d.wasmMemory,na:ri,r:function(n,l,f,b){return ri(n>>>0,l>>>0,f>>>0,b>>>0)}},re=function(){function n(f,b){return re=f.exports,re=ln(),re=Ol(),me.Ub.push(re.bb),Tt.unshift(re.va),Me=b,mr(),re}var l={a:Pl};if(Rt++,d.instantiateWasm)try{return d.instantiateWasm(l,n)}catch(f){ee(`Module.instantiateWasm callback failed with error: ${f}`),w(f)}return hr(l,function(f){n(f.instance,f.module)}).catch(w),{}}();d._OrtInit=(n,l)=>(d._OrtInit=re.wa)(n,l),d._OrtGetLastError=(n,l)=>(d._OrtGetLastError=re.xa)(n,l),d._OrtCreateSessionOptions=(n,l,f,b,A,P,z,L,Z,K)=>(d._OrtCreateSessionOptions=re.ya)(n,l,f,b,A,P,z,L,Z,K),d._OrtAppendExecutionProvider=(n,l)=>(d._OrtAppendExecutionProvider=re.za)(n,l),d._OrtAddFreeDimensionOverride=(n,l,f)=>(d._OrtAddFreeDimensionOverride=re.Aa)(n,l,f),d._OrtAddSessionConfigEntry=(n,l,f)=>(d._OrtAddSessionConfigEntry=re.Ba)(n,l,f),d._OrtReleaseSessionOptions=n=>(d._OrtReleaseSessionOptions=re.Ca)(n),d._OrtCreateSession=(n,l,f)=>(d._OrtCreateSession=re.Da)(n,l,f),d._OrtReleaseSession=n=>(d._OrtReleaseSession=re.Ea)(n),d._OrtGetInputOutputCount=(n,l,f)=>(d._OrtGetInputOutputCount=re.Fa)(n,l,f),d._OrtGetInputName=(n,l)=>(d._OrtGetInputName=re.Ga)(n,l),d._OrtGetOutputName=(n,l)=>(d._OrtGetOutputName=re.Ha)(n,l),d._OrtFree=n=>(d._OrtFree=re.Ia)(n),d._OrtCreateTensor=(n,l,f,b,A,P)=>(d._OrtCreateTensor=re.Ja)(n,l,f,b,A,P),d._OrtGetTensorData=(n,l,f,b,A)=>(d._OrtGetTensorData=re.Ka)(n,l,f,b,A),d._OrtReleaseTensor=n=>(d._OrtReleaseTensor=re.La)(n),d._OrtCreateRunOptions=(n,l,f,b)=>(d._OrtCreateRunOptions=re.Ma)(n,l,f,b),d._OrtAddRunConfigEntry=(n,l,f)=>(d._OrtAddRunConfigEntry=re.Na)(n,l,f),d._OrtReleaseRunOptions=n=>(d._OrtReleaseRunOptions=re.Oa)(n),d._OrtCreateBinding=n=>(d._OrtCreateBinding=re.Pa)(n),d._OrtBindInput=(n,l,f)=>(d._OrtBindInput=re.Qa)(n,l,f),d._OrtBindOutput=(n,l,f,b)=>(d._OrtBindOutput=re.Ra)(n,l,f,b),d._OrtClearBoundOutputs=n=>(d._OrtClearBoundOutputs=re.Sa)(n),d._OrtReleaseBinding=n=>(d._OrtReleaseBinding=re.Ta)(n),d._OrtRunWithBinding=(n,l,f,b,A)=>(d._OrtRunWithBinding=re.Ua)(n,l,f,b,A),d._OrtRun=(n,l,f,b,A,P,z,L)=>(d._OrtRun=re.Va)(n,l,f,b,A,P,z,L),d._OrtEndProfiling=n=>(d._OrtEndProfiling=re.Wa)(n),d._JsepOutput=(n,l,f)=>(d._JsepOutput=re.Xa)(n,l,f),d._JsepGetNodeName=n=>(d._JsepGetNodeName=re.Ya)(n);var oi=()=>(oi=re.Za)(),pn=d._pthread_self=()=>(pn=d._pthread_self=re._a)(),Rr=d._malloc=n=>(Rr=d._malloc=re.$a)(n),wt=d._free=n=>(wt=d._free=re.ab)(n);d.__emscripten_tls_init=()=>(d.__emscripten_tls_init=re.bb)();var ii=n=>(ii=re.cb)(n);d.__embind_initialize_bindings=()=>(d.__embind_initialize_bindings=re.db)();var ai=d.__emscripten_thread_init=(n,l,f,b,A,P)=>(ai=d.__emscripten_thread_init=re.fb)(n,l,f,b,A,P);d.__emscripten_thread_crashed=()=>(d.__emscripten_thread_crashed=re.gb)();var si=(n,l,f,b)=>(si=re.hb)(n,l,f,b),Zn=n=>(Zn=re.ib)(n),Xn=d.__emscripten_thread_exit=n=>(Xn=d.__emscripten_thread_exit=re.jb)(n),ui=()=>(ui=re.kb)(),li=(n,l)=>(li=re.lb)(n,l),Jn=()=>(Jn=re.mb)(),mn=n=>(mn=re.nb)(n),Qn=n=>(Qn=re.ob)(n),di=d.dynCall_ii=(n,l)=>(di=d.dynCall_ii=re.qb)(n,l),ci=n=>(ci=re.rb)(n),pi=()=>(pi=re.sb)(),mi=n=>(mi=re.tb)(n),fi=()=>(fi=re.ub)();d.___start_em_js=958871,d.___stop_em_js=959032;function Ol(){var n=re;n=Object.assign({},n);var l=b=>()=>b()>>>0,f=b=>A=>b(A)>>>0;return n.Za=l(n.Za),n._a=l(n._a),n.$a=f(n.$a),n.cb=f(n.cb),n.emscripten_main_runtime_thread_id=l(n.emscripten_main_runtime_thread_id),n.mb=l(n.mb),n.ob=f(n.ob),n}d.wasmMemory=be,d.stackAlloc=Qn,d.stackSave=Jn,d.stackRestore=mn,d.keepRuntimeAlive=()=>0<qe,d.UTF8ToString=Oe,d.stringToUTF8=Dt,d.lengthBytesUTF8=Je,d.ExitStatus=gr,d.PThread=me;var fn;Wt=function n(){fn||hi(),fn||(Wt=n)};function hi(){if(!(0<Rt))if(E)y(d),E||er(Tt),startWorker(d);else{if(d.preRun)for(typeof d.preRun=="function"&&(d.preRun=[d.preRun]);d.preRun.length;)It.unshift(d.preRun.shift());er(It),0<Rt||fn||(fn=!0,d.calledRun=!0,pe||(E||er(Tt),y(d),E||er(Vt)))}}return hi(),t.ready}})();typeof Ai=="object"&&typeof ao=="object"?ao.exports=Ci:typeof define=="function"&&define.amd&&define([],()=>Ci)});var Ti=Br((Vp,Wl)=>{Wl.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\\n\'});var lo,st,Mr,yn,zr,Bi,co,Ve=Q(()=>{"use strict";lo=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},st=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Mr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],yn=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},zr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Bi=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",co=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var bn=Q(()=>{"use strict"});var Mi=Q(()=>{"use strict";bn()});var zi,Ui=Q(()=>{"use strict";zi="1.17.0-dev.20240116-80f274ca6f"});var Vi,Kt,po=Q(()=>{"use strict";Ui();Vi="warning",Kt={wasm:{},webgl:{},webgpu:{},versions:{common:zi},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Vi=e}},get logLevel(){return Vi}};Object.defineProperty(Kt,"logLevel",{enumerable:!0})});var lr,Wi=Q(()=>{"use strict";po();lr=Kt});var Ni=Q(()=>{"use strict"});var Hi=Q(()=>{"use strict";wn()});var Li=Q(()=>{"use strict"});var Fi=Q(()=>{"use strict";wn()});var wn=Q(()=>{"use strict";Ni();Hi();Li();Fi()});var vn=Q(()=>{"use strict";wn()});var mo,ji,Yt,Zt,fo=Q(()=>{"use strict";po();mo=(e,t)=>{Kt.wasm.trace&&console.timeStamp(`${e}::ORT::${t}`)},ji=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],o=!1;for(let i=0;i<r.length;i++){if(o&&!r[i].includes("TRACE_FUNC")){let u=`FUNC_${e}::${r[i].trim().split(" ")[1]}`;t&&(u+=`::${t}`),mo("CPU",u);return}r[i].includes("TRACE_FUNC")&&(o=!0)}},Yt=e=>{Kt.wasm.trace&&ji("BEGIN",e)},Zt=e=>{Kt.wasm.trace&&ji("END",e)}});var qi=Q(()=>{"use strict";bn();vn();fo()});var Ki=Q(()=>{"use strict";qi()});var Yi=Q(()=>{"use strict"});var Zi=Q(()=>{"use strict";bn();vn()});var Xi=Q(()=>{"use strict";Zi()});var dr=Q(()=>{"use strict";Mi();Wi();Ki();vn();fo();Yi();Xi()});var Xl,Jl,Ji,Qi,ea,Ql,De,zt=Q(()=>{"use strict";Ve();Xl=["V","I","W","E","F"],Jl=(e,t)=>{console.log(`[${Xl[e]},${new Date().toISOString()}]${t}`)},ea=(e,t)=>{Ji=e,Qi=t},Ql=(e,t)=>{let r=zr(e),o=zr(Ji);r>=o&&Jl(r,typeof t=="function"?t():t)},De=(...e)=>{Qi&&Ql(...e)}});var ta,ra=Q(()=>{"use strict";Ve();ta=(e,t)=>new(yn(t))(e)});var $n=Q(()=>{"use strict"});var _n,ed,na,go,ho,ia,aa=Q(()=>{"use strict";zt();$n();_n=e=>Math.ceil(e/16)*16,ed=1,na=()=>ed++,go=async(e,t,r,o)=>{let i=_n(r),u=e.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,u,0,i),e.flush(),await u.mapAsync(GPUMapMode.READ);let p=u.getMappedRange();if(o){let m=o();return m.set(new Uint8Array(p,0,r)),m}else return new Uint8Array(p.slice(0,r))}finally{u.destroy()}},ho=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,i=r.byteOffset,u=r.byteLength,a=_n(u),p=this.storageCache.get(t);if(!p)throw new Error("gpu data for uploading does not exist");if(p.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${p.originalSize}, data size=${u}`);let m=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),h=m.getMappedRange();new Uint8Array(h).set(new Uint8Array(o,i,u)),m.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(m,0,p.gpuData.buffer,0,a),De("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(m)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(r);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let u=_n(o.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(o.gpuData.buffer,0,i.gpuData.buffer,0,u)}registerExternalBuffer(t,r,o){let i;if(o){if(i=this.externalBuffers.get(o),i===void 0)throw new Error("previous buffer is not registered");if(t===o)return De("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, buffer is the same, skip.`),i;this.externalBuffers.delete(o)}else i=na();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,i),De("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, registered.`),i}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),De("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=_n(t),i,u=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(u||a){let m=u?this.freeBuffers:this.freeUniformBuffers,h=m.get(o);h||(h=[],m.set(o,h)),h.length>0?i=h.pop():i=this.backend.device.createBuffer({size:o,usage:r})}else i=this.backend.device.createBuffer({size:o,usage:r});let p={id:na(),type:0,buffer:i};return this.storageCache.set(p.id,{gpuData:p,originalSize:t}),De("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${p.id}`),p}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return De("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await go(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},ia=(...e)=>new ho(...e)});var yo,xe,Ye=Q(()=>{"use strict";yo=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},xe=e=>new yo(e)});var bo,vt,W,Xt,Sn,xn,Cn,Ce=Q(()=>{"use strict";bo=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},vt=class{static calcShape(t,r,o=!1){let i=t.length,u=r.length;if(i===0)return r;if(u===0)return t;let a=Math.max(t.length,r.length),p=new Array(a);if(o){if(i<2||u<2)return;let m=bo.calcMatMulShape([t[i-2],t[i-1]],[r[u-2],r[u-1]]);if(m===void 0)return;[p[a-2],p[a-1]]=m}for(let m=o?3:1;m<=a;m++){let h=i-m<0?1:t[i-m],d=u-m<0?1:r[u-m];if(h!==d&&h>1&&d>1)return;p[a-m]=Math.max(h,d)}return p}static isValidBroadcast(t,r){let o=t.length,i=r.length;if(o>i)return!1;for(let u=1;u<=o;u++)if(t[o-u]!==1&&t[o-u]!==r[i-u])return!1;return!0}},W=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let i=1;for(let u=r;u<o;u++){if(t[u]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=t[u]}return i}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let i=r-3;i>=0;--i)o[i]=o[i+1]*t[i+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((i,u)=>i+r[u]+r[u+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,i)=>o===r[i])}},Xt=class e{static adjustPoolAttributes(t,r,o,i,u,a){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let p=0;p<r.length-2;p++)p>=o.length?o.push(r[p+2]):o[p]=r[p+2];for(let p=0;p<o.length;p++)if(p<i.length){if(i[p]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let p=0;p<o.length;p++)if(p<u.length){if(u[p]<0)throw new Error("dilations should be greater than or equal to 1")}else u.push(1);for(let p=0;p<o.length*2;p++)if(p<a.length){if(a[p]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let p=0;p<o.length;p++){if(o[p]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[p]>=o[p]||a[p+o.length]>=o[p])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,i,u,a,p){if(p){if(u.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let m=0;m<t.length-2;m++)e.adjustPadAndReturnShape(t[m+(a?1:2)],r[m],o[m],i[m],u,m,m+t.length-2,p)}}static computePoolOutputShape(t,r,o,i,u,a,p){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let m=[r[0],r[1]];return e.computeShapeHelper(t,r,m,o,i,u,a,p),m}static computeConvOutputShape(t,r,o,i,u,a,p){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let m=[t[0],r[0]];return e.computeShapeHelper(!1,t,m,o,i,u,a,p),m}static computeShapeHelper(t,r,o,i,u,a,p,m){if(t)for(let h=0;h<r.length-2;h++)o.push(1);else for(let h=0;h<r.length-2;h++)o.push(e.adjustPadAndReturnShape(r[h+2],i[h],u[h],a[h],p,h,h+r.length-2,m))}static adjustPadAndReturnShape(t,r,o,i,u,a,p,m){let h=o*(i-1)+1;if(m&&m!=="NOTSET")switch(m){case"VALID":return u[a]=0,u[p]=0,Math.floor((t-h)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let y=((t+r-1)/r-1)*r+i-t;return u[a]=Math.floor(m==="SAME_LOWER"?(y+1)/2:y/2),u[p]=y-u[a],Math.floor((t+y-i)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+u[a]+u[p]-h)/r+1)}},Sn=class{static getShapeOfGemmResult(t,r,o,i,u){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let a,p,m;r?(a=t[1],p=t[0]):(a=t[0],p=t[1]);let h=-1;if(i?(m=o[0],h=1):(m=o[1],h=0),o[h]!==p)throw new Error("dimension mismatch");if(a<=0||m<=0||p<=0)throw new Error("invalid shape specified");if(u&&!vt.isValidBroadcast(u,[a,m]))throw new Error("gemm: invalid bias shape for broadcast");return[a,m,p]}},xn=-34028234663852886e22,Cn=34028234663852886e22});var td,vo,Ne,ht,G,He,Ze,gt,ut,ce,$o,V,J,An,wo,sa,cr,_e=Q(()=>{"use strict";Ve();Ce();td=64,vo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Ne=(e,t=1)=>{let r=vo(e,t);return typeof r=="string"?r:r[0]},ht=(e,t=1)=>{let r=vo(e,t);return typeof r=="string"?r:r[1]},G=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:W.computeStrides(e)}],He=e=>e%4===0?4:e%2===0?2:1,Ze=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,gt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,ut=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,ce=(e,t,r,o)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?o==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:o==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,$o=(e,t,r,o,i)=>{let u=typeof r=="number",a=u?r:r.length,p=[...new Array(a).keys()],m=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,h=vo(t,i),d=typeof h=="string"?h:h[1],y=typeof h=="string"?h:h[0],w={indices:m,value:d,storage:y,tensor:t},_=F=>typeof F=="string"?F:`${F}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},x=u?"uniforms.":"",T=`${x}${e}_shape`,C=`${x}${e}_strides`,S="";for(let F=0;F<a-1;F++)S+=`\n    let dim${F} = current / ${ce(C,F,a)};\n    let rest${F} = current % ${ce(C,F,a)};\n    indices[${F}] = dim${F};\n    current = rest${F};\n    `;S+=`indices[${a-1}] = current;`;let E=a<2?"":`\n  fn o2i_${e}(offset: u32) -> ${w.indices} {\n    var indices: ${w.indices};\n    var current = offset;\n    ${S}\n    return indices;\n  }`,O=F=>(v.offsetToIndices=!0,a<2?F:`o2i_${e}(${F})`),U=[];if(a>=2)for(let F=a-1;F>=0;F--)U.push(`${ce(C,F,a)} * (indices[${F}])`);let M=a<2?"":`\n  fn i2o_${e}(indices: ${w.indices}) -> u32 {\n    return ${U.join("+")};\n  }`,N=F=>(v.indicesToOffset=!0,a<2?F:`i2o_${e}(${F})`),Y=(...F)=>a===0?"0u":`${w.indices}(${F.map(_).join(",")})`,se=(F,ie)=>a<2?`${F}`:`${ce(F,ie,a)}`,B=(F,ie,he)=>a<2?`${F}=${he};`:`${ce(F,ie,a)}=${he};`,te={},Pe=(F,ie)=>{v.broadcastedIndicesToOffset=!0;let he=`${ie.name}broadcastedIndicesTo${e}Offset`;if(he in te)return`${he}(${F})`;let Xe=[];for(let nt=a-1;nt>=0;nt--){let ke=ie.indicesGet("outputIndices",nt+ie.rank-a);Xe.push(`${se(C,nt)} * (${ke} % ${se(T,nt)})`)}return te[he]=`fn ${he}(outputIndices: ${ie.type.indices}) -> u32 {\n             return ${Xe.length>0?Xe.join("+"):"0u"};\n           }`,`${he}(${F})`},Ee=(F,ie)=>(()=>{if(w.storage===w.value)return`${e}[${F}]=${ie};`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`${e}[${F}]=vec2<u32>(u32(${ie}), select(0u, 0xFFFFFFFFu, ${ie} < 0));`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`${e}[${F}]=vec2<u32>(u32(${ie}), 0u);`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`${e}[${F}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ie}));`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),ee=F=>(()=>{if(w.storage===w.value)return`${e}[${F}]`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`i32(${e}[${F}].x)`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`u32(${e}[${F}].x)`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${F}] & 0xFFu), bool(${e}[${F}] & 0xFF00u), bool(${e}[${F}] & 0xFF0000u), bool(${e}[${F}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),be=a<2?"":`\n  fn get_${e}ByIndices(indices: ${w.indices}) -> ${d} {\n    return ${ee(`i2o_${e}(indices)`)};\n  }`,Me=a<2?"":(()=>{let F=p.map(he=>`d${he}: u32`).join(", "),ie=p.map(he=>`d${he}`).join(", ");return`\n  fn get_${e}(${F}) -> ${d} {\n    return get_${e}ByIndices(${Y(ie)});\n  }`})(),pe=(...F)=>{if(F.length!==a)throw new Error(`indices length must be ${a}`);let ie=F.map(_).join(",");return a===0?ee("0u"):a===1?ee(ie[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${ie})`)},ye=F=>a<2?ee(F):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${F})`),de=a<2?"":`\n  fn set_${e}ByIndices(indices: ${w.indices}, value: ${d}) {\n    ${Ee(`i2o_${e}(indices)`,"value")}\n  }`,we=a<2?"":(()=>{let F=p.map(he=>`d${he}: u32`).join(", "),ie=p.map(he=>`d${he}`).join(", ");return`\n  fn set_${e}(${F}, value: ${d}) {\n    set_${e}ByIndices(${Y(ie)}, value);\n  }`})();return{impl:()=>{let F=[],ie=!1;return v.offsetToIndices&&(F.push(E),ie=!0),v.indicesToOffset&&(F.push(M),ie=!0),v.broadcastedIndicesToOffset&&(Object.values(te).forEach(he=>F.push(he)),ie=!0),v.set&&(F.push(we),ie=!0),v.setByIndices&&(F.push(de),ie=!0),v.get&&(F.push(Me),ie=!0),v.getByIndices&&(F.push(be),ie=!0),!u&&ie&&F.unshift(`const ${T} = ${w.indices}(${r.join(",")});`,`const ${C} = ${w.indices}(${W.computeStrides(r).join(",")});`),F.join(`\n`)},type:w,offsetToIndices:O,indicesToOffset:N,broadcastedIndicesToOffset:Pe,indices:Y,indicesGet:se,indicesSet:B,set:(...F)=>{if(F.length!==a+1)throw new Error(`indices length must be ${a}`);let ie=F[a];if(typeof ie!="string")throw new Error("value must be string");let he=F.slice(0,a).map(_).join(",");return a===0?Ee("0u",ie):a===1?Ee(he[0],ie):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${he}, ${ie})`)},setByOffset:Ee,setByIndices:(F,ie)=>a<2?Ee(F,ie):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${F}, ${ie});`),get:pe,getByOffset:ee,getByIndices:ye,usage:o,name:e,strides:C,shape:T,rank:a}},V=(e,t,r,o=1)=>$o(e,t,r,"input",o),J=(e,t,r,o=1)=>$o(e,t,r,"output",o),An=(e,t,r,o=1)=>$o(e,t,r,"internal",o),wo=class{constructor(t){this.normalizedDispatchGroup=t;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=td){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],i=typeof t=="number"?1:t[2],u=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=u?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,p=u?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*i}u + local_idx;`;return`@compute @workgroup_size(${r}, ${o}, ${i})\n  fn main(${a}) {\n    ${p}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",i=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${i}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:i}of this.uniforms)if(i&&i>4)o==="f16"?t.push(`@align(16) ${r}:array<mat2x4<${o}>, ${Math.ceil(i/8)}>`):t.push(`${r}:array<vec4<${o}>, ${Math.ceil(i/4)}>`);else{let u=i==null||i===1?o:`vec${i}<${o}>`;t.push(`${r}:${u}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}},sa=e=>new wo(e),cr=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;i++){let u=r-1-i,a=e[u]||1;(t[t.length-1-i]||1)>1&&a===1&&o.unshift(u)}return o}});var rd,ua,nd,od,yt,la,da,pr=Q(()=>{"use strict";Ce();Ye();_e();rd=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ua=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,nd=(e,t)=>W.sortBasedOnPerm(e,ua(e.length,t)),od=(e,t,r,o)=>{let i=[];i.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)i.push(r.indicesSet("a",e[u],`i[${u}]`));return i.push("return a;}"),i.join(`\n`)},yt=(e,t)=>{let r=e.dataType,o=e.dims.length,i=ua(o,t),u=nd(e.dims,i),a=J("output",r,u.length),p=V("a",r,o),m=h=>`\n  ${h.registerUniform("output_size","u32").declareVariables(p,a)}\n\n  ${od(i,o,p,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${a.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${a.setByOffset("global_idx",p.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:h=>{let d=W.size(u);return{outputs:[{dims:u,dataType:h[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:"uint32",data:d},...G(h[0].dims),...G(u)]}},getShaderSource:m}},la=(e,t)=>{rd(e.inputs),e.compute(yt(e.inputs[0],t.perm))},da=e=>xe({perm:e.perm})});var id,ad,sd,ud,ld,dd,cd,pd,md,fd,$t,ca,pa,ma,fa,ha,ga,ya,ba,wa,va,$a=Q(()=>{"use strict";Ce();_e();In();pr();id={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},ad={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},sd={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},ud={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},ld=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},dd=(e,t)=>{let r=[],o=e.length;for(let u=0;u<o;u++)t.indexOf(u)===-1&&r.push(e[u]);let i=t.map(u=>e[u]);return[r,i]},cd=(e,t)=>{let r=e.length+t.length,o=[],i=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?o.push(e[i++]):o.push(1);return o},pd=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},md=(e,t)=>{let r=[];if(!pd(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},fd=(e,t,r,o,i,u,a)=>{let p=r[0].dims,m=W.size(u),h=W.size(a),d=V("_A",r[0].dataType,p),y=J("output",i,u),w=32,_=`\n          var<workgroup> aBestValues : array<${y.type.storage}, ${w}>;\n       `;return{name:e,shaderCache:t,getShaderSource:x=>`\n        ${x.registerUniform("reduceSize","u32").declareVariables(d,y)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${x.mainStart(w)}\n\n          let outputIndex = global_idx / ${w};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${y.type.storage}(${sd[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${w}) {\n           let candidate = ${y.type.storage}(${d.getByOffset("offset + k")});\n           bestValue = ${id[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${w}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${ad[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${y.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${y.type.storage}(uniforms.reduceSize)`:`${ud[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:m},programUniforms:[{type:"uint32",data:h}]})}},$t=(e,t,r,o)=>{let i=e.inputs.length===1?r:_o(e.inputs,r),u=i.axes;u.length===0&&!i.noopWithEmptyAxes&&(u=e.inputs[0].dims.map((_,v)=>v));let a=W.normalizeAxes(u,e.inputs[0].dims.length),p=a,m=e.inputs[0],h=md(p,e.inputs[0].dims.length);h.length>0&&(m=e.compute(yt(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],p=ld(p.length,m.dims.length));let[d,y]=dd(m.dims,p),w=d;i.keepDims&&(w=cd(d,a)),e.compute(fd(t,{hint:i.cacheKey,inputDependencies:["type"]},[m],o,e.inputs[0].dataType,w,y),{inputs:[m]})},ca=(e,t)=>{$t(e,"ReduceMeanShared",t,"mean")},pa=(e,t)=>{$t(e,"ReduceL1Shared",t,"l1")},ma=(e,t)=>{$t(e,"ReduceL2Shared",t,"l2")},fa=(e,t)=>{$t(e,"ReduceLogSumExpShared",t,"logSumExp")},ha=(e,t)=>{$t(e,"ReduceMaxShared",t,"max")},ga=(e,t)=>{$t(e,"ReduceMinShared",t,"min")},ya=(e,t)=>{$t(e,"ReduceProdShared",t,"prod")},ba=(e,t)=>{$t(e,"ReduceSumShared",t,"sum")},wa=(e,t)=>{$t(e,"ReduceSumSquareShared",t,"sumSquare")},va=(e,t)=>{$t(e,"ReduceLogSumShared",t,"logSum")}});var _t,hd,Tn,_o,St,gd,yd,bd,wd,vd,$d,_d,Sd,xd,Cd,xt,_a,Sa,xa,Ca,Aa,Ia,Ta,Ea,Pa,Oa,In=Q(()=>{"use strict";Ce();Ye();_e();$a();_t=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},hd=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Tn=(e,t,r,o,i,u,a=!1,p=!1)=>{let m=[],h=r[0].dims,d=h.length,y=W.normalizeAxes(i,d),w=!p&&y.length===0;h.forEach((T,C)=>{w||y.indexOf(C)>=0?a&&m.push(1):m.push(T)});let _=m.length,v=W.size(m);return{name:e,shaderCache:t,getShaderSource:T=>{let C=[],S=V("_A",r[0].dataType,d),E=J("output",u,_),O=o(S,E,y),U=O[2];for(let M=0,N=0;M<d;M++)w||y.indexOf(M)>=0?(a&&N++,U=`for(var j${M}: u32 = 0; j${M} < ${h[M]}; j${M}++) {\n                  ${O[2].includes("last_index")?`let last_index = j${M};`:""}\n                  ${S.indicesSet("input_indices",M,`j${M}`)}\n                  ${U}\n                }`):(C.push(`${S.indicesSet("input_indices",M,E.indicesGet("output_indices",N))};`),N++);return`\n\n        ${T.registerUniform("output_size","u32").declareVariables(S,E)}\n\n        ${T.mainStart()}\n          ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${S.type.indices};\n          let output_indices = ${E.offsetToIndices("global_idx")};\n\n          ${C.join(`\n`)}\n          ${O[0]}       // init ops for reduce max/min\n          ${O[1]}\n          ${U}\n          ${O[3]}\n          ${O.length===4?E.setByOffset("global_idx","value"):O.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:m,dataType:u}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:[{type:"uint32",data:v},...G(h),...G(m)]})}},_o=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),xe({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},St=(e,t,r,o)=>{let i=e.inputs,u=i.length===1?r:_o(i,r);e.compute(Tn(t,{hint:u.cacheKey,inputDependencies:["rank"]},[i[0]],u.noopWithEmptyAxes&&u.axes.length===0?hd:o,u.axes,i[0].dataType,u.keepDims,u.noopWithEmptyAxes),{inputs:[0]})},gd=(e,t)=>{_t(e.inputs),St(e,"ReduceLogSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},yd=(e,t)=>{_t(e.inputs),St(e,"ReduceL1",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},bd=(e,t)=>{_t(e.inputs),St(e,"ReduceL2",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},wd=(e,t)=>{_t(e.inputs),St(e,"ReduceLogSumExp",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},vd=(e,t)=>{_t(e.inputs),St(e,"ReduceMax",t,(o,i,u)=>{let a=[];for(let p=0;p<o.rank;p++)(u.indexOf(p)>=0||u.length===0)&&a.push(o.indicesSet("input_indices",p,0));return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},$d=(e,t)=>{_t(e.inputs),St(e,"ReduceMean",t,(o,i,u)=>{let a=1;for(let p=0;p<o.rank;p++)(u.indexOf(p)>=0||u.length===0)&&(a*=e.inputs[0].dims[p]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${a});`]})},_d=(e,t)=>{_t(e.inputs),St(e,"ReduceMin",t,(o,i,u)=>{let a=[];for(let p=0;p<o.rank;p++)(u.indexOf(p)>=0||u.length===0)&&a.push(`input_indices[${p}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Sd=(e,t)=>{_t(e.inputs),St(e,"ReduceProd",t,(o,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},xd=(e,t)=>{_t(e.inputs),St(e,"ReduceSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},Cd=(e,t)=>{_t(e.inputs),St(e,"ReduceSumSquare",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},xt=(e,t,r)=>{if(t.length===0)return r;let o=1,i=1;for(let u=0;u<t.length;u++)t.indexOf(u)===-1?o*=e[u]:i*=e[u];return i<32&&o>1024},_a=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$d(e,t):ca(e,t)},Sa=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yd(e,t):pa(e,t)},xa=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bd(e,t):ma(e,t)},Ca=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wd(e,t):fa(e,t)},Aa=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vd(e,t):ha(e,t)},Ia=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_d(e,t):ga(e,t)},Ta=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sd(e,t):ya(e,t)},Ea=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xd(e,t):ba(e,t)},Pa=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cd(e,t):wa(e,t)},Oa=(e,t)=>{xt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gd(e,t):va(e,t)}});var ka,Ra,Ba,So,Da=Q(()=>{"use strict";Ve();Ye();In();ka=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Ra=(e,t)=>{ka(e.inputs);let r=(o,i,u)=>{let a=[];for(let p=0;p<o.rank;p++)(u.indexOf(p)>=0||u.length===0)&&a.push(`input_indices[${p}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Ba=(e,t)=>{ka(e.inputs);let r=(o,i,u)=>{let a=[];for(let p=0;p<o.rank;p++)(u.indexOf(p)>=0||u.length===0)&&a.push(`input_indices[${p}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},So=e=>xe(e)});var Ad,Id,Td,Ed,En,Pd,Ma,xo=Q(()=>{"use strict";Ve();$n();_e();Ad=(e,t)=>{let r=e[0],o=e[1],i=e[2],u=e[3],a=e[4],p=e[5];if(a&&p)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let m=r.dims[0],h=r.dims[1],d=r.dims[2];if(i.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let y=i.dims[0]/3,w=y,_=w;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let E of t.qkvHiddenSizes)if(E%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");y=t.qkvHiddenSizes[0],w=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let v=h;if(y!==w)throw new Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==y+w+_)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let x=0;if(a){if(w!==_)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(a.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(a.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(a.dims[1]!==m)throw new Error(\'Input "past" second dimension must be batch_size\');if(a.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(a.dims[4]!==w/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(x=a.dims[3])}let T=v+x,C=-1,S=0;if(u)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");if(p)throw new Error("relativePositionBias is not supported");return{batchSize:m,sequenceLength:h,pastSequenceLength:x,kvSequenceLength:v,totalSequenceLength:T,maxSequenceLength:C,inputHiddenSize:d,hiddenSize:y,vHiddenSize:_,headSize:Math.floor(y/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:S,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Id=(e,t,r,o)=>{let i=He(o),u=64,a=o/i;a<u?u=1:a/8<64&&(u=Math.ceil(a/8));let p=Math.ceil(o/i/u),h=[{type:st(t.dataType),data:1/o},{type:"uint32",data:a},{type:"uint32",data:p}],d=Ne(t.dataType,i),y=w=>{let _=J("x",t.dataType,t.dims,i),v="thread_max_vector";i===2?v="max(thread_max_vector.x, thread_max_vector.y)":i===4&&(v="max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))");let x=ht(t.dataType),T=[{name:"d_inv",type:x},{name:"d_comp",type:"u32"},{name:"elements_per_wg",type:"u32"}];return`\n  var<workgroup> wgMax: array<f32, ${u}>;\n  var<workgroup> wgSum: array<f32, ${u}>;\n  ${w.registerUniforms(T).declareVariables(_)}\n  ${w.mainStart([u,1,1])}\n    let localOffset = local_idx * uniforms.elements_per_wg;\n    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;\n\n    var thread_max_vector = ${Ze("f32",i,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${gt(x,i,"x[offset + i]")}, thread_max_vector);\n    }\n    wgMax[local_idx] = ${v};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${u}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${Ze("f32",i,"0")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      sumVector += exp(${gt(x,i,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_idx] = ${ut("sumVector",i)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${u}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        x[offset + i] = ${Ze(x,i,"uniforms.d_inv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        let f32input = ${gt(x,i,"x[offset + i]")};\n        x[offset + i] = ${_.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`};e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${d};${i}`},getShaderSource:y,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:h})},{inputs:[t],outputs:[]})},Td=(e,t,r,o,i,u)=>{let a=[i.batchSize,i.numHeads,i.sequenceLength,i.kvSequenceLength+i.pastSequenceLength],p=u.scale===0?1/Math.sqrt(i.headSize):u.scale,m=He(i.headSize),h=i.headSize/m,d=12,y={x:Math.ceil(i.totalSequenceLength/d),y:Math.ceil(i.sequenceLength/d),z:i.batchSize*i.numHeads},w=st(t.dataType),_=[{type:"uint32",data:i.sequenceLength},{type:"uint32",data:h},{type:"uint32",data:i.totalSequenceLength},{type:"uint32",data:i.kvSequenceLength},{type:w,data:p}],v=[t,r],x=C=>{let S=V("q",t.dataType,t.dims,m),E=V("key",r.dataType,r.dims,m),O=J("output",t.dataType,a),U=Ne(t.dataType),M=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"alpha",type:U}];return`\n  const beta: ${U} = 1.0;\n  const TILE_SIZE = ${d}u;\n\n  var<workgroup> tileQ: array<${S.type.storage}, ${d*d}>;\n  var<workgroup> tileK: array<${S.type.storage}, ${d*d}>;\n  ${C.registerUniforms(M).declareVariables(S,E,O)}\n  ${C.mainStart([d,d,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${Ze(U,m)};\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (lm < uniforms.M && ln < uniforms.N) {\n      let outputIdx = headOffset + lm * uniforms.N + ln;\n      output[outputIdx] = ${ut("value",m)} * uniforms.alpha;\n    }\n  }`},T=e.compute({name:"AttentionProbs",shaderCache:{hint:`${m}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:y,programUniforms:_}),getShaderSource:x},{inputs:v,outputs:[-1]})[0];return Id(e,T,i.batchSize*i.numHeads*i.sequenceLength,i.totalSequenceLength),T},Ed=(e,t,r,o)=>{let i=[o.batchSize,o.sequenceLength,o.vHiddenSize],u=12,a={x:Math.ceil(o.vHeadSize/u),y:Math.ceil(o.sequenceLength/u),z:o.batchSize*o.numHeads},p=[{type:"uint32",data:o.sequenceLength},{type:"uint32",data:o.totalSequenceLength},{type:"uint32",data:o.vHeadSize},{type:"uint32",data:o.numHeads},{type:"uint32",data:o.vHiddenSize}],m=h=>{let d=V("probs",t.dataType,t.dims),y=V("v",r.dataType,r.dims),w=J("output",t.dataType,i),_=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`\n  const TILE_SIZE = ${u}u;\n  var<workgroup> tileQ: array<${d.type.value}, ${u*u}>;\n  var<workgroup> tileK: array<${d.type.value}, ${u*u}>;\n  ${h.registerUniforms(_).declareVariables(d,y,w)}\n  ${h.mainStart([u,u,1])}\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${d.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return e.compute({name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType,gpuDataType:0}],dispatchGroup:a,programUniforms:p}),getShaderSource:m},{inputs:[t,r],outputs:[0]})[0]},En=(e,t,r,o,i,u,a,p,m,h,d)=>{let y=Td(e,t,r,m,h,d);Ed(e,y,o,h)},Pd=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=t.sequenceLength,i=t.inputHiddenSize,u=t.headSize,a=12,p={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},m=[e.inputs[0],e.inputs[1],e.inputs[2]],h=[{type:"uint32",data:o},{type:"uint32",data:i},{type:"uint32",data:u},{type:"uint32",data:t.numHeads},{type:"uint32",data:t.headSize},{type:"uint32",data:t.hiddenSize},{type:"uint32",data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],d=y=>{let w=J("output_q",m[0].dataType,r),_=J("output_k",m[0].dataType,r),v=J("output_v",m[0].dataType,r),x=V("input",m[0].dataType,m[0].dims),T=V("weight",m[1].dataType,m[1].dims),C=V("bias",m[2].dataType,m[2].dims),S=x.type.storage,E=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${S}, ${a*a}>;\n  var<workgroup> tileWeightQ: array<${S}, ${a*a}>;\n  var<workgroup> tileWeightK: array<${S}, ${a*a}>;\n  var<workgroup> tileWeightV: array<${S}, ${a*a}>;\n  ${y.registerUniforms(E).declareVariables(x,T,C,w,_,v)}\n  ${y.mainStart([a,a,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${S}(0);\n    var valueK = ${S}(0);\n    var valueV = ${S}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:p,programUniforms:h}),getShaderSource:d},{inputs:m,outputs:[-1,-1,-1]})},Ma=(e,t)=>{let r=Ad(e.inputs,t),[o,i,u]=Pd(e,r);return En(e,o,i,u,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var Od,kd,Rd,za,Ua=Q(()=>{"use strict";dr();Ce();Ye();_e();Od=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,i,u)=>{let a=i.length;if(a!==o.length)throw new Error(`${u}: num dimensions != ${a}`);i.forEach((p,m)=>{if(p!==o[m])throw new Error(`${u}: dim[${m}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},kd=(e,t)=>{let{epsilon:r,spatial:o,format:i}=t,u=e[0].dims,a=o?He(u[u.length-1]):1,p=i==="NHWC"&&u.length>1?a:1,m=W.size(u)/a,h=o,d=h?u.length:u,y=V("x",e[0].dataType,e[0].dims,a),w=V("scale",e[1].dataType,e[1].dims,p),_=V("bias",e[2].dataType,e[2].dims,p),v=V("inputMean",e[3].dataType,e[3].dims,p),x=V("inputVar",e[4].dataType,e[4].dims,p),T=J("y",e[0].dataType,d,a),C=()=>{let E="";if(o)E=`let cOffset = ${u.length===1?"0u":i==="NHWC"?`outputIndices[${u.length-1}] / ${a}`:"outputIndices[1]"};`;else if(i==="NCHW")E=`\n            ${T.indicesSet("outputIndices","0","0")}\n            let cOffset = ${T.indicesToOffset("outputIndices")};`;else{E=`var cIndices = ${w.type.indices}(0);\n                       cIndices[0] = outputIndices[${u.length-1}];`;for(let O=1;O<w.rank;O++)E+=`cIndices[${O}] = outputIndices[${O}];`;E+=`let cOffset = ${w.indicesToOffset("cIndices")};`}return E},S=E=>`\n  const epsilon = ${r};\n  ${E.registerUniform("outputSize","u32").declareVariables(y,w,_,v,x,T)}\n  ${E.mainStart()}\n  ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${T.offsetToIndices(`global_idx * ${a}`)};\n    ${C()}\n    let scale = ${w.getByOffset("cOffset")};\n    let bias = ${_.getByOffset("cOffset")};\n    let inputMean = ${v.getByOffset("cOffset")};\n    let inputVar = ${x.getByOffset("cOffset")};\n    let x = ${y.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${T.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${a}`,inputDependencies:h?["rank","type","type","type","type"]:void 0},getShaderSource:S,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:h?[{type:"uint32",data:m},...G(u)]:[{type:"uint32",data:m}]})}},Rd=e=>xe(e),za=(e,t)=>{let{inputs:r,outputCount:o}=e,i=Rd({...t,outputCount:o});if(lr.webgpu.validateInputContent&&Od(r,i),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(kd(r,i))}});var Bd,Dd,Va,Wa=Q(()=>{"use strict";Ce();_e();Bd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Dd=e=>{let t=e[0].dims,r=e[0].dims[2],o=W.size(t)/4,i=e[0].dataType,u=V("input",i,t,4),a=V("bias",i,[r],4),p=V("residual",i,t,4),m=J("output",i,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:d=>`\n  const channels = ${r}u / 4;\n  ${d.declareVariables(u,a,p,m)}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${u.getByOffset("global_idx")}\n      + ${a.getByOffset("global_idx % channels")} + ${p.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx","value")}\n  }`}},Va=e=>{Bd(e.inputs),e.compute(Dd(e.inputs))}});var Md,Te,Na,Ha,Ga,La,Fa,ja,qa,Ka,Ya,zd,Za,Xa,Ja,Qa,Pn,es,On,ts,rs,ns,os,is,as,ss,us,ls,ds,cs,ps,ms,fs,hs,gs,ys,bs,ws,Co=Q(()=>{"use strict";Ve();Ce();Ye();_e();Md=(e,t,r,o,i,u)=>{let a=Math.ceil(t/4),p="";typeof i=="string"?p=`${i}(a)`:p=i("a");let m=V("inputData",r,[a],4),h=J("outputData",o,[a],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(m,h)}\n\n  ${u??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${m.getByOffset("global_idx")};\n    ${h.setByOffset("global_idx",p)}\n  }`},Te=(e,t,r,o,i,u=e.dataType)=>({name:t,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:a=>Md(a,W.size(e.dims),e.dataType,u,r,o),getRunData:a=>({outputs:[{dims:e.dims,dataType:u}],dispatchGroup:{x:Math.ceil(W.size(a[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(W.size(e.dims)/4)}]})}),Na=e=>{e.compute(Te(e.inputs[0],"Abs","abs"))},Ha=e=>{e.compute(Te(e.inputs[0],"Acos","acos"))},Ga=e=>{e.compute(Te(e.inputs[0],"Acosh","acosh"))},La=e=>{e.compute(Te(e.inputs[0],"Asin","asin"))},Fa=e=>{e.compute(Te(e.inputs[0],"Asinh","asinh"))},ja=e=>{e.compute(Te(e.inputs[0],"Atan","atan"))},qa=e=>{e.compute(Te(e.inputs[0],"Atanh","atanh"))},Ka=e=>xe(e),Ya=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(Te(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},zd=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:xn,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:Cn;return xe({min:t,max:r})},Za=(e,t)=>{let r=e.inputs.length===1?t:zd(e.inputs),o=ht(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Clip",i=>`clamp(${i}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},Xa=e=>{e.compute(Te(e.inputs[0],"Ceil","ceil"))},Ja=e=>{e.compute(Te(e.inputs[0],"Cos","cos"))},Qa=e=>{e.compute(Te(e.inputs[0],"Cosh","cosh"))},Pn=e=>xe(e),es=(e,t)=>{let r=ht(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},On=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ts=e=>{let t=ht(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,On(`vec4<${t}>`,t)))},rs=e=>{e.compute(Te(e.inputs[0],"Exp","exp"))},ns=e=>{e.compute(Te(e.inputs[0],"Floor","floor"))},os=e=>{let t=ht(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,On(`vec4<${t}>`,t)))},is=(e,t)=>{let r=ht(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},as=e=>{e.compute(Te(e.inputs[0],"Not",t=>`!${t}`))},ss=e=>{e.compute(Te(e.inputs[0],"Neg",t=>`-${t}`))},us=e=>{e.compute(Te(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},ls=e=>{let t=ht(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},ds=e=>{e.compute(Te(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},cs=e=>xe(e),ps=(e,t)=>{let r=ht(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"HardSigmoid",o=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${o} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},ms=e=>{e.compute(Te(e.inputs[0],"Sin","sin"))},fs=e=>{e.compute(Te(e.inputs[0],"Sinh","sinh"))},hs=e=>{e.compute(Te(e.inputs[0],"Sqrt","sqrt"))},gs=e=>{e.compute(Te(e.inputs[0],"Tan","tan"))},ys=e=>{e.compute(Te(e.inputs[0],"Tanh",t=>`sign(${t}) * (1 - exp(-2 * abs(${t}))) / (1 + exp(-2 * abs(${t})))`))},bs=(e,t)=>{let r=ht(e.inputs[0].dataType);return e.compute(Te(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},ws=e=>{e.compute(Te(e.inputs[0],"Log","log"))}});var Vd,Wd,vs,$s=Q(()=>{"use strict";Ce();_e();Co();Vd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Wd=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=V("input",e[0].dataType,e[0].dims,4),o=V("bias",e[0].dataType,[e[0].dims[2]],4),i=J("output",e[0].dataType,t,4),u=W.size(t)/4,a=Ne(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:m=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${m.declareVariables(r,o,i)}\n\n  ${On(`vec4<${a}>`,a)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${i.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},vs=e=>{Vd(e.inputs),e.compute(Wd(e.inputs))}});var Nd,Hd,Ct,_s,Ss,xs,Cs,As,Is,Ts,Es,Ps,Os,ks=Q(()=>{"use strict";Ve();Ce();_e();Nd=(e,t,r,o,i,u,a,p,m,h,d,y)=>{let w,_;typeof p=="string"?w=_=(S,E)=>`${p}((${S}),(${E}))`:typeof p=="function"?w=_=p:(w=p.scalar,_=p.vector);let v=J("outputData",d,o.length,4),x=V("aData",m,t.length,4),T=V("bData",h,r.length,4),C;if(i)if(u){let S=W.size(t)===1,E=W.size(r)===1,O=t.length>0&&t[t.length-1]%4===0,U=r.length>0&&r[r.length-1]%4===0;S||E?C=v.setByOffset("global_idx",_(S?`${x.type.value}(${x.getByOffset("0")}.x)`:x.getByOffset("global_idx"),E?`${T.type.value}(${T.getByOffset("0")}.x)`:T.getByOffset("global_idx"))):C=`\n            let outputIndices = ${v.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${x.broadcastedIndicesToOffset("outputIndices",v)};\n            let offsetB = ${T.broadcastedIndicesToOffset("outputIndices",v)};\n            ${v.setByOffset("global_idx",_(a||O?x.getByOffset("offsetA / 4u"):`${x.type.value}(${x.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||U?T.getByOffset("offsetB / 4u"):`${T.type.value}(${T.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else C=v.setByOffset("global_idx",_(x.getByOffset("global_idx"),T.getByOffset("global_idx")));else{if(!u)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let S=(E,O,U="")=>{let M=`aData[indexA${O}][componentA${O}]`,N=`bData[indexB${O}][componentB${O}]`;return`\n            let outputIndices${O} = ${v.offsetToIndices(`global_idx * 4u + ${O}u`)};\n            let offsetA${O} = ${x.broadcastedIndicesToOffset(`outputIndices${O}`,v)};\n            let offsetB${O} = ${T.broadcastedIndicesToOffset(`outputIndices${O}`,v)};\n            let indexA${O} = offsetA${O} / 4u;\n            let indexB${O} = offsetB${O} / 4u;\n            let componentA${O} = offsetA${O} % 4u;\n            let componentB${O} = offsetB${O} % 4u;\n            ${E}[${O}] = ${U}(${w(M,N)});\n          `};d===9?C=`\n            var data = vec4<u32>(0);\n            ${S("data",0,"u32")}\n            ${S("data",1,"u32")}\n            ${S("data",2,"u32")}\n            ${S("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:C=`\n            ${S("outputData[global_idx]",0)}\n            ${S("outputData[global_idx]",1)}\n            ${S("outputData[global_idx]",2)}\n            ${S("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(x,T,v)}\n\n        ${y??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${C}\n      }`},Hd=(e,t,r,o,i,u,a=r.dataType)=>{let p=!W.areEqual(r.dims,o.dims),m=r.dims,h=W.size(r.dims),d=!1,y=!1,w=[p];if(p){let _=vt.calcShape(r.dims,o.dims,!1);if(!_)throw new Error("Can\'t perform binary op on the given tensors");m=_,h=W.size(m);let v=W.size(r.dims)===1,x=W.size(o.dims)===1,T=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,C=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;w.push(v),w.push(x),w.push(T),w.push(C);let S=1;for(let E=1;E<m.length;E++){let O=r.dims[r.dims.length-E]??1,U=o.dims[o.dims.length-E]??1;if(O===U)S*=O;else break}S%4===0?(y=!0,d=!0):(v||x||T||C)&&(d=!0)}else d=!0;return w.push(d),{name:e,shaderCache:{hint:t+w.map(_=>_.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:_=>Nd(_,r.dims,o.dims,m,d,p,y,i,r.dataType,o.dataType,a,u),getRunData:()=>({outputs:[{dims:m,dataType:a}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(W.size(m)/4)},...G(r.dims),...G(o.dims),...G(m)]})}},Ct=(e,t,r,o,i,u)=>{e.compute(Hd(t,i??"",e.inputs[0],e.inputs[1],r,o,u))},_s=e=>{Ct(e,"Add",(t,r)=>`${t}+${r}`)},Ss=e=>{Ct(e,"Div",(t,r)=>`${t}/${r}`)},xs=e=>{Ct(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Cs=e=>{Ct(e,"Mul",(t,r)=>`${t}*${r}`)},As=e=>{let t=V("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Ct(e,"Pow",{scalar:(o,i)=>`pow_custom(${o},${i})`,vector:(o,i)=>`pow_vector_custom(${o},${i})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Is=e=>{Ct(e,"Sub",(t,r)=>`${t}-${r}`)},Ts=e=>{Ct(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Es=e=>{Ct(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ps=e=>{Ct(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Os=e=>{Ct(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Ld,Fd,jd,qd,Rs,Bs,Ds=Q(()=>{"use strict";Ce();Ye();_e();Ld=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},Fd=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,jd=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;++i){let u=t.setByOffset("global_idx",e[i].getByIndices("indices"));r===1?o.push(u):i===0?o.push(`if (inputIndex == ${i}u) { ${u} }`):i===r-1?o.push(`else { ${u} }`):o.push(`else if (inputIndex == ${i}) { ${u} }`)}return o.join(`\n`)},qd=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,i=r.slice(0);for(let C=1;C<e.length;C++){let S=e[C].dims.slice();for(let E=0;E<r.length;E++)if(E===o)i[o]+=S[E];else if(r[E]!==S[E])throw new Error("non concat dimensions must match")}let u=W.size(i),a=new Array(e.length),p=new Array(e.length),m=e[0].dataType,h=0,d=[],y=[],w=[{type:"uint32",data:u}];for(let C=0;C<e.length;++C)h+=e[C].dims[o],a[C]=h,y.push(e[C].dims.length),p[C]=V(`input${C}`,m,y[C]),d.push("rank"),w.push({type:"uint32",data:a[C]});for(let C=0;C<e.length;++C)w.push(...G(e[C].dims));w.push(...G(i));let _=J("output",m,i.length),v=_.indicesGet("indices",o),x=Array.from(Array(a.length).keys()).map(C=>`uniforms.sizeInConcatAxis${C}`).join(","),T=C=>`\n\n  ${(()=>{C.registerUniform("outputSize","u32");for(let S=0;S<e.length;S++)C.registerUniform(`sizeInConcatAxis${S}`,"u32");return C.declareVariables(...p,_)})()}\n\n  ${Fd(a.length,x)}\n\n  ${C.mainStart()}\n    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${_.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${v});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${x});\n      ${v} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${jd(p,_)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:w}),getShaderSource:T}},Rs=(e,t)=>{Ld(e.inputs),e.compute(qd(e.inputs,t.axis))},Bs=e=>xe({axis:e.axis})});var At,kn,Ut=Q(()=>{"use strict";Ce();At=(e,t)=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(uniforms.clip_min), ${t}(uniforms.clip_max));`;default:return""}},kn=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[xn,Cn];return{activation:t,clipMax:o,clipMin:r}}return{activation:t}}});var je,Rn,Bn=Q(()=>{"use strict";je=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Rn=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Dn,Ao=Q(()=>{"use strict";Dn=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var Kd,Yd,Ur,Ms,Zd,Vr,Xd,Mn,Wr=Q(()=>{"use strict";Ce();_e();Ut();Bn();Kd=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Yd=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Ur=(e,t,r="f32",o,i=!1,u=32,a=!1,p=32)=>{let m=t[1]*e[1],h=t[0]*e[0],d=i?m:u,y=i?u:m,w=d/t[0],_=u/t[1];if(!((i&&w===4&&e[1]===4||!i&&(w===3||w===4))&&d%t[0]===0&&u%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${w} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${w} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${u} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${w}<${r}>, ${d/w}>, ${y}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${h/e[0]}>, ${u}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${w};\nconst tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${m};\n\n  let num_tiles = ${a?`${Math.ceil(p/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${a?`i32(globalId.z) * ${p}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Kd(i,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${w===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Yd(i,w)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Ms=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Zd=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Vr=(e,t,r="f32",o,i=!1,u=32,a=!1,p=32,m=!1)=>{let h=e[1]*t[1],d=e[0]*t[0],y=i?h:u,w=i?u:h;if(!(w%t[1]===0&&y%t[0]===0&&u%t[1]===0))throw new Error(`tileAHight ${w} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${y} must be divisible by workgroupSize[0]${t[0]}, tileInner ${u} must be divisible by workgroupSize[1]${t[1]}`);let _=w/t[1],v=y/t[0],x=u/t[1],T=m?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${h};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${w}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${t[0]}) {\n          ${Ms(i,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${h};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${v};\nlet tileRowB = i32(localId.y) * ${x};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Ms(i,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${x}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Zd(i)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${y}>, ${w}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${d}>, ${u}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${a?`${Math.ceil(p/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${a?`i32(globalId.z) * ${p}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${T}\n  }\n`},Xd=(e,t,r,o,i,u=!1)=>{let[a,p,m]=i,[h,d,y,w]=o,_=cr(a,m),v=cr(p,m),x=Ne(o[0].type.tensor),T=()=>{let E=d.rank,O=h.rank,U=`var aIndices: ${d.type.indices};`;for(let M=E-2-1,N=O-1;M>=0;M--,N--)U+=`\naIndices[${M}] = ${O>1?`batchIndices[${N}]`:"batchIndices"};`;return _.forEach(M=>{U+=`\naIndices[${M}] = 0;`}),U+=`\naIndices[${E-2}] = u32(row);\n                   aIndices[${E-1}] = u32(colIn);`,U},C=()=>{let E=y.rank,O=h.rank,U=`var bIndices: ${y.type.indices};`;for(let M=E-2-1,N=O-1;M>=0;M--,N--)U+=`\nbIndices[${M}] = ${O>1?`batchIndices[${N}]`:"batchIndices"};`;return v.forEach(M=>{U+=`\nbIndices[${M}] = 0;`}),U+=`\nbIndices[${E-2}] = u32(row);\n                   bIndices[${E-1}] = u32(colIn);`,U};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${je(e,x)} {\n      var value = ${je(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        ${T()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${je(e,x)} {\n      var value = ${je(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        ${C()}\n        value = ${y.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${je(e,x)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${u?"bias[colIn]":`${je(e,x)}(bias[row])`};`:""}\n        ${r}\n        ${w.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Mn=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,p=u.slice(0,-2),m=a.slice(0,-2),h=o?o.slice(0,-2):r.slice(0,-2),d=W.size(h),y=u[u.length-2],w=u[u.length-1],_=a[a.length-1],v=w%4===0&&_%4===0,x=y<=8?[4,1,1]:[4,4,1],T=[8,8,1],C=[Math.ceil(_/T[0]/x[0]),Math.ceil(y/T[1]/x[1]),Math.ceil(d/T[2]/x[2])],S=v?4:1,E=[...p,y,w/S],O=E.length,U=[...m,w,_/S],M=U.length,N=[d,y,_/S],Y=[{type:"int32",data:y},{type:"int32",data:_},{type:"int32",data:w}];t.activation==="Clip"&&Y.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),Y.push(...G(h),...G(E),...G(U));let se=["rank","rank"],B=e.length>2;B&&(Y.push(...G(e[2].dims)),se.push("rank")),Y.push(...G(N));let te=Pe=>{let Ee=h.length,ee=An("batchDims",e[0].dataType,Ee,1),be=Ne(e[0].dataType),Me=V("a",e[0].dataType,O,S),pe=V("b",e[1].dataType,M,S),ye=J("result",e[0].dataType,N.length,S),de=[Me,pe];if(B){let Ge=i?S:1;de.push(V("bias",e[2].dataType,e[2].dims.length,Ge))}let we=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];t.activation==="Clip"&&we.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"});let ze=At(t,ye.type.value),Re=Xd(S,B,ze,[ee,Me,pe,ye],[p,m,h],i);return`\n  ${Pe.registerUniforms(we).registerInternalVariables(ee).declareVariables(...de,ye)}\n  ${Re}\n  ${v?Ur(x,T,be,ee):Vr(x,T,be,ee)}\n                   `};return{name:"MatMul",shaderCache:{hint:`${x};${t.activation};${v};${i}`,inputDependencies:se},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:Y}),getShaderSource:te}}});var Jd,zs,Us=Q(()=>{"use strict";zt();_e();Ut();Bn();Ao();Wr();Jd=(e,t,r,o,i=!1,u,a=4,p=4,m=4,h="f32")=>{let d=B=>{switch(B){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${B} is not supported.`)}},y=B=>{switch(B){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${B} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,v=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",x=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",T=e?"row":"col",C=e?"col":"row",S=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${T} / outWidth;\n    let outCol = ${T} % outWidth;\n\n    let WRow = ${C} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${C} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${C} % inChannels;\n    var resData = ${je(a,h)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${x}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${d(a)}\n    }\n    return resData;`,E=e?t&&o?`\n    let col = colIn * ${a};\n    ${S}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${S}\n    }\n    return ${je(a,h)}(0.0);`:o&&r?`\n    let col = colIn * ${a};\n    ${S}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${S}\n    }\n    return ${je(a,h)}(0.0);`,O=`${y(p)}`,U=je(m,h),M=e?je(a,h):je(p,h),N=e?je(p,h):je(a,h),Y=At(u,U);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${M} {\n      ${e?E:O}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${N} {\n      ${e?O:E}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${U}) {\n      let col = colIn * ${m};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${_}\n      ${Rn(i)}\n      ${Y}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},zs=(e,t,r,o,i,u,a,p)=>{let m=t.format==="NHWC",h=m?e[0].dims[3]:e[0].dims[1],d=r[0],y=m?r[2]:r[3],w=m?r[1]:r[2],_=m?r[3]:r[1],v=m&&(h%4===0||h%3===0)&&_%4===0,x=m?_:y*w,T=m?y*w:_,C=[8,8,1],S=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(x/C[0]/S[0]),Math.ceil(T/C[1]/S[1]),Math.ceil(d/C[2]/S[2])];De("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${E}`);let O=v?m&&h%4!==0?3:4:1,U=C[1]*S[1],M=C[0]*S[0],N=Math.max(C[0]*O,C[1]),Y=o%U===0,se=i%M===0,B=u%N===0,te=v?[O,4,4]:[1,1,1],Pe=[{type:"int32",data:o},{type:"int32",data:i},{type:"int32",data:u},{type:"int32",data:[t.pads[0],t.pads[1]]},{type:"int32",data:t.strides},{type:"int32",data:t.dilations}];t.activation==="Clip"&&Pe.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),Pe.push(...G(e[0].dims),...G(e[1].dims));let Ee=["rank","rank"];a&&(Pe.push(...G(e[2].dims)),Ee.push("rank")),Pe.push(...G(r));let ee=be=>{let Me=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];t.activation==="Clip"&&Me.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"});let pe=v?4:1,ye=Ne(e[0].dataType),de=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${ye}>`:ye}) {\n        result[flatIndex] = ${v?`vec4<${ye}>`:ye}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${ye}>`:ye}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`,we=V("x",e[0].dataType,e[0].dims.length,O===3?1:O),ze=V("w",e[1].dataType,e[1].dims.length,pe),Re=[we,ze],Ge=J("result",e[0].dataType,r.length,pe);if(a){let F=V("bias",e[2].dataType,e[2].dims.length,pe);Re.push(F),de+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${ye}>`:ye} {\n          return bias[coords.${m?"w":"y"}${v?"/ 4":""}];\n        }`}return`\n        ${Dn("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${be.registerUniforms(Me).declareVariables(...Re,Ge)}\n        ${de}\n        ${Jd(m,Y,se,B,a,t,te[0],te[1],te[2],ye)}\n        ${v?Ur(S,C,ye,void 0,!m,N):Vr(S,C,ye,void 0,!m,N,!1,void 0,p)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${O};${v};${Y};${se};${B};${U};${M};${N}`,inputDependencies:Ee},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:Pe}),getShaderSource:ee}}});var Io,Vs=Q(()=>{"use strict";Ce();_e();Eo();Ut();Io=(e,t,r)=>{let o=e.length>2,i=o?"value += b[output_channel];":"",u=e[0].dims,a=e[1].dims,p=a[0]/t.group,m=t.format==="NHWC",h=To(u,a,t.dilations,t.pads,t.strides,m),d=W.size(h),y=[{type:"uint32",data:d},{type:"uint32",data:t.dilations},{type:"uint32",data:[t.strides[0],t.strides[1]]},{type:"uint32",data:[t.pads[0],t.pads[1]]},{type:"uint32",data:p}];t.activation==="Clip"&&y.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),y.push(...G(u),...G(a),...G(h));let w=["rank","rank"];o&&(y.push(...G(e[2].dims)),w.push("rank")),y.push(...G(h));let _=v=>{let x=J("output",e[0].dataType,h.length),T=At(t,x.type.value),C=V("x",e[0].dataType,u.length),S=V("w",e[1].dataType,a.length),E=[C,S];o&&E.push(V("b",e[2].dataType,e[2].dims));let O=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return t.activation==="Clip"&&O.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}),`\n  ${v.registerUniforms(O).declareVariables(...E,x)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${x.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${m?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${m?1:2}], outputIndices[${m?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel / uniforms.output_channels_per_group;\n\n    var value: ${x.type.value} = ${x.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[${m?1:2}]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[${m?2:3}]) {\n            continue;\n          }\n\n          let xVal = ${m?C.get("batch","xHeight","xWidth","input_channel"):C.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${S.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${i}\n    ${T}\n    ${x.setByOffset("global_idx","value")}\n  }`};return{name:"GroupedConv",shaderCache:{hint:t.cacheKey,inputDependencies:w},getRunData:()=>({outputs:[{dims:r?r(h):h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:y}),getShaderSource:_}}});var Po,Qd,Ws,Oo=Q(()=>{"use strict";Ce();Wr();_e();Ut();Po=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,p=u[u.length-2],m=a[a.length-1],h=u[u.length-1],d=He(m),y=He(h),w=He(p),_=W.size(r)/d/w,v=e.length>2,x=o?o.slice(0,-2):r.slice(0,-2),C=[W.size(x),p,m],S=[{type:"uint32",data:_},{type:"uint32",data:p},{type:"uint32",data:m},{type:"uint32",data:h}];t.activation==="Clip"&&S.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),S.push(...G(x),...G(u),...G(a)),v&&S.push(...G(e[2].dims)),S.push(...G(C));let E=O=>{let U=An("batch_dims",e[0].dataType,x.length),M=V("a",e[0].dataType,u.length,y),N=V("b",e[1].dataType,a.length,d),Y=J("output",e[0].dataType,C.length,d),se=At(t,Y.type.value),B=[M,N],te="";if(v){let de=i?d:1;B.push(V("bias",e[2].dataType,e[2].dims.length,de)),te=`${i?`value += bias[col / ${de}];`:`value += ${Y.type.value}(bias[row + i]);`}`}let Pe=u.slice(0,-2),Ee=a.slice(0,-2),ee=cr(Pe,x),be=cr(Ee,x),Me=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];t.activation==="Clip"&&Me.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"});let pe=(de,we)=>{let ze=de.rank,Re=de.name;if(ze===2)return`var ${Re}_indices = ${de.type.indices}(0u, 0u);`;let Ge=U.rank,F=`var ${Re}_indices: ${de.type.indices};`;for(let ie=ze-2-1,he=Ge-1;ie>=0;ie--,he--)F+=`\n${Re}_indices[${ie}] = ${Ge>1?`batch_indices[${he}]`:"batch_indices"};`;return we.forEach(ie=>{F+=`\n${Re}_indices[${ie}] = 0;`}),F+=`${Re}_indices[${ze-2}] = 0u;\n                     ${Re}_indices[${ze-1}] = 0u;`,F},ye=()=>{let de=`var a_data: ${M.type.value};`;for(let we=0;we<y;we++)de+=`\n              let b_data${we} = b[(b_offset + (k + ${we}) * uniforms.N + col) / ${d}];`;for(let we=0;we<w;we++){de+=`a_data = a[(a_offset + (row + ${we}) * uniforms.K + k) / ${y}];`;for(let ze=0;ze<y;ze++)de+=`\n            values[${we}] = fma(${N.type.value}(a_data${y===1?"":`[${ze}]`}), b_data${ze}, values[${we}]);\n`}return de};return`\n  ${O.registerUniforms(Me).registerInternalVariables(U).declareVariables(...B,Y)}\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${d})) * ${d};\n    var index1 = global_idx / (uniforms.N / ${d});\n    let stride1 = uniforms.M / ${w};\n    let row = (index1 % stride1) * ${w};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${U.offsetToIndices("batch")};`}\n    ${pe(M,ee)}\n    let a_offset = ${M.indicesToOffset("a_indices")};\n    ${pe(N,be)}\n    let b_offset = ${N.indicesToOffset("b_indices")};\n    var values: array<${Y.type.value}, ${w}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {\n      ${ye()}\n    }\n    for (var i = 0u; i < ${w}u; i++) {\n      var value = values[i];\n      ${te}\n      ${se}\n      let cur_indices = ${Y.type.indices}(batch, row + i, col);\n      let offset = ${Y.indicesToOffset("cur_indices")};\n      ${Y.setByOffset(`offset / ${d}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${d};${y};${w};${i}`,inputDependencies:v?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:S}),getShaderSource:E}},Qd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Ws=e=>{Qd(e.inputs);let t=vt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Po(e.inputs,{activation:""},t)):e.compute(Mn(e.inputs,{activation:""},t))}});var To,Ns,ec,Hs,ko,tc,rc,Ro,Eo=Q(()=>{"use strict";Ce();Us();Wr();Vs();Ut();Oo();pr();To=(e,t,r,o,i,u)=>{let a=e[0],p=e.slice(u?1:2,u?3:4),m=p.length,h=t[0],y=t.slice(2).map((v,x)=>v+(v-1)*(r[x]-1)),_=p.map((v,x)=>v+o[x]+o[x+m]).map((v,x)=>Math.floor((v-y[x]+i[x])/i[x]));return _.splice(0,0,a),_.splice(u?3:1,0,h),_},Ns=[2,3,1,0],ec=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Hs=(e,t)=>{let r=e.kernelShape.slice();for(let u=2;u<t[1].dims.length;++u)r[u-2]===0&&(r[u-2]=t[1].dims[u]);let o=e.pads.slice();Xt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let i=Object.assign({},e);return Object.assign(i,{kernelShape:r,pads:o}),i},ko=e=>{let t=kn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,u=e.group,a=e.kernel_shape,p=e.pads,m=e.strides,h=e.w_is_const();return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,pads:p,strides:m,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},tc=(e,t,r)=>{let o=Hs(r,t),i=r.format==="NHWC";if(r.group!==1){e.compute(Io(t,o));return}let u=t.length===3,a=t[0].dims[i?1:2],p=t[0].dims[i?2:3],m=t[0].dims[i?3:1],h=t[1].dims[2],d=t[1].dims[3],y=To(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,i),w=y[i?1:2],_=y[i?2:3],v=y[i?3:1],x=i&&h===a&&d===p&&r.pads[0]===0&&r.pads[1]===0;if(x||h===1&&d===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let M=y[0],N,Y,se,B=[];if(i){let Ee=e.kernelCustomData.wT??e.compute(yt(t[1],Ns),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=Ee),x){let ee=a*p*m;N=t[0].reshape([1,M,ee]),Y=Ee.reshape([1,ee,v]),se=[1,M,v]}else N=t[0].reshape([M,a*p,m]),Y=Ee.reshape([1,m,v]),se=[M,w*_,v];B.push(N),B.push(Y)}else N=t[0].reshape([M,m,a*p]),Y=t[1].reshape([1,v,m]),se=[M,v,w*_],B.push(Y),B.push(N);u&&B.push(t[2]);let te=se[2],Pe=B[0].dims[B[0].dims.length-1];te<8&&Pe<8?e.compute(Po(B,o,y,se,i),{inputs:B}):e.compute(Mn(B,o,y,se,i),{inputs:B});return}let T=!0,C=e.kernelCustomData.wT??e.compute(yt(t[1],Ns),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=C);let S=[t[0],C];u&&S.push(t[2]);let E=i?w*_:v,O=i?v:w*_,U=h*d*m;e.compute(zs(S,o,y,E,O,U,u,T),{inputs:S})},rc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let i=[0,t.pads[0],0,t.pads[1]],u=[1].concat(t.strides),a=[1].concat(t.dilations),p=[1].concat(t.kernelShape),m=Hs({...t,pads:i,strides:u,dilations:a,kernelShape:p},o);e.compute(Io(o,m,h=>r?[h[0],h[2],h[3]]:[]))},Ro=(e,t)=>{ec(e.inputs,t),e.inputs[0].dims.length===3?rc(e,t):tc(e,e.inputs,t)}});var nc,Gs,Ls=Q(()=>{"use strict";zt();_e();Ut();Bn();Ao();Wr();nc=(e,t=!1,r,o=4)=>{let i=je(o,"f32"),u=C=>{switch(C){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${C} is not supported.`)}},a=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,p=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",d=e?"row":"col",y=e?"col":"row",w=`\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${d} / outWidth;\n      let outCol = ${d} % outWidth;\n\n      let WRow = ${y} / (uniforms.filter_dims[1] * inChannels);\n      let WCol = ${y} / inChannels % uniforms.filter_dims[1];\n      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${i}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {\n        return ${i}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${y} % inChannels;\n      ${a}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${o}];`,_=e?`\n      let col = colIn * ${o};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n        ${w}\n      }\n      return ${i}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n        ${w}\n      }\n      return ${i}(0.0);`,v=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);\n      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];\n      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(o)}\n      }\n      return ${i}(0.0);\n      `,x=At(r,i);return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?_:v}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${i} {\n    ${e?v:_}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${i}) {\n    let col = colIn * ${o};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${p}\n      ${Rn(t)}\n      ${x}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${o}] = value;\n    }\n  }`},Gs=(e,t,r,o,i,u,a,p)=>{let m=t.format==="NHWC",h=m?e[0].dims[3]:e[0].dims[1],d=r[0],y=m?r[2]:r[3],w=m?r[1]:r[2],_=m?r[3]:r[1],v=m?h%4===0&&_%4===0:y%4===0&&_%4===0,x=m?_:y*w,T=m?y*w:_,C=v?[8,8,1]:[x<=4||T<=4?4:16,x>4&&T<=4?4:16,1],S=v?[4,4,1]:[x<=4?1:4,x>4&&T<=4?1:4,1],E=[Math.ceil(x/C[0]/S[0]),Math.ceil(T/C[1]/S[1]),Math.ceil(d/C[2]/S[2])];De("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${E}`);let O=v?4:1,U=Math.max(C[0]*O,C[1]),M=v?4:1,N=[t.kernelShape[m?1:2],t.kernelShape[m?2:3]],Y=[N[0]+(t.dilations[0]<=1?0:(N[0]-1)*(t.dilations[0]-1)),N[1]+(t.dilations[1]<=1?0:(N[1]-1)*(t.dilations[1]-1))],se=[Y[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),Y[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],B=[{type:"int32",data:o},{type:"int32",data:i},{type:"int32",data:u},{type:"int32",data:t.strides},{type:"int32",data:t.dilations},{type:"int32",data:N},{type:"int32",data:se}];t.activation==="Clip"&&B.push({type:"float32",data:t.clipMax},{type:"float32",data:t.clipMin}),B.push(...G(e[0].dims),...G(e[1].dims));let te=["rank","rank"];a&&(B.push(...G(e[2].dims)),te.push("rank")),B.push(...G(r));let Pe=Ee=>{let ee=V("x",e[0].dataType,e[0].dims.length,M),be=V("w",e[1].dataType,e[1].dims.length,1),Me=J("result",e[0].dataType,r.length,M),pe=[ee,be],ye="";if(a){let we=V("bias",e[2].dataType,e[2].dims.length,M);pe.push(we),ye+=`\n          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?"vec4<f32>":"f32"} {\n            return bias[coords.${m?"w":"y"}${v?"/ 4":""}];\n          }`}let de=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:N.length},{name:"pads",type:"i32",length:se.length}];return t.activation==="Clip"&&de.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}),`\n        ${Dn("uniforms.result_strides")}\n        ${Ee.registerUniforms(de).declareVariables(...pe,Me)};\n        ${ye}\n        ${nc(m,a,t,O)}\n        ${v?Ur(S,C,"f32",void 0,!m,U):Vr(S,C,"f32",void 0,!m,U,!1,void 0,p)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${t.cacheKey};${S};${C};${v}`,inputDependencies:te},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:B}),getShaderSource:Pe}}});var oc,Bo,Fs=Q(()=>{"use strict";zt();Ce();_e();oc=(e,t,r,o,i,u=!1,a,p,m=!1)=>{let h=m?1:2,d=m?2:3,y=m?3:1,w=u?2:1,_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${a}>`:a}) {\n    result[flatIndex] = ${u?`vec4<${a}>`:a}(value);\n  }`;o&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${a}>`:a} {\n      return bias[coords.${m?"w":"y"}${u?"/ 4":""}];\n    }`);let v=u?4:1,x=V("W",t[1].dataType,t[1].dims.length,v),T=V("Dy",t[0].dataType,t[0].dims.length,v),C=[T,x];o&&C.push(V("bias",t[2].dataType,[r[y]].length,v));let S=J("result",t[0].dataType,r.length,v),E=`{\n        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];\n        let r = ${i?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];\n        let c = ${i?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${a}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${a}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {\n          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(uniforms.strides.x);\n          let wRPerm = uniforms.filter_dims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {\n            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let wCPerm = uniforms.filter_dims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${T.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${T.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = uniforms.Dy_shape[${y}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${T.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${x.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${T.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${o?"bias[c+i]":`vec4<${a}>(0.0)`};\n          ${S.set("batch","r","c + i","d1","value")};\n        }\n      }`,O=`\n          let outputIndices = ${S.offsetToIndices("global_idx")};\n          let batch = ${S.indicesGet("outputIndices",0)};\n          let d1 = ${S.indicesGet("outputIndices",y)};\n          let r = ${S.indicesGet("outputIndices",h)};\n          let c = ${S.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / uniforms.output_channels_per_group;\n          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${a}(0.0);\n          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n            if (wR % uniforms.dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(uniforms.strides[0]);\n            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n            if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[${h}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n              if (wC % uniforms.dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(uniforms.strides.y);\n              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n              if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * uniforms.input_channels_per_group;\n              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\n                let xValue = ${m?T.get("batch","idyR","idyC","inputChannel"):T.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${x.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${o?"bias[d1]":`${a}(0.0)`};\n          ${S.setByOffset("global_idx","value")};\n        `;return`\n  ${e.registerUniforms(p).declareVariables(...C,S)}\n  ${_}\n\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n  ${u?E:O}}`},Bo=(e,t,r)=>{let o=e.length>2,i=t.outputShape,u=W.size(i),a=[Math.ceil(u/64),1,1];De("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${a}`);let p=t.format==="NHWC",m=["rank","rank"],h=[t.strides[0],t.strides[1]],d=[t.kernelShape[p?1:2],t.kernelShape[p?2:3]],y=[t.dilations[0],t.dilations[1]],w=[d[0]+(t.dilations[0]<=1?0:(t.kernelShape[p?1:2]-1)*(t.dilations[0]-1)),d[1]+(t.dilations[1]<=1?0:(t.kernelShape[p?2:3]-1)*(t.dilations[1]-1))],_=[w[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),w[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],v=!1,x=t.group,T=e[1].dims,C=T[0]/x,S=T[1],E=[{type:"int32",data:u},{type:"uint32",data:h},{type:"uint32",data:d},{type:"uint32",data:y},{type:"uint32",data:w},{type:"int32",data:_},{type:"uint32",data:C},{type:"uint32",data:S},...G(e[0].dims),...G(e[1].dims)];o&&(E.push(...G(e[2].dims)),m.push("rank")),E.push(...G(i));let O=a[1]===1&&a[2]===1,U=M=>{let N=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:h.length},{name:"filter_dims",type:"u32",length:d.length},{name:"dilations",type:"u32",length:d.length},{name:"effective_filter_dims",type:"u32",length:w.length},{name:"pads",type:"i32",length:_.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Y=Ne(e[0].dataType);return`${oc(M,e,i,o,O,v,Y,N,p)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:m},getRunData:()=>({dispatchGroup:{x:a[0],y:a[1],z:a[2]},outputs:[{dims:r?r(i):i,dataType:e[0].dataType}],programUniforms:E}),getShaderSource:U}}});var ic,ac,sc,js,qs,uc,lc,dc,cc,Ks,Ys=Q(()=>{"use strict";Ls();Fs();Ut();pr();ic=(e,t,r,o,i,u)=>(e-1)*t+r+(o-1)*i+1-u,ac=(e,t,r,o,i)=>{let u=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=u,r[i]=e-u):t==="SAME_LOWER"&&(r[o]=e-u,r[i]=u)},sc=(e,t,r,o,i,u,a,p,m,h)=>{let d=e.length-2,y=h.length===0;if(m.length===0)for(let v=0;v<d;++v)m.push(0);let w=e[0],_=t[p?3:1]*i;for(let v=0,x=e.length-d-(p?1:0);v<d;++v,++x){let T=e[x],C=y?T*a[v]:h[v],S=ic(T,a[v],u[v],t[x],r[v],C);ac(S,o,u,v,v+d),y&&h.push(a[v]*(T-1)+m[v]+(t[x]-1)*r[v]+1-u[v]-u[v+d])}h.splice(0,0,w),h.splice(p?3:1,0,_)},js=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((y,w)=>y*w,1)===0){r.length=0;for(let y=2;y<t[1].dims.length;++y)r.push(t[1].dims[y])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let i=e.pads.slice(),u=e.outputShape.slice(),a=e.outputPadding.slice(),p=t[0].dims,m=e.dilations.slice();if(m.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;m=new Array(y).fill(1)}let h=e.strides.slice();if(h.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;h=new Array(y).fill(1)}sc(p,r,m,e.autoPad,e.group,i,h,o,a,u);let d=Object.assign({},e);return Object.assign(d,{kernelShape:r,pads:i,outputPadding:a,outputShape:u,dilations:m,strides:h}),d},qs=e=>{let t=kn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],i=e.dilations,u=e.group,a=e.kernelShape,p=e.pads,m=e.strides,h=e.wIsConst(),d=e.outputPadding,y=e.outputShape;return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,outputPadding:d,outputShape:y,pads:p,strides:m,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},uc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");let u=e[0].dims.length-2;if(t.dilations.reduce((d,y)=>d+y,0)>0&&t.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(t.strides.reduce((d,y)=>d+y,0)>0&&t.strides.length!==u)throw new Error(`strides should be ${u}D`);if(t.pads.reduce((d,y)=>d+y,0)>0&&t.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(t.outputPadding.length!==u&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${u}D`);if(t.kernelShape.reduce((d,y)=>d+y,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},lc=[2,3,1,0],dc=(e,t,r)=>{let o=js(r,t),i=r.format==="NHWC",u=o.outputShape,a=u[i?3:1],p=t[0].dims[i?3:1];if(o.group!==1||a===1&&p===1){e.compute(Bo(t,o));return}let m=u[i?1:2],h=u[i?2:3],d=t[1].dims[2],y=t[1].dims[3],w=i?m*h:a,_=i?a:m*h,v=d*y*p,x=!0,T=e.kernelCustomData.wT??e.compute(yt(t[1],lc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=T);let C=[t[0],T],S=t.length===3;S&&(!i&&t[2].dims.length===1?C.push(t[2].reshape([t[2].dims[0],1,1])):C.push(t[2])),e.compute(Gs(C,o,u,w,_,v,S,x),{inputs:C})},cc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let i=t.kernelShape;(i.length===0||i[0]===0)&&(i=[e.inputs[1].dims[2]]);let u=t.dilations;(u.length===0||u[0]===0)&&(u=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let p=t.pads;p.length===0&&(p=[0,0]),p=[0,p[0],0,p[1]],a=[1].concat(a),u=[1].concat(u),i=[1].concat(i);let m=js({...t,pads:p,strides:a,dilations:u,kernelShape:i},o);e.compute(Bo(o,m,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]]))},Ks=(e,t)=>{uc(e.inputs,t),e.inputs[0].dims.length===3?cc(e,t):dc(e,e.inputs,t)}});var pc,Zs,Xs,Js=Q(()=>{"use strict";Ve();Ce();Ye();_e();pc=(e,t,r,o)=>{let i=W.size(t),u=t.length,a=V("input",e,u),p=J("output",e,u),m=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),h=W.normalizeAxis(m,u),d=y=>{let w=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,_=ce("uniforms.input_shape","uniforms.axis",u),v=o.reverse?w+(o.exclusive?" + 1":""):"0",x=o.reverse?_:w+(o.exclusive?"":" + 1");return`\n                ${y.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,p)}\n                ${y.mainStart()}\n                  ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${p.offsetToIndices("global_idx")};\n                  var sum = ${p.type.value}(0);\n                  let first : i32 = ${v};\n                  let last : i32 = ${x};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${a.getByIndices("inputIndices")};\n                  }\n                  ${p.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:"uint32",data:i},{type:"int32",data:h},...G(t),...G(t)]}),getShaderSource:d}},Zs=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,i=e.inputs[1];e.compute(pc(o,r,i,t),{inputs:[0]})},Xs=e=>{let t=e.exclusive===1,r=e.reverse===1;return xe({exclusive:t,reverse:r})}});var Do,zn,Qs,mc,fc,Mo,zo,eu,hc,tu,ru,nu=Q(()=>{"use strict";Ce();Ye();_e();Do="[a-zA-Z]|\\\\.\\\\.\\\\.",zn="("+Do+")+",Qs="^"+zn+"$",mc="("+zn+",)*"+zn,fc="^"+mc+"$",Mo=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},zo=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,i]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(fc)))throw new Error("Invalid LHS term");if(o.split(",").forEach((p,m)=>{let h=t[m].dims.slice();if(!p.match(RegExp(Qs)))throw new Error("Invalid LHS term");let d=this.processTerm(p,!0,h,m);this.lhs.push(d)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([p,m])=>m.count===1||p==="...").map(([p])=>p).join("");else if(!i.match(RegExp(zn)))throw new Error("Invalid RHS");i.match(RegExp(Do,"g"))?.forEach(p=>{if(p==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let m=this.symbolToInfo.get(p);if(m===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(m.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(t,r,o){let i=this.symbolToInfo.get(t);if(i!==void 0){if(i.dimValue!==r&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(o)}else i={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,i)}processTerm(t,r,o,i=-1){let u=o.length,a=!1,p=[],m=0;if(!t.match(RegExp(Qs))&&!r&&t!=="")throw new Error("Invalid LHS term");let h=t.match(RegExp(Do,"g")),d=new Mo(i);return h?.forEach((y,w)=>{if(y==="..."){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let _=u-h.length+1;if(_<0)throw new Error("Ellipsis out of bounds");if(p=o.slice(m,m+_),this.hasEllipsis){if(this.ellipsisDims.length!==p.length||this.ellipsisDims.toString()!==p.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=p;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<p.length;v++){let x=String.fromCharCode("0".charCodeAt(0)+v);d.addSymbol(x,w+v),this.addSymbol(x,o[m++],i)}}else d.addSymbol(y,w+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(y,o[m++],i)}),d}},eu=e=>e+"_max",hc=(e,t,r,o)=>{let u=e.map(d=>d.length).map((d,y)=>V(`input${y}`,t,d)),a=W.size(o),p=J("output",t,o.length),m=[...r.symbolToInfo.keys()].filter(d=>!r.rhs.symbolToIndices.has(d)),h=d=>{let y=[],w="var prod = 1.0;",_="var sum = 0.0;",v="sum += prod;",x=[],T=[],C=[],S=[],E=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((U,M)=>{if(r.rhs.symbolToIndices.has(M)){let N=r.rhs.symbolToIndices.get(M)?.[0];N!==void 0&&r.lhs.forEach((Y,se)=>{if(U.inputIndices.includes(se)){let B=Y.symbolToIndices.get(M);if(B===void 0)throw new Error("Invalid symbol error");B.forEach(te=>{y.push(`${u[se].indicesSet(`input${se}Indices`,te,p.indicesGet("outputIndices",N))}`)})}})}else r.lhs.forEach((N,Y)=>{if(U.inputIndices.includes(Y)){let se=N.symbolToIndices.get(M);if(se===void 0)throw new Error("Invalid symbol error");se.forEach(B=>{x.push(`${u[Y].indicesSet(`input${Y}Indices`,B,`${M}`)}`)}),S.push(`prod *= ${u[Y].getByIndices(`input${Y}Indices`)};`)}}),T.push(`for(var ${M}: u32 = 0; ${M} < uniforms.${eu(M)}; ${M}++) {`),C.push("}")});let O=E?[...y,`let sum = ${u.map((U,M)=>U.getByIndices(`input${M}Indices`)).join(" * ")};`]:[...y,_,...T,...x,w,...S,v,...C];return`\n            ${d.registerUniforms(m.map(U=>({name:`${eu(U)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,p)}\n\n            ${d.mainStart()}\n            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${p.offsetToIndices("global_idx")};\n            ${u.map((U,M)=>`var input${M}Indices: ${u[M].type.indices};`).join(`\n`)}\n            ${O.join(`\n`)};\n            ${p.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let d=m.filter(w=>r.symbolToInfo.has(w)).map(w=>({type:"uint32",data:r.symbolToInfo.get(w)?.dimValue||0}));d.push({type:"uint32",data:a});let y=e.map((w,_)=>[...G(w)]).reduce((w,_)=>w.concat(_),d);return y.push(...G(o)),{outputs:[{dims:o,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:y}},getShaderSource:h}},tu=(e,t)=>{let r=new zo(e.inputs,t.equation),o=r.outputDims,i=e.inputs.map((u,a)=>u.dims);e.compute(hc(i,e.inputs[0].dataType,r,o))},ru=e=>{let t=e.equation.replace(/\\s+/g,"");return xe({equation:t})}});var gc,ou,yc,bc,iu,au=Q(()=>{"use strict";Ve();Ce();_e();gc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,i=t.length<r.length?0:t.length-r.length;for(;o<r.length&&i<t.length;++o,++i)if(r[o]!==t[i]&&r[o]!==1&&t[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ou=(e,t)=>{let r=e.length-t.length,o=[];for(let i=0;i<r;++i)o.push(e[i]);for(let i=0;i<t.length;++i)o.push(t[i]===1?e[i+r]:t[i]);return o},yc=(e,t)=>e.length>t.length?ou(e,t):ou(t,e),bc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=yc(t,r),i=e[0].dataType,u=i===9?4:1,a=Math.ceil(W.size(o)/u),p=h=>{let d=V("input",i,t.length,u),y=J("output",i,o.length,u),w;if(i===9){let _=(v,x,T="")=>`\n          let outputIndices${x} = ${y.offsetToIndices(`outputOffset + ${x}u`)};\n          let offset${x} = ${d.broadcastedIndicesToOffset(`outputIndices${x}`,y)};\n          let index${x} = offset${x} / 4u;\n          let component${x} = offset${x} % 4u;\n          ${v}[${x}] = ${T}(${d.getByOffset(`index${x}`)}[component${x}]);\n        `;w=`\n        let outputOffset = global_idx * ${u};\n        var data = vec4<u32>(0);\n        ${_("data",0,"u32")}\n        ${_("data",1,"u32")}\n        ${_("data",2,"u32")}\n        ${_("data",3,"u32")}\n        ${y.setByOffset("global_idx","data")}\n      }`}else w=`\n        let outputIndices = ${y.offsetToIndices("global_idx")};\n        let inputOffset = ${d.broadcastedIndicesToOffset("outputIndices",y)};\n        ${y.setByOffset("global_idx",d.getByOffset("inputOffset"))}\n      }`;return`\n    ${h.registerUniform("vec_size","u32").declareVariables(d,y)}\n    ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${w}`},m=[{type:"uint32",data:a},...G(t),...G(o)];return{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:["rank"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:m})}},iu=e=>{gc(e.inputs),e.compute(bc(e.inputs),{inputs:[0]})}});var wc,vc,su,uu,lu=Q(()=>{"use strict";Ve();Ce();Ye();_e();wc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},vc=(e,t)=>{let r=e[0].dims,o=e[1].dims,i=r.length,u=W.normalizeAxis(t.axis,i),a=r.slice(0);a.splice(u,1,...o);let p=r[u],m=e[0].dataType===9?4:1,h=Math.ceil(W.size(a)/m),d=[{type:"uint32",data:h},{type:"int32",data:p},{type:"uint32",data:u},...G(e[0].dims),...G(e[1].dims),...G(a)],y=w=>{let _=V("data",e[0].dataType,e[0].dims.length,m),v=V("inputIndices",e[1].dataType,e[1].dims.length),x=J("output",e[0].dataType,a.length,m),T=S=>{let E=o.length,O=`var indicesIndices${S}  = ${v.type.indices}(0);`;for(let U=0;U<E;U++)O+=`${E>1?`indicesIndices${S}[${U}]`:`indicesIndices${S}`} = ${a.length>1?`outputIndices${S}[uniforms.axis + ${U}]`:`outputIndices${S}`};`;O+=`\n          var idx${S} = ${v.getByIndices(`indicesIndices${S}`)};\n          if (idx${S} < 0) {\n            idx${S} = idx${S} + uniforms.axisDimLimit;\n          }\n          var dataIndices${S} = ${_.type.indices}(0);\n        `;for(let U=0,M=0;U<i;U++)U===u?(O+=`${i>1?`dataIndices${S}[${U}]`:`dataIndices${S}`} = u32(idx${S});`,M+=E):(O+=`${i>1?`dataIndices${S}[${U}]`:`dataIndices${S}`} = ${a.length>1?`outputIndices${S}[${M}]`:`outputIndices${S}`};`,M++);return O},C;if(e[0].dataType===9){let S=(E,O,U="")=>`\n          let outputIndices${O} = ${x.offsetToIndices(`outputOffset + ${O}u`)};\n          ${T(O)};\n          let offset${O} = ${_.indicesToOffset(`dataIndices${O}`)};\n          let index${O} = offset${O} / 4u;\n          let component${O} = offset${O} % 4u;\n          ${E}[${O}] = ${U}(${_.getByOffset(`index${O}`)}[component${O}]);\n        `;C=`\n        let outputOffset = global_idx * ${m};\n        var value = vec4<u32>(0);\n        ${S("value",0,"u32")}\n        ${S("value",1,"u32")}\n        ${S("value",2,"u32")}\n        ${S("value",3,"u32")}\n        ${x.setByOffset("global_idx","value")}\n      `}else C=`\n      let outputIndices = ${x.offsetToIndices("global_idx")};\n      ${T("")};\n      let value = ${_.getByIndices("dataIndices")};\n      ${x.setByOffset("global_idx","value")};\n      `;return`\n      ${w.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,v,x)}\n      ${w.mainStart()}\n        ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${C}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:y}},su=e=>xe({axis:e.axis}),uu=(e,t)=>{let r=e.inputs;wc(r),e.compute(vc(e.inputs,t))}});var $c,_c,du,cu,pu=Q(()=>{"use strict";Ce();Ye();_e();$c=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},_c=(e,t)=>{let r=e[0].dims,o=e[0].dataType,i=r.length,u=e[1].dims,a=e[1].dataType,p=W.normalizeAxis(t.axis,i),m=r[p],h=u.slice(0),d=W.size(h),y=V("input",o,i),w=V("indicesInput",a,u.length),_=J("output",o,h.length),v=[{type:"uint32",data:d},{type:"int32",data:m},{type:"uint32",data:p}];return v.push(...G(r)),v.push(...G(u)),v.push(...G(h)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:v}),getShaderSource:C=>`\n      ${C.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(y,w,_)}\n      ${C.mainStart()}\n      ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${_.offsetToIndices("global_idx")};\n\n      var idx = ${w.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${y.type.indices}(outputIndices);\n      ${y.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${y.getByIndices("inputIndices")};\n\n      ${_.setByOffset("global_idx","value")};\n  }`}},du=e=>xe({axis:e.axis}),cu=(e,t)=>{let r=e.inputs;$c(r),e.compute(_c(e.inputs,t))}});var Sc,xc,mu,fu,hu=Q(()=>{"use strict";Ce();_e();Sc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},xc=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[i,u,a]=Sn.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),p=[i,u];if(!p)throw new Error("Can\'t use gemm on the given tensors");let m=W.size(p),h=[{type:"uint32",data:m},{type:"uint32",data:i},{type:"uint32",data:u},{type:"uint32",data:a},{type:"float32",data:t.alpha},{type:"float32",data:t.beta}],d=["type","type"];e.length===3&&(h.push(...G(e[2].dims)),d.push("rank")),h.push(...G(p));let y=w=>{let _="";t.transA&&t.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let v=t.alpha===1?"":"value *= uniforms.alpha;",x=V("a",e[0].dataType,e[0].dims),T=V("b",e[1].dataType,e[1].dims),C=x.type.value,S=null,E=[x,T];e.length===3&&(S=V("c",e[2].dataType,e[2].dims.length),E.push(S));let O=J("output",e[0].dataType,p.length);E.push(O);let U=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`\n  ${w.registerUniforms(U).declareVariables(...E)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${C}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${_}\n    }\n\n    ${v}\n    ${(()=>S!=null?`let cOffset = ${S.broadcastedIndicesToOffset("vec2(m, n)",O)}; value += ${C}(uniforms.beta) * ${S.getByOffset("cOffset")};`:"")()}\n    output[global_idx] = value;\n  }`};return{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:h}),getShaderSource:y}},mu=e=>{let t=e.transA,r=e.transB,o=e.alpha,i=e.beta;return{transA:t,transB:r,alpha:o,beta:i,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},fu=(e,t)=>{Sc(e.inputs),e.compute(xc(e.inputs,t))}});var Cc,Ac,Ic,gu,yu=Q(()=>{"use strict";Ve();Ce();_e();Cc=(e,t)=>{let r=e[0].dims,o=r,i=2,u=W.sizeToDimension(r,i),a=W.sizeFromDimension(r,i),p=He(a),m=a/p,h=[r[0],r[1],m],d=["rank","type","type"],y=[{type:"uint32",data:a},{type:"uint32",data:m}];y.push(...G(h),...G(h));let w=_=>{let v=V("x",e[0].dataType,h.length,p),x=V("scale",e[1].dataType,e[1].dims),T=V("bias",e[2].dataType,e[2].dims),C=J("output",e[0].dataType,h.length,p),S=[v,x,T,C],E=v.type.value,O=p===1?"f32":`vec${p}<f32>`,U=64,M=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${O}, ${U}>;\n  const workgroupSize = ${U}u;\n  ${_.registerUniforms(M).declareVariables(...S)}\n  ${_.mainStart(U)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${O}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${O}(${v.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${ut("workgroupShared[0]",p)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${O}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${O}(${v.get("batch","channel","h")}) - ${O}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${ut("workgroupShared[0]",p)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${x.getByOffset("channel")});\n    let channelShift = f32(${T.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${v.get("batch","channel","h")} * ${E}(${O}(channelScale)) + ${E}(${O}(channelShift));\n      ${C.set("batch","channel","h","value")};\n    }\n  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${t.epsilon};${p}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u},programUniforms:y}),getShaderSource:w}},Ac=(e,t,r,o,i,u,a,p)=>{let m=He(a),h=64,d=m===1?"vec2f":`mat2x${m}f`,y=m===1?"f32":`vec${m}f`,w=(M,N)=>`${d}(${M}, ${N})`,_=i*a/m,v=Math.ceil(u/h),x=["type"],T=[{type:"uint32",data:v},{type:"uint32",data:u},{type:"uint32",data:Math.floor(a/m)},{type:"uint32",data:Math.floor(u*a/m)}],C=M=>{let N=V("input",t.dataType,t.dims,m);return`\n  ${M.declareVariables(N)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${M.mainStart(h)}\n    let currentImageNumber = global_idx / ${h} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${h}) % uniforms.C;\n    let wgId = global_idx % ${h};\n    let wgOffset = wgId * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${Ze("f32",m)};\n    var squaredSum = ${Ze("f32",m)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${y}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${w("sum","squaredSum")};\n  }`},S=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${m}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:[i,a,h,2],dataType:1}],dispatchGroup:{x:i*a/m},programUniforms:T}),getShaderSource:C},{inputs:[t],outputs:[-1]})[0],E=[{type:"uint32",data:_},{type:"uint32",data:u},{type:"uint32",data:Math.floor(a/m)},{type:"uint32",data:Math.floor(h*a/m)}],O=["type","type","type"],U=M=>{let N=V("scale",r.dataType,r.dims,m),Y=V("bias",o.dataType,o.dims,m);return`\n  @group(0) @binding(0) var<storage, read> input : array<${d}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${N.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${Y.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${M.mainStart()}\n    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${Ze("f32",m)};\n    var squaredSum = ${Ze("f32",m)};\n    for (var i: u32 = 0; i < ${h}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${h}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${p}));\n    let channelScale = invStdDev * ${y}(scale[currentChannelNumber]);\n    let channelShift = ${y}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${w("channelScale","channelShift")};\n  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${m};${p}`,inputDependencies:O},getRunData:()=>({outputs:[{dims:[i,a,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:E}),getShaderSource:U},{inputs:[S,r,o],outputs:[-1]})[0]},Ic=(e,t,r)=>{let o=t[0].dims,i=o,u=o[0],a=o[o.length-1],p=W.sizeFromDimension(o,1)/a,m=He(a),h=W.size(i)/m,d=[{type:"uint32",data:p},{type:"uint32",data:Math.floor(a/m)}],y=["type","type"],w=Ac(e,t[0],t[1],t[2],u,p,a,r.epsilon),_=v=>{let x=Ne(t[0].dataType),T=m===1?"vec2f":`mat2x${m}f`,C=m===1?x:`vec${m}<${x}>`,S=V("input",t[0].dataType,t[0].dims,m),E=J("output",t[0].dataType,i,m);return`\n  @group(0) @binding(0) var<storage, read> input : array<${S.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${T}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${E.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${v.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${C}(scale[0]), ${C}(scale[1]));\n  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${m}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:_},{inputs:[t[0],w]})},gu=(e,t)=>{t.format==="NHWC"?Ic(e,e.inputs,t):e.compute(Cc(e.inputs,t))}});var Tc,Ec,bu,wu=Q(()=>{"use strict";Ve();Ce();_e();Tc=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Ec=(e,t,r)=>{let o=e[0].dims,i=e[1],u=e[2],a=o,p=W.normalizeAxis(t.axis,o.length),m=W.sizeToDimension(o,p),h=W.sizeFromDimension(o,p),d=W.size(i.dims),y=u?W.size(u.dims):0;if(d!==h||u&&y!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${d} and bias size of ${y}`);let w=[];for(let O=0;O<o.length;++O)O<p?w.push(o[O]):w.push(1);let _=He(h),v=["type","type"],x=[{type:"uint32",data:m},{type:"float32",data:h},{type:"uint32",data:Math.floor(h/_)},{type:"float32",data:t.epsilon}];u&&v.push("type");let T=r>1,C=r>2,S=O=>{let U=Ne(e[0].dataType),M=[V("x",e[0].dataType,e[0].dims,_),V("scale",i.dataType,i.dims,_)];u&&M.push(V("bias",u.dataType,u.dims,_)),M.push(J("output",e[0].dataType,a,_)),T&&M.push(J("mean_data_output",1,w)),C&&M.push(J("inv_std_output",1,w));let N=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`\n  ${O.registerUniforms(N).declareVariables(...M)}\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var meanVector = ${Ze("f32",_)};\n    var meanSquareVector = ${Ze("f32",_)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${gt(U,_,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${ut("meanVector",_)} / uniforms.norm_size;\n    let invStdDev =\n        inverseSqrt(${ut("meanSquareVector",_)} / uniforms.norm_size - mean * mean + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${gt(U,_,"x[j + offset]")};\n      let f32scale = ${gt(U,_,"scale[j]")};\n      output[j + offset] = ${M[0].type.value}((f32input - mean) * invStdDev * f32scale\n        ${u?`+ ${gt(U,_,"bias[j]")}`:""}\n      );\n    }\n\n    ${T?"mean_data_output[global_idx] = mean":""};\n    ${C?"inv_std_output[global_idx] = invStdDev":""};\n  }`},E=[{dims:a,dataType:e[0].dataType}];return T&&E.push({dims:w,dataType:1}),C&&E.push({dims:w,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${_};${r}`,inputDependencies:v},getRunData:()=>({outputs:E,dispatchGroup:{x:Math.ceil(m/64)},programUniforms:x}),getShaderSource:S}},bu=(e,t)=>{Tc(e.inputs),e.compute(Ec(e.inputs,t,e.outputCount))}});var Pc,$u,vu,Oc,Uo,_u,Su=Q(()=>{"use strict";Ce();Ye();$n();xo();_e();pr();Pc=(e,t)=>{let r=e[0],o=e[1],i=e[2],u=e[3],a=e[4],p=e[5],m=e[6],h=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let d=!1,y=r.dims[0],w=r.dims[1],_=r.dims.length===3?d?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],v=w,x=0,T=0,C=Math.floor(_/t.numHeads);if(m&&h){if(m.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(h.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');x=m.dims[2],T=m.dims[2]}else if(m||h)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let S;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');S=2,v=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==C)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(i)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');S=5,v=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==C)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');S=0,v=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');S=3}if(u){if(u.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(i&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let E=0;if(a){E=8;let Y=a.dims;throw Y.length===1?Y[0]===y?E=1:Y[0]===3*y+2&&(E=3):Y.length===2&&Y[0]===y&&Y[1]===v&&(E=5),E===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let O=!1,U=_;if(i){if(i.dims.length!==3&&i.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==i.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(i.dims.length===3){if(v!==i.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');U=i.dims[2]}else{if(v!==i.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');U=i.dims[1]*i.dims[3],O=!0}}let M=x+v,N=!1;if(a)throw new Error("Key padding mask is not supported");if(p)throw new Error("extraAddQk is not supported");if(m)throw new Error("pastKey is not supported");if(h)throw new Error("pastValue is not supported");return{batchSize:y,sequenceLength:w,pastSequenceLength:x,kvSequenceLength:v,totalSequenceLength:M,maxSequenceLength:T,inputHiddenSize:0,hiddenSize:_,vHiddenSize:U,headSize:C,vHeadSize:Math.floor(U/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:E,scale:t.scale,broadcastResPosBias:N,passPastInKv:O,qkvFormat:S}},$u=e=>xe({...e}),vu=xe({perm:[0,2,1,3]}),Oc=(e,t,r,o,i,u,a)=>{let p=[o,i,u],m=W.size(p),h=[{type:"uint32",data:m},{type:"uint32",data:a},{type:"uint32",data:u}],d=y=>{let w=J("qkv_with_bias",t.dataType,p),_=V("qkv",t.dataType,p),v=V("bias",r.dataType,p),x=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`\n  ${y.registerUniforms(x).declareVariables(_,v,w)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:p,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:h}),getShaderSource:d},{inputs:[t,r],outputs:[-1]})[0]},Uo=(e,t,r,o,i,u,a,p)=>{let m=u;if(a){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return m=Oc(e,u,a,t,o,r*i,p),m=m.reshape([t,o,r,i]),e.compute(yt(m,vu.perm),{inputs:[m],outputs:[-1]})[0]}else return u.dims.length===3&&(m=u.reshape([t,o,r,i])),e.compute(yt(m,vu.perm),{inputs:[m],outputs:[-1]})[0]},_u=(e,t)=>{let r=Pc(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let o=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,i=Uo(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(o)return En(e,i,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let u=Uo(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),a=Uo(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);En(e,i,u,a,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var kc,Rc,Bc,Dc,Mc,zc,Uc,Vc,xu,Cu=Q(()=>{"use strict";Ve();Ce();_e();kc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Rc=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n            k = i32(${e.indicesGet("indices",i)}) - ${ce("uniforms.pads",i,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${ce("uniforms.x_shape",i,t)})) {\n              break;\n            }\n            offset += k * i32(${ce("uniforms.x_strides",i,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},Bc=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${ce("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${ce("uniforms.x_shape",i,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${ce("uniforms.x_shape",i,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${ce("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},Dc=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${ce("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${ce("uniforms.x_shape",i,t)})) {\n                  k = i32(${ce("uniforms.x_shape",i,t)}) - 1;\n                }\n                offset += k * i32(${ce("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},Mc=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${ce("uniforms.pads",i,r)};\n                if (k < 0)  {\n                  k += i32(${ce("uniforms.x_shape",i,t)}]);\n                }\n                if (k >= i32(${ce("uniforms.x_shape",i,t)})) {\n                  k -= i32(${ce("uniforms.x_shape",i,t)});\n                }\n                offset += k * i32(${ce("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},zc=(e,t,r)=>{switch(r.mode){case 0:return Rc(e,t,r.pads.length);case 1:return Bc(e,t,r.pads.length);case 2:return Dc(e,t,r.pads.length);case 3:return Mc(e,t,r.pads.length);default:throw new Error("Invalid mode")}},Uc=(e,t)=>{let r=W.padShape(e[0].dims.slice(),t.pads),o=e[0].dims,u=[{type:"uint32",data:W.size(r)},{type:"uint32",data:t.pads}];if(t.mode===0){let m=st(e[0].dataType);u.push({type:m,data:t.value})}u.push(...G(e[0].dims),...G(r));let a=["rank"],p=m=>{let h=J("output",e[0].dataType,r.length),d=V("x",e[0].dataType,o.length),y=d.type.value,w=zc(h,o.length,t),_=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&_.push({name:"constant_value",type:y}),`\n            ${m.registerUniforms(_).declareVariables(d,h)}\n            ${m.mainStart()}\n            ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${h.offsetToIndices("global_idx")};\n\n            var value = ${y}(0);\n            ${w}\n            output[global_idx] = value;\n        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(W.size(r)/64)},programUniforms:u}),getShaderSource:p}},Vc=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,i=e[0].dims.length,u=new Int32Array(2*i).fill(0);if(e.length>=4){let p=e[3].getBigInt64Array();for(let m=0;m<p.length;m++)u[Number(p[m])]=Number(r[m]),u[Number(p[m])+i]=Number(r[m+p.length])}else r.forEach((p,m)=>u[Number(m)]=Number(p));let a=[];return u.forEach(p=>a.push(p)),{mode:t.mode,value:o,pads:a}}else return t},xu=(e,t)=>{kc(e.inputs);let r=Vc(e.inputs,t);e.compute(Uc(e.inputs,r),{inputs:[0]})}});var Un,Au,Iu,Tu,Eu,Wc,Nc,Pu,Ou,ku,Ru,Bu,Du,Mu,zu,Uu,Vu,Wu,Nu,Hu=Q(()=>{"use strict";dr();Ce();_e();Un=e=>{if(lr.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Au=(e,t,r)=>{let o=t.format==="NHWC",i=e.dims.slice();o&&i.splice(1,0,i.pop());let u=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),p=t.strides.slice(),m=u?t.dilations.slice():[],h=t.pads.slice();Xt.adjustPoolAttributes(r,i,a,p,m,h);let d=Xt.computePoolOutputShape(r,i,p,m,a,h,t.autoPad),y=Object.assign({},t);u?Object.assign(y,{kernelShape:a,strides:p,pads:h,dilations:m,cacheKey:t.cacheKey}):Object.assign(y,{kernelShape:a,strides:p,pads:h,cacheKey:t.cacheKey});let w=d.slice();return w.push(w.splice(1,1)[0]),[y,o?w:d]},Iu=(e,t)=>{let r=t.format==="NHWC",o=W.size(e),i=W.size(t.kernelShape),u=[{type:"uint32",data:o},{type:"uint32",data:i}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let p=t.kernelShape[t.kernelShape.length-1],m=t.strides[t.strides.length-1],h=t.pads[t.pads.length/2-1],d=t.pads[t.pads.length-1],y=!!(h+d);u.push({type:"uint32",data:p},{type:"uint32",data:m},{type:"uint32",data:h},{type:"uint32",data:d}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let w=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],v=t.strides[t.strides.length-2],x=t.pads[t.pads.length/2-2],T=t.pads[t.pads.length-2];w=!!(x+T),u.push({type:"uint32",data:_},{type:"uint32",data:v},{type:"uint32",data:x},{type:"uint32",data:T}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[u,a,!0,y,w]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let p=W.computeStrides(t.kernelShape);u.push({type:"uint32",data:p},{type:"uint32",data:t.pads},{type:"uint32",data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:p.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let m=t.pads.reduce((h,d)=>h+d);return[u,a,!!m,!1,!1]}},Tu=(e,t,r,o,i,u,a,p,m,h,d,y)=>{let w=i.format==="NHWC",_=t.type.value,v=J("output",t.type.tensor,o);if(i.kernelShape.length<=2){let x="",T="",C="",S=r-(w?2:1);if(d?x=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${S}] < 0 || xIndices[${S}]\n                      >= uniforms.x_shape[${S}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`:x=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`,i.kernelShape.length===2){let O=r-(w?3:2);y?T=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${O}] = indices[${O}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${O}] < 0 || xIndices[${O}] >= uniforms.x_shape[${O}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:T=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${O}] = indices[${O}] * uniforms.sh - uniforms.phStart + j;\n                `,C=`\n              }\n            `}return`\n            ${e.registerUniforms(m).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var value = ${_}(${p});\n              var pad = 0;\n              ${T}\n              ${x}\n              ${C}\n              ${a}\n\n              output[global_idx] = value;\n            }`}else{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let x=i.kernelShape.length,T=i.pads.length,C="";return h?C=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${u}\n              }`:C=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${u}\n            `,`\n            ${e.registerUniforms(m).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${x}>;\n\n              var value = ${_}(${p});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${x-1}u; j++) {\n                  offsets[j] = offset / ${ce("uniforms.kernelStrides","j",x)};\n                  offset -= offsets[j] * ${ce("uniforms.kernelStrides","j",x)};\n                }\n                offsets[${x-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-x}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${ce("uniforms.strides",`j - ${r-x}u`,x)}\n                    + offsets[j - ${r-x}u] - ${ce("uniforms.pads","j - 2u",T)};\n                  ${C}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`}},Eu=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Wc=e=>`${Eu(e)};${e.countIncludePad}`,Nc=e=>`${Eu(e)};${e.storageOrder};${e.dilations}`,Pu=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ou=(e,t,r,o)=>{let[i,u]=Au(t,o,r),a=V("x",t.dataType,t.dims.length),p=a.type.value,m="value += x_val;",h="";i.countIncludePad?h+=`value /= ${p}(uniforms.kernelSize);`:h+=`value /= ${p}(i32(uniforms.kernelSize) - pad);`;let[d,y,w,_,v]=Iu(u,i);d.push(...G(t.dims),...G(u));let x=["rank"];return{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(W.size(u)/64)},programUniforms:d}),getShaderSource:T=>Tu(T,a,t.dims.length,u.length,i,m,h,0,y,w,_,v)}},ku=e=>{let t=e.count_include_pad!==0,r=Pu(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let o={countIncludePad:t,...r,cacheKey:""};return{...o,cacheKey:Wc(o)}},Ru=(e,t)=>{Un(e.inputs),e.compute(Ou("AveragePool",e.inputs[0],!1,t))},Bu={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Du=e=>{let t=e.format;return{format:t,...Bu,cacheKey:t}},Mu=(e,t)=>{Un(e.inputs),e.compute(Ou("GlobalAveragePool",e.inputs[0],!0,t))},zu=(e,t,r,o)=>{let[i,u]=Au(t,o,r),a=`\n      value = max(x_val, value);\n    `,p="",m=V("x",t.dataType,t.dims.length),h=["rank"],[d,y,w,_,v]=Iu(u,i);return d.push(...G(t.dims),...G(u)),{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(W.size(u)/64)},programUniforms:d}),getShaderSource:x=>Tu(x,m,t.dims.length,u.length,i,a,p,-1e5,y,w,_,v)}},Uu=(e,t)=>{Un(e.inputs),e.compute(zu("MaxPool",e.inputs[0],!1,t))},Vu=e=>{let t=e.storage_order,r=e.dilations,o=Pu(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:t,dilations:r,...o,cacheKey:""};return{...i,cacheKey:Nc(i)}},Wu=e=>{let t=e.format;return{format:t,...Bu,cacheKey:t}},Nu=(e,t)=>{Un(e.inputs),e.compute(zu("GlobalMaxPool",e.inputs[0],!0,t))}});var Gc,Lc,Gu,Lu=Q(()=>{"use strict";dr();Ve();_e();Gc=(e,t,r)=>{let o=e===t,i=e<t&&r<0,u=e>t&&r>0;if(o||i||u)throw new Error("Range these inputs\' contents are invalid.")},Lc=(e,t,r,o)=>{let i=Math.abs(Math.ceil((t-e)/r)),u=[i],a=i,p=st(o),m=[{type:"uint32",data:a},{type:p,data:e},{type:p,data:r},...G(u)],h=d=>{let y=J("output",o,u.length),w=y.type.value,_=[{name:"outputSize",type:"u32"},{name:"start",type:w},{name:"delta",type:w}];return`\n        ${d.registerUniforms(_).declareVariables(y)}\n        ${d.mainStart()}\n        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${w}(global_idx) * uniforms.delta;\n      }`};return{name:"Range",shaderCache:{hint:`${o}`},getShaderSource:h,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:m})}},Gu=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),lr.webgpu.validateInputContent&&Gc(t,r,o),e.compute(Lc(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var Fc,jc,qc,Kc,Yc,Zc,Xc,Jc,Qc,ep,tp,Fu,rp,np,op,ip,ap,ju,qu,Ku=Q(()=>{"use strict";Ce();Ye();_e();Fc=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},jc=(e,t,r)=>{t.every(i=>i>=0&&i<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((i,u)=>o[i]=e[u]),o},qc=(e,t,r,o,i,u)=>{let[a,p,m]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(d=>u.push(d));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(p>0&&e.length>p&&e[p].dims.length>0){if(e[p].getFloat32Array().forEach(d=>o.push(d)),o.length!==0&&o.length!==h&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Fc(o,t),t.axes.length>0&&jc(o,t.axes,h).forEach((d,y)=>o[y]=d)}if(m>0&&e.length>m&&(e[m].getBigInt64Array().forEach(d=>i.push(Number(d))),i.length!==h||r>=18&&i.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(i.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof i<"u"&&o.length>0&&i.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},Kc=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Yc=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Zc=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),i=e.length===0?o:e.slice();return t.length>0?(t.forEach((u,a)=>{o[u]=i[a],o[a+r]=i[t.length+a]}),o):i},Xc=(e,t,r,o)=>{let i=[];if(r.length>0)if(o.length>0){if(e.forEach(u=>i.push(u)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((u,a)=>i[u]=r[a])}else r.forEach(u=>i.push(u));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");i=e.map((u,a)=>Math.round(u*t[a]))}return i},Jc=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(u=>t[u]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(u=>t[u]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach(u=>t[u]=o),r.axes.forEach(u=>i[u]=Math.round(e[u]*t[u]))):(t.fill(o,0,t.length),i.forEach((u,a)=>i[a]=Math.round(u*t[a]))),i},Qc=(e,t,r,o,i)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${ce("uniforms.scales","i",o)};\n        var roi_low = ${ce("uniforms.roi","i",i)};\n        var roi_hi = ${ce("uniforms.roi",`i + ${t.length}`,i)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${ce("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${ce("uniforms.output_shape","i",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,ep=(e,t,r,o,i,u,a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${ce("uniforms.scales","i",i)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${ce("uniforms.roi","i",u)};\n          var roi_hi = ${ce("uniforms.roi",`i + ${r.length}`,u)};\n          var input_shape_i = ${ce("uniforms.input_shape","i",r.length)};\n          var output_shape_i = ${ce("uniforms.output_shape","i",o.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,tp=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${ce("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,Fu=(e,t,r,o)=>e.rank>o?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",r,"batch")};\n`:"",rp=(e,t,r,o,i)=>{let[a,p,m,h]=r.length===2?[-1,0,1,-1]:[0,2,3,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",p,`max(0, min(row, ${r[p]} - 1))`)};\n      ${e.indicesSet("input_indices",m,`max(0, min(col, ${r[m]} - 1))`)};\n      ${Fu(e,h,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${d} = originalIndices[${p}];\n      var col:${d} = originalIndices[${m}];\n      ${o?`if (row < 0 || row > (${r[p]} - 1) || col < 0 || col > (${r[m]} - 1)) {\n        return ${i};\n      }`:""};\n      row = max(0, min(row, ${r[p]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${h}])`:"0"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${d} = getInputValue(batch, channel, row1, col1);\n      var x12: ${d} = getInputValue(batch, channel, row1, col2);\n      var x21: ${d} = getInputValue(batch, channel, row2, col1);\n      var x22: ${d} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${d} = abs(row - ${d}(row1));\n      var dx2: ${d} = abs(${d}(row2) - row);\n      var dy1: ${d} = abs(col - ${d}(col1));\n      var dy2: ${d} = abs(${d}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},np=(e,t,r,o,i,u,a,p,m,h)=>{let d=r.length===2,y=!0,[w,_]=d?[0,1]:y?[2,3]:[1,2],v=e.type.value,x=T=>{let C=T===w?"row":"col";return`\n      fn ${C}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${v} {\n        var output_index = ${t.indicesGet("output_indices",T)};\n        var originalIdx: ${v} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[T]},\n        ${o[T]}, ${r[T]}, ${u[T]}, ${u[T]} + ${r.length});\n        var fractOriginalIdx: ${v} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${p} && (originalIdx < 0 || originalIdx > (${r[T]} - 1))) {\n          return ${m};\n        }\n        var data: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${C}: ${v} = originalIdx + ${v}(i);\n          if (${C} < 0 || ${C} >= ${r[T]}) {\n            ${(()=>h?`coefs[i + 1] = 0.0;\n                        continue;`:p?`return ${m};`:`${C} = max(0, min(${C}, ${r[T]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",T,`u32(${C})`)};\n          data[i + 1] = ${T===w?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${x(w)};\n    ${x(_)};\n  fn getCubicInterpolationCoefs(s: ${v}) -> array<${v}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${v} = 1.0 - absS;\n    var twoMinusAbsS: ${v} = 2.0 - absS;\n    var onePlusAbsS: ${v} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${v}, 4>, coefs: array<${v}, 4>) -> ${v} {\n    var coefsSum: ${v} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${v} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},op=(e,t,r,o,i)=>{let[a,p,m,h,d]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],y=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${y} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",p,`max(0, min(depth, ${r[p]} - 1))`)};\n      ${e.indicesSet("input_indices",m,`max(0, min(height, ${r[m]} - 1))`)};\n      ${e.indicesSet("input_indices",h,`max(0, min(width, ${r[h]} - 1))`)};\n      ${Fu(e,d,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${y} = originalIndices[${p}];\n      var height:${y} = originalIndices[${m}];\n      var width:${y} = originalIndices[${h}];\n      ${o?`if (depth < 0 || depth > (${r[p]} - 1) || height < 0 || height > (${r[m]} - 1) || width < 0 || (width > ${r[h]} - 1)) {\n      return ${i};\n        }`:""};\n\n    depth = max(0, min(depth, ${r[p]} - 1));\n      height = max(0, min(height, ${r[m]} - 1));\n      width = max(0, min(width, ${r[h]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${d}])`:"0"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${y} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${y} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${y} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${y} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${y} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${y} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${y} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${y} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${y} = abs(depth - ${y}(depth1));\n      var dx2: ${y} = abs(${y}(depth2) - depth);\n      var dy1: ${y} = abs(height - ${y}(height1));\n      var dy2: ${y} = abs(${y}(height2) - height);\n      var dz1: ${y} = abs(width - ${y}(width1));\n      var dz2: ${y} = abs(${y}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},ip=(e,t,r,o,i,u)=>{let a=e.dims,p=Zc(u,t.axes,a.length),m=Xc(a,o,i,t.axes),h=o.slice();o.length===0&&(h=a.map((S,E)=>S===0?1:m[E]/S),t.keepAspectRatioPolicy!=="stretch"&&(m=Jc(a,h,t)));let d=J("output",e.dataType,m.length),y=V("input",e.dataType,a.length),w=W.size(m),_=a.length===m.length&&a.every((S,E)=>S===m[E]),v=t.coordinateTransformMode==="tf_crop_and_resize",x=t.extrapolationValue,T=y.type.value,C=S=>`\n      ${_?"":`\n      ${Kc(t.coordinateTransformMode,T)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${tp(y,a)};\n              ${Yc(t.nearestMode,r,T)};\n              ${ep(y,d,a,m,h.length,p.length,v)};\n              `;case"linear":return`\n              ${Qc(d,a,m,h.length,p.length)};\n              ${(()=>{if(a.length===2||a.length===4)return`${rp(y,d,a,v,x)}`;if(a.length===3||a.length===5)return`${op(y,d,a,v,x)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(a.length===2||a.length===4)return`${np(y,d,a,m,h,p,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${S.registerUniform("output_size","u32").registerUniform("scales","f32",h.length).registerUniform("roi","f32",p.length).declareVariables(y,d)}\n      ${S.mainStart()}\n        ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${_?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var input_indices: ${y.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${y.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${a.length===2||a.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${h.length>0?h:""}|${i.length>0?i:""}|${p.length>0?p:""}|${_}|${a}`,inputDependencies:["rank"]},getShaderSource:C,getRunData:()=>({outputs:[{dims:m,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:"uint32",data:w},{type:"float32",data:h},{type:"float32",data:p},...G(a),...G(m)]})}},ap=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},ju=(e,t)=>{let r=[],o=[],i=[],u=ap(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");qc(e.inputs,t,u,r,o,i),e.compute(ip(e.inputs[0],t,u,r,o,i),{inputs:[0]})},qu=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,i=e.cubicCoeffA,u=e.excludeOutside!==0,a=e.extrapolationValue,p=e.keepAspectRatioPolicy,m=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return xe({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:i,excludeOutside:u,extrapolationValue:a,keepAspectRatioPolicy:p,mode:m,nearestMode:h})}});var sp,up,Yu,Zu=Q(()=>{"use strict";Ve();Ce();_e();sp=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=t.dims[t.dims.length-1],u=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==u)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error("Beta must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error("Bias must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},up=(e,t,r,o)=>{let i=e[0].dims,u=W.size(i),a=i,p=u,m=i.slice(-1)[0],h=o?i.slice(0,-1).concat(1):[],d=e.length>3,y=e.length>4,w=o&&r>1,_=o&&r>2,v=r>3,x=He(m),T=[{type:"uint32",data:p},{type:"uint32",data:x},{type:"uint32",data:m},{type:"float32",data:t.epsilon}],C=E=>{let O=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],U=[V("x",e[0].dataType,e[0].dims,x),V("skip",e[1].dataType,e[1].dims,x),V("gamma",e[2].dataType,e[2].dims,x)];d&&U.push(V("beta",e[3].dataType,e[3].dims,x)),y&&U.push(V("bias",e[4].dataType,e[4].dims,x)),U.push(J("output",e[0].dataType,a,x)),w&&U.push(J("mean_output",1,h)),_&&U.push(J("inv_std_output",1,h)),v&&U.push(J("input_skip_bias_sum",e[0].dataType,a,x));let M=Ne(e[0].dataType);return`\n\n      ${E.registerUniforms(O).declareVariables(...U)}\n\n      ${E.mainStart()}\n        ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size / uniforms.hidden_size")}\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        let offset = global_idx * hidden_size_vectorized;\n        var sum = ${Ze("f32",x)};\n        var squareSum = ${Ze("f32",x)};\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${y?"bias[i]":"0.0"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${v?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${gt(M,x,"value")};\n          sum += f32_value;\n          squareSum += f32_value * f32_value;\n        }\n        let mean = ${ut("sum",x)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${ut("squareSum",x)} / f32(uniforms.hidden_size) - mean * mean + uniforms.epsilon);\n        ${w?"mean_output[global_idx] = mean;":""}\n        ${_?"inv_std_output[global_idx] = inv_std_dev;":""}\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${M}(mean)) * ${M}(inv_std_dev) * gamma[i] + ${d?"beta[i]":"0.0"};\n        }\n      }`},S=[{dims:a,dataType:e[0].dataType}];return r>1&&S.push({dims:h,dataType:1}),r>2&&S.push({dims:h,dataType:1}),r>3&&S.push({dims:i,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${x};${w};${_};${v}`,inputDependencies:e.map((E,O)=>"type")},getShaderSource:C,getRunData:()=>({outputs:S,dispatchGroup:{x:Math.ceil(p/m/64)},programUniforms:T})}},Yu=(e,t)=>{sp(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(up(e.inputs,t,e.outputCount,!1),{outputs:o})}});var lp,Vn,dp,Xu,cp,pp,Ju,Qu,el=Q(()=>{"use strict";Ve();Ce();Ye();_e();lp=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Vn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},dp=(e,t)=>{if(e.length>1){let r=Vn(e,1),o=Vn(e,2),i=Vn(e,3);return i.length===0&&(i=[...Array(e[0].dims.length).keys()]),xe({starts:r,ends:o,axes:i})}else return t},Xu=(e,t,r,o,i)=>{let u=e;return e<0&&(u+=r[o[t]]),i[t]<0?Math.max(0,Math.min(u,r[o[t]]-1)):Math.max(0,Math.min(u,r[o[t]]))},cp=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${ce("uniforms.input_shape","i",r.length)};\n            let steps_i = ${ce("uniforms.steps","i",r.length)};\n            let signs_i = ${ce("uniforms.signs","i",r.length)};\n            let starts_i = ${ce("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,pp=(e,t)=>{let r=e[0].dims,o=W.size(r),i=t.axes.length>0?W.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],u=Vn(e,4);u.forEach(C=>C!==0||(()=>{throw new Error("step cannot be 0")})),u.length===0&&(u=Array(i.length).fill(1));let a=t.starts.map((C,S)=>Xu(C,S,r,i,u)),p=t.ends.map((C,S)=>Xu(C,S,r,i,u));if(i.length!==a.length||i.length!==p.length)throw new Error("start, ends and axes should have the same number of elements");if(i.length!==r.length)for(let C=0;C<r.length;++C)i.includes(C)||(a.splice(C,0,0),p.splice(C,0,r[C]),u.splice(C,0,1));let m=u.map(C=>Math.sign(C));u.forEach((C,S,E)=>{if(C<0){let O=(p[S]-a[S])/C,U=a[S],M=U+O*u[S];a[S]=M,p[S]=U,E[S]=-C}});let h=r.slice(0);i.forEach((C,S)=>{h[C]=Math.ceil((p[C]-a[C])/u[C])});let d={dims:h,dataType:e[0].dataType},y=J("output",e[0].dataType,h.length),w=V("input",e[0].dataType,e[0].dims.length),_=W.size(h),v=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:m.length},{name:"steps",type:"u32",length:u.length}],x=[{type:"uint32",data:_},{type:"uint32",data:a},{type:"int32",data:m},{type:"uint32",data:u},...G(e[0].dims),...G(h)],T=C=>`\n      ${C.registerUniforms(v).declareVariables(w,y)}\n        ${cp(w,y,r)}\n        ${C.mainStart()}\n          ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${y.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${y.setByOffset("global_idx",w.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${m.length}_${a.length}_${u.length}`,inputDependencies:["rank"]},getShaderSource:T,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:x})}},Ju=(e,t)=>{lp(e.inputs,t);let r=dp(e.inputs,t);e.compute(pp(e.inputs,r),{inputs:[0]})},Qu=e=>{let t=e.starts,r=e.ends,o=e.axes;return xe({starts:t,ends:r,axes:o})}});var mp,fp,tl,rl,nl=Q(()=>{"use strict";Ce();Ye();_e();mp=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},fp=(e,t)=>{let r=e.dims,o=W.size(r),i=64,u=t.axis;if(u<0&&(u=r.length+u),u<r.length-1)throw new Error("softmax only supports last axis for now.");let a=r[u],p=o/a,m=He(a),h=a/m,d=(T,C)=>C===4?`max(max(${T}.x, ${T}.y), max(${T}.z, ${T}.w))`:C===2?`max(${T}.x, ${T}.y)`:C===3?`max(max(${T}.x, ${T}.y), ${T}.z)`:T,y=V("x",e.dataType,e.dims,m),w=J("result",e.dataType,e.dims,m),_=y.type.value,v=Ne(e.dataType)==="f32"?`var threadMax = ${_}(-3.402823e+38f);`:`var threadMax = ${_}(-65504.0h);`,x=T=>`\n      var<workgroup> rowMaxShared : ${_};\n      var<workgroup> rowSumShared : ${_};\n      var<workgroup> threadShared : array<${_}, ${i}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${T.registerUniform("packedCols","i32").declareVariables(y,w)}\n      ${T.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${i};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${v}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${_}(${d("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${_}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${_}(${ut("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:p},programUniforms:[{type:"uint32",data:h}]}),getShaderSource:x}},tl=(e,t)=>{mp(e.inputs),e.compute(fp(e.inputs[0],t))},rl=e=>xe({axis:e.axis})});var hp,gp,yp,bp,wp,ol,il,al=Q(()=>{"use strict";Ce();Ye();_e();hp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},gp=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),o=r.length),xe({numOutputs:o,axis:t.axis,splitSizes:r})},yp=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${ce("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,bp=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let i=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(i):o===0?r.push(`if (output_number == ${o}u) { ${i} }`):o===t-1?r.push(`else { ${i} }`):r.push(`else if (output_number == ${o}) { ${i} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},wp=(e,t)=>{let r=e[0].dims,o=W.size(r),i=e[0].dataType,u=W.normalizeAxis(t.axis,r.length),a=new Array(t.numOutputs),p=V("input",i,r),m=new Array(t.numOutputs),h=[],d=[],y=0,w=[{type:"uint32",data:o}];for(let v=0;v<t.numOutputs;v++){y+=t.splitSizes[v],m[v]=y;let x=r.slice();x[t.axis]=t.splitSizes[v],d.push(x),a[v]=J(`output${v}`,i,x),h.push({dims:d[v],dataType:e[0].dataType})}w.push({type:"uint32",data:m}),w.push(...G(r)),d.forEach(v=>w.push(...G(v)));let _=v=>`\n  ${v.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",m.length).declareVariables(p,...a)}\n  ${yp(m.length)}\n  ${bp(a)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${p.offsetToIndices("global_idx")};\n    var index = ${p.indicesGet("indices",u)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${ce("uniforms.size_in_split_axis","output_number - 1u",m.length)};\n      ${p.indicesSet("indices",u,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:h,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:w})}},ol=(e,t)=>{hp(e.inputs);let r=e.inputs.length===1?t:gp(e.inputs,t);e.compute(wp(e.inputs,r),{inputs:[0]})},il=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return xe({axis:t,numOutputs:o,splitSizes:r})}});var sl,vp,$p,_p,ul,ll=Q(()=>{"use strict";Ve();Ce();_e();sl=e=>Array.from(e.getBigInt64Array(),Number),vp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(sl(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},$p=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},_p=e=>{let t=e[0].dims,r=sl(e[1]),o=$p(t,r),i=W.size(o),u=e[0].dataType,a=V("input",u,t.length),p=J("output",u,o.length),m=h=>`\n      const inputShape = ${a.indices(...t)};\n      ${h.registerUniform("output_size","u32").declareVariables(a,p)}\n      ${h.mainStart()}\n      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${p.offsetToIndices("global_idx")};\n      var input_indices: ${a.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${p.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${a.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${p.setByOffset("global_idx",a.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:"uint32",data:i},...G(e[0].dims),...G(o)]}),getShaderSource:m}},ul=e=>{vp(e.inputs),e.compute(_p(e.inputs),{inputs:[0]})}});var Sp,xp,dl,cl=Q(()=>{"use strict";Ve();Ce();_e();Sp=(e,t,r,o,i)=>{let u=J("output_data",i,r.length,4),a=V("a_data",t[1].dataType,t[1].dims.length,4),p=V("b_data",t[2].dataType,t[2].dims.length,4),m=V("c_data",t[0].dataType,t[0].dims.length,4),h,d=(y,w,_)=>`select(${w}, ${y}, ${_})`;if(!o)h=u.setByOffset("global_idx",d(a.getByOffset("global_idx"),p.getByOffset("global_idx"),m.getByOffset("global_idx")));else{let y=(w,_,v="")=>{let x=`a_data[index_a${_}][component_a${_}]`,T=`b_data[index_b${_}][component_b${_}]`,C=`bool(c_data[index_c${_}] & ${4278190080>>>(3-_)*8}u)`;return`\n            let output_indices${_} = ${u.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_b${_} = ${p.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_c${_} = ${m.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            ${w}[${_}] = ${v}(${d(x,T,C)});\n          `};i===9?h=`\n            var data = vec4<u32>(0);\n            ${y("data",0,"u32")}\n            ${y("data",1,"u32")}\n            ${y("data",2,"u32")}\n            ${y("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:h=`\n            ${y("output_data[global_idx]",0)}\n            ${y("output_data[global_idx]",1)}\n            ${y("output_data[global_idx]",2)}\n            ${y("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(m,a,p,u)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${h}\n      }`},xp=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,i=e[1].dataType,u=!(W.areEqual(t,r)&&W.areEqual(r,o)),a=t,p=W.size(t);if(u){let h=vt.calcShape(vt.calcShape(t,r,!1),o,!1);if(!h)throw new Error("Can\'t perform where op on the given tensors");a=h,p=W.size(a)}let m=Math.ceil(p/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:h=>Sp(h,e,a,u,i),getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:"uint32",data:m},...G(o),...G(t),...G(r),...G(a)]})}},dl=e=>{e.compute(xp(e.inputs))}});var pl,ml=Q(()=>{"use strict";Da();xo();Ua();Wa();$s();ks();Ds();Eo();Ys();Js();nu();au();lu();pu();hu();yu();wu();Oo();Su();Cu();Hu();Lu();In();Ku();Zu();el();nl();al();ll();pr();Co();cl();pl=new Map([["Abs",[Na]],["Acos",[Ha]],["Acosh",[Ga]],["Add",[_s]],["ArgMax",[Ba,So]],["ArgMin",[Ra,So]],["Asin",[La]],["Asinh",[Fa]],["Atan",[ja]],["Atanh",[qa]],["Attention",[Ma]],["AveragePool",[Ru,ku]],["BatchNormalization",[za]],["BiasAdd",[Va]],["BiasSplitGelu",[vs]],["Cast",[Ya,Ka]],["Ceil",[Xa]],["Clip",[Za]],["Concat",[Rs,Bs]],["Conv",[Ro,ko]],["ConvTranspose",[Ks,qs]],["Cos",[Ja]],["Cosh",[Qa]],["CumSum",[Zs,Xs]],["Div",[Ss]],["Einsum",[tu,ru]],["Elu",[es,Pn]],["Equal",[xs]],["Erf",[ts]],["Exp",[rs]],["Expand",[iu]],["Floor",[ns]],["FusedConv",[Ro,ko]],["Gather",[uu,su]],["GatherElements",[cu,du]],["Gelu",[os]],["Gemm",[fu,mu]],["GlobalAveragePool",[Mu,Du]],["GlobalMaxPool",[Nu,Wu]],["Greater",[Ts]],["GreaterOrEqual",[Ps]],["HardSigmoid",[ps,cs]],["InstanceNormalization",[gu]],["LayerNormalization",[bu]],["LeakyRelu",[is,Pn]],["Less",[Es]],["LessOrEqual",[Os]],["Log",[ws]],["MatMul",[Ws]],["MaxPool",[Uu,Vu]],["Mul",[Cs]],["MultiHeadAttention",[_u,$u]],["Neg",[ss]],["Not",[as]],["Pad",[xu]],["Pow",[As]],["Range",[Gu]],["Reciprocal",[us]],["ReduceMin",[Ia]],["ReduceMean",[_a]],["ReduceMax",[Aa]],["ReduceSum",[Ea]],["ReduceProd",[Ta]],["ReduceL1",[Sa]],["ReduceL2",[xa]],["ReduceLogSum",[Oa]],["ReduceLogSumExp",[Ca]],["ReduceSumSquare",[Pa]],["Relu",[ls]],["Resize",[ju,qu]],["Sigmoid",[ds]],["Sin",[ms]],["Sinh",[fs]],["Slice",[Ju,Qu]],["SkipLayerNormalization",[Yu]],["Split",[ol,il]],["Sqrt",[hs]],["Softmax",[tl,rl]],["Sub",[Is]],["Tan",[gs]],["Tanh",[ys]],["ThresholdedRelu",[bs,Pn]],["Tile",[ul]],["Transpose",[la,da]],["Where",[dl]]])});var Wn,fl=Q(()=>{"use strict";dr();zt();_e();Wn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,i,u){Yt(t.programInfo.name);let a=this.backend.device,p=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2),p.setPipeline(t.computePipeline);let m=[];for(let d of r)m.push({binding:m.length,resource:{buffer:d.buffer}});for(let d of o)m.push({binding:m.length,resource:{buffer:d.buffer}});u&&m.push({binding:m.length,resource:u});let h=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:m,label:t.programInfo.name});p.setBindGroup(0,h),p.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Zt(t.programInfo.name)}dispose(){}build(t,r){Yt(t.name);let o=this.backend.device,i=[];o.features.has("shader-f16")&&i.push("enable f16;");let u=sa(r),a=t.getShaderSource(u),p=`${i.join(`\n`)}\n${u.additionalImplementations}\n${a}`,m=o.createShaderModule({code:p,label:t.name});De("verbose",()=>`[WebGPU] ${t.name} shader code: ${p}`);let h=o.createComputePipeline({compute:{module:m,entryPoint:"main"},layout:"auto",label:t.name});return Zt(t.name),{programInfo:t,computePipeline:h}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,i=typeof t=="number"?1:t.z||1,u=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=u&&o<=u&&i<=u)return[r,o,i];let a=r*o*i,p=Math.ceil(Math.sqrt(a));if(p>u){if(p=Math.ceil(Math.cbrt(a)),p>u)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[p,p,p]}else return[p,p,1]}}});var Cp,Ap,Nn,hl=Q(()=>{"use strict";dr();Ve();zt();ra();aa();ml();fl();Cp=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let i=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${i}`);break}case"rank":{let u=e[o].dims.length;r.push(`${i};${u}`);break}case"dims":{let u=e[o].dims.join(",");r.push(`${i};${u}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},Ap=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${Cp(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},Nn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let o=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(i),this.gpuDataManager=ia(this),this.programManager=new Wn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,ea(t.logLevel,!!t.debug),this.device.onuncapturederror=u=>{u.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${u.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Yt(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),o=this.pendingQueries.get(t);for(let i=0;i<r.length/2;i++){let u=o[i],a=u.kernelId,p=this.kernels.get(a),m=p.kernelType,h=p.kernelName,d=u.programName,y=u.inputTensorViews,w=u.outputTensorViews,_=r[i*2],v=r[i*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=_);let x=Number(_-this.queryTimeBase),T=Number(v-this.queryTimeBase);if(!Number.isSafeInteger(x)||!Number.isSafeInteger(T))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:y.map(C=>({dims:C.dims,dataType:st(C.dataType)})),outputsMetadata:w.map(C=>({dims:C.dims,dataType:st(C.dataType)})),kernelId:a,kernelType:m,kernelName:h,programName:d,startTime:x,endTime:T});else{let C="";y.forEach((E,O)=>{C+=`input[${O}]: [${E.dims}] | ${st(E.dataType)}, `});let S="";w.forEach((E,O)=>{S+=`output[${O}]: [${E.dims}] | ${st(E.dataType)}, `}),console.log(`[profiling] kernel "${a}|${m}|${h}|${d}" ${C}${S}execution time: ${T-x} ns`)}mo("GPU",`${d}::${_}::${v}`)}t.unmap(),this.pendingQueries.delete(t)}),Zt()}run(t,r,o,i,u){Yt(t.name);let a=[];for(let S=0;S<r.length;++S){let E=this.gpuDataManager.get(r[S].data);if(!E)throw new Error(`no GPU data for input: ${r[S].data}`);a[S]=E}let{outputs:p,dispatchGroup:m,programUniforms:h}=t.getRunData(r),d=o.length===0?p.map((S,E)=>E):o;if(d.length!==p.length)throw new Error(`Output size ${d.length} must be equal to ${p.length}.`);let y=[],w=[];for(let S=0;S<p.length;++S){if(!Number.isInteger(d[S])||d[S]<-3||d[S]>=p.length)throw new Error(`Invalid output index: ${d[S]}`);if(d[S]===-3)continue;let E=d[S]===-1,O=d[S]===-2,U=E||O?u(p[S].dataType,p[S].dims):i(d[S],p[S].dataType,p[S].dims),M=this.gpuDataManager.get(U.data);if(!M)throw new Error(`no GPU data for output: ${U.data}`);if(E&&this.temporaryData.push(M),O){let N=this.kernelPersistentData.get(this.currentKernelId);N||(N=[],this.kernelPersistentData.set(this.currentKernelId,N)),N.push(M)}y.push(U),w.push(M)}let _;if(h){let S=0,E=[];h.forEach(N=>{let Y=typeof N.data=="number"?[N.data]:N.data;if(Y.length===0)return;let se=N.type==="float16"?2:4,B,te;N.type==="float16"?(te=Y.length>4?16:Y.length>2?8:Y.length*se,B=Y.length>4?16:se*Y.length):(te=Y.length<=2?Y.length*se:16,B=16),S=Math.ceil(S/te)*te,E.push(S);let Pe=N.type==="float16"?8:4;S+=Y.length>4?Math.ceil(Y.length/Pe)*B:Y.length*se});let O=16;S=Math.ceil(S/O)*O;let U=new ArrayBuffer(S);h.forEach((N,Y)=>{let se=E[Y],B=typeof N.data=="number"?[N.data]:N.data;N.type==="int32"?new Int32Array(U,se,B.length).set(B):N.type==="uint32"?new Uint32Array(U,se,B.length).set(B):N.type==="float16"?new Uint16Array(U,se,B.length).set(B):new Float32Array(U,se,B.length).set(B)});let M=this.gpuDataManager.create(S,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(M.buffer,0,U,0,S),this.gpuDataManager.release(M.id),_={offset:0,size:S,buffer:M.buffer}}let v=this.programManager.normalizeDispatchGroupSize(m),x=v[1]===1&&v[2]===1,T=Ap(t,r,x),C=this.programManager.getArtifact(T);if(C||(C=this.programManager.build(t,v),this.programManager.setArtifact(T,C),De("info",()=>`[artifact] key: ${T}, programName: ${t.name}`)),De("info",()=>`[ProgramManager] run "${t.name}" (key=${T}) with ${v[0]}x${v[1]}x${v[2]}`),this.queryType!=="none"){let S={kernelId:this.currentKernelId,programName:C.programInfo.name,inputTensorViews:r,outputTensorViews:y};this.pendingKernels.push(S)}return this.programManager.run(C,a,w,v,_),Zt(t.name),y}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,i){let u=pl.get(t);if(!u)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:i,kernelEntry:u[0],attributes:[u[1],o]};this.kernels.set(r,a)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let i=this.kernels.get(t);if(!i)throw new Error(`kernel not created: ${t}`);let u=i.kernelType,a=i.kernelName,p=i.kernelEntry,m=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${u}] ${a}" is not allowed to be called recursively`);this.currentKernelId=t,m[0]&&(m[1]=m[0](m[1]),m[0]=void 0),De("info",()=>`[WebGPU] Start to run kernel "[${u}] ${a}"...`);let h=this.env.debug;this.temporaryData=[];try{return h&&this.device.pushErrorScope("validation"),p(r,m[1]),0}catch(d){return o.push(Promise.resolve(`[WebGPU] Kernel "[${u}] ${a}" failed. ${d}`)),1}finally{h&&o.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${u}] ${a}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,i){let u=this.sessionExternalDataMapping.get(t);u||(u=new Map,this.sessionExternalDataMapping.set(t,u));let a=u.get(r),p=this.gpuDataManager.registerExternalBuffer(o,i,a?.[1]);return u.set(r,[p,o]),p}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let i=await go(this,t,r);return ta(i.buffer,o)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||this.env.wasm.trace)&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}onRunStart(){this.setQueryType()}}});var gl={};hn(gl,{init:()=>Ip});var Nr,Vo,Ip,yl=Q(()=>{"use strict";Ve();hl();zt();Ce();Nr=class e{constructor(t,r,o,i){this.module=t;this.dataType=r;this.data=o;this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=W.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=W.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=W.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(W.size(t)!==W.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Vo=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let i=t.HEAPU32,u=o>>>2;this.opKernelContext=i[u++];let a=i[u++];this.outputCount=i[u++],this.customDataOffset=i[u++],this.customDataSize=i[u++];let p=[];for(let m=0;m<a;m++){let h=i[u++],d=i[u++],y=i[u++],w=[];for(let _=0;_<y;_++)w.push(i[u++]);p.push(new Nr(t,h,d,w))}this.inputs=p}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(p=>typeof p=="number"?this.inputs[p]:p)??this.inputs,i=r?.outputs??[],u=(p,m,h)=>new Nr(this.module,m,this.output(p,h),h),a=(p,m)=>{let h=Mr(p);if(!h)throw new Error(`Unsupported data type: ${p}`);let d=h*W.size(m);return new Nr(this.module,p,this.backend.gpuDataManager.create(d).id,m)};return this.backend.run(t,o,i,u,a)}output(t,r){let o=this.module.stackSave();try{let i=this.module.stackAlloc((1+r.length)*4),u=i>>2;this.module.HEAPU32[u++]=r.length;for(let a=0;a<r.length;a++)this.module.HEAPU32[u++]=r[a];return this.module._JsepOutput(this.opKernelContext,t,i)}catch(i){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(o)}}},Ip=async(e,t,r)=>{let o=e.jsepInit;if(!o)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");let i=new Nn;await i.initialize(t,r),o(i,u=>i.alloc(u),u=>i.free(u),(u,a,p,m=!1)=>{if(m)De("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${u}, dst=${a}, size=${p}`),i.memcpy(u,a);else{De("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${u}, gpuDataId=${a}, size=${p}`);let h=e.HEAPU8.subarray(u>>>0,(u>>>0)+p);i.upload(a,h)}},async(u,a,p)=>{De("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${u}, dataOffset=${a}, size=${p}`),await i.download(u,()=>e.HEAPU8.subarray(a>>>0,(a>>>0)+p))},(u,a,p)=>i.createKernel(u,a,p,e.UTF8ToString(e._JsepGetNodeName(a))),u=>i.releaseKernel(u),(u,a,p,m)=>{De("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${p}, kernel=${u}, contextDataOffset=${a}`);let h=new Vo(e,i,a);return i.computeKernel(u,h,m)})}});var Pi;Pi=vi();var Nl=Ii(),so,uo=!1,gn=!1,Ei=!1,Hl=e=>{if(e===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+e+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+e+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Gl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ll=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Oi=async e=>{if(uo)return Promise.resolve();if(gn)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Ei)throw new Error("previous call to \'initializeWebAssembly()\' failed.");gn=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,i=Hl(r),u=o&&Gl(),a=e.wasmPaths,p=typeof a=="string"?a:void 0,m=Ll(u,i),h=typeof a=="object"?a[m]:void 0,d=!1,y=[];if(t>0&&y.push(new Promise(w=>{setTimeout(()=>{d=!0,w()},t)})),y.push(new Promise((w,_)=>{let v=i?Nl:Pi,x={locateFile:(T,C)=>{if(i&&T.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Ti()],{type:"text/javascript"}));if(T.endsWith(".wasm")){if(h)return h;let S=p??C;return m==="ort-wasm-simd.wasm"?S+"ort-wasm-simd.jsep.wasm":m==="ort-wasm-simd-threaded.wasm"?S+"ort-wasm-simd-threaded.jsep.wasm":S+m}return C+T}};if(i)if(x.numThreads=r,typeof Blob>"u")x.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let T=`var ortWasmThreaded=${v.toString()};`;x.mainScriptUrlOrBlob=new Blob([T],{type:"text/javascript"})}v(x).then(T=>{gn=!1,uo=!0,so=T,w()},T=>{gn=!1,Ei=!0,_(T)})})),await Promise.race(y),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ue=()=>{if(uo&&so)return so;throw new Error("WebAssembly is not initialized yet.")};var We=(e,t)=>{let r=Ue(),o=r.lengthBytesUTF8(e)+1,i=r._malloc(o);return r.stringToUTF8(e,i,o),t.push(i),i},Dr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([i,u])=>{let a=t?t+i:i;if(typeof u=="object")Dr(u,a+".",r,o);else if(typeof u=="string"||typeof u=="number")o(a,u.toString());else if(typeof u=="boolean")o(a,u?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof u}`)})},Be=e=>{let t=Ue(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let i=t.HEAP32[o/4],u=t.HEAPU32[o/4+1],a=u?t.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(r)}};var ki=e=>{let t=Ue(),r=0,o=[],i=e||{};try{if(e?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(i.terminate=!1);let u=0;return e?.tag!==void 0&&(u=We(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,u),r===0&&Be("Can\'t create run options."),e?.extra!==void 0&&Dr(e.extra,"",new WeakSet,(a,p)=>{let m=We(a,o),h=We(p,o);t._OrtAddRunConfigEntry(r,m,h)!==0&&Be(`Can\'t set a run config entry: ${a} - ${p}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(a=>t._free(a)),u}};var Fl=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},jl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},ql=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Kl=(e,t,r)=>{for(let o of t){let i=typeof o=="string"?o:o.name;switch(i){case"webnn":if(i="WEBNN",typeof o!="string"){let a=o;if(a?.deviceType){let p=We("deviceType",r),m=We(a.deviceType,r);Ue()._OrtAddSessionConfigEntry(e,p,m)!==0&&Be(`Can\'t set a session config entry: \'deviceType\' - ${a.deviceType}.`)}if(a?.numThreads){let p=a.numThreads;(typeof p!="number"||!Number.isInteger(p)||p<0)&&(p=0);let m=We("numThreads",r),h=We(p.toString(),r);Ue()._OrtAddSessionConfigEntry(e,m,h)!==0&&Be(`Can\'t set a session config entry: \'numThreads\' - ${a.numThreads}.`)}if(a?.powerPreference){let p=We("powerPreference",r),m=We(a.powerPreference,r);Ue()._OrtAddSessionConfigEntry(e,p,m)!==0&&Be(`Can\'t set a session config entry: \'powerPreference\' - ${a.powerPreference}.`)}}break;case"webgpu":if(i="JS",typeof o!="string"){let a=o;if(a?.preferredLayout){if(a.preferredLayout!=="NCHW"&&a.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${a.preferredLayout}`);let p=We("preferredLayout",r),m=We(a.preferredLayout,r);Ue()._OrtAddSessionConfigEntry(e,p,m)!==0&&Be(`Can\'t set a session config entry: \'preferredLayout\' - ${a.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let u=We(i,r);Ue()._OrtAppendExecutionProvider(e,u)!==0&&Be(`Can\'t append execution provider: ${i}.`)}},Ri=e=>{let t=Ue(),r=0,o=[],i=e||{};ql(i);try{let u=Fl(i.graphOptimizationLevel??"all"),a=jl(i.executionMode??"sequential"),p=typeof i.logId=="string"?We(i.logId,o):0,m=i.logSeverityLevel??2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);let h=i.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let d=typeof i.optimizedModelFilePath=="string"?We(i.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(u,!!i.enableCpuMemArena,!!i.enableMemPattern,a,!!i.enableProfiling,0,p,m,h,d),r===0&&Be("Can\'t create session options."),i.executionProviders&&Kl(r,i.executionProviders,o),i.freeDimensionOverrides)for(let[y,w]of Object.entries(i.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof w!="number"||!Number.isInteger(w)||w<0)throw new Error(`free dimension override value must be a non-negative integer: ${w}`);let _=We(y,o);t._OrtAddFreeDimensionOverride(r,_,w)!==0&&Be(`Can\'t set a free dimension override: ${y} - ${w}.`)}return i.extra!==void 0&&Dr(i.extra,"",new WeakSet,(y,w)=>{let _=We(y,o),v=We(w,o);t._OrtAddSessionConfigEntry(r,_,v)!==0&&Be(`Can\'t set a session config entry: ${y} - ${w}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(a=>t._free(a)),u}};Ve();var Di=async e=>{if(typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let r=(void 0)(e),o=[];for await(let i of r)o.push(i);return new Uint8Array(Buffer.concat(o))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let i=t.body.getReader(),u;try{u=new ArrayBuffer(o)}catch(p){if(p instanceof RangeError){let m=Math.ceil(o/65536);u=new WebAssembly.Memory({initial:m,maximum:m}).buffer}else throw p}let a=0;for(;;){let{done:p,value:m}=await i.read();if(p)break;let h=m.byteLength;new Uint8Array(u,a,h).set(m),a+=h}return new Uint8Array(u,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)};var Tp=(e,t)=>{Ue()._OrtInit(e,t)!==0&&Be("Can\'t initialize onnxruntime.")},wl=async e=>{Tp(e.wasm.numThreads,zr(e.logLevel))},vl=async(e,t)=>{if(t==="webgpu"||t==="webnn"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\');if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");let o=(yl(),ur(gl)).init;await o(Ue(),e,r)}},Hr=new Map,Ep=e=>{let t=Ue(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Be("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Wo=e=>{let t=Ue(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},$l=async(e,t)=>{let r,o,i=Ue();Array.isArray(e)?[r,o]=e:e.buffer===i.HEAPU8.buffer?[r,o]=[e.byteOffset,e.byteLength]:[r,o]=Wo(e);let u=0,a=0,p=0,m=[],h=[],d=[];try{if([a,m]=Ri(t),t?.externalData&&i.mountExternalData){let C=[];for(let S of t.externalData){let E=typeof S=="string"?S:S.path;C.push(Di(typeof S=="string"?S:S.data).then(O=>{i.mountExternalData(E,O)}))}await Promise.all(C)}u=await i._OrtCreateSession(r,o,a),u===0&&Be("Can\'t create a session.");let[y,w]=Ep(u),_=[],v=[],x=[];for(let C=0;C<y;C++){let S=i._OrtGetInputName(u,C);S===0&&Be("Can\'t get an input name."),h.push(S),_.push(i.UTF8ToString(S))}for(let C=0;C<w;C++){let S=i._OrtGetOutputName(u,C);S===0&&Be("Can\'t get an output name."),d.push(S);let E=i.UTF8ToString(S);v.push(E);{let O=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[E]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);x.push(O)}}let T=null;return x.some(C=>C==="gpu-buffer")&&(p=i._OrtCreateBinding(u),p===0&&Be("Can\'t create IO binding."),T={handle:p,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map(C=>co(C))}),Hr.set(u,[u,h,d,T]),[u,_,v]}catch(y){throw h.forEach(w=>i._OrtFree(w)),d.forEach(w=>i._OrtFree(w)),p!==0&&i._OrtReleaseBinding(p),u!==0&&i._OrtReleaseSession(u),y}finally{i._free(r),a!==0&&i._OrtReleaseSessionOptions(a),m.forEach(y=>i._free(y)),i.unmountExternalData?.()}},_l=e=>{let t=Ue(),r=Hr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,i,u,a]=r;a&&t._OrtReleaseBinding(a.handle),t.jsepUnregisterBuffers?.(e),i.forEach(p=>t._OrtFree(p)),u.forEach(p=>t._OrtFree(p)),t._OrtReleaseSession(o),Hr.delete(e)},bl=(e,t,r,o,i)=>{if(!e){t.push(0);return}let u=Ue(),a=e[0],p=e[1],m=e[3],h,d;if(a==="string"&&m==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(m==="gpu-buffer"){let _=e[2].gpuBuffer,v=Mr(lo(a));d=p.reduce((x,T)=>x*T,1)*v,h=u.jsepRegisterBuffer(o,i,_,d)}else{let _=e[2];if(Array.isArray(_)){d=4*_.length,h=u._malloc(d),r.push(h);let v=h/4;for(let x=0;x<_.length;x++){if(typeof _[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);u.HEAPU32[v++]=We(_[x],r)}}else d=_.byteLength,h=u._malloc(d),r.push(h),u.HEAPU8.set(new Uint8Array(_.buffer,_.byteOffset,d),h)}let y=u.stackSave(),w=u.stackAlloc(4*p.length);try{let _=w/4;p.forEach(x=>u.HEAP32[_++]=x);let v=u._OrtCreateTensor(lo(a),h,d,w,p.length,co(m));v===0&&Be(`Can\'t create tensor for input/output. session=${o}, index=${i}.`),t.push(v)}finally{u.stackRestore(y)}},Sl=async(e,t,r,o,i,u)=>{let a=Ue(),p=Hr.get(e);if(!p)throw new Error(`cannot run inference. invalid session id: ${e}`);let[m,h,d,y]=p,w=t.length,_=o.length,v=0,x=[],T=[],C=[],S=[],E=a.stackSave(),O=a.stackAlloc(w*4),U=a.stackAlloc(w*4),M=a.stackAlloc(_*4),N=a.stackAlloc(_*4);try{[v,x]=ki(u);for(let ee=0;ee<w;ee++)bl(r[ee],T,S,e,t[ee]);for(let ee=0;ee<_;ee++)bl(i[ee],C,S,e,w+o[ee]);let Y=O/4,se=U/4,B=M/4,te=N/4;for(let ee=0;ee<w;ee++)a.HEAPU32[Y++]=T[ee],a.HEAPU32[se++]=h[t[ee]];for(let ee=0;ee<_;ee++)a.HEAPU32[B++]=C[ee],a.HEAPU32[te++]=d[o[ee]];if(y){let{handle:ee,outputPreferredLocations:be,outputPreferredLocationsEncoded:Me}=y;if(h.length!==w)throw new Error(`input count from feeds (${w}) is expected to be always equal to model\'s input count (${h.length}).`);for(let pe=0;pe<w;pe++){let ye=t[pe];await a._OrtBindInput(ee,h[ye],T[pe])!==0&&Be(`Can\'t bind input[${pe}] for session=${e}.`)}for(let pe=0;pe<_;pe++){let ye=o[pe];i[pe]?.[3]?a._OrtBindOutput(ee,d[ye],C[pe],0)!==0&&Be(`Can\'t bind pre-allocated output[${pe}] for session=${e}.`):a._OrtBindOutput(ee,d[ye],0,Me[ye])!==0&&Be(`Can\'t bind output[${pe}] to ${be[pe]} for session=${e}.`)}}a.jsepOnRunStart?.();let Pe;y?Pe=await a._OrtRunWithBinding(m,y.handle,_,M,v):Pe=await a._OrtRun(m,U,O,w,N,_,M,v),Pe!==0&&Be("failed to call OrtRun().");let Ee=[];for(let ee=0;ee<_;ee++){let be=a.HEAPU32[M/4+ee];if(be===C[ee]){Ee.push(i[ee]);continue}let Me=a.stackSave(),pe=a.stackAlloc(4*4),ye=!1,de,we=0;try{a._OrtGetTensorData(be,pe,pe+4,pe+8,pe+12)!==0&&Be(`Can\'t access output tensor data on index ${ee}.`);let Re=pe/4,Ge=a.HEAPU32[Re++];we=a.HEAPU32[Re++];let F=a.HEAPU32[Re++],ie=a.HEAPU32[Re++],he=[];for(let ke=0;ke<ie;ke++)he.push(a.HEAPU32[F/4+ke]);a._OrtFree(F);let Xe=he.reduce((ke,Le)=>ke*Le,1);de=st(Ge);let nt=y?.outputPreferredLocations[o[ee]];if(de==="string"){if(nt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let ke=[],Le=we/4;for(let It=0;It<Xe;It++){let Tt=a.HEAPU32[Le++],Vt=It===Xe-1?void 0:a.HEAPU32[Le]-Tt;ke.push(a.UTF8ToString(Tt,Vt))}Ee.push([de,he,ke,"cpu"])}else if(nt==="gpu-buffer"&&Xe>0){let ke=a.jsepGetBuffer(we),Le=Mr(Ge);if(Le===void 0||!Bi(de))throw new Error(`Unsupported data type: ${de}`);ye=!0,Ee.push([de,he,{gpuBuffer:ke,download:a.jsepCreateDownloader(ke,Xe*Le,de),dispose:()=>{a._OrtReleaseTensor(be)}},"gpu-buffer"])}else{let ke=yn(de),Le=new ke(Xe);new Uint8Array(Le.buffer,Le.byteOffset,Le.byteLength).set(a.HEAPU8.subarray(we,we+Le.byteLength)),Ee.push([de,he,Le,"cpu"])}}finally{a.stackRestore(Me),de==="string"&&we&&a._free(we),ye||a._OrtReleaseTensor(be)}}return y&&a._OrtClearBoundOutputs(y.handle),Ee}finally{a.stackRestore(E),T.forEach(Y=>a._OrtReleaseTensor(Y)),C.forEach(Y=>a._OrtReleaseTensor(Y)),S.forEach(Y=>a._free(Y)),v!==0&&a._OrtReleaseRunOptions(v),x.forEach(Y=>a._free(Y))}},xl=e=>{let t=Ue(),r=Hr.get(e);if(!r)throw new Error("invalid session id");let o=r[0],i=t._OrtEndProfiling(o);i===0&&Be("Can\'t get an profile file name."),t._OrtFree(i)},Cl=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Oi(r.wasm).then(()=>{wl(r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:i}=r;vl(i,o).then(()=>{postMessage({type:t})},u=>{postMessage({type:t,err:u})});break}case"copy-from":{let{buffer:o}=r,i=Wo(o);postMessage({type:t,out:i});break}case"create":{let{model:o,options:i}=r;$l(o,i).then(u=>{postMessage({type:t,out:u})},u=>{postMessage({type:t,err:u})});break}case"release":_l(r),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:i,inputs:u,outputIndices:a,options:p}=r;Sl(o,i,u,a,new Array(a.length).fill(null),p).then(m=>{m.some(h=>h[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:m},Cl(m))},m=>{postMessage({type:t,err:m})});break}case"end-profiling":xl(r),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'})),ul=U((()=>{ue(),ol(),ys(),Mu=()=>!!p.wasm.proxy&&typeof document<"u",Nu=!1,Wu=!1,Uu=!1,Hu=new Map,Lu=(e,t)=>{let n=Hu.get(e);n?n.push(t):Hu.set(e,[t])},Fu=()=>{if(Nu||!Wu||Uu||!Du)throw new Error("worker not ready")},Gu=e=>{switch(e.data.type){case"init-wasm":Nu=!1,e.data.err?(Uu=!0,Vu[1](e.data.err)):(Wu=!0,Vu[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=Hu.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},ju=typeof document<"u"?document?.currentScript?.src:void 0,qu=async()=>{if(!Wu){if(Nu)throw new Error("multiple calls to 'initWasm()' detected.");if(Uu)throw new Error("previous call to 'initWasm()' failed.");if(Nu=!0,Mu())return void 0===p.wasm.wasmPaths&&ju&&0!==ju.indexOf("blob:")&&(p.wasm.wasmPaths=ju.substr(0,+ju.lastIndexOf("/")+1)),new Promise(((e,t)=>{Du?.terminate();let n=URL.createObjectURL(new Blob([sl()],{type:"text/javascript"}));(Du=new Worker(n,{name:"ort-wasm-proxy-worker"})).onerror=e=>t(e),Du.onmessage=Gu,URL.revokeObjectURL(n),Vu=[e,t];let r={type:"init-wasm",in:p};Du.postMessage(r)}));try{await Oe(p.wasm),await Cu(p),Wu=!0}catch(e){throw Uu=!0,e}finally{Nu=!1}}},Ku=async e=>{if(Mu())return Fu(),new Promise(((t,n)=>{Lu("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:p}};Du.postMessage(r)}));await Eu(p,e)},Yu=async e=>Mu()?(Fu(),new Promise(((t,n)=>{Lu("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};Du.postMessage(r,[e.buffer])}))):Au(e),Zu=async(e,t)=>{if(Mu()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Fu(),new Promise(((n,r)=>{Lu("create",[n,r]);let a={type:"create",in:{model:e,options:t}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Du.postMessage(a,i)}))}return ku(e,t)},Qu=async e=>{if(Mu())return Fu(),new Promise(((t,n)=>{Lu("release",[t,n]);let r={type:"release",in:e};Du.postMessage(r)}));Ou(e)},Xu=async(e,t,n,r,a,i)=>{if(Mu()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return Fu(),new Promise(((a,o)=>{Lu("run",[a,o]);let s=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:s,outputIndices:r,options:i}};Du.postMessage(u,Pu(s))}))}return zu(e,t,n,r,a,i)},Ju=async e=>{if(Mu())return Fu(),new Promise(((t,n)=>{Lu("end-profiling",[t,n]);let r={type:"end-profiling",in:e};Du.postMessage(r)}));Bu(e)}})),ll=U((()=>{ue(),ul(),$s(),_s(),el=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},tl=e=>{switch(e[3]){case"cpu":return new E(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!qe(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:a}=e[2];return E.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},nl=class{async fetchModelAndCopyToWasmMemory(e){return Yu(await Ye(e))}async loadModel(e,t){let n;A(),n="string"==typeof e?typeof process<"u"&&process.versions&&process.versions.node?await Ye(e):await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames]=await Zu(n,t),k()}async dispose(){return Qu(this.sessionId)}async run(e,t,n){A();let r=[],a=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],i=this.inputNames.indexOf(t);if(-1===i)throw new Error(`invalid input '${t}'`);r.push(n),a.push(i)}));let i=[],o=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output '${t}'`);i.push(n),o.push(r)}));let s=r.map(((e,t)=>el(e,(()=>`input "${this.inputNames[a[t]]}"`)))),u=i.map(((e,t)=>e?el(e,(()=>`output "${this.outputNames[o[t]]}"`)):null)),l=await Xu(this.sessionId,a,s,o,u,n),d={};for(let e=0;e<l.length;e++)d[this.outputNames[o[e]]]=i[e]??tl(l[e]);return k(),d}startProfiling(){}endProfiling(){Ju(this.sessionId)}}})),dl=U((()=>{ue(),ul(),ll(),rl=()=>{if(("number"!=typeof p.wasm.initTimeout||p.wasm.initTimeout<0)&&(p.wasm.initTimeout=0),"boolean"!=typeof p.wasm.simd&&(p.wasm.simd=!0),"boolean"!=typeof p.wasm.proxy&&(p.wasm.proxy=!1),"boolean"!=typeof p.wasm.trace&&(p.wasm.trace=!1),"number"!=typeof p.wasm.numThreads||!Number.isInteger(p.wasm.numThreads)||p.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(p.wasm.numThreads=1);let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;p.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},al=class{async init(e){rl(),await qu(),await Ku(e)}async createInferenceSessionHandler(e,t){let n=new nl;return await n.loadModel(e,t),Promise.resolve(n)}}})),pl={};H(pl,{wasmBackend:()=>cl});var cl,fl=U((()=>{dl(),cl=new al})),hl={};H(hl,{InferenceSession:()=>R,TRACE:()=>I,TRACE_FUNC_BEGIN:()=>A,TRACE_FUNC_END:()=>k,Tensor:()=>E,TrainingSession:()=>B,default:()=>ml,env:()=>p,registerBackend:()=>o}),e.exports=L(hl),ue(),ue(),ue();var ml=se;{let e=(fl(),L(pl)).wasmBackend;o("webgpu",e,5),o("webnn",e,5),o("cpu",e,10),o("wasm",e,10)}Object.defineProperty(p.versions,"web",{value:"1.18.0-dev.20240130-9f68a27c7a",enumerable:!0})}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}return n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{const e=n(122),t=500,r=500,a=1024,i=1024,o={sam_b:["https://huggingface.co/schmuell/sam-b-fp16/resolve/main/sam_vit_b_01ec64.encoder-fp16.onnx","https://huggingface.co/schmuell/sam-b-fp16/resolve/main/sam_vit_b_01ec64.decoder.onnx"],sam_b_local:["models/sam_vit_b_01ec64.encoder-fp16.onnx","models/sam_vit_b_01ec64.decoder.onnx"]},s=function(){var e={model:"sam_b",provider:"webgpu",device:"gpu",threads:"1"};let t=window.location.search.substring(1).split("&");for(var n=0;n<t.length;n++){let r=t[n].split("=");if(r[0]in e)e[r[0]]=decodeURIComponent(r[1]);else if(r[0].length>0)throw new Error("unknown argument: "+r[0])}return e.threads=parseInt(e.threads),e}();let u,l,d;var p;e.env.wasm.numThreads=s.threads,e.env.wasm.proxy=!0;var c,f=[],h=[],m=[],g=!1;function y(e){document.getElementById("status").innerText+=`\n${e}`}async function b(t){if(!g)try{g=!0,u.style.cursor="wait";const n=u.getBoundingClientRect(),r=t.clientX-n.left,o=t.clientY-n.top,s=t.shiftKey?0:1;void 0===p&&await f[0];const l=await p;t.ctrlKey||(h=[],m=[]),h.push(r,o),m.push(s);let y=u.getContext("2d");y.clearRect(0,0,u.width,u.height),u.width=c.width,u.height=c.height,y.putImageData(c,0,0),y.fillStyle="blue",y.fillRect(r,o,10,10);const b=new e.Tensor(new Float32Array(h),[1,h.length/2,2]),w=new e.Tensor(new Float32Array(m),[1,m.length]),v=new e.Tensor(new Float32Array(65536),[1,1,256,256]),$=new e.Tensor(new Float32Array([0]),[1]),_=new e.Tensor(new Float32Array([i,a]),[2]),x=await f[1],S={image_embeddings:new e.Tensor(l.image_embeddings.type,Float32Array.from(l.image_embeddings.data),l.image_embeddings.dims),point_coords:b,point_labels:w,mask_input:v,has_mask_input:$,orig_im_size:_},C=performance.now(),E=await x.run(S);d.innerText=`${(performance.now()-C).toFixed(1)}ms`;const I=E.masks.toImageData();y.globalAlpha=.3,y.drawImage(await createImageBitmap(I),0,0)}finally{u.style.cursor="default",g=!1}}async function w(n){const o=document.getElementById("encoder_latency");o.innerText="",l.disabled=!0,d.innerText="",u.style.cursor="wait",p=void 0;var s=n.width,h=n.height;s>h?s>t&&(h*=t/s,s=t):h>r&&(s*=r/h,h=r),s=Math.round(s),h=Math.round(h),u.width=s,u.height=h;var m=u.getContext("2d");m.drawImage(n,0,0,s,h),c=m.getImageData(0,0,s,h);const g={input_image:await e.Tensor.fromImage(c,options={resizedWidth:a,resizedHeight:i})},y=await f[0],b=performance.now();(p=y.run(g)).then((()=>{o.innerText=`${(performance.now()-b).toFixed(1)}ms`,u.style.cursor="default"})),l.disabled=!1}async function v(t,n,r){let a=s.provider;switch(a){case"webnn":if(!("ml"in navigator))throw new Error("webnn is NOT supported");a={name:"webnn",deviceType:s.device,powerPreference:"default"};break;case"webgpu":if(!navigator.gpu)throw new Error("webgpu is NOT supported")}const i={executionProviders:[a]};(async function(e){try{const t=await caches.open("onnx");s.clear_cache&&t.delete(e);let n=await t.match(e);return null==n?(await t.add(e),n=await t.match(e),y(`${e} (from network)`)):y(`${e} (from cache)`),await n.arrayBuffer()}catch(t){return y(`${e} (from network)`),await fetch(e).then((e=>e.arrayBuffer()))}})(t[n]).then((a=>{f[n]=e.InferenceSession.create(a,i),f[n].then((()=>{y(`${t[n]} loaded.`),0==n&&v(t,1)}),(e=>{throw y(`${t[n]} failed with ${e}.`),e})),void 0!==r&&w(r)}))}document.addEventListener("DOMContentLoaded",(()=>{!async function(){const e=o[s.model];u=document.getElementById("img_canvas"),u.addEventListener("click",b),u.style.cursor="wait",l=document.getElementById("file-in"),d=document.getElementById("decoder_latency");let t=document.getElementById("original-image");v(e,0,t).then((()=>{}),(e=>{y(e)})),l.onchange=function(e){let n=(e.target||window.event.src).files;if(FileReader&&n&&n.length){let e=new FileReader;e.onload=()=>{t.onload=()=>w(t),t.src=e.result},e.readAsDataURL(n[0])}}}()}))})(),{}})()));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UyxJQUFNZ2hELEVBQVlDLEdBQy9CQSxFQUFJbGhELElBQU1taUQsRUFBV0MsTUFBTSxFQUUvQkQsRUFBV0UsY0FBY0osRUFBTSxHQUNuQyxDQUNKLENBQ0osQ0FFc0RLLEVBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcnQtc2FtL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9vcnQtc2FtLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9kaXN0L2Nqcy9vcnQud2ViZ3B1Lm1pbi5qcyIsIndlYnBhY2s6Ly9vcnQtc2FtL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL29ydC1zYW0vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9vcnQtc2FtLy4vbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuICIsIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4xOC4wLWRldi4yMDI0MDEzMC05ZjY4YTI3YzdhXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7dmFyIENhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgQmQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgTWQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIERkPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIFE9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgYnI9KGUsdCk9PigpPT4odHx8ZSgodD17ZXhwb3J0czp7fX0pLmV4cG9ydHMsdCksdC5leHBvcnRzKSxucj0oZSx0KT0+e2Zvcih2YXIgciBpbiB0KUNhKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSx6ZD0oZSx0LHIsYSk9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IGkgb2YgTWQodCkpIURkLmNhbGwoZSxpKSYmaSE9PXImJkNhKGUsaSx7Z2V0OigpPT50W2ldLGVudW1lcmFibGU6IShhPUJkKHQsaSkpfHxhLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIEd0PWU9PnpkKENhKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciBFbixhcixGdCxPbixrbj1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RW49bmV3IE1hcCxhcj1bXSxGdD0oZSx0LHIpPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgYT1Fbi5nZXQoZSk7aWYoYT09PXZvaWQgMClFbi5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5OnJ9KTtlbHNle2lmKGEucHJpb3JpdHk+cilyZXR1cm47aWYoYS5wcmlvcml0eT09PXImJmEuYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke3J9YCl9aWYocj49MCl7bGV0IGk9YXIuaW5kZXhPZihlKTtpIT09LTEmJmFyLnNwbGljZShpLDEpO2ZvcihsZXQgcz0wO3M8YXIubGVuZ3RoO3MrKylpZihFbi5nZXQoYXJbc10pLnByaW9yaXR5PD1yKXthci5zcGxpY2UocywwLGUpO3JldHVybn1hci5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0sT249YXN5bmMgZT0+e2xldCB0PWUubGVuZ3RoPT09MD9hcjplLHI9W107Zm9yKGxldCBhIG9mIHQpe2xldCBpPUVuLmdldChhKTtpZihpKXtpZihpLmluaXRpYWxpemVkKXJldHVybiBpLmJhY2tlbmQ7aWYoaS5hYm9ydGVkKWNvbnRpbnVlO2xldCBzPSEhaS5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIHN8fChpLmluaXRQcm9taXNlPWkuYmFja2VuZC5pbml0KGEpKSxhd2FpdCBpLmluaXRQcm9taXNlLGkuaW5pdGlhbGl6ZWQ9ITAsaS5iYWNrZW5kfWNhdGNoKG8pe3N8fHIucHVzaCh7bmFtZTphLGVycjpvfSksaS5hYm9ydGVkPSEwfWZpbmFsbHl7ZGVsZXRlIGkuaW5pdFByb21pc2V9fX10aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ci5tYXAoYT0+YFske2EubmFtZX1dICR7YS5lcnJ9YCkuam9pbihcIiwgXCIpfWApfX0pO3ZhciBxaT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7a24oKX0pO3ZhciBqaSxLaT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7amk9XCIxLjE3LjAtZGV2LjIwMjQwMTE2LTgwZjI3NGNhNmZcIn0pO3ZhciBZaSxpcixJYT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7S2koKTtZaT1cIndhcm5pbmdcIixpcj17d2FzbTp7fSx3ZWJnbDp7fSx3ZWJncHU6e30sdmVyc2lvbnM6e2NvbW1vbjpqaX0sc2V0IGxvZ0xldmVsKGUpe2lmKGUhPT12b2lkIDApe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wifHxbXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihlKT09PS0xKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApO1lpPWV9fSxnZXQgbG9nTGV2ZWwoKXtyZXR1cm4gWWl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoaXIsXCJsb2dMZXZlbFwiLHtlbnVtZXJhYmxlOiEwfSl9KTt2YXIgQWUsWmk9USgoKT0+e1widXNlIHN0cmljdFwiO0lhKCk7QWU9aXJ9KTt2YXIgWGksUWksSmk9USgoKT0+e1widXNlIHN0cmljdFwiO1hpPShlLHQpPT57bGV0IHI9dHlwZW9mIGRvY3VtZW50PFwidVwiP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpO3Iud2lkdGg9ZS5kaW1zWzNdLHIuaGVpZ2h0PWUuZGltc1syXTtsZXQgYT1yLmdldENvbnRleHQoXCIyZFwiKTtpZihhIT1udWxsKXtsZXQgaSxzO3Q/LnRlbnNvckxheW91dCE9PXZvaWQgMCYmdC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIj8oaT1lLmRpbXNbMl0scz1lLmRpbXNbM10pOihpPWUuZGltc1szXSxzPWUuZGltc1syXSk7bGV0IG89dD8uZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsYz10Py5ub3JtLHAsbTtjPT09dm9pZCAwfHxjLm1lYW49PT12b2lkIDA/cD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgYy5tZWFuPT1cIm51bWJlclwiP3A9W2MubWVhbixjLm1lYW4sYy5tZWFuLGMubWVhbl06KHA9W2MubWVhblswXSxjLm1lYW5bMV0sYy5tZWFuWzJdLDBdLGMubWVhblszXSE9PXZvaWQgMCYmKHBbM109Yy5tZWFuWzNdKSksYz09PXZvaWQgMHx8Yy5iaWFzPT09dm9pZCAwP209WzAsMCwwLDBdOnR5cGVvZiBjLmJpYXM9PVwibnVtYmVyXCI/bT1bYy5iaWFzLGMuYmlhcyxjLmJpYXMsYy5iaWFzXToobT1bYy5iaWFzWzBdLGMuYmlhc1sxXSxjLmJpYXNbMl0sMF0sYy5iaWFzWzNdIT09dm9pZCAwJiYobVszXT1jLmJpYXNbM10pKTtsZXQgbD1zKmksZz0wLGI9bCx3PWwqMiwkPS0xO289PT1cIlJHQkFcIj8oZz0wLGI9bCx3PWwqMiwkPWwqMyk6bz09PVwiUkdCXCI/KGc9MCxiPWwsdz1sKjIpOm89PT1cIlJCR1wiJiYoZz0wLHc9bCxiPWwqMik7Zm9yKGxldCB4PTA7eDxzO3grKylmb3IobGV0IFQ9MDtUPGk7VCsrKXtsZXQgQz0oZS5kYXRhW2crK10tbVswXSkqcFswXSxTPShlLmRhdGFbYisrXS1tWzFdKSpwWzFdLEU9KGUuZGF0YVt3KytdLW1bMl0pKnBbMl0sTz0kPT09LTE/MjU1OihlLmRhdGFbJCsrXS1tWzNdKSpwWzNdO2EuZmlsbFN0eWxlPVwicmdiYShcIitDK1wiLFwiK1MrXCIsXCIrRStcIixcIitPK1wiKVwiLGEuZmlsbFJlY3QoVCx4LDEsMSl9aWYoXCJ0b0RhdGFVUkxcImluIHIpcmV0dXJuIHIudG9EYXRhVVJMKCk7dGhyb3cgbmV3IEVycm9yKFwidG9EYXRhVVJMIGlzIG5vdCBzdXBwb3J0ZWRcIil9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfSxRaT0oZSx0KT0+e2xldCByPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTpuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSkuZ2V0Q29udGV4dChcIjJkXCIpLGE7aWYociE9bnVsbCl7bGV0IGkscyxvO3Q/LnRlbnNvckxheW91dCE9PXZvaWQgMCYmdC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIj8oaT1lLmRpbXNbMl0scz1lLmRpbXNbMV0sbz1lLmRpbXNbM10pOihpPWUuZGltc1szXSxzPWUuZGltc1syXSxvPWUuZGltc1sxXSk7bGV0IGM9dCE9PXZvaWQgMCYmdC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIixwPXQ/Lm5vcm0sbSxsO3A9PT12b2lkIDB8fHAubWVhbj09PXZvaWQgMD9tPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiBwLm1lYW49PVwibnVtYmVyXCI/bT1bcC5tZWFuLHAubWVhbixwLm1lYW4scC5tZWFuXToobT1bcC5tZWFuWzBdLHAubWVhblsxXSxwLm1lYW5bMl0sMjU1XSxwLm1lYW5bM10hPT12b2lkIDAmJihtWzNdPXAubWVhblszXSkpLHA9PT12b2lkIDB8fHAuYmlhcz09PXZvaWQgMD9sPVswLDAsMCwwXTp0eXBlb2YgcC5iaWFzPT1cIm51bWJlclwiP2w9W3AuYmlhcyxwLmJpYXMscC5iaWFzLHAuYmlhc106KGw9W3AuYmlhc1swXSxwLmJpYXNbMV0scC5iaWFzWzJdLDBdLHAuYmlhc1szXSE9PXZvaWQgMCYmKGxbM109cC5iaWFzWzNdKSk7bGV0IGc9cyppO2lmKHQhPT12b2lkIDAmJih0LmZvcm1hdCE9PXZvaWQgMCYmbz09PTQmJnQuZm9ybWF0IT09XCJSR0JBXCJ8fG89PT0zJiZ0LmZvcm1hdCE9PVwiUkdCXCImJnQuZm9ybWF0IT09XCJCR1JcIikpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpO2xldCBiPTQsdz0wLCQ9MSx4PTIsVD0zLEM9MCxTPWcsRT1nKjIsTz0tMTtjPT09XCJSR0JBXCI/KEM9MCxTPWcsRT1nKjIsTz1nKjMpOmM9PT1cIlJHQlwiPyhDPTAsUz1nLEU9ZyoyKTpjPT09XCJSQkdcIiYmKEM9MCxFPWcsUz1nKjIpLGE9ci5jcmVhdGVJbWFnZURhdGEoaSxzKTtmb3IobGV0IFU9MDtVPHMqaTt3Kz1iLCQrPWIseCs9YixUKz1iLFUrKylhLmRhdGFbd109KGUuZGF0YVtDKytdLWxbMF0pKm1bMF0sYS5kYXRhWyRdPShlLmRhdGFbUysrXS1sWzFdKSptWzFdLGEuZGF0YVt4XT0oZS5kYXRhW0UrK10tbFsyXSkqbVsyXSxhLmRhdGFbVF09Tz09PS0xPzI1NTooZS5kYXRhW08rK10tbFszXSkqbVszXX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIik7cmV0dXJuIGF9fSk7dmFyIEFhLGVvLHRvLHJvLG5vLGFvPVEoKCk9PntcInVzZSBzdHJpY3RcIjtQbigpO0FhPShlLHQpPT57aWYoZT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkXCIpO2lmKHQuaGVpZ2h0PT09dm9pZCAwfHx0LndpZHRoPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkXCIpO2lmKHQudGVuc29yTGF5b3V0PT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKFwiTkhXQyBUZW5zb3IgbGF5b3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO2xldHtoZWlnaHQ6cix3aWR0aDphfT10LGk9dC5ub3JtPz97bWVhbjoyNTUsYmlhczowfSxzLG87dHlwZW9mIGkubWVhbj09XCJudW1iZXJcIj9zPVtpLm1lYW4saS5tZWFuLGkubWVhbixpLm1lYW5dOnM9W2kubWVhblswXSxpLm1lYW5bMV0saS5tZWFuWzJdLGkubWVhblszXT8/MjU1XSx0eXBlb2YgaS5iaWFzPT1cIm51bWJlclwiP289W2kuYmlhcyxpLmJpYXMsaS5iaWFzLGkuYmlhc106bz1baS5iaWFzWzBdLGkuYmlhc1sxXSxpLmJpYXNbMl0saS5iaWFzWzNdPz8wXTtsZXQgYz10LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQkFcIixwPXQudGVuc29yRm9ybWF0IT09dm9pZCAwJiZ0LnRlbnNvckZvcm1hdCE9PXZvaWQgMD90LnRlbnNvckZvcm1hdDpcIlJHQlwiLG09ciphLGw9cD09PVwiUkdCQVwiP25ldyBGbG9hdDMyQXJyYXkobSo0KTpuZXcgRmxvYXQzMkFycmF5KG0qMyksZz00LGI9MCx3PTEsJD0yLHg9MyxUPTAsQz1tLFM9bSoyLEU9LTE7Yz09PVwiUkdCXCImJihnPTMsYj0wLHc9MSwkPTIseD0tMSkscD09PVwiUkdCQVwiP0U9bSozOnA9PT1cIlJCR1wiPyhUPTAsUz1tLEM9bSoyKTpwPT09XCJCR1JcIiYmKFM9MCxDPW0sVD1tKjIpO2ZvcihsZXQgVT0wO1U8bTtVKyssYis9ZywkKz1nLHcrPWcseCs9ZylsW1QrK109KGVbYl0rb1swXSkvc1swXSxsW0MrK109KGVbd10rb1sxXSkvc1sxXSxsW1MrK109KGVbJF0rb1syXSkvc1syXSxFIT09LTEmJnghPT0tMSYmKGxbRSsrXT0oZVt4XStvWzNdKS9zWzNdKTtyZXR1cm4gcD09PVwiUkdCQVwiP25ldyBhdChcImZsb2F0MzJcIixsLFsxLDQscixhXSk6bmV3IGF0KFwiZmxvYXQzMlwiLGwsWzEsMyxyLGFdKX0sZW89YXN5bmMoZSx0KT0+e2xldCByPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50PFwidVwiJiZlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCxhPXR5cGVvZiBJbWFnZURhdGE8XCJ1XCImJmUgaW5zdGFuY2VvZiBJbWFnZURhdGEsaT10eXBlb2YgSW1hZ2VCaXRtYXA8XCJ1XCImJmUgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCxzPXR5cGVvZiBlPT1cInN0cmluZ1wiLG8sYz10Pz97fSxwPSgpPT57aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2lmKHR5cGVvZiBPZmZzY3JlZW5DYW52YXM8XCJ1XCIpcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKX0sbT1sPT5sIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fGwgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM/bC5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDtpZihyKXtsZXQgbD1wKCk7bC53aWR0aD1lLndpZHRoLGwuaGVpZ2h0PWUuaGVpZ2h0O2xldCBnPW0obCk7aWYoZyE9bnVsbCl7bGV0IGI9ZS5oZWlnaHQsdz1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJihiPXQucmVzaXplZEhlaWdodCx3PXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihjPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7Yy50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsYy5oZWlnaHQ9YixjLndpZHRoPXd9ZWxzZSBjLnRlbnNvckZvcm1hdD1cIlJHQkFcIixjLmhlaWdodD1iLGMud2lkdGg9dztnLmRyYXdJbWFnZShlLDAsMCksbz1nLmdldEltYWdlRGF0YSgwLDAsdyxiKS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKGEpe2xldCBsLGc7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8obD10LnJlc2l6ZWRIZWlnaHQsZz10LnJlc2l6ZWRXaWR0aCk6KGw9ZS5oZWlnaHQsZz1lLndpZHRoKSx0IT09dm9pZCAwJiYoYz10KSxjLmZvcm1hdD1cIlJHQkFcIixjLmhlaWdodD1sLGMud2lkdGg9Zyx0IT09dm9pZCAwKXtsZXQgYj1wKCk7Yi53aWR0aD1nLGIuaGVpZ2h0PWw7bGV0IHc9bShiKTtpZih3IT1udWxsKXcucHV0SW1hZ2VEYXRhKGUsMCwwKSxvPXcuZ2V0SW1hZ2VEYXRhKDAsMCxnLGwpLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2Ugbz1lLmRhdGF9ZWxzZSBpZihpKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IGw9cCgpO2wud2lkdGg9ZS53aWR0aCxsLmhlaWdodD1lLmhlaWdodDtsZXQgZz1tKGwpO2lmKGchPW51bGwpe2xldCBiPWUuaGVpZ2h0LHc9ZS53aWR0aDtyZXR1cm4gZy5kcmF3SW1hZ2UoZSwwLDAsdyxiKSxvPWcuZ2V0SW1hZ2VEYXRhKDAsMCx3LGIpLmRhdGEsYy5oZWlnaHQ9YixjLndpZHRoPXcsQWEobyxjKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihzKXJldHVybiBuZXcgUHJvbWlzZSgobCxnKT0+e2xldCBiPXAoKSx3PW0oYik7aWYoIWV8fCF3KXJldHVybiBnKCk7bGV0ICQ9bmV3IEltYWdlOyQuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIiwkLnNyYz1lLCQub25sb2FkPSgpPT57Yi53aWR0aD0kLndpZHRoLGIuaGVpZ2h0PSQuaGVpZ2h0LHcuZHJhd0ltYWdlKCQsMCwwLGIud2lkdGgsYi5oZWlnaHQpO2xldCB4PXcuZ2V0SW1hZ2VEYXRhKDAsMCxiLndpZHRoLGIuaGVpZ2h0KTtjLmhlaWdodD1iLmhlaWdodCxjLndpZHRoPWIud2lkdGgsbChBYSh4LmRhdGEsYykpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKG8hPT12b2lkIDApcmV0dXJuIEFhKG8sYyk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LHRvPShlLHQpPT57bGV0e3dpZHRoOnIsaGVpZ2h0OmEsZG93bmxvYWQ6aSxkaXNwb3NlOnN9PXQsbz1bMSxhLHIsNF07cmV0dXJuIG5ldyBhdCh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczpvLGRvd25sb2FkOmksZGlzcG9zZTpzfSl9LHJvPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczphLGRvd25sb2FkOmksZGlzcG9zZTpzfT10O3JldHVybiBuZXcgYXQoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczphLGRvd25sb2FkOmksZGlzcG9zZTpzfSl9LG5vPShlLHQscik9Pm5ldyBhdCh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsdHlwZTplLGRhdGE6dCxkaW1zOnI/P1t0Lmxlbmd0aF19KX0pO3ZhciBGcixSbixpbyxvbyxzbz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RnI9bmV3IE1hcChbW1wiZmxvYXQzMlwiLEZsb2F0MzJBcnJheV0sW1widWludDhcIixVaW50OEFycmF5XSxbXCJpbnQ4XCIsSW50OEFycmF5XSxbXCJ1aW50MTZcIixVaW50MTZBcnJheV0sW1wiZmxvYXQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XV0pLFJuPW5ldyBNYXAoW1tGbG9hdDMyQXJyYXksXCJmbG9hdDMyXCJdLFtVaW50OEFycmF5LFwidWludDhcIl0sW0ludDhBcnJheSxcImludDhcIl0sW1VpbnQxNkFycmF5LFwidWludDE2XCJdLFtJbnQxNkFycmF5LFwiaW50MTZcIl0sW0ludDMyQXJyYXksXCJpbnQzMlwiXSxbRmxvYXQ2NEFycmF5LFwiZmxvYXQ2NFwiXSxbVWludDMyQXJyYXksXCJ1aW50MzJcIl1dKSxpbz0hMSxvbz0oKT0+e2lmKCFpbyl7aW89ITA7bGV0IGU9dHlwZW9mIEJpZ0ludDY0QXJyYXk8XCJ1XCImJnR5cGVvZiBCaWdJbnQ2NEFycmF5LmZyb209PVwiZnVuY3Rpb25cIix0PXR5cGVvZiBCaWdVaW50NjRBcnJheTxcInVcIiYmdHlwZW9mIEJpZ1VpbnQ2NEFycmF5LmZyb209PVwiZnVuY3Rpb25cIjtlJiYoRnIuc2V0KFwiaW50NjRcIixCaWdJbnQ2NEFycmF5KSxSbi5zZXQoQmlnSW50NjRBcnJheSxcImludDY0XCIpKSx0JiYoRnIuc2V0KFwidWludDY0XCIsQmlnVWludDY0QXJyYXkpLFJuLnNldChCaWdVaW50NjRBcnJheSxcInVpbnQ2NFwiKSl9fX0pO3ZhciB1byxsbyxjbz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7UG4oKTt1bz1lPT57bGV0IHQ9MTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IGE9ZVtyXTtpZih0eXBlb2YgYSE9XCJudW1iZXJcInx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKGEpKXRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtyfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7YX1gKTtpZihhPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtyfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7YX1gKTt0Kj1hfXJldHVybiB0fSxsbz0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IGF0KGUudHlwZSxlLmRhdGEsdCk7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiBuZXcgYXQoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLGRhdGE6ZS5kYXRhLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gbmV3IGF0KHtsb2NhdGlvbjpcInRleHR1cmVcIix0ZXh0dXJlOmUudGV4dHVyZSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIG5ldyBhdCh7bG9jYXRpb246XCJncHUtYnVmZmVyXCIsZ3B1QnVmZmVyOmUuZ3B1QnVmZmVyLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHtlLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCl9fX0pO3ZhciBhdCxQbj1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SmkoKTthbygpO3NvKCk7Y28oKTthdD1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsYSl7b28oKTtsZXQgaSxzO2lmKHR5cGVvZiB0PT1cIm9iamVjdFwiJiZcImxvY2F0aW9uXCJpbiB0KXN3aXRjaCh0aGlzLmRhdGFMb2NhdGlvbj10LmxvY2F0aW9uLGk9dC50eXBlLHM9dC5kaW1zLHQubG9jYXRpb24pe2Nhc2VcImNwdS1waW5uZWRcIjp7bGV0IGM9RnIuZ2V0KGkpO2lmKCFjKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke2l9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHBpbm5lZCBidWZmZXJgKTtpZighKHQuZGF0YSBpbnN0YW5jZW9mIGMpKXRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2MubmFtZX1gKTt0aGlzLmNwdURhdGE9dC5kYXRhO2JyZWFrfWNhc2VcInRleHR1cmVcIjp7aWYoaSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke2l9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTt0aGlzLmdwdVRleHR1cmVEYXRhPXQudGV4dHVyZSx0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJncHUtYnVmZmVyXCI6e2lmKGkhPT1cImZsb2F0MzJcIiYmaSE9PVwiZmxvYXQxNlwiJiZpIT09XCJpbnQzMlwiJiZpIT09XCJpbnQ2NFwiJiZpIT09XCJ1aW50MzJcIiYmaSE9PVwiYm9vbFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke2l9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIGdwdSBidWZmZXJgKTt0aGlzLmdwdUJ1ZmZlckRhdGE9dC5ncHVCdWZmZXIsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApfWVsc2V7bGV0IGMscDtpZih0eXBlb2YgdD09XCJzdHJpbmdcIilpZihpPXQscD1hLHQ9PT1cInN0cmluZ1wiKXtpZighQXJyYXkuaXNBcnJheShyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtjPXJ9ZWxzZXtsZXQgbT1Gci5nZXQodCk7aWYobT09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHt0fS5gKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZih0PT09XCJmbG9hdDE2XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNyZWF0aW5nIGEgZmxvYXQxNiB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBVaW50MTZBcnJheSBhcyBkYXRhLlwiKTt0PT09XCJ1aW50NjRcInx8dD09PVwiaW50NjRcIj9jPW0uZnJvbShyLEJpZ0ludCk6Yz1tLmZyb20ocil9ZWxzZSBpZihyIGluc3RhbmNlb2YgbSljPXI7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7aX0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHttfWApfWVsc2UgaWYocD1yLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBtPXR5cGVvZiB0WzBdO2lmKG09PT1cInN0cmluZ1wiKWk9XCJzdHJpbmdcIixjPXQ7ZWxzZSBpZihtPT09XCJib29sZWFuXCIpaT1cImJvb2xcIixjPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7bX0uYCl9ZWxzZXtsZXQgbT1Sbi5nZXQodC5jb25zdHJ1Y3Rvcik7aWYobT09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtpPW0sYz10fWlmKHA9PT12b2lkIDApcD1bYy5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkocCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO3M9cCx0aGlzLmNwdURhdGE9Yyx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBvPXVvKHMpO2lmKHRoaXMuY3B1RGF0YSYmbyE9PXRoaXMuY3B1RGF0YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7b30pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1pLHRoaXMuZGltcz1zLHRoaXMuc2l6ZT1vfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxyKXtyZXR1cm4gZW8odCxyKX1zdGF0aWMgZnJvbVRleHR1cmUodCxyKXtyZXR1cm4gdG8odCxyKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LHIpe3JldHVybiBybyh0LHIpfXN0YXRpYyBmcm9tUGlubmVkQnVmZmVyKHQscixhKXtyZXR1cm4gbm8odCxyLGEpfXRvRGF0YVVSTCh0KXtyZXR1cm4gWGkodGhpcyx0KX10b0ltYWdlRGF0YSh0KXtyZXR1cm4gUWkodGhpcyx0KX1nZXQgZGF0YSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5jcHVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBvbiBDUFUuIFVzZSBgZ2V0RGF0YSgpYCB0byBkb3dubG9hZCBHUFUgZGF0YSB0byBDUFUsIG9yIHVzZSBgdGV4dHVyZWAgb3IgYGdwdUJ1ZmZlcmAgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBHUFUgZGF0YSBkaXJlY3RseS5cIik7cmV0dXJuIHRoaXMuY3B1RGF0YX1nZXQgbG9jYXRpb24oKXtyZXR1cm4gdGhpcy5kYXRhTG9jYXRpb259Z2V0IHRleHR1cmUoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1VGV4dHVyZURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuXCIpO3JldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhfWdldCBncHVCdWZmZXIoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuZ3B1QnVmZmVyRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci5cIik7cmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IHI9YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9cix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxyfWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuaXNEb3dubG9hZGluZz12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJub25lXCJ9ZW5zdXJlVmFsaWQoKXtpZih0aGlzLmRhdGFMb2NhdGlvbj09PVwibm9uZVwiKXRocm93IG5ldyBFcnJvcihcIlRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXCIpfXJlc2hhcGUodCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZG93bmxvYWRlcnx8dGhpcy5kaXNwb3Nlcil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLlwiKTtyZXR1cm4gbG8odGhpcyx0KX19fSk7dmFyIFplLEJuPVEoKCk9PntcInVzZSBzdHJpY3RcIjtQbigpO1plPWF0fSk7dmFyIHFyLHBvLGR0LGN0LFRhPVEoKCk9PntcInVzZSBzdHJpY3RcIjtJYSgpO3FyPShlLHQpPT57aXIud2FzbS50cmFjZSYmY29uc29sZS50aW1lU3RhbXAoYCR7ZX06Ok9SVDo6JHt0fWApfSxwbz0oZSx0KT0+e2xldCByPW5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyl8fFtdLGE9ITE7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDtpKyspe2lmKGEmJiFyW2ldLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IHM9YEZVTkNfJHtlfTo6JHtyW2ldLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYocys9YDo6JHt0fWApLHFyKFwiQ1BVXCIscyk7cmV0dXJufXJbaV0uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYoYT0hMCl9fSxkdD1lPT57aXIud2FzbS50cmFjZSYmcG8oXCJCRUdJTlwiLGUpfSxjdD1lPT57aXIud2FzbS50cmFjZSYmcG8oXCJFTkRcIixlKX19KTt2YXIgTW4sZm89USgoKT0+e1widXNlIHN0cmljdFwiO2tuKCk7Qm4oKTtUYSgpO01uPWNsYXNzIGV7Y29uc3RydWN0b3IodCl7dGhpcy5oYW5kbGVyPXR9YXN5bmMgcnVuKHQscixhKXtkdCgpO2xldCBpPXt9LHM9e307aWYodHlwZW9mIHQhPVwib2JqZWN0XCJ8fHQ9PT1udWxsfHx0IGluc3RhbmNlb2YgWmV8fEFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgbz0hMDtpZih0eXBlb2Ygcj09XCJvYmplY3RcIil7aWYocj09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZihyIGluc3RhbmNlb2YgWmUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7aWYoQXJyYXkuaXNBcnJheShyKSl7aWYoci5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTtvPSExO2ZvcihsZXQgbSBvZiByKXtpZih0eXBlb2YgbSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtpZih0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobSk9PT0tMSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bX0uYCk7aVttXT1udWxsfWlmKHR5cGVvZiBhPT1cIm9iamVjdFwiJiZhIT09bnVsbClzPWE7ZWxzZSBpZih0eXBlb2YgYTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBtPSExLGw9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocik7Zm9yKGxldCBnIG9mIHRoaXMub3V0cHV0TmFtZXMpaWYobC5pbmRleE9mKGcpIT09LTEpe2xldCBiPXJbZ107KGI9PT1udWxsfHxiIGluc3RhbmNlb2YgWmUpJiYobT0hMCxvPSExLGlbZ109Yil9aWYobSl7aWYodHlwZW9mIGE9PVwib2JqZWN0XCImJmEhPT1udWxsKXM9YTtlbHNlIGlmKHR5cGVvZiBhPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2Ugcz1yfX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO2ZvcihsZXQgbSBvZiB0aGlzLmlucHV0TmFtZXMpaWYodHlwZW9mIHRbbV0+XCJ1XCIpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHttfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO2lmKG8pZm9yKGxldCBtIG9mIHRoaXMub3V0cHV0TmFtZXMpaVttXT1udWxsO2xldCBjPWF3YWl0IHRoaXMuaGFuZGxlci5ydW4odCxpLHMpLHA9e307Zm9yKGxldCBtIGluIGMpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYyxtKSl7bGV0IGw9Y1ttXTtsIGluc3RhbmNlb2YgWmU/cFttXT1sOnBbbV09bmV3IFplKGwudHlwZSxsLmRhdGEsbC5kaW1zKX1yZXR1cm4gY3QoKSxwfWFzeW5jIHJlbGVhc2UoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKX1zdGF0aWMgYXN5bmMgY3JlYXRlKHQscixhLGkpe2R0KCk7bGV0IHMsbz17fTtpZih0eXBlb2YgdD09XCJzdHJpbmdcIil7aWYocz10LHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClvPXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtpZihzPXQsdHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKW89cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI8XCJ1XCImJnQgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcil7bGV0IGc9dCxiPTAsdz10LmJ5dGVMZW5ndGg7aWYodHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKW89cjtlbHNlIGlmKHR5cGVvZiByPT1cIm51bWJlclwiKXtpZihiPXIsIU51bWJlci5pc1NhZmVJbnRlZ2VyKGIpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoYjwwfHxiPj1nLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7Zy5ieXRlTGVuZ3RofSkuYCk7aWYodz10LmJ5dGVMZW5ndGgtYix0eXBlb2YgYT09XCJudW1iZXJcIil7aWYodz1hLCFOdW1iZXIuaXNTYWZlSW50ZWdlcih3KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHc8PTB8fGIrdz5nLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7Zy5ieXRlTGVuZ3RoLWJ9XS5gKTtpZih0eXBlb2YgaT09XCJvYmplY3RcIiYmaSE9PW51bGwpbz1pO2Vsc2UgaWYodHlwZW9mIGk8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0eXBlb2YgYTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYSBudW1iZXIuXCIpfWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7cz1uZXcgVWludDhBcnJheShnLGIsdyl9ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO2xldCBwPShvLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10pLm1hcChnPT50eXBlb2YgZz09XCJzdHJpbmdcIj9nOmcubmFtZSksbD1hd2FpdChhd2FpdCBPbihwKSkuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIocyxvKTtyZXR1cm4gY3QoKSxuZXcgZShsKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX19KTt2YXIgbW8saG89USgoKT0+e1widXNlIHN0cmljdFwiO2ZvKCk7bW89TW59KTt2YXIgZ289USgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFVkLERuLHlvPVEoKCk9PntcInVzZSBzdHJpY3RcIjtrbigpO0JuKCk7VWQ9XCJUcmFpbmluZyBiYWNrZW5kIGNvdWxkIG5vdCBiZSByZXNvbHZlZC4gTWFrZSBzdXJlIHlvdSdyZSB1c2luZyB0aGUgY29ycmVjdCBjb25maWd1cmF0aW9uICYgV2ViQXNzZW1ibHkgZmlsZXMuXCIsRG49Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LHIsYSl7dGhpcy5oYW5kbGVyPXQsdGhpcy5oYXNPcHRpbWl6ZXJNb2RlbD1yLHRoaXMuaGFzRXZhbE1vZGVsPWF9Z2V0IHRyYWluaW5nSW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgdHJhaW5pbmdPdXRwdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXN9Z2V0IGV2YWxJbnB1dE5hbWVzKCl7aWYodGhpcy5oYXNFdmFsTW9kZWwpcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsSW5wdXROYW1lczt0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuXCIpfWdldCBldmFsT3V0cHV0TmFtZXMoKXtpZih0aGlzLmhhc0V2YWxNb2RlbClyZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxPdXRwdXROYW1lczt0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuXCIpfXN0YXRpYyBhc3luYyBjcmVhdGUodCxyKXtsZXQgYT10LmV2YWxNb2RlbHx8XCJcIixpPXQub3B0aW1pemVyTW9kZWx8fFwiXCIscz1yfHx7fSxjPShzLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10pLm1hcChtPT50eXBlb2YgbT09XCJzdHJpbmdcIj9tOm0ubmFtZSkscD1hd2FpdCBPbihjKTtpZihwLmNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIpe2xldCBtPWF3YWl0IHAuY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcih0LmNoZWNrcG9pbnRTdGF0ZSx0LnRyYWluTW9kZWwsYSxpLHMpO3JldHVybiBuZXcgZShtLCEhdC5vcHRpbWl6ZXJNb2RlbCwhIXQuZXZhbE1vZGVsKX1lbHNlIHRocm93IG5ldyBFcnJvcihVZCl9dHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAodCxyLGEsaSxzKXtsZXQgbz17fSxjPXt9O2lmKHR5cGVvZiBhIT1cIm9iamVjdFwifHxhPT09bnVsbHx8YSBpbnN0YW5jZW9mIFplfHxBcnJheS5pc0FycmF5KGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IHA9ITA7aWYodHlwZW9mIGk9PVwib2JqZWN0XCIpe2lmKGk9PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYoaSBpbnN0YW5jZW9mIFplKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkoaSkpe2lmKGkubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7cD0hMTtmb3IobGV0IG0gb2YgaSl7aWYodHlwZW9mIG0hPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYoci5pbmRleE9mKG0pPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke219LmApO29bbV09bnVsbH1pZih0eXBlb2Ygcz09XCJvYmplY3RcIiYmcyE9PW51bGwpYz1zO2Vsc2UgaWYodHlwZW9mIHM8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgbT0hMSxsPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGkpO2ZvcihsZXQgZyBvZiByKWlmKGwuaW5kZXhPZihnKSE9PS0xKXtsZXQgYj1pW2ddOyhiPT09bnVsbHx8YiBpbnN0YW5jZW9mIFplKSYmKG09ITAscD0hMSxvW2ddPWIpfWlmKG0pe2lmKHR5cGVvZiBzPT1cIm9iamVjdFwiJiZzIT09bnVsbCljPXM7ZWxzZSBpZih0eXBlb2YgczxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGM9aX19ZWxzZSBpZih0eXBlb2YgaTxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IG0gb2YgdClpZih0eXBlb2YgYVttXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke219JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYocClmb3IobGV0IG0gb2YgcilvW21dPW51bGw7cmV0dXJuW28sY119Y29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnModCl7bGV0IHI9e307Zm9yKGxldCBhIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxhKSl7bGV0IGk9dFthXTtpIGluc3RhbmNlb2YgWmU/clthXT1pOnJbYV09bmV3IFplKGkudHlwZSxpLmRhdGEsaS5kaW1zKX1yZXR1cm4gcn1hc3luYyBsYXp5UmVzZXRHcmFkKCl7YXdhaXQgdGhpcy5oYW5kbGVyLmxhenlSZXNldEdyYWQoKX1hc3luYyBydW5UcmFpblN0ZXAodCxyLGEpe2xldFtpLHNdPXRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAodGhpcy50cmFpbmluZ0lucHV0TmFtZXMsdGhpcy50cmFpbmluZ091dHB1dE5hbWVzLHQscixhKSxvPWF3YWl0IHRoaXMuaGFuZGxlci5ydW5UcmFpblN0ZXAodCxpLHMpO3JldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKG8pfWFzeW5jIHJ1bk9wdGltaXplclN0ZXAodCl7aWYodGhpcy5oYXNPcHRpbWl6ZXJNb2RlbClhd2FpdCB0aGlzLmhhbmRsZXIucnVuT3B0aW1pemVyU3RlcCh0fHx7fSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gT3B0aW1pemVyTW9kZWwgbG9hZGVkLlwiKX1hc3luYyBydW5FdmFsU3RlcCh0LHIsYSl7aWYodGhpcy5oYXNFdmFsTW9kZWwpe2xldFtpLHNdPXRoaXMudHlwZU5hcnJvd2luZ0ZvclJ1blN0ZXAodGhpcy5ldmFsSW5wdXROYW1lcyx0aGlzLmV2YWxPdXRwdXROYW1lcyx0LHIsYSksbz1hd2FpdCB0aGlzLmhhbmRsZXIucnVuRXZhbFN0ZXAodCxpLHMpO3JldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKG8pfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBUcmFpbmluZ1Nlc3Npb24gaGFzIG5vIEV2YWxNb2RlbCBsb2FkZWQuXCIpfWFzeW5jIGdldFBhcmFtZXRlcnNTaXplKHQ9ITApe3JldHVybiB0aGlzLmhhbmRsZXIuZ2V0UGFyYW1ldGVyc1NpemUodCl9YXN5bmMgbG9hZFBhcmFtZXRlcnNCdWZmZXIodCxyPSEwKXtsZXQgYT1hd2FpdCB0aGlzLmdldFBhcmFtZXRlcnNTaXplKHIpO2lmKHQubGVuZ3RoIT09NCphKXRocm93IG5ldyBFcnJvcihcIlNpemUgb2YgdGhlIGJ1ZmZlciBwYXNzZWQgaW50byBsb2FkUGFyYW1ldGVyc0J1ZmZlciBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBpbiB0aGUgbW9kZWwuIFBsZWFzZSB1c2UgZ2V0UGFyYW1ldGVyc1NpemUgbWV0aG9kIHRvIGNoZWNrLlwiKTtyZXR1cm4gdGhpcy5oYW5kbGVyLmxvYWRQYXJhbWV0ZXJzQnVmZmVyKHQscil9YXN5bmMgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModD0hMCl7cmV0dXJuIHRoaXMuaGFuZGxlci5nZXRDb250aWd1b3VzUGFyYW1ldGVycyh0KX1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9fX0pO3ZhciBibyx2bz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eW8oKTtibz1Ebn0pO3ZhciBFYT17fTtucihFYSx7SW5mZXJlbmNlU2Vzc2lvbjooKT0+bW8sVFJBQ0U6KCk9PnFyLFRSQUNFX0ZVTkNfQkVHSU46KCk9PmR0LFRSQUNFX0ZVTkNfRU5EOigpPT5jdCxUZW5zb3I6KCk9PlplLFRyYWluaW5nU2Vzc2lvbjooKT0+Ym8sZW52OigpPT5BZSxyZWdpc3RlckJhY2tlbmQ6KCk9PkZ0fSk7dmFyIGJ0PVEoKCk9PntcInVzZSBzdHJpY3RcIjtxaSgpO1ppKCk7aG8oKTtCbigpO1RhKCk7Z28oKTt2bygpfSk7dmFyIE9hPXt9O25yKE9hLHtjcmVhdGVSZWFkU3RyZWFtOigpPT4kbyxyZWFkRmlsZTooKT0+V2QscmVhZEZpbGVTeW5jOigpPT5OZH0pO3ZhciBXZCxOZCwkbyxrYT1RKCgpPT57V2Q9dm9pZCAwLE5kPXZvaWQgMCwkbz12b2lkIDB9KTt2YXIgUGE9e307bnIoUGEse2pvaW46KCk9PlZkfSk7dmFyIFZkLFJhPVEoKCk9PntWZD12b2lkIDB9KTt2YXIgeG89YnIoKFNvLEJhKT0+e1widXNlIHN0cmljdFwiO3ZhciBfbz0oKCk9Pnt2YXIgZT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKGU9ZXx8X19maWxlbmFtZSksZnVuY3Rpb24odD17fSl7dmFyIHI9dCxhLGk7ci5yZWFkeT1uZXcgUHJvbWlzZSgodSxmKT0+e2E9dSxpPWZ9KSxyLm1vdW50RXh0ZXJuYWxEYXRhPSh1LGYpPT57KHIuZ2J8fChyLmdiPW5ldyBNYXApKS5zZXQodSxmKX0sci51bm1vdW50RXh0ZXJuYWxEYXRhPSgpPT57ZGVsZXRlIHIuZ2J9LHIuanNlcEluaXQ9KHUsZix5LF8sQSxNLEgsWCk9PntyLkZiPXUsci52Yj1mLHIueGI9eSxyLm9iPV8sci53Yj1BLHIuU2E9TSxyLnliPUgsci56Yj1YLGY9KGoscSxuZSk9PiguLi5tZSk9PntsZXQgJGU9ZXQsUD1xPy4oKTttZT1qKC4uLm1lKTtsZXQgb2U9cT8uKCk7cmV0dXJuIFAhPT1vZSYmKGo9b2UsbmUoUCkscT1uZT1udWxsKSxldCE9JGU/Y24oKTptZX0seT1qPT5hc3luYyguLi5xKT0+e3RyeXtpZihyLmZiKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7bGV0IG5lPXIuZmI9e0FiOnFbMF0sZXJyb3JzOltdfSxtZT1hd2FpdCBqKC4uLnEpO2lmKHIuZmIhPT1uZSl0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7dS5mbHVzaCgpO2xldCAkZT1uZS5lcnJvcnM7aWYoMDwkZS5sZW5ndGgpe2xldCBQPWF3YWl0IFByb21pc2UuYWxsKCRlKTtpZihQPVAuZmlsdGVyKG9lPT5vZSksMDxQLmxlbmd0aCl0aHJvdyBFcnJvcihQLmpvaW4oYFxuYCkpfXJldHVybiBtZX1maW5hbGx5e3IuZmI9bnVsbH19LHIuX09ydENyZWF0ZVNlc3Npb249ZihyLl9PcnRDcmVhdGVTZXNzaW9uLCgpPT5yLl9PcnRDcmVhdGVTZXNzaW9uLGo9PnIuX09ydENyZWF0ZVNlc3Npb249aiksci5fT3J0UnVuPXkoZihyLl9PcnRSdW4sKCk9PnIuX09ydFJ1bixqPT5yLl9PcnRSdW49aikpLHIuX09ydFJ1bldpdGhCaW5kaW5nPXkoZihyLl9PcnRSdW5XaXRoQmluZGluZywoKT0+ci5fT3J0UnVuV2l0aEJpbmRpbmcsaj0+ci5fT3J0UnVuV2l0aEJpbmRpbmc9aikpLHIuX09ydEJpbmRJbnB1dD1mKHIuX09ydEJpbmRJbnB1dCwoKT0+ci5fT3J0QmluZElucHV0LGo9PnIuX09ydEJpbmRJbnB1dD1qKSxyLmpzZXBSZWdpc3RlckJ1ZmZlcj0oaixxLG5lLG1lKT0+dS5yZWdpc3RlckJ1ZmZlcihqLHEsbmUsbWUpLHIuanNlcFVucmVnaXN0ZXJCdWZmZXJzPWo9Pnt1LnVucmVnaXN0ZXJCdWZmZXJzKGopfSxyLmpzZXBHZXRCdWZmZXI9aj0+dS5nZXRCdWZmZXIoaiksci5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oaixxLG5lKT0+dS5jcmVhdGVEb3dubG9hZGVyKGoscSxuZSksci5qc2VwT25SdW5TdGFydD0oKT0+dS5vblJ1blN0YXJ0KCl9O3ZhciBzPU9iamVjdC5hc3NpZ24oe30sciksbz1cIi4vdGhpcy5wcm9ncmFtXCIsYz0odSxmKT0+e3Rocm93IGZ9LHA9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIixtPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsbD10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIsZz1cIlwiLGIsdywkO2lmKGwpe3ZhciB4PShrYSgpLEd0KE9hKSksVD0oUmEoKSxHdChQYSkpO2c9bT9ULmRpcm5hbWUoZykrXCIvXCI6X19kaXJuYW1lK1wiL1wiLGI9KHUsZik9Pih1PWllKHUpP25ldyBVUkwodSk6VC5ub3JtYWxpemUodSkseC5yZWFkRmlsZVN5bmModSxmP3ZvaWQgMDpcInV0ZjhcIikpLCQ9dT0+KHU9Yih1LCEwKSx1LmJ1ZmZlcnx8KHU9bmV3IFVpbnQ4QXJyYXkodSkpLHUpLHc9KHUsZix5LF89ITApPT57dT1pZSh1KT9uZXcgVVJMKHUpOlQubm9ybWFsaXplKHUpLHgucmVhZEZpbGUodSxfP3ZvaWQgMDpcInV0ZjhcIiwoQSxNKT0+e0E/eShBKTpmKF8/TS5idWZmZXI6TSl9KX0sIXIudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKG89cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxjPSh1LGYpPT57dGhyb3cgcHJvY2Vzcy5leGl0Q29kZT11LGZ9LHIuaW5zcGVjdD0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifWVsc2UocHx8bSkmJihtP2c9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKGc9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLGUmJihnPWUpLGcuaW5kZXhPZihcImJsb2I6XCIpIT09MD9nPWcuc3Vic3RyKDAsZy5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpnPVwiXCIsYj11PT57dmFyIGY9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBmLm9wZW4oXCJHRVRcIix1LCExKSxmLnNlbmQobnVsbCksZi5yZXNwb25zZVRleHR9LG0mJigkPXU9Pnt2YXIgZj1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGYub3BlbihcIkdFVFwiLHUsITEpLGYucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixmLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZi5yZXNwb25zZSl9KSx3PSh1LGYseSk9Pnt2YXIgXz1uZXcgWE1MSHR0cFJlcXVlc3Q7Xy5vcGVuKFwiR0VUXCIsdSwhMCksXy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLF8ub25sb2FkPSgpPT57Xy5zdGF0dXM9PTIwMHx8Xy5zdGF0dXM9PTAmJl8ucmVzcG9uc2U/ZihfLnJlc3BvbnNlKTp5KCl9LF8ub25lcnJvcj15LF8uc2VuZChudWxsKX0pO3ZhciBDPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksUz1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihyLHMpLHM9bnVsbCx0eXBlb2YgV2ViQXNzZW1ibHkhPVwib2JqZWN0XCImJkdlKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgRSxPPSExLFUsRCxWLFksc2UsQix0ZSxrZSxPZSxlZSxiZTtmdW5jdGlvbiBVZSgpe3ZhciB1PUUuYnVmZmVyO3IuSEVBUDg9RD1uZXcgSW50OEFycmF5KHUpLHIuSEVBUDE2PVk9bmV3IEludDE2QXJyYXkodSksci5IRUFQVTg9Vj1uZXcgVWludDhBcnJheSh1KSxyLkhFQVBVMTY9c2U9bmV3IFVpbnQxNkFycmF5KHUpLHIuSEVBUDMyPUI9bmV3IEludDMyQXJyYXkodSksci5IRUFQVTMyPXRlPW5ldyBVaW50MzJBcnJheSh1KSxyLkhFQVBGMzI9a2U9bmV3IEZsb2F0MzJBcnJheSh1KSxyLkhFQVBGNjQ9YmU9bmV3IEZsb2F0NjRBcnJheSh1KSxyLkhFQVA2ND1PZT1uZXcgQmlnSW50NjRBcnJheSh1KSxyLkhFQVBVNjQ9ZWU9bmV3IEJpZ1VpbnQ2NEFycmF5KHUpfXZhciBwZT1bXSx5ZT1bXSxkZT1bXSx2ZT0wLFdlPW51bGwsQmU9bnVsbDtmdW5jdGlvbiBHZSh1KXt0aHJvdyB1PVwiQWJvcnRlZChcIit1K1wiKVwiLFModSksTz0hMCxVPTEsdT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHUrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGkodSksdX12YXIgRj11PT51LnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLGllPXU9PnUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIiksaGU7aWYoaGU9XCJvcnQtd2FzbS1zaW1kLndhc21cIiwhRihoZSkpe3ZhciBKZT1oZTtoZT1yLmxvY2F0ZUZpbGU/ci5sb2NhdGVGaWxlKEplLGcpOmcrSmV9ZnVuY3Rpb24gb3QodSl7aWYoJClyZXR1cm4gJCh1KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBSZSh1KXtpZihwfHxtKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIWllKHUpKXJldHVybiBmZXRjaCh1LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGY9PntpZighZi5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrdStcIidcIjtyZXR1cm4gZi5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9Pm90KHUpKTtpZih3KXJldHVybiBuZXcgUHJvbWlzZSgoZix5KT0+e3codSxfPT5mKG5ldyBVaW50OEFycmF5KF8pKSx5KX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5vdCh1KSl9ZnVuY3Rpb24gRmUodSxmLHkpe3JldHVybiBSZSh1KS50aGVuKF89PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKF8sZikpLnRoZW4oXz0+XykudGhlbih5LF89PntTKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke199YCksR2UoXyl9KX1mdW5jdGlvbiBCdCh1LGYpe3ZhciB5PWhlO3JldHVybiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8Rih5KXx8aWUoeSl8fGx8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP0ZlKHksdSxmKTpmZXRjaCh5LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKF89PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKF8sdSkudGhlbihmLGZ1bmN0aW9uKEEpe3JldHVybiBTKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtBfWApLFMoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxGZSh5LHUsZil9KSl9dmFyIE10PXs5NDUxNjg6KHUsZix5LF8pPT57aWYodHlwZW9mIHI+XCJ1XCJ8fCFyLmdiKXJldHVybiAxO2lmKHU9cWUodT4+PjApLHUuc3RhcnRzV2l0aChcIi4vXCIpJiYodT11LnN1YnN0cmluZygyKSksdT1yLmdiLmdldCh1KSwhdSlyZXR1cm4gMjtpZihmPj4+PTAseT4+Pj0wLGYreT51LmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e3JldHVybiBWLnNldCh1LnN1YmFycmF5KGYsZit5KSxfPj4+MD4+PjApLDB9Y2F0Y2h7cmV0dXJuIDR9fSw5NDU2Njk6dT0+ci52Yih1KSw5NDU3MDI6dT0+ci54Yih1KSw5NDU3MzQ6KHUsZix5KT0+e3Iub2IodSxmLHksITApfSw5NDU3NzM6KHUsZix5KT0+e3Iub2IodSxmLHkpfSw5NDU4MDY6dT0+e3IuU2EoXCJBYnNcIix1LHZvaWQgMCl9LDk0NTg1Nzp1PT57ci5TYShcIk5lZ1wiLHUsdm9pZCAwKX0sOTQ1OTA4OnU9PntyLlNhKFwiRmxvb3JcIix1LHZvaWQgMCl9LDk0NTk2MTp1PT57ci5TYShcIkNlaWxcIix1LHZvaWQgMCl9LDk0NjAxMzp1PT57ci5TYShcIlJlY2lwcm9jYWxcIix1LHZvaWQgMCl9LDk0NjA3MTp1PT57ci5TYShcIlNxcnRcIix1LHZvaWQgMCl9LDk0NjEyMzp1PT57ci5TYShcIkV4cFwiLHUsdm9pZCAwKX0sOTQ2MTc0OnU9PntyLlNhKFwiRXJmXCIsdSx2b2lkIDApfSw5NDYyMjU6dT0+e3IuU2EoXCJTaWdtb2lkXCIsdSx2b2lkIDApfSw5NDYyODA6KHUsZix5KT0+e3IuU2EoXCJIYXJkU2lnbW9pZFwiLHUse2FscGhhOmYsYmV0YTp5fSl9LDk0NjM1OTp1PT57ci5TYShcIkxvZ1wiLHUsdm9pZCAwKX0sOTQ2NDEwOnU9PntyLlNhKFwiU2luXCIsdSx2b2lkIDApfSw5NDY0NjE6dT0+e3IuU2EoXCJDb3NcIix1LHZvaWQgMCl9LDk0NjUxMjp1PT57ci5TYShcIlRhblwiLHUsdm9pZCAwKX0sOTQ2NTYzOnU9PntyLlNhKFwiQXNpblwiLHUsdm9pZCAwKX0sOTQ2NjE1OnU9PntyLlNhKFwiQWNvc1wiLHUsdm9pZCAwKX0sOTQ2NjY3OnU9PntyLlNhKFwiQXRhblwiLHUsdm9pZCAwKX0sOTQ2NzE5OnU9PntyLlNhKFwiU2luaFwiLHUsdm9pZCAwKX0sOTQ2NzcxOnU9PntyLlNhKFwiQ29zaFwiLHUsdm9pZCAwKX0sOTQ2ODIzOnU9PntyLlNhKFwiQXNpbmhcIix1LHZvaWQgMCl9LDk0Njg3Njp1PT57ci5TYShcIkFjb3NoXCIsdSx2b2lkIDApfSw5NDY5Mjk6dT0+e3IuU2EoXCJBdGFuaFwiLHUsdm9pZCAwKX0sOTQ2OTgyOnU9PntyLlNhKFwiVGFuaFwiLHUsdm9pZCAwKX0sOTQ3MDM0OnU9PntyLlNhKFwiTm90XCIsdSx2b2lkIDApfSw5NDcwODU6KHUsZix5KT0+e3IuU2EoXCJDbGlwXCIsdSx7bWluOmYsbWF4Onl9KX0sOTQ3MTU0OnU9PntyLlNhKFwiQ2xpcFwiLHUsdm9pZCAwKX0sOTQ3MjA2Oih1LGYpPT57ci5TYShcIkVsdVwiLHUse2FscGhhOmZ9KX0sOTQ3MjY0OnU9PntyLlNhKFwiUmVsdVwiLHUsdm9pZCAwKX0sOTQ3MzE2Oih1LGYpPT57ci5TYShcIkxlYWt5UmVsdVwiLHUse2FscGhhOmZ9KX0sOTQ3MzgwOih1LGYpPT57ci5TYShcIlRocmVzaG9sZGVkUmVsdVwiLHUse2FscGhhOmZ9KX0sOTQ3NDUwOih1LGYpPT57ci5TYShcIkNhc3RcIix1LHt0bzpmfSl9LDk0NzUwODp1PT57ci5TYShcIkFkZFwiLHUsdm9pZCAwKX0sOTQ3NTU5OnU9PntyLlNhKFwiU3ViXCIsdSx2b2lkIDApfSw5NDc2MTA6dT0+e3IuU2EoXCJNdWxcIix1LHZvaWQgMCl9LDk0NzY2MTp1PT57ci5TYShcIkRpdlwiLHUsdm9pZCAwKX0sOTQ3NzEyOnU9PntyLlNhKFwiUG93XCIsdSx2b2lkIDApfSw5NDc3NjM6dT0+e3IuU2EoXCJFcXVhbFwiLHUsdm9pZCAwKX0sOTQ3ODE2OnU9PntyLlNhKFwiR3JlYXRlclwiLHUsdm9pZCAwKX0sOTQ3ODcxOnU9PntyLlNhKFwiR3JlYXRlck9yRXF1YWxcIix1LHZvaWQgMCl9LDk0NzkzMzp1PT57ci5TYShcIkxlc3NcIix1LHZvaWQgMCl9LDk0Nzk4NTp1PT57ci5TYShcIkxlc3NPckVxdWFsXCIsdSx2b2lkIDApfSw5NDgwNDQ6KHUsZix5LF8sQSk9PntyLlNhKFwiUmVkdWNlTWVhblwiLHUse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXksYXhlczpfP0FycmF5LmZyb20oQi5zdWJhcnJheShfPj4+MCxBPj4+MCkpOltdfSl9LDk0ODIwMzoodSxmLHksXyxBKT0+e3IuU2EoXCJSZWR1Y2VNYXhcIix1LHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF5LGF4ZXM6Xz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoXz4+PjAsQT4+PjApKTpbXX0pfSw5NDgzNjE6KHUsZix5LF8sQSk9PntyLlNhKFwiUmVkdWNlTWluXCIsdSx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEheSxheGVzOl8/QXJyYXkuZnJvbShCLnN1YmFycmF5KF8+Pj4wLEE+Pj4wKSk6W119KX0sOTQ4NTE5Oih1LGYseSxfLEEpPT57ci5TYShcIlJlZHVjZVByb2RcIix1LHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF5LGF4ZXM6Xz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoXz4+PjAsQT4+PjApKTpbXX0pfSw5NDg2Nzg6KHUsZix5LF8sQSk9PntyLlNhKFwiUmVkdWNlU3VtXCIsdSx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEheSxheGVzOl8/QXJyYXkuZnJvbShCLnN1YmFycmF5KF8+Pj4wLEE+Pj4wKSk6W119KX0sOTQ4ODM2Oih1LGYseSxfLEEpPT57ci5TYShcIlJlZHVjZUwxXCIsdSx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEheSxheGVzOl8/QXJyYXkuZnJvbShCLnN1YmFycmF5KF8+Pj4wLEE+Pj4wKSk6W119KX0sOTQ4OTkzOih1LGYseSxfLEEpPT57ci5TYShcIlJlZHVjZUwyXCIsdSx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEheSxheGVzOl8/QXJyYXkuZnJvbShCLnN1YmFycmF5KF8+Pj4wLEE+Pj4wKSk6W119KX0sOTQ5MTUwOih1LGYseSxfLEEpPT57ci5TYShcIlJlZHVjZUxvZ1N1bVwiLHUse2tlZXBEaW1zOiEhZixub29wV2l0aEVtcHR5QXhlczohIXksYXhlczpfP0FycmF5LmZyb20oQi5zdWJhcnJheShfPj4+MCxBPj4+MCkpOltdfSl9LDk0OTMxMToodSxmLHksXyxBKT0+e3IuU2EoXCJSZWR1Y2VTdW1TcXVhcmVcIix1LHtrZWVwRGltczohIWYsbm9vcFdpdGhFbXB0eUF4ZXM6ISF5LGF4ZXM6Xz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoXz4+PjAsQT4+PjApKTpbXX0pfSw5NDk0NzU6KHUsZix5LF8sQSk9PntyLlNhKFwiUmVkdWNlTG9nU3VtRXhwXCIsdSx7a2VlcERpbXM6ISFmLG5vb3BXaXRoRW1wdHlBeGVzOiEheSxheGVzOl8/QXJyYXkuZnJvbShCLnN1YmFycmF5KF8+Pj4wLEE+Pj4wKSk6W119KX0sOTQ5NjM5OnU9PntyLlNhKFwiV2hlcmVcIix1LHZvaWQgMCl9LDk0OTY5MjoodSxmLHkpPT57ci5TYShcIlRyYW5zcG9zZVwiLHUse3Blcm06Zj9BcnJheS5mcm9tKEIuc3ViYXJyYXkoZj4+PjAseT4+PjApKTpbXX0pfSw5NDk4MDA6KHUsZix5LF8sQSxNLEgsWCxqLHEsbmUsbWUsJGUsUCxvZSk9PntyLlNhKFwiQ29udlRyYW5zcG9zZVwiLHUse2Zvcm1hdDpqP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6ZixkaWxhdGlvbnM6W3ldLGdyb3VwOl8sa2VybmVsX3NoYXBlOltBXSxwYWRzOltNLEhdLHN0cmlkZXM6W1hdLHdJc0NvbnN0OigpPT4hIURbcT4+PjBdLG91dHB1dFBhZGRpbmc6bmU/QXJyYXkuZnJvbShCLnN1YmFycmF5KG5lPj4+MCxtZT4+PjApKTpbXSxvdXRwdXRTaGFwZTokZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJGU+Pj4wLFA+Pj4wKSk6W10sYWN0aXZhdGlvbjpxZShvZSl9KX0sOTUwMjAyOih1LGYseSxfLEEsTSxILFgsaixxLG5lLG1lLCRlLFApPT57ci5TYShcIkNvbnZUcmFuc3Bvc2VcIix1LHtmb3JtYXQ6WD9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmYsZGlsYXRpb25zOkFycmF5LmZyb20oQi5zdWJhcnJheSh5Pj4+MCwoeT4+PjApKzI+Pj4wKSksZ3JvdXA6XyxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKEIuc3ViYXJyYXkoQT4+PjAsKEE+Pj4wKSsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShCLnN1YmFycmF5KE0+Pj4wLChNPj4+MCkrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oQi5zdWJhcnJheShIPj4+MCwoSD4+PjApKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhRFtqPj4+MF0sb3V0cHV0UGFkZGluZzpxP0FycmF5LmZyb20oQi5zdWJhcnJheShxPj4+MCxuZT4+PjApKTpbXSxvdXRwdXRTaGFwZTptZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkobWU+Pj4wLCRlPj4+MCkpOltdLGFjdGl2YXRpb246cWUoUCl9KX0sOTUwNzY3Oih1LGYseSxfLEEsTSxILFgsaixxLG5lLG1lLCRlLFAsb2UpPT57ci5TYShcIkNvbnZUcmFuc3Bvc2VcIix1LHtmb3JtYXQ6aj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmYsZGlsYXRpb25zOlt5XSxncm91cDpfLGtlcm5lbF9zaGFwZTpbQV0scGFkczpbTSxIXSxzdHJpZGVzOltYXSx3SXNDb25zdDooKT0+ISFEW3E+Pj4wXSxvdXRwdXRQYWRkaW5nOm5lP0FycmF5LmZyb20oQi5zdWJhcnJheShuZT4+PjAsbWU+Pj4wKSk6W10sb3V0cHV0U2hhcGU6JGU/QXJyYXkuZnJvbShCLnN1YmFycmF5KCRlPj4+MCxQPj4+MCkpOltdLGFjdGl2YXRpb246cWUob2UpfSl9LDk1MTE2OToodSxmLHksXyxBLE0sSCxYLGoscSxuZSxtZSwkZSxQKT0+e3IuU2EoXCJDb252VHJhbnNwb3NlXCIsdSx7Zm9ybWF0Olg/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpmLGRpbGF0aW9uczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoeT4+PjAsKHk+Pj4wKSsyPj4+MCkpLGdyb3VwOl8sa2VybmVsU2hhcGU6QXJyYXkuZnJvbShCLnN1YmFycmF5KEE+Pj4wLChBPj4+MCkrMj4+PjApKSxwYWRzOkFycmF5LmZyb20oQi5zdWJhcnJheShNPj4+MCwoTT4+PjApKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoSD4+PjAsKEg+Pj4wKSsyPj4+MCkpLHdJc0NvbnN0OigpPT4hIURbaj4+PjBdLG91dHB1dFBhZGRpbmc6cT9BcnJheS5mcm9tKEIuc3ViYXJyYXkocT4+PjAsbmU+Pj4wKSk6W10sb3V0cHV0U2hhcGU6bWU/QXJyYXkuZnJvbShCLnN1YmFycmF5KG1lPj4+MCwkZT4+PjApKTpbXSxhY3RpdmF0aW9uOnFlKFApfSl9LDk1MTczNDoodSxmKT0+e3IuU2EoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLHUse2Zvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1MTgyNToodSxmLHksXyxBLE0sSCxYLGoscSxuZSxtZSwkZSxQLG9lLEllKT0+e3IuU2EoXCJBdmVyYWdlUG9vbFwiLHUse2Zvcm1hdDpJZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGNlaWxfbW9kZTp5LGNvdW50X2luY2x1ZGVfcGFkOl8sc3RvcmFnZV9vcmRlcjpBLGRpbGF0aW9uczpbTSxIXSxrZXJuZWxfc2hhcGU6W1gsal0scGFkczpbcSxuZSxtZSwkZV0sc3RyaWRlczpbUCxvZV19KX0sOTUyMTA5Oih1LGYpPT57ci5TYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsdSx7Zm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTUyMjAwOih1LGYseSxfLEEsTSxILFgsaixxLG5lLG1lLCRlLFAsb2UsSWUpPT57ci5TYShcIkF2ZXJhZ2VQb29sXCIsdSx7Zm9ybWF0OkllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsY2VpbF9tb2RlOnksY291bnRfaW5jbHVkZV9wYWQ6XyxzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltNLEhdLGtlcm5lbF9zaGFwZTpbWCxqXSxwYWRzOltxLG5lLG1lLCRlXSxzdHJpZGVzOltQLG9lXX0pfSw5NTI0ODQ6KHUsZik9PntyLlNhKFwiR2xvYmFsTWF4UG9vbFwiLHUse2Zvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1MjU3MToodSxmLHksXyxBLE0sSCxYLGoscSxuZSxtZSwkZSxQLG9lLEllKT0+e3IuU2EoXCJNYXhQb29sXCIsdSx7Zm9ybWF0OkllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsY2VpbF9tb2RlOnksY291bnRfaW5jbHVkZV9wYWQ6XyxzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltNLEhdLGtlcm5lbF9zaGFwZTpbWCxqXSxwYWRzOltxLG5lLG1lLCRlXSxzdHJpZGVzOltQLG9lXX0pfSw5NTI4NTE6KHUsZik9PntyLlNhKFwiR2xvYmFsTWF4UG9vbFwiLHUse2Zvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1MjkzODoodSxmLHksXyxBLE0sSCxYLGoscSxuZSxtZSwkZSxQLG9lLEllKT0+e3IuU2EoXCJNYXhQb29sXCIsdSx7Zm9ybWF0OkllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsY2VpbF9tb2RlOnksY291bnRfaW5jbHVkZV9wYWQ6XyxzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltNLEhdLGtlcm5lbF9zaGFwZTpbWCxqXSxwYWRzOltxLG5lLG1lLCRlXSxzdHJpZGVzOltQLG9lXX0pfSw5NTMyMTg6KHUsZix5LF8sQSk9PntyLlNhKFwiR2VtbVwiLHUse2FscGhhOmYsYmV0YTp5LHRyYW5zQTpfLHRyYW5zQjpBfSl9LDk1MzMyMjp1PT57ci5TYShcIk1hdE11bFwiLHUsdm9pZCAwKX0sOTUzMzc2Oih1LGYseSxfKT0+e3IuU2EoXCJBcmdNYXhcIix1LHtrZWVwRGltczohIWYsc2VsZWN0TGFzdEluZGV4OiEheSxheGlzOl99KX0sOTUzNDg0Oih1LGYseSxfKT0+e3IuU2EoXCJBcmdNaW5cIix1LHtrZWVwRGltczohIWYsc2VsZWN0TGFzdEluZGV4OiEheSxheGlzOl99KX0sOTUzNTkyOih1LGYpPT57ci5TYShcIlNvZnRtYXhcIix1LHtheGlzOmZ9KX0sOTUzNjU1Oih1LGYpPT57ci5TYShcIkNvbmNhdFwiLHUse2F4aXM6Zn0pfSw5NTM3MTU6KHUsZix5LF8sQSk9PntyLlNhKFwiU3BsaXRcIix1LHtheGlzOmYsbnVtT3V0cHV0czp5LHNwbGl0U2l6ZXM6Xz9BcnJheS5mcm9tKEIuc3ViYXJyYXkoXz4+PjAsQT4+PjApKTpbXX0pfSw5NTM4NTU6dT0+e3IuU2EoXCJFeHBhbmRcIix1LHZvaWQgMCl9LDk1MzkwOToodSxmKT0+e3IuU2EoXCJHYXRoZXJcIix1LHtheGlzOk51bWJlcihmKX0pfSw5NTM5ODA6KHUsZik9PntyLlNhKFwiR2F0aGVyRWxlbWVudHNcIix1LHtheGlzOk51bWJlcihmKX0pfSw5NTQwNTk6KHUsZix5LF8sQSxNLEgsWCxqLHEsbmUpPT57ci5TYShcIlJlc2l6ZVwiLHUse2FudGlhbGlhczpmLGF4ZXM6eT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoeT4+PjAsXz4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpxZShBKSxjdWJpY0NvZWZmQTpNLGV4Y2x1ZGVPdXRzaWRlOkgsZXh0cmFwb2xhdGlvblZhbHVlOlgsa2VlcEFzcGVjdFJhdGlvUG9saWN5OnFlKGopLG1vZGU6cWUocSksbmVhcmVzdE1vZGU6cWUobmUpfSl9LDk1NDQwNToodSxmLHksXyxBLE0sSCk9PntyLlNhKFwiU2xpY2VcIix1LHtzdGFydHM6Zj9BcnJheS5mcm9tKEIuc3ViYXJyYXkoZj4+PjAseT4+PjApKTpbXSxlbmRzOl8/QXJyYXkuZnJvbShCLnN1YmFycmF5KF8+Pj4wLEE+Pj4wKSk6W10sYXhlczpNP0FycmF5LmZyb20oQi5zdWJhcnJheShNPj4+MCxIPj4+MCkpOltdfSl9LDk1NDYyMTp1PT57ci5TYShcIlRpbGVcIix1LHZvaWQgMCl9LDk1NDY3MzoodSxmLHkpPT57ci5TYShcIkxheWVyTm9ybWFsaXphdGlvblwiLHUse2F4aXM6TnVtYmVyKGYpLGVwc2lsb246TnVtYmVyKHkpfSl9LDk1NDc4MDoodSxmLHkpPT57ci5TYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHUse2Vwc2lsb246Zixmb3JtYXQ6eT9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTQ4OTQ6KHUsZix5KT0+e3IuU2EoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIix1LHtlcHNpbG9uOmYsZm9ybWF0Onk/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTU1MDA4OnU9PntyLlNhKFwiUmFuZ2VcIix1LHZvaWQgMCl9LDk1NTA2MToodSxmKT0+e3IuU2EoXCJFaW5zdW1cIix1LHtlcXVhdGlvbjpxZShmKX0pfSw5NTUxNDI6KHUsZix5LF8sQSk9PntyLlNhKFwiUGFkXCIsdSx7bW9kZTpmLHZhbHVlOnkscGFkczpfP0FycmF5LmZyb20oQi5zdWJhcnJheShfPj4+MCxBPj4+MCkpOltdfSl9LDk1NTI2OToodSxmLHksXyxBLE0pPT57ci5TYShcIkJhdGNoTm9ybWFsaXphdGlvblwiLHUse2Vwc2lsb246Zixtb21lbnR1bTp5LHNwYXRpYWw6ISFBLHRyYWluaW5nTW9kZTohIV8sZm9ybWF0Ok0/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTU1NDM4Oih1LGYseSxfLEEsTSk9PntyLlNhKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsdSx7ZXBzaWxvbjpmLG1vbWVudHVtOnksc3BhdGlhbDohIUEsdHJhaW5pbmdNb2RlOiEhXyxmb3JtYXQ6TT9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTU2MDc6KHUsZix5KT0+e3IuU2EoXCJDdW1TdW1cIix1LHtleGNsdXNpdmU6TnVtYmVyKGYpLHJldmVyc2U6TnVtYmVyKHkpfSl9LDk1NTcwNDoodSxmLHksXyxBLE0sSCxYLGopPT57ci5TYShcIkF0dGVudGlvblwiLHUse251bUhlYWRzOmYsaXNVbmlkaXJlY3Rpb25hbDp5LG1hc2tGaWx0ZXJWYWx1ZTpfLHNjYWxlOkEsZG9Sb3Rhcnk6TSxxa3ZIaWRkZW5TaXplczpIP0FycmF5LmZyb20oQi5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcihYKStIPj4+MCkpOltdLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ISFqfSl9LDk1NTk3Njp1PT57ci5TYShcIkdlbHVcIix1LHZvaWQgMCl9LDk1NjAyODoodSxmLHksXyxBLE0pPT57ci5TYShcIk11bHRpSGVhZEF0dGVudGlvblwiLHUse251bUhlYWRzOmYsaXNVbmlkaXJlY3Rpb25hbDp5LG1hc2tGaWx0ZXJWYWx1ZTpfLHNjYWxlOkEsZG9Sb3Rhcnk6TX0pfSw5NTYxODc6dT0+e3IuU2EoXCJCaWFzQWRkXCIsdSx2b2lkIDApfSw5NTYyNDI6dT0+e3IuU2EoXCJCaWFzU3BsaXRHZWx1XCIsdSx2b2lkIDApfSw5NTYzMDM6KHUsZik9PntyLlNhKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHUse2Vwc2lsb246Zn0pfSw5NTYzODQ6KHUsZix5LF8sQSxNLEgsWCxqLHEsbmUsbWUsJGUpPT57ci5TYShcIkNvbnZcIix1LHtmb3JtYXQ6aj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpmLGRpbGF0aW9uczpbeV0sZ3JvdXA6XyxrZXJuZWxfc2hhcGU6W0FdLHBhZHM6TT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoTT4+PjAsSD4+PjApKTpbXSxzdHJpZGVzOltYXSx3X2lzX2NvbnN0OigpPT4hIURbcT4+PjBdLGFjdGl2YXRpb246cWUobmUpLGFjdGl2YXRpb25fcGFyYW1zOm1lP0FycmF5LmZyb20oa2Uuc3ViYXJyYXkobWU+Pj4wLCRlPj4+MCkpOltdfSl9LDk1Njc1NDoodSxmLHksXyxBLE0sSCxYLGoscSxuZSxtZSwkZSxQLG9lLEllKT0+e3IuU2EoXCJDb252XCIsdSx7Zm9ybWF0Om1lP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmYsZGlsYXRpb25zOlt5LF9dLGdyb3VwOkEsa2VybmVsX3NoYXBlOltNLEhdLHBhZHM6WD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoWD4+PjAsaj4+PjApKTpbXSxzdHJpZGVzOltxLG5lXSx3X2lzX2NvbnN0OigpPT4hIURbJGU+Pj4wXSxhY3RpdmF0aW9uOnFlKFApLGFjdGl2YXRpb25fcGFyYW1zOm9lP0FycmF5LmZyb20oa2Uuc3ViYXJyYXkob2U+Pj4wLEllPj4+MCkpOltdfSl9LDk1NzE0NTp1PT57ci55Yih1KX0sOTU3MTc5Oih1LGYpPT5yLnpiKHUsZixyLmZiLkFiLHIuZmIuZXJyb3JzKX07ZnVuY3Rpb24gS3QodSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke3V9KWAsdGhpcy5zdGF0dXM9dX1mdW5jdGlvbiBOdCh1KXt0aGlzLmNiPXUtMjQsdGhpcy5yYj1mdW5jdGlvbihmKXt0ZVt0aGlzLmNiKzQ+Pj4yPj4+MF09Zn0sdGhpcy5xYj1mdW5jdGlvbihmKXt0ZVt0aGlzLmNiKzg+Pj4yPj4+MF09Zn0sdGhpcy5rYj1mdW5jdGlvbihmLHkpe3RoaXMuamIoKSx0aGlzLnJiKGYpLHRoaXMucWIoeSl9LHRoaXMuamI9ZnVuY3Rpb24oKXt0ZVt0aGlzLmNiKzE2Pj4+Mj4+PjBdPTB9fXZhciB1cj0wLFl0PTAseHI9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLFZ0PSh1LGYseSk9PntmPj4+PTA7dmFyIF89Zit5O2Zvcih5PWY7dVt5XSYmISh5Pj1fKTspKyt5O2lmKDE2PHktZiYmdS5idWZmZXImJnhyKXJldHVybiB4ci5kZWNvZGUodS5zdWJhcnJheShmLHkpKTtmb3IoXz1cIlwiO2Y8eTspe3ZhciBBPXVbZisrXTtpZihBJjEyOCl7dmFyIE09dVtmKytdJjYzO2lmKChBJjIyNCk9PTE5MilfKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChBJjMxKTw8NnxNKTtlbHNle3ZhciBIPXVbZisrXSY2MztBPShBJjI0MCk9PTIyND8oQSYxNSk8PDEyfE08PDZ8SDooQSY3KTw8MTh8TTw8MTJ8SDw8Nnx1W2YrK10mNjMsNjU1MzY+QT9fKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEEpOihBLT02NTUzNixfKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fEE+PjEwLDU2MzIwfEEmMTAyMykpfX1lbHNlIF8rPVN0cmluZy5mcm9tQ2hhckNvZGUoQSl9cmV0dXJuIF99LHFlPSh1LGYpPT4odT4+Pj0wKT9WdChWLHUsZik6XCJcIixEdD11PT57Zm9yKHZhciBmPTAseT0wO3k8dS5sZW5ndGg7Kyt5KXt2YXIgXz11LmNoYXJDb2RlQXQoeSk7MTI3Pj1fP2YrKzoyMDQ3Pj1fP2YrPTI6NTUyOTY8PV8mJjU3MzQzPj1fPyhmKz00LCsreSk6Zis9M31yZXR1cm4gZn0sQ3Q9KHUsZix5LF8pPT57aWYoeT4+Pj0wLCEoMDxfKSlyZXR1cm4gMDt2YXIgQT15O189eStfLTE7Zm9yKHZhciBNPTA7TTx1Lmxlbmd0aDsrK00pe3ZhciBIPXUuY2hhckNvZGVBdChNKTtpZig1NTI5Njw9SCYmNTczNDM+PUgpe3ZhciBYPXUuY2hhckNvZGVBdCgrK00pO0g9NjU1MzYrKChIJjEwMjMpPDwxMCl8WCYxMDIzfWlmKDEyNz49SCl7aWYoeT49XylicmVhaztmW3krKz4+PjBdPUh9ZWxzZXtpZigyMDQ3Pj1IKXtpZih5KzE+PV8pYnJlYWs7Zlt5Kys+Pj4wXT0xOTJ8SD4+Nn1lbHNle2lmKDY1NTM1Pj1IKXtpZih5KzI+PV8pYnJlYWs7Zlt5Kys+Pj4wXT0yMjR8SD4+MTJ9ZWxzZXtpZih5KzM+PV8pYnJlYWs7Zlt5Kys+Pj4wXT0yNDB8SD4+MTgsZlt5Kys+Pj4wXT0xMjh8SD4+MTImNjN9Zlt5Kys+Pj4wXT0xMjh8SD4+NiY2M31mW3krKz4+PjBdPTEyOHxIJjYzfX1yZXR1cm4gZlt5Pj4+MF09MCx5LUF9LENyPXU9PntpZih1PT09bnVsbClyZXR1cm5cIm51bGxcIjt2YXIgZj10eXBlb2YgdTtyZXR1cm4gZj09PVwib2JqZWN0XCJ8fGY9PT1cImFycmF5XCJ8fGY9PT1cImZ1bmN0aW9uXCI/dS50b1N0cmluZygpOlwiXCIrdX0sbm4sc3Q9dT0+e2Zvcih2YXIgZj1cIlwiO1ZbdT4+PjBdOylmKz1ubltWW3UrKz4+PjBdXTtyZXR1cm4gZn0sSXI9e30sWnQ9e30sQXI9e30sZ3Q7ZnVuY3Rpb24gYW4odSxmLHk9e30pe3ZhciBfPWYubmFtZTtpZighdSl0aHJvdyBuZXcgZ3QoYHR5cGUgXCIke199XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKFp0Lmhhc093blByb3BlcnR5KHUpKXtpZih5LnRiKXJldHVybjt0aHJvdyBuZXcgZ3QoYENhbm5vdCByZWdpc3RlciB0eXBlICcke199JyB0d2ljZWApfVp0W3VdPWYsZGVsZXRlIEFyW3VdLElyLmhhc093blByb3BlcnR5KHUpJiYoZj1Jclt1XSxkZWxldGUgSXJbdV0sZi5mb3JFYWNoKEE9PkEoKSkpfWZ1bmN0aW9uIEtlKHUsZix5PXt9KXtpZighKFwiYXJnUGFja0FkdmFuY2VcImluIGYpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlXCIpO2FuKHUsZix5KX12YXIgVHI9KHUsZix5KT0+e3N3aXRjaChmKXtjYXNlIDE6cmV0dXJuIHk/Xz0+RFtfPj4+MD4+PjBdOl89PlZbXz4+PjA+Pj4wXTtjYXNlIDI6cmV0dXJuIHk/Xz0+WVtfPj4+MT4+PjBdOl89PnNlW18+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiB5P189PkJbXz4+PjI+Pj4wXTpfPT50ZVtfPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4geT9fPT5PZVtfPj4+M106Xz0+ZWVbXz4+PjNdO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke2Z9KTogJHt1fWApfX07ZnVuY3Rpb24gRXIoKXt0aGlzLiRhPVt2b2lkIDBdLHRoaXMubmI9W119dmFyIFBlPW5ldyBFcjtmdW5jdGlvbiBPcih1KXt1Pj4+PTAsdT49UGUuY2ImJi0tUGUuZ2V0KHUpLnBiPT09MCYmUGUuamIodSl9dmFyIHdlPXU9PntpZighdSl0aHJvdyBuZXcgZ3QoXCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSBcIit1KTtyZXR1cm4gUGUuZ2V0KHUpLnZhbHVlfSx1dD11PT57c3dpdGNoKHUpe2Nhc2Ugdm9pZCAwOnJldHVybiAxO2Nhc2UgbnVsbDpyZXR1cm4gMjtjYXNlITA6cmV0dXJuIDM7Y2FzZSExOnJldHVybiA0O2RlZmF1bHQ6cmV0dXJuIFBlLmtiKHtwYjoxLHZhbHVlOnV9KX19O2Z1bmN0aW9uIGxyKHUpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShCW3U+Pj4yPj4+MF0pfXZhciBrcj0odSxmKT0+e3N3aXRjaChmKXtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHkpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShrZVt5Pj4+Mj4+PjBdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbih5KXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoYmVbeT4+PjM+Pj4wXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtmfSk6ICR7dX1gKX19O2Z1bmN0aW9uIGZhKHUpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZSh0ZVt1Pj4+Mj4+PjBdKX12YXIgUHI9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnZvaWQgMCxtYT0odSxmKT0+e2Zvcih2YXIgeT11Pj4xLF89eStmLzI7ISh5Pj1fKSYmc2VbeT4+PjBdOykrK3k7aWYoeTw8PTEsMzI8eS11JiZQcilyZXR1cm4gUHIuZGVjb2RlKFYuc3ViYXJyYXkodT4+PjAseT4+PjApKTtmb3IoeT1cIlwiLF89MDshKF8+PWYvMik7KytfKXt2YXIgQT1ZW3UrMipfPj4+MT4+PjBdO2lmKEE9PTApYnJlYWs7eSs9U3RyaW5nLmZyb21DaGFyQ29kZShBKX1yZXR1cm4geX0sZmU9KHUsZix5KT0+e2lmKHk/Pz0yMTQ3NDgzNjQ3LDI+eSlyZXR1cm4gMDt5LT0yO3ZhciBfPWY7eT15PDIqdS5sZW5ndGg/eS8yOnUubGVuZ3RoO2Zvcih2YXIgQT0wO0E8eTsrK0EpWVtmPj4+MT4+PjBdPXUuY2hhckNvZGVBdChBKSxmKz0yO3JldHVybiBZW2Y+Pj4xPj4+MF09MCxmLV99LGRyPXU9PjIqdS5sZW5ndGgsb249KHUsZik9Pntmb3IodmFyIHk9MCxfPVwiXCI7ISh5Pj1mLzQpOyl7dmFyIEE9Qlt1KzQqeT4+PjI+Pj4wXTtpZihBPT0wKWJyZWFrOysreSw2NTUzNjw9QT8oQS09NjU1MzYsXys9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxBPj4xMCw1NjMyMHxBJjEwMjMpKTpfKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEEpfXJldHVybiBffSxoYT0odSxmLHkpPT57aWYoZj4+Pj0wLHk/Pz0yMTQ3NDgzNjQ3LDQ+eSlyZXR1cm4gMDt2YXIgXz1mO3k9Xyt5LTQ7Zm9yKHZhciBBPTA7QTx1Lmxlbmd0aDsrK0Epe3ZhciBNPXUuY2hhckNvZGVBdChBKTtpZig1NTI5Njw9TSYmNTczNDM+PU0pe3ZhciBIPXUuY2hhckNvZGVBdCgrK0EpO009NjU1MzYrKChNJjEwMjMpPDwxMCl8SCYxMDIzfWlmKEJbZj4+PjI+Pj4wXT1NLGYrPTQsZis0PnkpYnJlYWt9cmV0dXJuIEJbZj4+PjI+Pj4wXT0wLGYtX30sc249dT0+e2Zvcih2YXIgZj0wLHk9MDt5PHUubGVuZ3RoOysreSl7dmFyIF89dS5jaGFyQ29kZUF0KHkpOzU1Mjk2PD1fJiY1NzM0Mz49XyYmKyt5LGYrPTR9cmV0dXJuIGZ9LFJyPSh1LGYpPT57dmFyIHk9WnRbdV07aWYoeT09PXZvaWQgMCl0aHJvdyB1PWVyKHUpLHk9c3QodSksbHQodSksbmV3IGd0KGYrXCIgaGFzIHVua25vd24gdHlwZSBcIit5KTtyZXR1cm4geX0sQnI9KHUsZix5KT0+e3ZhciBfPVtdO3JldHVybiB1PXUudG9XaXJlVHlwZShfLHkpLF8ubGVuZ3RoJiYodGVbZj4+PjI+Pj4wXT11dChfKSksdX0sWHQ9dT0+e3RyeXt1KCl9Y2F0Y2goZil7R2UoZil9fTtmdW5jdGlvbiB1bigpe3ZhciB1PXVlLGY9e307Zm9yKGxldFt5LF9db2YgT2JqZWN0LmVudHJpZXModSkpZlt5XT10eXBlb2YgXz09XCJmdW5jdGlvblwiP2Z1bmN0aW9uKCl7SHQucHVzaCh5KTt0cnl7cmV0dXJuIF8uYXBwbHkobnVsbCxhcmd1bWVudHMpfWZpbmFsbHl7T3x8KEh0LnBvcCgpLGV0JiZ3dD09PTEmJkh0Lmxlbmd0aD09PTAmJih3dD0wLFh0KFNuKSx0eXBlb2YgRmliZXJzPFwidVwiJiZGaWJlcnMuSGIoKSkpfX06XztyZXR1cm4gZn12YXIgd3Q9MCxldD1udWxsLE1yPTAsSHQ9W10sRHI9e30senI9e30sbG49MCxjcj1udWxsLGRuPVtdO2Z1bmN0aW9uIGNuKCl7cmV0dXJuIG5ldyBQcm9taXNlKCh1LGYpPT57Y3I9e3Jlc29sdmU6dSxyZWplY3Q6Zn19KX1mdW5jdGlvbiBwbigpe3ZhciB1PUx0KDY1NTQ4KSxmPXUrMTI7dGVbdT4+PjI+Pj4wXT1mLHRlW3UrND4+PjI+Pj4wXT1mKzY1NTM2LGY9SHRbMF07dmFyIHk9RHJbZl07cmV0dXJuIHk9PT12b2lkIDAmJih5PWxuKyssRHJbZl09eSx6clt5XT1mKSxCW3UrOD4+PjI+Pj4wXT15LHV9ZnVuY3Rpb24gZm4odSl7aWYoIU8pe2lmKHd0PT09MCl7dmFyIGY9ITEseT0hMTt1KChfPTApPT57aWYoIU8mJihNcj1fLGY9ITAseSkpe3d0PTIsWHQoKCk9PiR0KGV0KSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIubGIuc2ImJkJyb3dzZXIubGIucmVzdW1lKCksXz0hMTt0cnl7dmFyIEE9KDAsdWVbenJbQltldCs4Pj4+Mj4+PjBdXV0pKCl9Y2F0Y2goWCl7QT1YLF89ITB9dmFyIE09ITE7aWYoIWV0KXt2YXIgSD1jcjtIJiYoY3I9bnVsbCwoXz9ILnJlamVjdDpILnJlc29sdmUpKEEpLE09ITApfWlmKF8mJiFNKXRocm93IEF9fSkseT0hMCxmfHwod3Q9MSxldD1wbigpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLmxiLnNiJiZCcm93c2VyLmxiLnBhdXNlKCksWHQoKCk9PnRyKGV0KSkpfWVsc2Ugd3Q9PT0yPyh3dD0wLFh0KGh0KSxsdChldCksZXQ9bnVsbCxkbi5mb3JFYWNoKF89PntpZighTyl0cnl7XygpO3RyeXtVPVU9Xz1VLHIub25FeGl0Py4oXyksTz0hMCxjKF8sbmV3IEt0KF8pKX1jYXRjaChBKXtBIGluc3RhbmNlb2YgS3R8fEE9PVwidW53aW5kXCJ8fGMoMSxBKX19Y2F0Y2goQSl7QSBpbnN0YW5jZW9mIEt0fHxBPT1cInVud2luZFwifHxjKDEsQSl9fSkpOkdlKGBpbnZhbGlkIHN0YXRlOiAke3d0fWApO3JldHVybiBNcn19ZnVuY3Rpb24gVXIodSl7cmV0dXJuIGZuKGY9Pnt1KCkudGhlbihmKX0pfXZhciBRdD1bXSxtbj17fSxwcj11PT57dmFyIGY9bW5bdV07cmV0dXJuIGY9PT12b2lkIDA/c3QodSk6Zn0sV3I9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLG10PXU9Pnt2YXIgZj1RdC5sZW5ndGg7cmV0dXJuIFF0LnB1c2godSksZn0sTnI9KHUsZik9Pntmb3IodmFyIHk9QXJyYXkodSksXz0wO188dTsrK18peVtfXT1Scih0ZVtmKzQqXz4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIitfKTtyZXR1cm4geX0sZnI9KHUsZik9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLFwibmFtZVwiLHt2YWx1ZTp1fSk7ZnVuY3Rpb24gZ2EodSl7dmFyIGY9RnVuY3Rpb247aWYoIShmIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IG5ldyBUeXBlRXJyb3IoYG5ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAke3R5cGVvZiBmfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciB5PWZyKGYubmFtZXx8XCJ1bmtub3duRnVuY3Rpb25OYW1lXCIsZnVuY3Rpb24oKXt9KTtyZXR1cm4geS5wcm90b3R5cGU9Zi5wcm90b3R5cGUseT1uZXcgeSx1PWYuYXBwbHkoeSx1KSx1IGluc3RhbmNlb2YgT2JqZWN0P3U6eX12YXIgdHQ9dT0+dSU0PT09MCYmKHUlMTAwIT09MHx8dSU0MDA9PT0wKSxobj1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSx5dD1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XSxWcj11PT57dmFyIGY9RHQodSkrMSx5PUx0KGYpO3JldHVybiB5JiZDdCh1LFYseSxmKSx5fSxtcj1bXSxydD0odSxmKT0+e21yLmxlbmd0aD0wO2Zvcih2YXIgeTt5PVZbdSsrPj4+MF07KXt2YXIgXz15IT0xMDU7XyY9eSE9MTEyLGYrPV8mJmYlOD80OjAsbXIucHVzaCh5PT0xMTI/dGVbZj4+PjI+Pj4wXTp5PT0xMDY/T2VbZj4+PjNdOnk9PTEwNT9CW2Y+Pj4yPj4+MF06YmVbZj4+PjM+Pj4wXSksZis9Xz84OjR9cmV0dXJuIG1yfSxKdD17fSxZZT0oKT0+e2lmKCFudCl7dmFyIHU9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86b3x8XCIuL3RoaXMucHJvZ3JhbVwifSxmO2ZvcihmIGluIEp0KUp0W2ZdPT09dm9pZCAwP2RlbGV0ZSB1W2ZdOnVbZl09SnRbZl07dmFyIHk9W107Zm9yKGYgaW4gdSl5LnB1c2goYCR7Zn09JHt1W2ZdfWApO250PXl9cmV0dXJuIG50fSxudCxnbj1bbnVsbCxbXSxbXV0seW49WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxibj1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIHZuKHUpe3ZhciBmPUFycmF5KER0KHUpKzEpO3JldHVybiBDdCh1LGYsMCxmLmxlbmd0aCksZn1mdW5jdGlvbiB3bih1LGYseSxfKXtmdW5jdGlvbiBBKFAsb2UsSWUpe2ZvcihQPXR5cGVvZiBQPT1cIm51bWJlclwiP1AudG9TdHJpbmcoKTpQfHxcIlwiO1AubGVuZ3RoPG9lOylQPUllWzBdK1A7cmV0dXJuIFB9ZnVuY3Rpb24gTShQLG9lKXtyZXR1cm4gQShQLG9lLFwiMFwiKX1mdW5jdGlvbiBIKFAsb2Upe2Z1bmN0aW9uIEllKFd0KXtyZXR1cm4gMD5XdD8tMTowPFd0PzE6MH12YXIgVXQ7cmV0dXJuKFV0PUllKFAuZ2V0RnVsbFllYXIoKS1vZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYoVXQ9SWUoUC5nZXRNb250aCgpLW9lLmdldE1vbnRoKCkpKT09PTAmJihVdD1JZShQLmdldERhdGUoKS1vZS5nZXREYXRlKCkpKSxVdH1mdW5jdGlvbiBYKFApe3N3aXRjaChQLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKFAuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIFA7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShQLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKFAuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoUC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShQLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShQLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGooUCl7dmFyIG9lPVAuYWI7Zm9yKFA9bmV3IERhdGUobmV3IERhdGUoUC5iYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPG9lOyl7dmFyIEllPVAuZ2V0TW9udGgoKSxVdD0odHQoUC5nZXRGdWxsWWVhcigpKT95bjpibilbSWVdO2lmKG9lPlV0LVAuZ2V0RGF0ZSgpKW9lLT1VdC1QLmdldERhdGUoKSsxLFAuc2V0RGF0ZSgxKSwxMT5JZT9QLnNldE1vbnRoKEllKzEpOihQLnNldE1vbnRoKDApLFAuc2V0RnVsbFllYXIoUC5nZXRGdWxsWWVhcigpKzEpKTtlbHNle1Auc2V0RGF0ZShQLmdldERhdGUoKStvZSk7YnJlYWt9fXJldHVybiBJZT1uZXcgRGF0ZShQLmdldEZ1bGxZZWFyKCkrMSwwLDQpLG9lPVgobmV3IERhdGUoUC5nZXRGdWxsWWVhcigpLDAsNCkpLEllPVgoSWUpLDA+PUgob2UsUCk/MD49SChJZSxQKT9QLmdldEZ1bGxZZWFyKCkrMTpQLmdldEZ1bGxZZWFyKCk6UC5nZXRGdWxsWWVhcigpLTF9dT4+Pj0wLGY+Pj49MCx5Pj4+PTAsXz4+Pj0wO3ZhciBxPXRlW18rNDA+Pj4yPj4+MF07Xz17RGI6QltfPj4+Mj4+PjBdLENiOkJbXys0Pj4+Mj4+PjBdLGhiOkJbXys4Pj4+Mj4+PjBdLG1iOkJbXysxMj4+PjI+Pj4wXSxpYjpCW18rMTY+Pj4yPj4+MF0sYmI6QltfKzIwPj4+Mj4+PjBdLFdhOkJbXysyND4+PjI+Pj4wXSxhYjpCW18rMjg+Pj4yPj4+MF0sR2I6QltfKzMyPj4+Mj4+PjBdLEJiOkJbXyszNj4+PjI+Pj4wXSxFYjpxP3FlKHEpOlwiXCJ9LHk9cWUoeSkscT17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgbmUgaW4gcSl5PXkucmVwbGFjZShuZXcgUmVnRXhwKG5lLFwiZ1wiKSxxW25lXSk7dmFyIG1lPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksJGU9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO3E9e1wiJWFcIjpQPT5tZVtQLldhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6UD0+bWVbUC5XYV0sXCIlYlwiOlA9PiRlW1AuaWJdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpQPT4kZVtQLmliXSxcIiVDXCI6UD0+TSgoUC5iYisxOTAwKS8xMDB8MCwyKSxcIiVkXCI6UD0+TShQLm1iLDIpLFwiJWVcIjpQPT5BKFAubWIsMixcIiBcIiksXCIlZ1wiOlA9PmooUCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOlA9PmooUCksXCIlSFwiOlA9Pk0oUC5oYiwyKSxcIiVJXCI6UD0+KFA9UC5oYixQPT0wP1A9MTI6MTI8UCYmKFAtPTEyKSxNKFAsMikpLFwiJWpcIjpQPT57Zm9yKHZhciBvZT0wLEllPTA7SWU8PVAuaWItMTtvZSs9KHR0KFAuYmIrMTkwMCk/eW46Ym4pW0llKytdKTtyZXR1cm4gTShQLm1iK29lLDMpfSxcIiVtXCI6UD0+TShQLmliKzEsMiksXCIlTVwiOlA9Pk0oUC5DYiwyKSxcIiVuXCI6KCk9PmBcbmAsXCIlcFwiOlA9PjA8PVAuaGImJjEyPlAuaGI/XCJBTVwiOlwiUE1cIixcIiVTXCI6UD0+TShQLkRiLDIpLFwiJXRcIjooKT0+XCJcdFwiLFwiJXVcIjpQPT5QLldhfHw3LFwiJVVcIjpQPT5NKE1hdGguZmxvb3IoKFAuYWIrNy1QLldhKS83KSwyKSxcIiVWXCI6UD0+e3ZhciBvZT1NYXRoLmZsb29yKChQLmFiKzctKFAuV2ErNiklNykvNyk7aWYoMj49KFAuV2ErMzcxLVAuYWItMiklNyYmb2UrKyxvZSlvZT09NTMmJihJZT0oUC5XYSszNzEtUC5hYiklNyxJZT09NHx8SWU9PTMmJnR0KFAuYmIpfHwob2U9MSkpO2Vsc2V7b2U9NTI7dmFyIEllPShQLldhKzctUC5hYi0xKSU3OyhJZT09NHx8SWU9PTUmJnR0KFAuYmIlNDAwLTEpKSYmb2UrK31yZXR1cm4gTShvZSwyKX0sXCIld1wiOlA9PlAuV2EsXCIlV1wiOlA9Pk0oTWF0aC5mbG9vcigoUC5hYis3LShQLldhKzYpJTcpLzcpLDIpLFwiJXlcIjpQPT4oUC5iYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6UD0+UC5iYisxOTAwLFwiJXpcIjpQPT57UD1QLkJiO3ZhciBvZT0wPD1QO3JldHVybiBQPU1hdGguYWJzKFApLzYwLChvZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyhQLzYwKjEwMCtQJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6UD0+UC5FYixcIiUlXCI6KCk9PlwiJVwifSx5PXkucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKTtmb3IobmUgaW4gcSl5LmluY2x1ZGVzKG5lKSYmKHk9eS5yZXBsYWNlKG5ldyBSZWdFeHAobmUsXCJnXCIpLHFbbmVdKF8pKSk7cmV0dXJuIHk9eS5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIiksbmU9dm4oeSksbmUubGVuZ3RoPmY/MDooRC5zZXQobmUsdT4+PjApLG5lLmxlbmd0aC0xKX1mb3IodmFyICRuPUFycmF5KDI1NiksaHI9MDsyNTY+aHI7Kytocikkbltocl09U3RyaW5nLmZyb21DaGFyQ29kZShocik7bm49JG4sZ3Q9ci5CaW5kaW5nRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih1KXtzdXBlcih1KSx0aGlzLm5hbWU9XCJCaW5kaW5nRXJyb3JcIn19LHIuSW50ZXJuYWxFcnJvcj1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHUpe3N1cGVyKHUpLHRoaXMubmFtZT1cIkludGVybmFsRXJyb3JcIn19LE9iamVjdC5hc3NpZ24oRXIucHJvdG90eXBlLHtnZXQodSl7cmV0dXJuIHRoaXMuJGFbdV19LGhhcyh1KXtyZXR1cm4gdGhpcy4kYVt1XSE9PXZvaWQgMH0sa2IodSl7dmFyIGY9dGhpcy5uYi5wb3AoKXx8dGhpcy4kYS5sZW5ndGg7cmV0dXJuIHRoaXMuJGFbZl09dSxmfSxqYih1KXt0aGlzLiRhW3VdPXZvaWQgMCx0aGlzLm5iLnB1c2godSl9fSksUGUuJGEucHVzaCh7dmFsdWU6dm9pZCAwfSx7dmFsdWU6bnVsbH0se3ZhbHVlOiEwfSx7dmFsdWU6ITF9KSxQZS5jYj1QZS4kYS5sZW5ndGgsci5jb3VudF9lbXZhbF9oYW5kbGVzPSgpPT57Zm9yKHZhciB1PTAsZj1QZS5jYjtmPFBlLiRhLmxlbmd0aDsrK2YpUGUuJGFbZl0hPT12b2lkIDAmJisrdTtyZXR1cm4gdX07dmFyIHlhPXtpYTpmdW5jdGlvbih1LGYseSl7cmV0dXJuIFVyKGFzeW5jKCk9Pnthd2FpdCByLndiKHUsZix5KX0pfSxhOmZ1bmN0aW9uKHUsZix5KXt0aHJvdyB1Pj4+PTAsbmV3IE50KHUpLmtiKGY+Pj4wLHk+Pj4wKSx1cj11LFl0KyssdXJ9LHg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sYmE6ZnVuY3Rpb24oKXt9LE86ZnVuY3Rpb24oKXt9LFE6ZnVuY3Rpb24oKXt9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LCQ6ZnVuY3Rpb24oKXt9LFc6ZnVuY3Rpb24oKXt9LF86ZnVuY3Rpb24oKXt9LEQ6ZnVuY3Rpb24oKXt9LFA6ZnVuY3Rpb24oKXt9LE06ZnVuY3Rpb24oKXt9LGFhOmZ1bmN0aW9uKCl7fSxOOmZ1bmN0aW9uKCl7fSxHOmZ1bmN0aW9uKHUsZix5LF8sQSl7Zj4+Pj0wLGY9c3QoZik7dmFyIE09Zi5pbmRleE9mKFwidVwiKSE9LTE7TSYmKEE9KDFuPDw2NG4pLTFuKSxLZSh1Pj4+MCx7bmFtZTpmLGZyb21XaXJlVHlwZTpIPT5ILHRvV2lyZVR5cGU6ZnVuY3Rpb24oSCxYKXtpZih0eXBlb2YgWCE9XCJiaWdpbnRcIiYmdHlwZW9mIFghPVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke0NyKFgpfVwiIHRvICR7dGhpcy5uYW1lfWApO2lmKFg8X3x8WD5BKXRocm93IG5ldyBUeXBlRXJyb3IoYFBhc3NpbmcgYSBudW1iZXIgXCIke0NyKFgpfVwiIGZyb20gSlMgc2lkZSB0byBDL0MrKyBzaWRlIHRvIGFuIGFyZ3VtZW50IG9mIHR5cGUgXCIke2Z9XCIsIHdoaWNoIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIFske199LCAke0F9XSFgKTtyZXR1cm4gWH0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpUcihmLHk+Pj4wLCFNKSxlYjpudWxsfSl9LGdhOmZ1bmN0aW9uKHUsZix5LF8pe2Y9c3QoZj4+PjApLEtlKHU+Pj4wLHtuYW1lOmYsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKEEpe3JldHVybiEhQX0sdG9XaXJlVHlwZTpmdW5jdGlvbihBLE0pe3JldHVybiBNP3k6X30sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbihBKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoVltBPj4+MF0pfSxlYjpudWxsfSl9LGZhOmZ1bmN0aW9uKHUsZil7Zj1zdChmPj4+MCksS2UodT4+PjAse25hbWU6Zixmcm9tV2lyZVR5cGU6eT0+e3ZhciBfPXdlKHkpO3JldHVybiBPcih5KSxffSx0b1dpcmVUeXBlOih5LF8pPT51dChfKSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmxyLGViOm51bGx9KX0sRjpmdW5jdGlvbih1LGYseSl7Zj1zdChmPj4+MCksS2UodT4+PjAse25hbWU6Zixmcm9tV2lyZVR5cGU6Xz0+Xyx0b1dpcmVUeXBlOihfLEEpPT5BLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6a3IoZix5Pj4+MCksZWI6bnVsbH0pfSx0OmZ1bmN0aW9uKHUsZix5LF8sQSl7aWYodT4+Pj0wLHk+Pj49MCxmPXN0KGY+Pj4wKSxBPT09LTEmJihBPTQyOTQ5NjcyOTUpLEE9WD0+WCxfPT09MCl7dmFyIE09MzItOCp5O0E9WD0+WDw8TT4+Pk19dmFyIEg9Zi5pbmNsdWRlcyhcInVuc2lnbmVkXCIpP2Z1bmN0aW9uKFgsail7cmV0dXJuIGo+Pj4wfTpmdW5jdGlvbihYLGope3JldHVybiBqfTtLZSh1LHtuYW1lOmYsZnJvbVdpcmVUeXBlOkEsdG9XaXJlVHlwZTpILGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6VHIoZix5LF8hPT0wKSxlYjpudWxsfSl9LG46ZnVuY3Rpb24odSxmLHkpe2Z1bmN0aW9uIF8oTSl7cmV0dXJuIG5ldyBBKEQuYnVmZmVyLHRlW00rND4+PjI+Pj4wXSx0ZVtNPj4+Mj4+PjBdKX12YXIgQT1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXksQmlnSW50NjRBcnJheSxCaWdVaW50NjRBcnJheV1bZl07eT1zdCh5Pj4+MCksS2UodT4+PjAse25hbWU6eSxmcm9tV2lyZVR5cGU6XyxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOl99LHt0YjohMH0pfSxIOmZ1bmN0aW9uKHUsZil7Zj1zdChmPj4+MCk7dmFyIHk9Zj09PVwic3RkOjpzdHJpbmdcIjtLZSh1Pj4+MCx7bmFtZTpmLGZyb21XaXJlVHlwZTpmdW5jdGlvbihfKXt2YXIgQT10ZVtfPj4+Mj4+PjBdLE09Xys0O2lmKHkpZm9yKHZhciBIPU0sWD0wO1g8PUE7KytYKXt2YXIgaj1NK1g7aWYoWD09QXx8VltqPj4+MF09PTApe2lmKEg9cWUoSCxqLUgpLHE9PT12b2lkIDApdmFyIHE9SDtlbHNlIHErPVN0cmluZy5mcm9tQ2hhckNvZGUoMCkscSs9SDtIPWorMX19ZWxzZXtmb3IocT1BcnJheShBKSxYPTA7WDxBOysrWClxW1hdPVN0cmluZy5mcm9tQ2hhckNvZGUoVltNK1g+Pj4wXSk7cT1xLmpvaW4oXCJcIil9cmV0dXJuIGx0KF8pLHF9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oXyxBKXtBIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJihBPW5ldyBVaW50OEFycmF5KEEpKTt2YXIgTT10eXBlb2YgQT09XCJzdHJpbmdcIjtpZighKE18fEEgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxBIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fEEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXRocm93IG5ldyBndChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7dmFyIEg9eSYmTT9EdChBKTpBLmxlbmd0aCxYPUx0KDQrSCsxKSxqPVgrNDtpZih0ZVtYPj4+Mj4+PjBdPUgseSYmTSlDdChBLFYsaixIKzEpO2Vsc2UgaWYoTSlmb3IoTT0wO008SDsrK00pe3ZhciBxPUEuY2hhckNvZGVBdChNKTtpZigyNTU8cSl0aHJvdyBsdChqKSxuZXcgZ3QoXCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHNcIik7VltqK00+Pj4wXT1xfWVsc2UgZm9yKE09MDtNPEg7KytNKVZbaitNPj4+MF09QVtNXTtyZXR1cm4gXyE9PW51bGwmJl8ucHVzaChsdCxYKSxYfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZhLGViKF8pe2x0KF8pfX0pfSx6OmZ1bmN0aW9uKHUsZix5KXtpZihmPj4+PTAseT4+Pj0wLHk9c3QoeSksZj09PTIpdmFyIF89bWEsQT1mZSxNPWRyLEg9KCk9PnNlLFg9MTtlbHNlIGY9PT00JiYoXz1vbixBPWhhLE09c24sSD0oKT0+dGUsWD0yKTtLZSh1Pj4+MCx7bmFtZTp5LGZyb21XaXJlVHlwZTpqPT57Zm9yKHZhciBxPXRlW2o+Pj4yPj4+MF0sbmU9SCgpLG1lLCRlPWorNCxQPTA7UDw9cTsrK1Ape3ZhciBvZT1qKzQrUCpmOyhQPT1xfHxuZVtvZT4+PlhdPT0wKSYmKCRlPV8oJGUsb2UtJGUpLG1lPT09dm9pZCAwP21lPSRlOihtZSs9U3RyaW5nLmZyb21DaGFyQ29kZSgwKSxtZSs9JGUpLCRlPW9lK2YpfXJldHVybiBsdChqKSxtZX0sdG9XaXJlVHlwZTooaixxKT0+e2lmKHR5cGVvZiBxIT1cInN0cmluZ1wiKXRocm93IG5ldyBndChgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHt5fWApO3ZhciBuZT1NKHEpLG1lPUx0KDQrbmUrZik7cmV0dXJuIHRlW21lPj4+Ml09bmU+PlgsQShxLG1lKzQsbmUrZiksaiE9PW51bGwmJmoucHVzaChsdCxtZSksbWV9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6bHIsZWIoail7bHQoail9fSl9LGhhOmZ1bmN0aW9uKHUsZil7Zj1zdChmPj4+MCksS2UodT4+PjAse3ViOiEwLG5hbWU6ZixhcmdQYWNrQWR2YW5jZTowLGZyb21XaXJlVHlwZTooKT0+e30sdG9XaXJlVHlwZTooKT0+e319KX0sZGE6KCk9PjEsczpmdW5jdGlvbih1LGYseSl7cmV0dXJuIGY+Pj49MCx5Pj4+PTAsdT13ZSh1Pj4+MCksZj1ScihmLFwiZW12YWw6OmFzXCIpLEJyKGYseSx1KX0sdzpmdW5jdGlvbih1KXtyZXR1cm4gdT4+Pj0wLFVyKCgpPT4odT13ZSh1KSx1LnRoZW4odXQpKSl9LG86ZnVuY3Rpb24odSxmLHksXyl7cmV0dXJuIHk+Pj49MCxfPj4+PTAsdT1RdFt1Pj4+MF0sZj13ZShmPj4+MCksdShudWxsLGYseSxfKX0sazpmdW5jdGlvbih1LGYseSxfLEEpe3JldHVybiB5Pj4+PTAsXz4+Pj0wLEE+Pj49MCx1PVF0W3U+Pj4wXSxmPXdlKGY+Pj4wKSx5PXByKHkpLHUoZixmW3ldLF8sQSl9LGI6T3IsQTpmdW5jdGlvbih1LGYpe3JldHVybiBmPj4+PTAsdT13ZSh1Pj4+MCksZj13ZShmKSx1PT1mfSxtOmZ1bmN0aW9uKHUpe3JldHVybiB1Pj4+PTAsdT09PTA/dXQoV3IoKSk6KHU9cHIodSksdXQoV3IoKVt1XSkpfSxpOmZ1bmN0aW9uKHUsZix5KXtmPU5yKHUsZj4+PjApO3ZhciBfPWYuc2hpZnQoKTt1LS07dmFyIEE9YHJldHVybiBmdW5jdGlvbiAob2JqLCBmdW5jLCBkZXN0cnVjdG9yc1JlZiwgYXJncykge1xuYCxNPTAsSD1bXTt5PT09MCYmSC5wdXNoKFwib2JqXCIpO2Zvcih2YXIgWD1bXCJyZXRUeXBlXCJdLGo9W19dLHE9MDtxPHU7KytxKUgucHVzaChcImFyZ1wiK3EpLFgucHVzaChcImFyZ1R5cGVcIitxKSxqLnB1c2goZltxXSksQSs9YCAgdmFyIGFyZyR7cX0gPSBhcmdUeXBlJHtxfS5yZWFkVmFsdWVGcm9tUG9pbnRlcihhcmdzJHtNP1wiK1wiK006XCJcIn0pO1xuYCxNKz1mW3FdLmFyZ1BhY2tBZHZhbmNlO2ZvcihBKz1gICB2YXIgcnYgPSAke3k9PT0xP1wibmV3IGZ1bmNcIjpcImZ1bmMuY2FsbFwifSgke0guam9pbihcIiwgXCIpfSk7XG5gLHE9MDtxPHU7KytxKWZbcV0uZGVsZXRlT2JqZWN0JiYoQSs9YCAgYXJnVHlwZSR7cX0uZGVsZXRlT2JqZWN0KGFyZyR7cX0pO1xuYCk7cmV0dXJuIF8udWJ8fChYLnB1c2goXCJlbXZhbF9yZXR1cm5WYWx1ZVwiKSxqLnB1c2goQnIpLEErPWAgIHJldHVybiBlbXZhbF9yZXR1cm5WYWx1ZShyZXRUeXBlLCBkZXN0cnVjdG9yc1JlZiwgcnYpO1xuYCksWC5wdXNoKEErYH07XG5gKSx1PWdhKFgpLmFwcGx5KG51bGwsaikseT1gbWV0aG9kQ2FsbGVyPCgke2YubWFwKG5lPT5uZS5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke18ubmFtZX0+YCxtdChmcih5LHUpKX0scjpmdW5jdGlvbih1LGYpe3JldHVybiBmPj4+PTAsdT13ZSh1Pj4+MCksZj13ZShmKSx1dCh1W2ZdKX0sZTpmdW5jdGlvbih1KXt1Pj4+PTAsNDx1JiYoUGUuZ2V0KHUpLnBiKz0xKX0sdTpmdW5jdGlvbigpe3JldHVybiB1dChbXSl9LGw6ZnVuY3Rpb24odSl7dT13ZSh1Pj4+MCk7Zm9yKHZhciBmPUFycmF5KHUubGVuZ3RoKSx5PTA7eTx1Lmxlbmd0aDt5KyspZlt5XT11W3ldO3JldHVybiB1dChmKX0sZDpmdW5jdGlvbih1KXtyZXR1cm4gdXQocHIodT4+PjApKX0sajpmdW5jdGlvbigpe3JldHVybiB1dCh7fSl9LGg6ZnVuY3Rpb24odSl7dT4+Pj0wO2Zvcih2YXIgZj13ZSh1KTtmLmxlbmd0aDspe3ZhciB5PWYucG9wKCk7Zi5wb3AoKSh5KX1Pcih1KX0sZzpmdW5jdGlvbih1LGYseSl7Zj4+Pj0wLHk+Pj49MCx1PXdlKHU+Pj4wKSxmPXdlKGYpLHk9d2UoeSksdVtmXT15fSxjOmZ1bmN0aW9uKHUsZil7cmV0dXJuIGY+Pj49MCx1PVJyKHU+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIiksdT11LnJlYWRWYWx1ZUZyb21Qb2ludGVyKGYpLHV0KHUpfSxUOmZ1bmN0aW9uKHUsZil7dT0tOTAwNzE5OTI1NDc0MDk5Mj51fHw5MDA3MTk5MjU0NzQwOTkyPHU/TmFOOk51bWJlcih1KSxmPj4+PTAsdT1uZXcgRGF0ZSgxZTMqdSksQltmPj4+Mj4+PjBdPXUuZ2V0VVRDU2Vjb25kcygpLEJbZis0Pj4+Mj4+PjBdPXUuZ2V0VVRDTWludXRlcygpLEJbZis4Pj4+Mj4+PjBdPXUuZ2V0VVRDSG91cnMoKSxCW2YrMTI+Pj4yPj4+MF09dS5nZXRVVENEYXRlKCksQltmKzE2Pj4+Mj4+PjBdPXUuZ2V0VVRDTW9udGgoKSxCW2YrMjA+Pj4yPj4+MF09dS5nZXRVVENGdWxsWWVhcigpLTE5MDAsQltmKzI0Pj4+Mj4+PjBdPXUuZ2V0VVRDRGF5KCksQltmKzI4Pj4+Mj4+PjBdPSh1LmdldFRpbWUoKS1EYXRlLlVUQyh1LmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxVOmZ1bmN0aW9uKHUsZil7dT0tOTAwNzE5OTI1NDc0MDk5Mj51fHw5MDA3MTk5MjU0NzQwOTkyPHU/TmFOOk51bWJlcih1KSxmPj4+PTAsdT1uZXcgRGF0ZSgxZTMqdSksQltmPj4+Mj4+PjBdPXUuZ2V0U2Vjb25kcygpLEJbZis0Pj4+Mj4+PjBdPXUuZ2V0TWludXRlcygpLEJbZis4Pj4+Mj4+PjBdPXUuZ2V0SG91cnMoKSxCW2YrMTI+Pj4yPj4+MF09dS5nZXREYXRlKCksQltmKzE2Pj4+Mj4+PjBdPXUuZ2V0TW9udGgoKSxCW2YrMjA+Pj4yPj4+MF09dS5nZXRGdWxsWWVhcigpLTE5MDAsQltmKzI0Pj4+Mj4+PjBdPXUuZ2V0RGF5KCksQltmKzI4Pj4+Mj4+PjBdPSh0dCh1LmdldEZ1bGxZZWFyKCkpP2huOnl0KVt1LmdldE1vbnRoKCldK3UuZ2V0RGF0ZSgpLTF8MCxCW2YrMzY+Pj4yPj4+MF09LSg2MCp1LmdldFRpbWV6b25lT2Zmc2V0KCkpO3ZhciB5PW5ldyBEYXRlKHUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksXz1uZXcgRGF0ZSh1LmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO0JbZiszMj4+PjI+Pj4wXT0oeSE9XyYmdS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihfLHkpKXwwfSxWOmZ1bmN0aW9uKHUpe3U+Pj49MDt2YXIgZj1uZXcgRGF0ZShCW3UrMjA+Pj4yPj4+MF0rMTkwMCxCW3UrMTY+Pj4yPj4+MF0sQlt1KzEyPj4+Mj4+PjBdLEJbdSs4Pj4+Mj4+PjBdLEJbdSs0Pj4+Mj4+PjBdLEJbdT4+PjI+Pj4wXSwwKSx5PUJbdSszMj4+PjI+Pj4wXSxfPWYuZ2V0VGltZXpvbmVPZmZzZXQoKSxBPW5ldyBEYXRlKGYuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksTT1uZXcgRGF0ZShmLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEg9TWF0aC5taW4oTSxBKTtyZXR1cm4gMD55P0JbdSszMj4+PjI+Pj4wXT0rKEEhPU0mJkg9PV8pOjA8eSE9KEg9PV8pJiYoQT1NYXRoLm1heChNLEEpLGYuc2V0VGltZShmLmdldFRpbWUoKSs2ZTQqKCgwPHk/SDpBKS1fKSkpLEJbdSsyND4+PjI+Pj4wXT1mLmdldERheSgpLEJbdSsyOD4+PjI+Pj4wXT0odHQoZi5nZXRGdWxsWWVhcigpKT9objp5dClbZi5nZXRNb250aCgpXStmLmdldERhdGUoKS0xfDAsQlt1Pj4+Mj4+PjBdPWYuZ2V0U2Vjb25kcygpLEJbdSs0Pj4+Mj4+PjBdPWYuZ2V0TWludXRlcygpLEJbdSs4Pj4+Mj4+PjBdPWYuZ2V0SG91cnMoKSxCW3UrMTI+Pj4yPj4+MF09Zi5nZXREYXRlKCksQlt1KzE2Pj4+Mj4+PjBdPWYuZ2V0TW9udGgoKSxCW3UrMjA+Pj4yPj4+MF09Zi5nZXRZZWFyKCksdT1mLmdldFRpbWUoKSxpc05hTih1KT8oQltfbigpPj4+Mj4+PjBdPTYxLHU9LTEpOnUvPTFlMyxCaWdJbnQodSl9LFI6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LFM6ZnVuY3Rpb24oKXt9LEs6ZnVuY3Rpb24odSxmLHkpe2Z1bmN0aW9uIF8oail7cmV0dXJuKGo9ai50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9qWzFdOlwiR01UXCJ9eT4+Pj0wO3ZhciBBPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxNPW5ldyBEYXRlKEEsMCwxKSxIPW5ldyBEYXRlKEEsNiwxKTtBPU0uZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgWD1ILmdldFRpbWV6b25lT2Zmc2V0KCk7dGVbdT4+PjA+Pj4yPj4+MF09NjAqTWF0aC5tYXgoQSxYKSxCW2Y+Pj4wPj4+Mj4+PjBdPSsoQSE9WCksdT1fKE0pLGY9XyhIKSx1PVZyKHUpLGY9VnIoZiksWDxBPyh0ZVt5Pj4+Mj4+PjBdPXUsdGVbeSs0Pj4+Mj4+PjBdPWYpOih0ZVt5Pj4+Mj4+PjBdPWYsdGVbeSs0Pj4+Mj4+PjBdPXUpfSx2OigpPT57R2UoXCJcIil9LGY6ZnVuY3Rpb24odSxmLHkpe3JldHVybiB1Pj4+PTAsZj1ydChmPj4+MCx5Pj4+MCksTXRbdV0uYXBwbHkobnVsbCxmKX0sSTpmdW5jdGlvbih1LGYseSl7cmV0dXJuIHU+Pj49MCxmPXJ0KGY+Pj4wLHk+Pj4wKSxNdFt1XS5hcHBseShudWxsLGYpfSxFOigpPT5EYXRlLm5vdygpLEw6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0scTooKT0+cGVyZm9ybWFuY2Uubm93KCksSjpmdW5jdGlvbih1KXt1Pj4+PTA7dmFyIGY9Vi5sZW5ndGg7aWYoNDI5NDkwMTc2MDx1KXJldHVybiExO2Zvcih2YXIgeT0xOzQ+PXk7eSo9Mil7dmFyIF89ZiooMSsuMi95KTtfPU1hdGgubWluKF8sdSsxMDA2NjMyOTYpO3ZhciBBPU1hdGg7Xz1NYXRoLm1heCh1LF8pO2U6e0E9KEEubWluLmNhbGwoQSw0Mjk0OTAxNzYwLF8rKDY1NTM2LV8lNjU1MzYpJTY1NTM2KS1FLmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1KS82NTUzNjt0cnl7RS5ncm93KEEpLFVlKCk7dmFyIE09MTticmVhayBlfWNhdGNoe31NPXZvaWQgMH1pZihNKXJldHVybiEwfXJldHVybiExfSxZOmZ1bmN0aW9uKHUsZil7dT4+Pj0wLGY+Pj49MDt2YXIgeT0wO3JldHVybiBZZSgpLmZvckVhY2goKF8sQSk9Pnt2YXIgTT1mK3k7Zm9yKEE9dGVbdSs0KkE+Pj4yPj4+MF09TSxNPTA7TTxfLmxlbmd0aDsrK00pRFtBKys+Pj4wPj4+MF09Xy5jaGFyQ29kZUF0KE0pO0RbQT4+PjA+Pj4wXT0wLHkrPV8ubGVuZ3RoKzF9KSwwfSxaOmZ1bmN0aW9uKHUsZil7dT4+Pj0wLGY+Pj49MDt2YXIgeT1ZZSgpO3RlW3U+Pj4yPj4+MF09eS5sZW5ndGg7dmFyIF89MDtyZXR1cm4geS5mb3JFYWNoKEE9Pl8rPUEubGVuZ3RoKzEpLHRlW2Y+Pj4yPj4+MF09XywwfSx5OigpPT41MixDOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSxYOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxCOmZ1bmN0aW9uKHUsZix5LF8pe2Y+Pj49MCx5Pj4+PTAsXz4+Pj0wO2Zvcih2YXIgQT0wLE09MDtNPHk7TSsrKXt2YXIgSD10ZVtmPj4+Mj4+PjBdLFg9dGVbZis0Pj4+Mj4+PjBdO2YrPTg7Zm9yKHZhciBqPTA7ajxYO2orKyl7dmFyIHE9VltIK2o+Pj4wXSxuZT1nblt1XTtxPT09MHx8cT09PTEwPygodT09PTE/QzpTKShWdChuZSwwKSksbmUubGVuZ3RoPTApOm5lLnB1c2gocSl9QSs9WH1yZXR1cm4gdGVbXz4+PjI+Pj4wXT1BLDB9LGVhOnduLHA6ZnVuY3Rpb24odSxmLHksXyl7cmV0dXJuIHduKHU+Pj4wLGY+Pj4wLHk+Pj4wLF8+Pj4wKX19LHVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdSh5KXtyZXR1cm4gdWU9eS5leHBvcnRzLHVlPXVuKCksdWU9eG4oKSxFPXVlLmphLFVlKCkseWUudW5zaGlmdCh1ZS5rYSksdmUtLSx2ZT09MCYmKFdlIT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoV2UpLFdlPW51bGwpLEJlJiYoeT1CZSxCZT1udWxsLHkoKSkpLHVlfXZhciBmPXthOnlhfTtpZih2ZSsrLHIuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gci5pbnN0YW50aWF0ZVdhc20oZix1KX1jYXRjaCh5KXtTKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke3l9YCksaSh5KX1yZXR1cm4gQnQoZixmdW5jdGlvbih5KXt1KHkuaW5zdGFuY2UpfSkuY2F0Y2goaSkse319KCk7ci5fT3J0SW5pdD0odSxmKT0+KHIuX09ydEluaXQ9dWUubGEpKHUsZiksci5fT3J0R2V0TGFzdEVycm9yPSh1LGYpPT4oci5fT3J0R2V0TGFzdEVycm9yPXVlLm1hKSh1LGYpLHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPSh1LGYseSxfLEEsTSxILFgsaixxKT0+KHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXVlLm5hKSh1LGYseSxfLEEsTSxILFgsaixxKSxyLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0odSxmKT0+KHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXVlLm9hKSh1LGYpLHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0odSxmLHkpPT4oci5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPXVlLnBhKSh1LGYseSksci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PSh1LGYseSk9PihyLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9dWUucWEpKHUsZix5KSxyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9dT0+KHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz11ZS5yYSkodSksci5fT3J0Q3JlYXRlU2Vzc2lvbj0odSxmLHkpPT4oci5fT3J0Q3JlYXRlU2Vzc2lvbj11ZS5zYSkodSxmLHkpLHIuX09ydFJlbGVhc2VTZXNzaW9uPXU9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbj11ZS50YSkodSksci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0odSxmLHkpPT4oci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD11ZS51YSkodSxmLHkpLHIuX09ydEdldElucHV0TmFtZT0odSxmKT0+KHIuX09ydEdldElucHV0TmFtZT11ZS52YSkodSxmKSxyLl9PcnRHZXRPdXRwdXROYW1lPSh1LGYpPT4oci5fT3J0R2V0T3V0cHV0TmFtZT11ZS53YSkodSxmKSxyLl9PcnRGcmVlPXU9PihyLl9PcnRGcmVlPXVlLnhhKSh1KSxyLl9PcnRDcmVhdGVUZW5zb3I9KHUsZix5LF8sQSxNKT0+KHIuX09ydENyZWF0ZVRlbnNvcj11ZS55YSkodSxmLHksXyxBLE0pLHIuX09ydEdldFRlbnNvckRhdGE9KHUsZix5LF8sQSk9PihyLl9PcnRHZXRUZW5zb3JEYXRhPXVlLnphKSh1LGYseSxfLEEpLHIuX09ydFJlbGVhc2VUZW5zb3I9dT0+KHIuX09ydFJlbGVhc2VUZW5zb3I9dWUuQWEpKHUpLHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KHUsZix5LF8pPT4oci5fT3J0Q3JlYXRlUnVuT3B0aW9ucz11ZS5CYSkodSxmLHksXyksci5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KHUsZix5KT0+KHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXVlLkNhKSh1LGYseSksci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9dT0+KHIuX09ydFJlbGVhc2VSdW5PcHRpb25zPXVlLkRhKSh1KSxyLl9PcnRDcmVhdGVCaW5kaW5nPXU9PihyLl9PcnRDcmVhdGVCaW5kaW5nPXVlLkVhKSh1KSxyLl9PcnRCaW5kSW5wdXQ9KHUsZix5KT0+KHIuX09ydEJpbmRJbnB1dD11ZS5GYSkodSxmLHkpLHIuX09ydEJpbmRPdXRwdXQ9KHUsZix5LF8pPT4oci5fT3J0QmluZE91dHB1dD11ZS5HYSkodSxmLHksXyksci5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9dT0+KHIuX09ydENsZWFyQm91bmRPdXRwdXRzPXVlLkhhKSh1KSxyLl9PcnRSZWxlYXNlQmluZGluZz11PT4oci5fT3J0UmVsZWFzZUJpbmRpbmc9dWUuSWEpKHUpLHIuX09ydFJ1bldpdGhCaW5kaW5nPSh1LGYseSxfLEEpPT4oci5fT3J0UnVuV2l0aEJpbmRpbmc9dWUuSmEpKHUsZix5LF8sQSksci5fT3J0UnVuPSh1LGYseSxfLEEsTSxILFgpPT4oci5fT3J0UnVuPXVlLkthKSh1LGYseSxfLEEsTSxILFgpLHIuX09ydEVuZFByb2ZpbGluZz11PT4oci5fT3J0RW5kUHJvZmlsaW5nPXVlLkxhKSh1KSxyLl9Kc2VwT3V0cHV0PSh1LGYseSk9PihyLl9Kc2VwT3V0cHV0PXVlLk1hKSh1LGYseSksci5fSnNlcEdldE5vZGVOYW1lPXU9PihyLl9Kc2VwR2V0Tm9kZU5hbWU9dWUuTmEpKHUpO3ZhciBfbj0oKT0+KF9uPXVlLk9hKSgpLEx0PXIuX21hbGxvYz11PT4oTHQ9ci5fbWFsbG9jPXVlLlBhKSh1KSxsdD1yLl9mcmVlPXU9PihsdD1yLl9mcmVlPXVlLlFhKSh1KSxlcj11PT4oZXI9dWUuUmEpKHUpLGdyPSgpPT4oZ3I9dWUuVGEpKCkseXI9dT0+KHlyPXVlLlVhKSh1KSxIcj11PT4oSHI9dWUuVmEpKHUpLHRyPXU9Pih0cj11ZS5YYSkodSksU249KCk9PihTbj11ZS5ZYSkoKSwkdD11PT4oJHQ9dWUuWmEpKHUpLGh0PSgpPT4oaHQ9dWUuX2EpKCk7ci5fX19zdGFydF9lbV9qcz05NTcyOTEsci5fX19zdG9wX2VtX2pzPTk1NzQ1MjtmdW5jdGlvbiB4bigpe3ZhciB1PXVlO3U9T2JqZWN0LmFzc2lnbih7fSx1KTt2YXIgZj1fPT4oKT0+XygpPj4+MCx5PV89PkE9Pl8oQSk+Pj4wO3JldHVybiB1Lk9hPWYodS5PYSksdS5QYT15KHUuUGEpLHUuUmE9eSh1LlJhKSx1LlRhPWYodS5UYSksdS5WYT15KHUuVmEpLHV9ci5zdGFja0FsbG9jPUhyLHIuc3RhY2tTYXZlPWdyLHIuc3RhY2tSZXN0b3JlPXlyLHIuVVRGOFRvU3RyaW5nPXFlLHIuc3RyaW5nVG9VVEY4PSh1LGYseSk9PkN0KHUsVixmLHkpLHIubGVuZ3RoQnl0ZXNVVEY4PUR0O3ZhciB6dDtCZT1mdW5jdGlvbiB1KCl7enR8fExyKCksenR8fChCZT11KX07ZnVuY3Rpb24gTHIoKXtpZighKDA8dmUpKXtpZihyLnByZVJ1bilmb3IodHlwZW9mIHIucHJlUnVuPT1cImZ1bmN0aW9uXCImJihyLnByZVJ1bj1bci5wcmVSdW5dKTtyLnByZVJ1bi5sZW5ndGg7KXt2YXIgdT1yLnByZVJ1bi5zaGlmdCgpO3BlLnVuc2hpZnQodSl9Zm9yKDswPHBlLmxlbmd0aDspcGUuc2hpZnQoKShyKTtpZighKDA8dmV8fHp0fHwoenQ9ITAsci5jYWxsZWRSdW49ITAsTykpKXtmb3IoOzA8eWUubGVuZ3RoOyl5ZS5zaGlmdCgpKHIpO2ZvcihhKHIpOzA8ZGUubGVuZ3RoOylkZS5zaGlmdCgpKHIpfX19cmV0dXJuIExyKCksdC5yZWFkeX19KSgpO3R5cGVvZiBTbz09XCJvYmplY3RcIiYmdHlwZW9mIEJhPT1cIm9iamVjdFwiP0JhLmV4cG9ydHM9X286dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9Pl9vKX0pO3ZhciBDbz1icigoKT0+e30pO3ZhciBJbz1icigoKT0+e30pO3ZhciBBbz17fTtucihBbyx7Y3B1czooKT0+SGR9KTt2YXIgSGQsVG89USgoKT0+e0hkPXZvaWQgMH0pO3ZhciBrbz1icigoT28sTWEpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEVvPSgoKT0+e3ZhciBlPXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYoZT1lfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbih0PXt9KXtmdW5jdGlvbiByKCl7cmV0dXJuIGJlLmJ1ZmZlciE9ZGUuYnVmZmVyJiZSZSgpLGRlfWZ1bmN0aW9uIGEoKXtyZXR1cm4gYmUuYnVmZmVyIT1kZS5idWZmZXImJlJlKCksdmV9ZnVuY3Rpb24gaSgpe3JldHVybiBiZS5idWZmZXIhPWRlLmJ1ZmZlciYmUmUoKSxXZX1mdW5jdGlvbiBzKCl7cmV0dXJuIGJlLmJ1ZmZlciE9ZGUuYnVmZmVyJiZSZSgpLEJlfWZ1bmN0aW9uIG8oKXtyZXR1cm4gYmUuYnVmZmVyIT1kZS5idWZmZXImJlJlKCksR2V9ZnVuY3Rpb24gYygpe3JldHVybiBiZS5idWZmZXIhPWRlLmJ1ZmZlciYmUmUoKSxGfWZ1bmN0aW9uIHAoKXtyZXR1cm4gYmUuYnVmZmVyIT1kZS5idWZmZXImJlJlKCksaWV9ZnVuY3Rpb24gbSgpe3JldHVybiBiZS5idWZmZXIhPWRlLmJ1ZmZlciYmUmUoKSxvdH12YXIgbD10LGcsYjtsLnJlYWR5PW5ldyBQcm9taXNlKChuLGQpPT57Zz1uLGI9ZH0pLGwubW91bnRFeHRlcm5hbERhdGE9KG4sZCk9PnsobC5GYnx8KGwuRmI9bmV3IE1hcCkpLnNldChuLGQpfSxsLnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgbC5GYn0sbC5qc2VwSW5pdD0obixkLGgsdixJLGsseixHKT0+e2wucmM9bixsLiRiPWQsbC5iYz1oLGwuT2I9dixsLmFjPUksbC5lYj1rLGwuY2M9eixsLmRjPUcsZD0oWixLLGFlKT0+KC4uLmdlKT0+e2xldCBTZT1odCxSPUs/LigpO2dlPVooLi4uZ2UpO2xldCBsZT1LPy4oKTtyZXR1cm4gUiE9PWxlJiYoWj1sZSxhZShSKSxLPWFlPW51bGwpLGh0IT1TZT9BKCk6Z2V9LGg9Wj0+YXN5bmMoLi4uSyk9Pnt0cnl7aWYobC5FYil0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCBhZT1sLkViPXtmYzpLWzBdLGVycm9yczpbXX0sZ2U9YXdhaXQgWiguLi5LKTtpZihsLkViIT09YWUpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO24uZmx1c2goKTtsZXQgU2U9YWUuZXJyb3JzO2lmKDA8U2UubGVuZ3RoKXtsZXQgUj1hd2FpdCBQcm9taXNlLmFsbChTZSk7aWYoUj1SLmZpbHRlcihsZT0+bGUpLDA8Ui5sZW5ndGgpdGhyb3cgRXJyb3IoUi5qb2luKGBcbmApKX1yZXR1cm4gZ2V9ZmluYWxseXtsLkViPW51bGx9fSxsLl9PcnRDcmVhdGVTZXNzaW9uPWQobC5fT3J0Q3JlYXRlU2Vzc2lvbiwoKT0+bC5fT3J0Q3JlYXRlU2Vzc2lvbixaPT5sLl9PcnRDcmVhdGVTZXNzaW9uPVopLGwuX09ydFJ1bj1oKGQobC5fT3J0UnVuLCgpPT5sLl9PcnRSdW4sWj0+bC5fT3J0UnVuPVopKSxsLl9PcnRSdW5XaXRoQmluZGluZz1oKGQobC5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PmwuX09ydFJ1bldpdGhCaW5kaW5nLFo9PmwuX09ydFJ1bldpdGhCaW5kaW5nPVopKSxsLl9PcnRCaW5kSW5wdXQ9ZChsLl9PcnRCaW5kSW5wdXQsKCk9PmwuX09ydEJpbmRJbnB1dCxaPT5sLl9PcnRCaW5kSW5wdXQ9WiksbC5qc2VwUmVnaXN0ZXJCdWZmZXI9KFosSyxhZSxnZSk9Pm4ucmVnaXN0ZXJCdWZmZXIoWixLLGFlLGdlKSxsLmpzZXBVbnJlZ2lzdGVyQnVmZmVycz1aPT57bi51bnJlZ2lzdGVyQnVmZmVycyhaKX0sbC5qc2VwR2V0QnVmZmVyPVo9Pm4uZ2V0QnVmZmVyKFopLGwuanNlcENyZWF0ZURvd25sb2FkZXI9KFosSyxhZSk9Pm4uY3JlYXRlRG93bmxvYWRlcihaLEssYWUpLGwuanNlcE9uUnVuU3RhcnQ9KCk9Pm4ub25SdW5TdGFydCgpfTt2YXIgdz1PYmplY3QuYXNzaWduKHt9LGwpLCQ9XCIuL3RoaXMucHJvZ3JhbVwiLHg9KG4sZCk9Pnt0aHJvdyBkfSxUPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIsQz10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLFM9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLEU9bC5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxPPVwiXCI7ZnVuY3Rpb24gVShuKXtyZXR1cm4gbC5sb2NhdGVGaWxlP2wubG9jYXRlRmlsZShuLE8pOk8rbn12YXIgRCxWLFk7aWYoUyl7dmFyIHNlPShrYSgpLEd0KE9hKSksQj0oUmEoKSxHdChQYSkpO089Qz9CLmRpcm5hbWUoTykrXCIvXCI6X19kaXJuYW1lK1wiL1wiLEQ9KGQsaCk9PihkPUR0KGQpP25ldyBVUkwoZCk6Qi5ub3JtYWxpemUoZCksc2UucmVhZEZpbGVTeW5jKGQsaD92b2lkIDA6XCJ1dGY4XCIpKSxZPWQ9PihkPUQoZCwhMCksZC5idWZmZXJ8fChkPW5ldyBVaW50OEFycmF5KGQpKSxkKSxWPShkLGgsdixJPSEwKT0+e2Q9RHQoZCk/bmV3IFVSTChkKTpCLm5vcm1hbGl6ZShkKSxzZS5yZWFkRmlsZShkLEk/dm9pZCAwOlwidXRmOFwiLChrLHopPT57az92KGspOmgoST96LmJ1ZmZlcjp6KX0pfSwhbC50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoJD1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHg9KGQsaCk9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWQsaH0sbC5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7bGV0IG47dHJ5e249Q28oKX1jYXRjaChkKXt0aHJvdyBjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKSxkfWdsb2JhbC5Xb3JrZXI9bi5Xb3JrZXJ9ZWxzZShUfHxDKSYmKEM/Tz1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoTz1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksdHlwZW9mIGU8XCJ1XCImJmUmJihPPWUpLE8uaW5kZXhPZihcImJsb2I6XCIpIT09MD9PPU8uc3Vic3RyKDAsTy5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpPPVwiXCIsU3x8KEQ9bj0+e3ZhciBkPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZC5vcGVuKFwiR0VUXCIsbiwhMSksZC5zZW5kKG51bGwpLGQucmVzcG9uc2VUZXh0fSxDJiYoWT1uPT57dmFyIGQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBkLm9wZW4oXCJHRVRcIixuLCExKSxkLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGQucmVzcG9uc2UpfSksVj0obixkLGgpPT57dmFyIHY9bmV3IFhNTEh0dHBSZXF1ZXN0O3Yub3BlbihcIkdFVFwiLG4sITApLHYucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix2Lm9ubG9hZD0oKT0+e3Yuc3RhdHVzPT0yMDB8fHYuc3RhdHVzPT0wJiZ2LnJlc3BvbnNlP2Qodi5yZXNwb25zZSk6aCgpfSx2Lm9uZXJyb3I9aCx2LnNlbmQobnVsbCl9KSk7UyYmdHlwZW9mIHBlcmZvcm1hbmNlPlwidVwiJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPUlvKCkucGVyZm9ybWFuY2UpO3ZhciB0ZT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLGtlPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtTJiYodGU9KC4uLm4pPT5zZS53cml0ZVN5bmMoMSxuLmpvaW4oXCIgXCIpK2BcbmApLGtlPSguLi5uKT0+c2Uud3JpdGVTeW5jKDIsbi5qb2luKFwiIFwiKStgXG5gKSk7dmFyIE9lPXRlLGVlPWtlO09iamVjdC5hc3NpZ24obCx3KSx3PW51bGwsdHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZWdChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIGJlLFVlLHBlPSExLHllLGRlLHZlLFdlLEJlLEdlLEYsaWUsaGUsSmUsb3Q7ZnVuY3Rpb24gUmUoKXt2YXIgbj1iZS5idWZmZXI7bC5IRUFQOD1kZT1uZXcgSW50OEFycmF5KG4pLGwuSEVBUDE2PVdlPW5ldyBJbnQxNkFycmF5KG4pLGwuSEVBUFU4PXZlPW5ldyBVaW50OEFycmF5KG4pLGwuSEVBUFUxNj1CZT1uZXcgVWludDE2QXJyYXkobiksbC5IRUFQMzI9R2U9bmV3IEludDMyQXJyYXkobiksbC5IRUFQVTMyPUY9bmV3IFVpbnQzMkFycmF5KG4pLGwuSEVBUEYzMj1pZT1uZXcgRmxvYXQzMkFycmF5KG4pLGwuSEVBUEY2ND1vdD1uZXcgRmxvYXQ2NEFycmF5KG4pLGwuSEVBUDY0PWhlPW5ldyBCaWdJbnQ2NEFycmF5KG4pLGwuSEVBUFU2ND1KZT1uZXcgQmlnVWludDY0QXJyYXkobil9dmFyIEZlPTE2Nzc3MjE2O2lmKEUpYmU9bC53YXNtTWVtb3J5O2Vsc2UgaWYobC53YXNtTWVtb3J5KWJlPWwud2FzbU1lbW9yeTtlbHNlIGlmKGJlPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6RmUvNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSwhKGJlLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBlZShcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxTJiZlZShcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kL29yIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7UmUoKSxGZT1iZS5idWZmZXIuYnl0ZUxlbmd0aDt2YXIgQnQ9W10sTXQ9W10sS3Q9W10sTnQ9MCx1cj1udWxsLFl0PW51bGw7ZnVuY3Rpb24geHIoKXtpZihOdC0tLE50PT0wJiYodXIhPT1udWxsJiYoY2xlYXJJbnRlcnZhbCh1ciksdXI9bnVsbCksWXQpKXt2YXIgbj1ZdDtZdD1udWxsLG4oKX19ZnVuY3Rpb24gVnQobil7dGhyb3cgbj1cIkFib3J0ZWQoXCIrbitcIilcIixlZShuKSxwZT0hMCx5ZT0xLG49bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihuK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxiKG4pLG59dmFyIHFlPW49Pm4uc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIiksRHQ9bj0+bi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSxDdDtDdD1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiLHFlKEN0KXx8KEN0PVUoQ3QpKTtmdW5jdGlvbiBDcihuKXtpZihZKXJldHVybiBZKG4pO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIG5uKG4pe2lmKFR8fEMpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYhRHQobikpcmV0dXJuIGZldGNoKG4se2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZD0+e2lmKCFkLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIituK1wiJ1wiO3JldHVybiBkLmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+Q3IobikpO2lmKFYpcmV0dXJuIG5ldyBQcm9taXNlKChkLGgpPT57VihuLHY9PmQobmV3IFVpbnQ4QXJyYXkodikpLGgpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PkNyKG4pKX1mdW5jdGlvbiBzdChuLGQsaCl7cmV0dXJuIG5uKG4pLnRoZW4odj0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodixkKSkudGhlbih2PT52KS50aGVuKGgsdj0+e2VlKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3Z9YCksVnQodil9KX1mdW5jdGlvbiBJcihuLGQpe3ZhciBoPUN0O3JldHVybiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmchPVwiZnVuY3Rpb25cInx8cWUoaCl8fER0KGgpfHxTfHx0eXBlb2YgZmV0Y2ghPVwiZnVuY3Rpb25cIj9zdChoLG4sZCk6ZmV0Y2goaCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbih2PT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh2LG4pLnRoZW4oZCxmdW5jdGlvbihJKXtyZXR1cm4gZWUoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke0l9YCksZWUoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxzdChoLG4sZCl9KSl9dmFyIFp0PXs5NDY3NDg6KG4sZCxoLHYpPT57aWYodHlwZW9mIGw+XCJ1XCJ8fCFsLkZiKXJldHVybiAxO2lmKG49UGUobj4+PjApLG4uc3RhcnRzV2l0aChcIi4vXCIpJiYobj1uLnN1YnN0cmluZygyKSksbj1sLkZiLmdldChuKSwhbilyZXR1cm4gMjtpZihkPj4+PTAsaD4+Pj0wLHY+Pj49MCxkK2g+bi5ieXRlTGVuZ3RoKXJldHVybiAzO3RyeXtyZXR1cm4gYSgpLnNldChuLnN1YmFycmF5KGQsZCtoKSx2Pj4+MCksMH1jYXRjaHtyZXR1cm4gNH19LDk0NzI0OTpuPT5sLiRiKG4pLDk0NzI4MjpuPT5sLmJjKG4pLDk0NzMxNDoobixkLGgpPT57bC5PYihuLGQsaCwhMCl9LDk0NzM1MzoobixkLGgpPT57bC5PYihuLGQsaCl9LDk0NzM4NjpuPT57bC5lYihcIkFic1wiLG4sdm9pZCAwKX0sOTQ3NDM3Om49PntsLmViKFwiTmVnXCIsbix2b2lkIDApfSw5NDc0ODg6bj0+e2wuZWIoXCJGbG9vclwiLG4sdm9pZCAwKX0sOTQ3NTQxOm49PntsLmViKFwiQ2VpbFwiLG4sdm9pZCAwKX0sOTQ3NTkzOm49PntsLmViKFwiUmVjaXByb2NhbFwiLG4sdm9pZCAwKX0sOTQ3NjUxOm49PntsLmViKFwiU3FydFwiLG4sdm9pZCAwKX0sOTQ3NzAzOm49PntsLmViKFwiRXhwXCIsbix2b2lkIDApfSw5NDc3NTQ6bj0+e2wuZWIoXCJFcmZcIixuLHZvaWQgMCl9LDk0NzgwNTpuPT57bC5lYihcIlNpZ21vaWRcIixuLHZvaWQgMCl9LDk0Nzg2MDoobixkLGgpPT57bC5lYihcIkhhcmRTaWdtb2lkXCIsbix7YWxwaGE6ZCxiZXRhOmh9KX0sOTQ3OTM5Om49PntsLmViKFwiTG9nXCIsbix2b2lkIDApfSw5NDc5OTA6bj0+e2wuZWIoXCJTaW5cIixuLHZvaWQgMCl9LDk0ODA0MTpuPT57bC5lYihcIkNvc1wiLG4sdm9pZCAwKX0sOTQ4MDkyOm49PntsLmViKFwiVGFuXCIsbix2b2lkIDApfSw5NDgxNDM6bj0+e2wuZWIoXCJBc2luXCIsbix2b2lkIDApfSw5NDgxOTU6bj0+e2wuZWIoXCJBY29zXCIsbix2b2lkIDApfSw5NDgyNDc6bj0+e2wuZWIoXCJBdGFuXCIsbix2b2lkIDApfSw5NDgyOTk6bj0+e2wuZWIoXCJTaW5oXCIsbix2b2lkIDApfSw5NDgzNTE6bj0+e2wuZWIoXCJDb3NoXCIsbix2b2lkIDApfSw5NDg0MDM6bj0+e2wuZWIoXCJBc2luaFwiLG4sdm9pZCAwKX0sOTQ4NDU2Om49PntsLmViKFwiQWNvc2hcIixuLHZvaWQgMCl9LDk0ODUwOTpuPT57bC5lYihcIkF0YW5oXCIsbix2b2lkIDApfSw5NDg1NjI6bj0+e2wuZWIoXCJUYW5oXCIsbix2b2lkIDApfSw5NDg2MTQ6bj0+e2wuZWIoXCJOb3RcIixuLHZvaWQgMCl9LDk0ODY2NToobixkLGgpPT57bC5lYihcIkNsaXBcIixuLHttaW46ZCxtYXg6aH0pfSw5NDg3MzQ6bj0+e2wuZWIoXCJDbGlwXCIsbix2b2lkIDApfSw5NDg3ODY6KG4sZCk9PntsLmViKFwiRWx1XCIsbix7YWxwaGE6ZH0pfSw5NDg4NDQ6bj0+e2wuZWIoXCJSZWx1XCIsbix2b2lkIDApfSw5NDg4OTY6KG4sZCk9PntsLmViKFwiTGVha3lSZWx1XCIsbix7YWxwaGE6ZH0pfSw5NDg5NjA6KG4sZCk9PntsLmViKFwiVGhyZXNob2xkZWRSZWx1XCIsbix7YWxwaGE6ZH0pfSw5NDkwMzA6KG4sZCk9PntsLmViKFwiQ2FzdFwiLG4se3RvOmR9KX0sOTQ5MDg4Om49PntsLmViKFwiQWRkXCIsbix2b2lkIDApfSw5NDkxMzk6bj0+e2wuZWIoXCJTdWJcIixuLHZvaWQgMCl9LDk0OTE5MDpuPT57bC5lYihcIk11bFwiLG4sdm9pZCAwKX0sOTQ5MjQxOm49PntsLmViKFwiRGl2XCIsbix2b2lkIDApfSw5NDkyOTI6bj0+e2wuZWIoXCJQb3dcIixuLHZvaWQgMCl9LDk0OTM0MzpuPT57bC5lYihcIkVxdWFsXCIsbix2b2lkIDApfSw5NDkzOTY6bj0+e2wuZWIoXCJHcmVhdGVyXCIsbix2b2lkIDApfSw5NDk0NTE6bj0+e2wuZWIoXCJHcmVhdGVyT3JFcXVhbFwiLG4sdm9pZCAwKX0sOTQ5NTEzOm49PntsLmViKFwiTGVzc1wiLG4sdm9pZCAwKX0sOTQ5NTY1Om49PntsLmViKFwiTGVzc09yRXF1YWxcIixuLHZvaWQgMCl9LDk0OTYyNDoobixkLGgsdixJKT0+e2wuZWIoXCJSZWR1Y2VNZWFuXCIsbix7a2VlcERpbXM6ISFkLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOnY/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkodj4+PjAsST4+PjApKTpbXX0pfSw5NDk3ODM6KG4sZCxoLHYsSSk9PntsLmViKFwiUmVkdWNlTWF4XCIsbix7a2VlcERpbXM6ISFkLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOnY/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkodj4+PjAsST4+PjApKTpbXX0pfSw5NDk5NDE6KG4sZCxoLHYsSSk9PntsLmViKFwiUmVkdWNlTWluXCIsbix7a2VlcERpbXM6ISFkLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOnY/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkodj4+PjAsST4+PjApKTpbXX0pfSw5NTAwOTk6KG4sZCxoLHYsSSk9PntsLmViKFwiUmVkdWNlUHJvZFwiLG4se2tlZXBEaW1zOiEhZCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp2P0FycmF5LmZyb20obygpLnN1YmFycmF5KHY+Pj4wLEk+Pj4wKSk6W119KX0sOTUwMjU4OihuLGQsaCx2LEkpPT57bC5lYihcIlJlZHVjZVN1bVwiLG4se2tlZXBEaW1zOiEhZCxub29wV2l0aEVtcHR5QXhlczohIWgsYXhlczp2P0FycmF5LmZyb20obygpLnN1YmFycmF5KHY+Pj4wLEk+Pj4wKSk6W119KX0sOTUwNDE2OihuLGQsaCx2LEkpPT57bC5lYihcIlJlZHVjZUwxXCIsbix7a2VlcERpbXM6ISFkLG5vb3BXaXRoRW1wdHlBeGVzOiEhaCxheGVzOnY/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkodj4+PjAsST4+PjApKTpbXX0pfSw5NTA1NzM6KG4sZCxoLHYsSSk9PntsLmViKFwiUmVkdWNlTDJcIixuLHtrZWVwRGltczohIWQsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6dj9BcnJheS5mcm9tKG8oKS5zdWJhcnJheSh2Pj4+MCxJPj4+MCkpOltdfSl9LDk1MDczMDoobixkLGgsdixJKT0+e2wuZWIoXCJSZWR1Y2VMb2dTdW1cIixuLHtrZWVwRGltczohIWQsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6dj9BcnJheS5mcm9tKG8oKS5zdWJhcnJheSh2Pj4+MCxJPj4+MCkpOltdfSl9LDk1MDg5MToobixkLGgsdixJKT0+e2wuZWIoXCJSZWR1Y2VTdW1TcXVhcmVcIixuLHtrZWVwRGltczohIWQsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6dj9BcnJheS5mcm9tKG8oKS5zdWJhcnJheSh2Pj4+MCxJPj4+MCkpOltdfSl9LDk1MTA1NToobixkLGgsdixJKT0+e2wuZWIoXCJSZWR1Y2VMb2dTdW1FeHBcIixuLHtrZWVwRGltczohIWQsbm9vcFdpdGhFbXB0eUF4ZXM6ISFoLGF4ZXM6dj9BcnJheS5mcm9tKG8oKS5zdWJhcnJheSh2Pj4+MCxJPj4+MCkpOltdfSl9LDk1MTIxOTpuPT57bC5lYihcIldoZXJlXCIsbix2b2lkIDApfSw5NTEyNzI6KG4sZCxoKT0+e2wuZWIoXCJUcmFuc3Bvc2VcIixuLHtwZXJtOmQ/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkoZD4+PjAsaD4+PjApKTpbXX0pfSw5NTEzODA6KG4sZCxoLHYsSSxrLHosRyxaLEssYWUsZ2UsU2UsUixsZSk9PntsLmViKFwiQ29udlRyYW5zcG9zZVwiLG4se2Zvcm1hdDpaP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6ZCxkaWxhdGlvbnM6W2hdLGdyb3VwOnYsa2VybmVsX3NoYXBlOltJXSxwYWRzOltrLHpdLHN0cmlkZXM6W0ddLHdJc0NvbnN0OigpPT4hIXIoKVtLPj4+MF0sb3V0cHV0UGFkZGluZzphZT9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShhZT4+PjAsZ2U+Pj4wKSk6W10sb3V0cHV0U2hhcGU6U2U/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkoU2U+Pj4wLFI+Pj4wKSk6W10sYWN0aXZhdGlvbjpQZShsZSl9KX0sOTUxNzgyOihuLGQsaCx2LEksayx6LEcsWixLLGFlLGdlLFNlLFIpPT57bC5lYihcIkNvbnZUcmFuc3Bvc2VcIixuLHtmb3JtYXQ6Rz9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmQsZGlsYXRpb25zOkFycmF5LmZyb20obygpLnN1YmFycmF5KGg+Pj4wLChoPj4+MCkrMj4+PjApKSxncm91cDp2LGtlcm5lbFNoYXBlOkFycmF5LmZyb20obygpLnN1YmFycmF5KEk+Pj4wLChJPj4+MCkrMj4+PjApKSxwYWRzOkFycmF5LmZyb20obygpLnN1YmFycmF5KGs+Pj4wLChrPj4+MCkrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20obygpLnN1YmFycmF5KHo+Pj4wLCh6Pj4+MCkrMj4+PjApKSx3SXNDb25zdDooKT0+ISFyKClbWj4+PjBdLG91dHB1dFBhZGRpbmc6Sz9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShLPj4+MCxhZT4+PjApKTpbXSxvdXRwdXRTaGFwZTpnZT9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShnZT4+PjAsU2U+Pj4wKSk6W10sYWN0aXZhdGlvbjpQZShSKX0pfSw5NTIzNDc6KG4sZCxoLHYsSSxrLHosRyxaLEssYWUsZ2UsU2UsUixsZSk9PntsLmViKFwiQ29udlRyYW5zcG9zZVwiLG4se2Zvcm1hdDpaP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6ZCxkaWxhdGlvbnM6W2hdLGdyb3VwOnYsa2VybmVsX3NoYXBlOltJXSxwYWRzOltrLHpdLHN0cmlkZXM6W0ddLHdJc0NvbnN0OigpPT4hIXIoKVtLPj4+MF0sb3V0cHV0UGFkZGluZzphZT9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShhZT4+PjAsZ2U+Pj4wKSk6W10sb3V0cHV0U2hhcGU6U2U/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkoU2U+Pj4wLFI+Pj4wKSk6W10sYWN0aXZhdGlvbjpQZShsZSl9KX0sOTUyNzQ5OihuLGQsaCx2LEksayx6LEcsWixLLGFlLGdlLFNlLFIpPT57bC5lYihcIkNvbnZUcmFuc3Bvc2VcIixuLHtmb3JtYXQ6Rz9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmQsZGlsYXRpb25zOkFycmF5LmZyb20obygpLnN1YmFycmF5KGg+Pj4wLChoPj4+MCkrMj4+PjApKSxncm91cDp2LGtlcm5lbFNoYXBlOkFycmF5LmZyb20obygpLnN1YmFycmF5KEk+Pj4wLChJPj4+MCkrMj4+PjApKSxwYWRzOkFycmF5LmZyb20obygpLnN1YmFycmF5KGs+Pj4wLChrPj4+MCkrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20obygpLnN1YmFycmF5KHo+Pj4wLCh6Pj4+MCkrMj4+PjApKSx3SXNDb25zdDooKT0+ISFyKClbWj4+PjBdLG91dHB1dFBhZGRpbmc6Sz9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShLPj4+MCxhZT4+PjApKTpbXSxvdXRwdXRTaGFwZTpnZT9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShnZT4+PjAsU2U+Pj4wKSk6W10sYWN0aXZhdGlvbjpQZShSKX0pfSw5NTMzMTQ6KG4sZCk9PntsLmViKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixuLHtmb3JtYXQ6ZD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTM0MDU6KG4sZCxoLHYsSSxrLHosRyxaLEssYWUsZ2UsU2UsUixsZSxUZSk9PntsLmViKFwiQXZlcmFnZVBvb2xcIixuLHtmb3JtYXQ6VGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZCxjZWlsX21vZGU6aCxjb3VudF9pbmNsdWRlX3BhZDp2LHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W2ssel0sa2VybmVsX3NoYXBlOltHLFpdLHBhZHM6W0ssYWUsZ2UsU2VdLHN0cmlkZXM6W1IsbGVdfSl9LDk1MzY4OToobixkKT0+e2wuZWIoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLG4se2Zvcm1hdDpkP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1Mzc4MDoobixkLGgsdixJLGsseixHLFosSyxhZSxnZSxTZSxSLGxlLFRlKT0+e2wuZWIoXCJBdmVyYWdlUG9vbFwiLG4se2Zvcm1hdDpUZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpkLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOnYsc3RvcmFnZV9vcmRlcjpJLGRpbGF0aW9uczpbayx6XSxrZXJuZWxfc2hhcGU6W0csWl0scGFkczpbSyxhZSxnZSxTZV0sc3RyaWRlczpbUixsZV19KX0sOTU0MDY0OihuLGQpPT57bC5lYihcIkdsb2JhbE1heFBvb2xcIixuLHtmb3JtYXQ6ZD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTQxNTE6KG4sZCxoLHYsSSxrLHosRyxaLEssYWUsZ2UsU2UsUixsZSxUZSk9PntsLmViKFwiTWF4UG9vbFwiLG4se2Zvcm1hdDpUZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpkLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOnYsc3RvcmFnZV9vcmRlcjpJLGRpbGF0aW9uczpbayx6XSxrZXJuZWxfc2hhcGU6W0csWl0scGFkczpbSyxhZSxnZSxTZV0sc3RyaWRlczpbUixsZV19KX0sOTU0NDMxOihuLGQpPT57bC5lYihcIkdsb2JhbE1heFBvb2xcIixuLHtmb3JtYXQ6ZD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTQ1MTg6KG4sZCxoLHYsSSxrLHosRyxaLEssYWUsZ2UsU2UsUixsZSxUZSk9PntsLmViKFwiTWF4UG9vbFwiLG4se2Zvcm1hdDpUZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpkLGNlaWxfbW9kZTpoLGNvdW50X2luY2x1ZGVfcGFkOnYsc3RvcmFnZV9vcmRlcjpJLGRpbGF0aW9uczpbayx6XSxrZXJuZWxfc2hhcGU6W0csWl0scGFkczpbSyxhZSxnZSxTZV0sc3RyaWRlczpbUixsZV19KX0sOTU0Nzk4OihuLGQsaCx2LEkpPT57bC5lYihcIkdlbW1cIixuLHthbHBoYTpkLGJldGE6aCx0cmFuc0E6dix0cmFuc0I6SX0pfSw5NTQ5MDI6bj0+e2wuZWIoXCJNYXRNdWxcIixuLHZvaWQgMCl9LDk1NDk1NjoobixkLGgsdik9PntsLmViKFwiQXJnTWF4XCIsbix7a2VlcERpbXM6ISFkLHNlbGVjdExhc3RJbmRleDohIWgsYXhpczp2fSl9LDk1NTA2NDoobixkLGgsdik9PntsLmViKFwiQXJnTWluXCIsbix7a2VlcERpbXM6ISFkLHNlbGVjdExhc3RJbmRleDohIWgsYXhpczp2fSl9LDk1NTE3MjoobixkKT0+e2wuZWIoXCJTb2Z0bWF4XCIsbix7YXhpczpkfSl9LDk1NTIzNToobixkKT0+e2wuZWIoXCJDb25jYXRcIixuLHtheGlzOmR9KX0sOTU1Mjk1OihuLGQsaCx2LEkpPT57bC5lYihcIlNwbGl0XCIsbix7YXhpczpkLG51bU91dHB1dHM6aCxzcGxpdFNpemVzOnY/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkodj4+PjAsST4+PjApKTpbXX0pfSw5NTU0MzU6bj0+e2wuZWIoXCJFeHBhbmRcIixuLHZvaWQgMCl9LDk1NTQ4OToobixkKT0+e2wuZWIoXCJHYXRoZXJcIixuLHtheGlzOk51bWJlcihkKX0pfSw5NTU1NjA6KG4sZCk9PntsLmViKFwiR2F0aGVyRWxlbWVudHNcIixuLHtheGlzOk51bWJlcihkKX0pfSw5NTU2Mzk6KG4sZCxoLHYsSSxrLHosRyxaLEssYWUpPT57bC5lYihcIlJlc2l6ZVwiLG4se2FudGlhbGlhczpkLGF4ZXM6aD9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShoPj4+MCx2Pj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOlBlKEkpLGN1YmljQ29lZmZBOmssZXhjbHVkZU91dHNpZGU6eixleHRyYXBvbGF0aW9uVmFsdWU6RyxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6UGUoWiksbW9kZTpQZShLKSxuZWFyZXN0TW9kZTpQZShhZSl9KX0sOTU1OTg1OihuLGQsaCx2LEksayx6KT0+e2wuZWIoXCJTbGljZVwiLG4se3N0YXJ0czpkP0FycmF5LmZyb20obygpLnN1YmFycmF5KGQ+Pj4wLGg+Pj4wKSk6W10sZW5kczp2P0FycmF5LmZyb20obygpLnN1YmFycmF5KHY+Pj4wLEk+Pj4wKSk6W10sYXhlczprP0FycmF5LmZyb20obygpLnN1YmFycmF5KGs+Pj4wLHo+Pj4wKSk6W119KX0sOTU2MjAxOm49PntsLmViKFwiVGlsZVwiLG4sdm9pZCAwKX0sOTU2MjUzOihuLGQsaCk9PntsLmViKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsbix7YXhpczpOdW1iZXIoZCksZXBzaWxvbjpOdW1iZXIoaCl9KX0sOTU2MzYwOihuLGQsaCk9PntsLmViKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsbix7ZXBzaWxvbjpkLGZvcm1hdDpoP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1NjQ3NDoobixkLGgpPT57bC5lYihcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLG4se2Vwc2lsb246ZCxmb3JtYXQ6aD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTY1ODg6bj0+e2wuZWIoXCJSYW5nZVwiLG4sdm9pZCAwKX0sOTU2NjQxOihuLGQpPT57bC5lYihcIkVpbnN1bVwiLG4se2VxdWF0aW9uOlBlKGQpfSl9LDk1NjcyMjoobixkLGgsdixJKT0+e2wuZWIoXCJQYWRcIixuLHttb2RlOmQsdmFsdWU6aCxwYWRzOnY/QXJyYXkuZnJvbShvKCkuc3ViYXJyYXkodj4+PjAsST4+PjApKTpbXX0pfSw5NTY4NDk6KG4sZCxoLHYsSSxrKT0+e2wuZWIoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixuLHtlcHNpbG9uOmQsbW9tZW50dW06aCxzcGF0aWFsOiEhSSx0cmFpbmluZ01vZGU6ISF2LGZvcm1hdDprP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1NzAxODoobixkLGgsdixJLGspPT57bC5lYihcIkJhdGNoTm9ybWFsaXphdGlvblwiLG4se2Vwc2lsb246ZCxtb21lbnR1bTpoLHNwYXRpYWw6ISFJLHRyYWluaW5nTW9kZTohIXYsZm9ybWF0Oms/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTU3MTg3OihuLGQsaCk9PntsLmViKFwiQ3VtU3VtXCIsbix7ZXhjbHVzaXZlOk51bWJlcihkKSxyZXZlcnNlOk51bWJlcihoKX0pfSw5NTcyODQ6KG4sZCxoLHYsSSxrLHosRyxaKT0+e2wuZWIoXCJBdHRlbnRpb25cIixuLHtudW1IZWFkczpkLGlzVW5pZGlyZWN0aW9uYWw6aCxtYXNrRmlsdGVyVmFsdWU6dixzY2FsZTpJLGRvUm90YXJ5OmsscWt2SGlkZGVuU2l6ZXM6ej9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShOdW1iZXIoRyk+Pj4wLE51bWJlcihHKSt6Pj4+MCkpOltdLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ISFafSl9LDk1NzU1NjpuPT57bC5lYihcIkdlbHVcIixuLHZvaWQgMCl9LDk1NzYwODoobixkLGgsdixJLGspPT57bC5lYihcIk11bHRpSGVhZEF0dGVudGlvblwiLG4se251bUhlYWRzOmQsaXNVbmlkaXJlY3Rpb25hbDpoLG1hc2tGaWx0ZXJWYWx1ZTp2LHNjYWxlOkksZG9Sb3Rhcnk6a30pfSw5NTc3Njc6bj0+e2wuZWIoXCJCaWFzQWRkXCIsbix2b2lkIDApfSw5NTc4MjI6bj0+e2wuZWIoXCJCaWFzU3BsaXRHZWx1XCIsbix2b2lkIDApfSw5NTc4ODM6KG4sZCk9PntsLmViKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLG4se2Vwc2lsb246ZH0pfSw5NTc5NjQ6KG4sZCxoLHYsSSxrLHosRyxaLEssYWUsZ2UsU2UpPT57bC5lYihcIkNvbnZcIixuLHtmb3JtYXQ6Wj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpkLGRpbGF0aW9uczpbaF0sZ3JvdXA6dixrZXJuZWxfc2hhcGU6W0ldLHBhZHM6az9BcnJheS5mcm9tKG8oKS5zdWJhcnJheShrPj4+MCx6Pj4+MCkpOltdLHN0cmlkZXM6W0ddLHdfaXNfY29uc3Q6KCk9PiEhcigpW0s+Pj4wXSxhY3RpdmF0aW9uOlBlKGFlKSxhY3RpdmF0aW9uX3BhcmFtczpnZT9BcnJheS5mcm9tKHAoKS5zdWJhcnJheShnZT4+PjAsU2U+Pj4wKSk6W119KX0sOTU4MzM0OihuLGQsaCx2LEksayx6LEcsWixLLGFlLGdlLFNlLFIsbGUsVGUpPT57bC5lYihcIkNvbnZcIixuLHtmb3JtYXQ6Z2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6ZCxkaWxhdGlvbnM6W2gsdl0sZ3JvdXA6SSxrZXJuZWxfc2hhcGU6W2ssel0scGFkczpHP0FycmF5LmZyb20obygpLnN1YmFycmF5KEc+Pj4wLFo+Pj4wKSk6W10sc3RyaWRlczpbSyxhZV0sd19pc19jb25zdDooKT0+ISFyKClbU2U+Pj4wXSxhY3RpdmF0aW9uOlBlKFIpLGFjdGl2YXRpb25fcGFyYW1zOmxlP0FycmF5LmZyb20ocCgpLnN1YmFycmF5KGxlPj4+MCxUZT4+PjApKTpbXX0pfSw5NTg3MjU6bj0+e2wuY2Mobil9LDk1ODc1OToobixkKT0+bC5kYyhuLGQsbC5FYi5mYyxsLkViLmVycm9ycyl9O2Z1bmN0aW9uIEFyKG4pe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtufSlgLHRoaXMuc3RhdHVzPW59dmFyIGd0PW49PntuLnRlcm1pbmF0ZSgpLG4ub25tZXNzYWdlPSgpPT57fX0sYW49bj0+e2ZlLnliLmxlbmd0aD09MCYmKFByKCksZmUuUGIoZmUueWJbMF0pKTt2YXIgZD1mZS55Yi5wb3AoKTtpZighZClyZXR1cm4gNjtmZS56Yi5wdXNoKGQpLGZlLnBiW24ueGJdPWQsZC54Yj1uLnhiO3ZhciBoPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOm4uaGMsYXJnOm4uVmIscHRocmVhZF9wdHI6bi54Yn07cmV0dXJuIFMmJmQudW5yZWYoKSxkLnBvc3RNZXNzYWdlKGgsbi5uYyksMH0sS2U9MCxUcj10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsRXI9KG4sZCxoKT0+e2Q+Pj49MDt2YXIgdj1kK2g7Zm9yKGg9ZDtuW2hdJiYhKGg+PXYpOykrK2g7aWYoMTY8aC1kJiZuLmJ1ZmZlciYmVHIpcmV0dXJuIFRyLmRlY29kZShuLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP24uc2xpY2UoZCxoKTpuLnN1YmFycmF5KGQsaCkpO2Zvcih2PVwiXCI7ZDxoOyl7dmFyIEk9bltkKytdO2lmKEkmMTI4KXt2YXIgaz1uW2QrK10mNjM7aWYoKEkmMjI0KT09MTkyKXYrPVN0cmluZy5mcm9tQ2hhckNvZGUoKEkmMzEpPDw2fGspO2Vsc2V7dmFyIHo9bltkKytdJjYzO0k9KEkmMjQwKT09MjI0PyhJJjE1KTw8MTJ8azw8Nnx6OihJJjcpPDwxOHxrPDwxMnx6PDw2fG5bZCsrXSY2Myw2NTUzNj5JP3YrPVN0cmluZy5mcm9tQ2hhckNvZGUoSSk6KEktPTY1NTM2LHYrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ST4+MTAsNTYzMjB8SSYxMDIzKSl9fWVsc2Ugdis9U3RyaW5nLmZyb21DaGFyQ29kZShJKX1yZXR1cm4gdn0sUGU9KG4sZCk9PihuPj4+PTApP0VyKGEoKSxuLGQpOlwiXCIsT3I9bj0+e3ZhciBkPVNhKCk7cmV0dXJuIG49bigpLEFuKGQpLG59O2Z1bmN0aW9uIHdlKG4sZCl7dmFyIGg9YXJndW1lbnRzLmxlbmd0aC0yLHY9YXJndW1lbnRzO3JldHVybiBPcigoKT0+e2Zvcih2YXIgST0yKmgsaz14YSg4KkkpLHo9az4+PjMsRz0wO0c8aDtHKyspe3ZhciBaPXZbMitHXTt0eXBlb2YgWj09XCJiaWdpbnRcIj8oaGVbeisyKkddPTFuLGhlW3orMipHKzFdPVopOihoZVt6KzIqR109MG4sbSgpW3orMipHKzE+Pj4wXT1aKX1yZXR1cm4gRGkobixJLGssZCl9KX1mdW5jdGlvbiB1dChuKXtpZihFKXJldHVybiB3ZSgwLDEsbik7eWU9biwwPEtlfHwoZmUuaWMoKSxsLm9uRXhpdD8uKG4pLHBlPSEwKSx4KG4sbmV3IEFyKG4pKX12YXIgbHI9bj0+e2lmKHllPW4sRSl0aHJvdyBvbihuKSxcInVud2luZFwiO3V0KG4pfSxrcj1uPT57biBpbnN0YW5jZW9mIEFyfHxuPT1cInVud2luZFwifHx4KDEsbil9O2Z1bmN0aW9uIGZhKCl7Zm9yKHZhciBuPWwubnVtVGhyZWFkcztuLS07KVByKCk7QnQudW5zaGlmdCgoKT0+e050KyssbWEoKCk9PnhyKCkpfSl9ZnVuY3Rpb24gUHIoKXt2YXIgbj1VKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53b3JrZXIuanNcIik7bj1uZXcgV29ya2VyKG4pLGZlLnliLnB1c2gobil9ZnVuY3Rpb24gbWEobil7RT9uKCk6UHJvbWlzZS5hbGwoZmUueWIubWFwKGZlLlBiKSkudGhlbihuKX12YXIgZmU9e3liOltdLHpiOltdLFViOltdLHBiOnt9LEliKCl7RT8oZmUucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWZlLmVjLGZlLnRocmVhZEluaXRUTFM9ZmUuVGIsZmUuc2V0RXhpdFN0YXR1cz1mZS5TYik6ZmEoKX0sU2I6bj0+eWU9bixzYzpbXCIkdGVybWluYXRlV29ya2VyXCJdLGljOigpPT57Zm9yKHZhciBuIG9mIGZlLnpiKWd0KG4pO2ZvcihuIG9mIGZlLnliKWd0KG4pO2ZlLnliPVtdLGZlLnpiPVtdLGZlLnBiPVtdfSxSYjpuPT57dmFyIGQ9bi54YjtkZWxldGUgZmUucGJbZF0sZmUueWIucHVzaChuKSxmZS56Yi5zcGxpY2UoZmUuemIuaW5kZXhPZihuKSwxKSxuLnhiPTAsJGEoZCl9LGVjKCl7fSxUYigpe2ZlLlViLmZvckVhY2gobj0+bigpKX0sUGI6bj0+bmV3IFByb21pc2UoZD0+e24ub25tZXNzYWdlPWs9PntrPWsuZGF0YTt2YXIgej1rLmNtZDtpZihrLnRhcmdldFRocmVhZCYmay50YXJnZXRUaHJlYWQhPUluKCkpe3ZhciBHPWZlLnBiW2sudGFyZ2V0VGhyZWFkXTtHP0cucG9zdE1lc3NhZ2UoayxrLnRyYW5zZmVyTGlzdCk6ZWUoYEludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCIke3p9XCIgdG8gdGFyZ2V0IHB0aHJlYWQgJHtrLnRhcmdldFRocmVhZH0sIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIWApfWVsc2Ugej09PVwiY2hlY2tNYWlsYm94XCI/ZXIoKTp6PT09XCJzcGF3blRocmVhZFwiP2FuKGspOno9PT1cImNsZWFudXBUaHJlYWRcIj9mZS5SYihmZS5wYltrLnRocmVhZF0pOno9PT1cImtpbGxUaHJlYWRcIj8oaz1rLnRocmVhZCx6PWZlLnBiW2tdLGRlbGV0ZSBmZS5wYltrXSxndCh6KSwkYShrKSxmZS56Yi5zcGxpY2UoZmUuemIuaW5kZXhPZih6KSwxKSx6LnhiPTApOno9PT1cImNhbmNlbFRocmVhZFwiP2ZlLnBiW2sudGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTp6PT09XCJsb2FkZWRcIj8obi5sb2FkZWQ9ITAsUyYmIW4ueGImJm4udW5yZWYoKSxkKG4pKTp6PT09XCJhbGVydFwiP2FsZXJ0KGBUaHJlYWQgJHtrLnRocmVhZElkfTogJHtrLnRleHR9YCk6ay50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiP24ucG9zdE1lc3NhZ2Uoayk6ej09PVwiY2FsbEhhbmRsZXJcIj9sW2suaGFuZGxlcl0oLi4uay5hcmdzKTp6JiZlZShgd29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kICR7en1gKX0sbi5vbmVycm9yPWs9Pnt0aHJvdyBlZShgd29ya2VyIHNlbnQgYW4gZXJyb3IhICR7ay5maWxlbmFtZX06JHtrLmxpbmVub306ICR7ay5tZXNzYWdlfWApLGt9LFMmJihuLm9uKFwibWVzc2FnZVwiLGs9Pm4ub25tZXNzYWdlKHtkYXRhOmt9KSksbi5vbihcImVycm9yXCIsaz0+bi5vbmVycm9yKGspKSk7dmFyIGg9W10sdj1bXCJvbkV4aXRcIl0sSTtmb3IoSSBvZiB2KWwuaGFzT3duUHJvcGVydHkoSSkmJmgucHVzaChJKTtuLnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsaGFuZGxlcnM6aCx1cmxPckJsb2I6bC5tYWluU2NyaXB0VXJsT3JCbG9ifHxlLHdhc21NZW1vcnk6YmUsd2FzbU1vZHVsZTpVZX0pfSl9O2wuUFRocmVhZD1mZTt2YXIgZHI9bj0+e2Zvcig7MDxuLmxlbmd0aDspbi5zaGlmdCgpKGwpfTtsLmVzdGFibGlzaFN0YWNrU3BhY2U9KCk9Pnt2YXIgbj1JbigpLGQ9YygpW24rNTI+Pj4yPj4+MF07bj1jKClbbis1Nj4+PjI+Pj4wXSxVaShkLGQtbiksQW4oZCl9O2Z1bmN0aW9uIG9uKG4pe2lmKEUpcmV0dXJuIHdlKDEsMCxuKTtscihuKX1sLmludm9rZUVudHJ5UG9pbnQ9KG4sZCk9PntuPVdpLmFwcGx5KG51bGwsW24sZF0pLDA8S2U/ZmUuU2Iobik6X2Eobil9O2Z1bmN0aW9uIGhhKG4pe3RoaXMuRGI9bi0yNCx0aGlzLnBjPWZ1bmN0aW9uKGQpe2MoKVt0aGlzLkRiKzQ+Pj4yPj4+MF09ZH0sdGhpcy5NYj1mdW5jdGlvbihkKXtjKClbdGhpcy5EYis4Pj4+Mj4+PjBdPWR9LHRoaXMuSWI9ZnVuY3Rpb24oZCxoKXt0aGlzLktiKCksdGhpcy5wYyhkKSx0aGlzLk1iKGgpfSx0aGlzLktiPWZ1bmN0aW9uKCl7YygpW3RoaXMuRGIrMTY+Pj4yPj4+MF09MH19dmFyIHNuPTAsUnI9MDtmdW5jdGlvbiBCcihuLGQsaCx2KXtyZXR1cm4gRT93ZSgyLDEsbixkLGgsdik6WHQobixkLGgsdil9ZnVuY3Rpb24gWHQobixkLGgsdil7aWYobj4+Pj0wLGQ+Pj49MCxoPj4+PTAsdj4+Pj0wLHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4gZWUoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBJPVtdO3JldHVybiBFJiZJLmxlbmd0aD09PTA/QnIobixkLGgsdik6KG49e2hjOmgseGI6bixWYjp2LG5jOkl9LEU/KG4ucWM9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKG4sSSksMCk6YW4obikpfWZ1bmN0aW9uIHVuKG4sZCxoKXtyZXR1cm4gRT93ZSgzLDEsbixkLGgpOjB9ZnVuY3Rpb24gd3QobixkKXtpZihFKXJldHVybiB3ZSg0LDEsbixkKX12YXIgZXQ9bj0+e2Zvcih2YXIgZD0wLGg9MDtoPG4ubGVuZ3RoOysraCl7dmFyIHY9bi5jaGFyQ29kZUF0KGgpOzEyNz49dj9kKys6MjA0Nz49dj9kKz0yOjU1Mjk2PD12JiY1NzM0Mz49dj8oZCs9NCwrK2gpOmQrPTN9cmV0dXJuIGR9LE1yPShuLGQsaCx2KT0+e2lmKGg+Pj49MCwhKDA8dikpcmV0dXJuIDA7dmFyIEk9aDt2PWgrdi0xO2Zvcih2YXIgaz0wO2s8bi5sZW5ndGg7KytrKXt2YXIgej1uLmNoYXJDb2RlQXQoayk7aWYoNTUyOTY8PXomJjU3MzQzPj16KXt2YXIgRz1uLmNoYXJDb2RlQXQoKytrKTt6PTY1NTM2KygoeiYxMDIzKTw8MTApfEcmMTAyM31pZigxMjc+PXope2lmKGg+PXYpYnJlYWs7ZFtoKys+Pj4wXT16fWVsc2V7aWYoMjA0Nz49eil7aWYoaCsxPj12KWJyZWFrO2RbaCsrPj4+MF09MTkyfHo+PjZ9ZWxzZXtpZig2NTUzNT49eil7aWYoaCsyPj12KWJyZWFrO2RbaCsrPj4+MF09MjI0fHo+PjEyfWVsc2V7aWYoaCszPj12KWJyZWFrO2RbaCsrPj4+MF09MjQwfHo+PjE4LGRbaCsrPj4+MF09MTI4fHo+PjEyJjYzfWRbaCsrPj4+MF09MTI4fHo+PjYmNjN9ZFtoKys+Pj4wXT0xMjh8eiY2M319cmV0dXJuIGRbaD4+PjBdPTAsaC1JfSxIdD0obixkLGgpPT5NcihuLGEoKSxkLGgpO2Z1bmN0aW9uIERyKG4sZCl7aWYoRSlyZXR1cm4gd2UoNSwxLG4sZCl9ZnVuY3Rpb24genIobixkLGgpe2lmKEUpcmV0dXJuIHdlKDYsMSxuLGQsaCl9ZnVuY3Rpb24gbG4obixkLGgpe3JldHVybiBFP3dlKDcsMSxuLGQsaCk6MH1mdW5jdGlvbiBjcihuLGQpe2lmKEUpcmV0dXJuIHdlKDgsMSxuLGQpfWZ1bmN0aW9uIGRuKG4sZCxoKXtpZihFKXJldHVybiB3ZSg5LDEsbixkLGgpfWZ1bmN0aW9uIGNuKG4sZCxoLHYpe2lmKEUpcmV0dXJuIHdlKDEwLDEsbixkLGgsdil9ZnVuY3Rpb24gcG4obixkLGgsdil7aWYoRSlyZXR1cm4gd2UoMTEsMSxuLGQsaCx2KX1mdW5jdGlvbiBmbihuLGQsaCx2KXtpZihFKXJldHVybiB3ZSgxMiwxLG4sZCxoLHYpfWZ1bmN0aW9uIFVyKG4pe2lmKEUpcmV0dXJuIHdlKDEzLDEsbil9ZnVuY3Rpb24gUXQobixkKXtpZihFKXJldHVybiB3ZSgxNCwxLG4sZCl9ZnVuY3Rpb24gbW4obixkLGgpe2lmKEUpcmV0dXJuIHdlKDE1LDEsbixkLGgpfXZhciBwcj1uPT57aWYobj09PW51bGwpcmV0dXJuXCJudWxsXCI7dmFyIGQ9dHlwZW9mIG47cmV0dXJuIGQ9PT1cIm9iamVjdFwifHxkPT09XCJhcnJheVwifHxkPT09XCJmdW5jdGlvblwiP24udG9TdHJpbmcoKTpcIlwiK259LFdyLG10PW49Pntmb3IodmFyIGQ9XCJcIjthKClbbj4+PjBdOylkKz1XclthKClbbisrPj4+MF1dO3JldHVybiBkfSxOcj17fSxmcj17fSxnYT17fSx0dDtmdW5jdGlvbiBobihuLGQsaD17fSl7dmFyIHY9ZC5uYW1lO2lmKCFuKXRocm93IG5ldyB0dChgdHlwZSBcIiR7dn1cIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7aWYoZnIuaGFzT3duUHJvcGVydHkobikpe2lmKGguWWIpcmV0dXJuO3Rocm93IG5ldyB0dChgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7dn0nIHR3aWNlYCl9ZnJbbl09ZCxkZWxldGUgZ2Fbbl0sTnIuaGFzT3duUHJvcGVydHkobikmJihkPU5yW25dLGRlbGV0ZSBOcltuXSxkLmZvckVhY2goST0+SSgpKSl9ZnVuY3Rpb24geXQobixkLGg9e30pe2lmKCEoXCJhcmdQYWNrQWR2YW5jZVwiaW4gZCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlZ2lzdGVyVHlwZSByZWdpc3RlcmVkSW5zdGFuY2UgcmVxdWlyZXMgYXJnUGFja0FkdmFuY2VcIik7aG4obixkLGgpfXZhciBWcj0obixkLGgpPT57c3dpdGNoKGQpe2Nhc2UgMTpyZXR1cm4gaD92PT5yKClbdj4+PjA+Pj4wXTp2PT5hKClbdj4+PjA+Pj4wXTtjYXNlIDI6cmV0dXJuIGg/dj0+aSgpW3Y+Pj4xPj4+MF06dj0+cygpW3Y+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBoP3Y9Pm8oKVt2Pj4+Mj4+PjBdOnY9PmMoKVt2Pj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gaD92PT5oZVt2Pj4+M106dj0+SmVbdj4+PjNdO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke2R9KTogJHtufWApfX07ZnVuY3Rpb24gbXIoKXt0aGlzLndiPVt2b2lkIDBdLHRoaXMuTmI9W119dmFyIHJ0PW5ldyBtcjtmdW5jdGlvbiBKdChuKXtuPj4+PTAsbj49cnQuRGImJi0tcnQuZ2V0KG4pLlFiPT09MCYmcnQuTWIobil9dmFyIFllPW49PntpZighbil0aHJvdyBuZXcgdHQoXCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSBcIituKTtyZXR1cm4gcnQuZ2V0KG4pLnZhbHVlfSxudD1uPT57c3dpdGNoKG4pe2Nhc2Ugdm9pZCAwOnJldHVybiAxO2Nhc2UgbnVsbDpyZXR1cm4gMjtjYXNlITA6cmV0dXJuIDM7Y2FzZSExOnJldHVybiA0O2RlZmF1bHQ6cmV0dXJuIHJ0LktiKHtRYjoxLHZhbHVlOm59KX19O2Z1bmN0aW9uIGduKG4pe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShvKClbbj4+PjI+Pj4wXSl9dmFyIHluPShuLGQpPT57c3dpdGNoKGQpe2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24oaCl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHAoKVtoPj4+Mj4+PjBdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbihoKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUobSgpW2g+Pj4zPj4+MF0pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7ZH0pOiAke259YCl9fTtmdW5jdGlvbiBibihuKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoYygpW24+Pj4yPj4+MF0pfXZhciB2bj10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIik6dm9pZCAwLHduPShuLGQpPT57Zm9yKHZhciBoPW4+PjEsdj1oK2QvMjshKGg+PXYpJiZzKClbaD4+PjBdOykrK2g7aWYoaDw8PTEsMzI8aC1uJiZ2bilyZXR1cm4gdm4uZGVjb2RlKGEoKS5zbGljZShuLGgpKTtmb3IoaD1cIlwiLHY9MDshKHY+PWQvMik7Kyt2KXt2YXIgST1pKClbbisyKnY+Pj4xPj4+MF07aWYoST09MClicmVhaztoKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEkpfXJldHVybiBofSwkbj0obixkLGgpPT57aWYoaD8/PTIxNDc0ODM2NDcsMj5oKXJldHVybiAwO2gtPTI7dmFyIHY9ZDtoPWg8MipuLmxlbmd0aD9oLzI6bi5sZW5ndGg7Zm9yKHZhciBJPTA7STxoOysrSSl7dmFyIGs9bi5jaGFyQ29kZUF0KEkpO2koKVtkPj4+MT4+PjBdPWssZCs9Mn1yZXR1cm4gaSgpW2Q+Pj4xPj4+MF09MCxkLXZ9LGhyPW49PjIqbi5sZW5ndGgseWE9KG4sZCk9Pntmb3IodmFyIGg9MCx2PVwiXCI7IShoPj1kLzQpOyl7dmFyIEk9bygpW24rNCpoPj4+Mj4+PjBdO2lmKEk9PTApYnJlYWs7KytoLDY1NTM2PD1JPyhJLT02NTUzNix2Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fEk+PjEwLDU2MzIwfEkmMTAyMykpOnYrPVN0cmluZy5mcm9tQ2hhckNvZGUoSSl9cmV0dXJuIHZ9LHVlPShuLGQsaCk9PntpZihkPj4+PTAsaD8/PTIxNDc0ODM2NDcsND5oKXJldHVybiAwO3ZhciB2PWQ7aD12K2gtNDtmb3IodmFyIEk9MDtJPG4ubGVuZ3RoOysrSSl7dmFyIGs9bi5jaGFyQ29kZUF0KEkpO2lmKDU1Mjk2PD1rJiY1NzM0Mz49ayl7dmFyIHo9bi5jaGFyQ29kZUF0KCsrSSk7az02NTUzNisoKGsmMTAyMyk8PDEwKXx6JjEwMjN9aWYobygpW2Q+Pj4yPj4+MF09ayxkKz00LGQrND5oKWJyZWFrfXJldHVybiBvKClbZD4+PjI+Pj4wXT0wLGQtdn0sX249bj0+e2Zvcih2YXIgZD0wLGg9MDtoPG4ubGVuZ3RoOysraCl7dmFyIHY9bi5jaGFyQ29kZUF0KGgpOzU1Mjk2PD12JiY1NzM0Mz49diYmKytoLGQrPTR9cmV0dXJuIGR9LEx0PSgpPT57aWYoISgwPEtlKSl0cnl7RT9fYSh5ZSk6bHIoeWUpfWNhdGNoKG4pe2tyKG4pfX07ZnVuY3Rpb24gbHQobil7bj4+Pj0wLHR5cGVvZiBBdG9taWNzLm9jPT1cImZ1bmN0aW9uXCImJihBdG9taWNzLm9jKG8oKSxuPj4+MixuKS52YWx1ZS50aGVuKGVyKSxuKz0xMjgsQXRvbWljcy5zdG9yZShvKCksbj4+PjIsMSkpfWwuX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0PWx0O3ZhciBlcj0oKT0+e3ZhciBuPUluKCk7aWYobiYmKGx0KG4pLCFwZSkpdHJ5e3ppKCksTHQoKX1jYXRjaChkKXtrcihkKX19O2wuY2hlY2tNYWlsYm94PWVyO3ZhciBncj1bXSx5cj0obixkKT0+e3ZhciBoPWZyW25dO2lmKGg9PT12b2lkIDApdGhyb3cgbj1CaShuKSxoPW10KG4pLEl0KG4pLG5ldyB0dChkK1wiIGhhcyB1bmtub3duIHR5cGUgXCIraCk7cmV0dXJuIGh9LEhyPShuLGQsaCk9Pnt2YXIgdj1bXTtyZXR1cm4gbj1uLnRvV2lyZVR5cGUodixoKSx2Lmxlbmd0aCYmKGMoKVtkPj4+Mj4+PjBdPW50KHYpKSxufSx0cj1uPT57dHJ5e24oKX1jYXRjaChkKXtWdChkKX19O2Z1bmN0aW9uIFNuKCl7dmFyIG49cmUsZD17fTtmb3IobGV0W2gsdl1vZiBPYmplY3QuZW50cmllcyhuKSlkW2hdPXR5cGVvZiB2PT1cImZ1bmN0aW9uXCI/ZnVuY3Rpb24oKXt6dC5wdXNoKGgpO3RyeXtyZXR1cm4gdi5hcHBseShudWxsLGFyZ3VtZW50cyl9ZmluYWxseXtwZXx8KHp0LnBvcCgpLGh0JiYkdD09PTEmJnp0Lmxlbmd0aD09PTAmJigkdD0wLEtlKz0xLHRyKFZpKSx0eXBlb2YgRmliZXJzPFwidVwiJiZGaWJlcnMudWMoKSkpfX06djtyZXR1cm4gZH12YXIgJHQ9MCxodD1udWxsLHhuPTAsenQ9W10sTHI9e30sdT17fSxmPTAseT1udWxsLF89W107ZnVuY3Rpb24gQSgpe3JldHVybiBuZXcgUHJvbWlzZSgobixkKT0+e3k9e3Jlc29sdmU6bixyZWplY3Q6ZH19KX1mdW5jdGlvbiBNKCl7dmFyIG49R3IoNjU1NDgpLGQ9bisxMjtjKClbbj4+PjI+Pj4wXT1kLGMoKVtuKzQ+Pj4yPj4+MF09ZCs2NTUzNixkPXp0WzBdO3ZhciBoPUxyW2RdO3JldHVybiBoPT09dm9pZCAwJiYoaD1mKyssTHJbZF09aCx1W2hdPWQpLGQ9aCxvKClbbis4Pj4+Mj4+PjBdPWQsbn1mdW5jdGlvbiBIKCl7dmFyIG49bygpW2h0Kzg+Pj4yPj4+MF07cmV0dXJuIG49cmVbdVtuXV0sLS1LZSxuKCl9ZnVuY3Rpb24gWChuKXtpZighcGUpe2lmKCR0PT09MCl7dmFyIGQ9ITEsaD0hMTtuKCh2PTApPT57aWYoIXBlJiYoeG49dixkPSEwLGgpKXskdD0yLHRyKCgpPT5IaShodCkpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkpiLlhiJiZCcm93c2VyLkpiLnJlc3VtZSgpLHY9ITE7dHJ5e3ZhciBJPUgoKX1jYXRjaChHKXtJPUcsdj0hMH12YXIgaz0hMTtpZighaHQpe3ZhciB6PXk7eiYmKHk9bnVsbCwodj96LnJlamVjdDp6LnJlc29sdmUpKEkpLGs9ITApfWlmKHYmJiFrKXRocm93IEl9fSksaD0hMCxkfHwoJHQ9MSxodD1NKCksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuSmIuWGImJkJyb3dzZXIuSmIucGF1c2UoKSx0cigoKT0+TmkoaHQpKSl9ZWxzZSAkdD09PTI/KCR0PTAsdHIoTGkpLEl0KGh0KSxodD1udWxsLF8uZm9yRWFjaCh2PT57aWYoIXBlKXRyeXt2KCksTHQoKX1jYXRjaChJKXtrcihJKX19KSk6VnQoYGludmFsaWQgc3RhdGU6ICR7JHR9YCk7cmV0dXJuIHhufX1mdW5jdGlvbiBqKG4pe3JldHVybiBYKGQ9PntuKCkudGhlbihkKX0pfXZhciBxPVtdLG5lPXt9LG1lPW49Pnt2YXIgZD1uZVtuXTtyZXR1cm4gZD09PXZvaWQgMD9tdChuKTpkfSwkZT0oKT0+dHlwZW9mIGdsb2JhbFRoaXM9PVwib2JqZWN0XCI/Z2xvYmFsVGhpczpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCksUD1uPT57dmFyIGQ9cS5sZW5ndGg7cmV0dXJuIHEucHVzaChuKSxkfSxvZT0obixkKT0+e2Zvcih2YXIgaD1BcnJheShuKSx2PTA7djxuOysrdiloW3ZdPXlyKGMoKVtkKzQqdj4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIit2KTtyZXR1cm4gaH0sSWU9KG4sZCk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLFwibmFtZVwiLHt2YWx1ZTpufSk7ZnVuY3Rpb24gVXQobil7dmFyIGQ9RnVuY3Rpb247aWYoIShkIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IG5ldyBUeXBlRXJyb3IoYG5ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAke3R5cGVvZiBkfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciBoPUllKGQubmFtZXx8XCJ1bmtub3duRnVuY3Rpb25OYW1lXCIsZnVuY3Rpb24oKXt9KTtyZXR1cm4gaC5wcm90b3R5cGU9ZC5wcm90b3R5cGUsaD1uZXcgaCxuPWQuYXBwbHkoaCxuKSxuIGluc3RhbmNlb2YgT2JqZWN0P246aH12YXIgV3Q9bj0+biU0PT09MCYmKG4lMTAwIT09MHx8biU0MDA9PT0wKSxnaT1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSx5aT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiBiaShuLGQsaCx2LEksayx6KXtyZXR1cm4gRT93ZSgxNiwxLG4sZCxoLHYsSSxrLHopOi01Mn1mdW5jdGlvbiB2aShuLGQsaCx2LEksayl7aWYoRSlyZXR1cm4gd2UoMTcsMSxuLGQsaCx2LEksayl9dmFyIHdpPW49Pnt2YXIgZD1ldChuKSsxLGg9R3IoZCk7cmV0dXJuIGgmJkh0KG4saCxkKSxofSxiYT1bXSwkaT0obixkKT0+e2JhLmxlbmd0aD0wO2Zvcih2YXIgaDtoPWEoKVtuKys+Pj4wXTspe3ZhciB2PWghPTEwNTt2Jj1oIT0xMTIsZCs9diYmZCU4PzQ6MCxiYS5wdXNoKGg9PTExMj9jKClbZD4+PjI+Pj4wXTpoPT0xMDY/aGVbZD4+PjNdOmg9PTEwNT9vKClbZD4+PjI+Pj4wXTptKClbZD4+PjM+Pj4wXSksZCs9dj84OjR9cmV0dXJuIGJhfSx2YT17fSxfaT0oKT0+e2lmKCF3YSl7dmFyIG49e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86JHx8XCIuL3RoaXMucHJvZ3JhbVwifSxkO2ZvcihkIGluIHZhKXZhW2RdPT09dm9pZCAwP2RlbGV0ZSBuW2RdOm5bZF09dmFbZF07dmFyIGg9W107Zm9yKGQgaW4gbiloLnB1c2goYCR7ZH09JHtuW2RdfWApO3dhPWh9cmV0dXJuIHdhfSx3YTtmdW5jdGlvbiBTaShuLGQpe2lmKEUpcmV0dXJuIHdlKDE4LDEsbixkKTtuPj4+PTAsZD4+Pj0wO3ZhciBoPTA7cmV0dXJuIF9pKCkuZm9yRWFjaCgodixJKT0+e3ZhciBrPWQraDtmb3IoST1jKClbbis0Kkk+Pj4yPj4+MF09ayxrPTA7azx2Lmxlbmd0aDsrK2spcigpW0krKz4+PjA+Pj4wXT12LmNoYXJDb2RlQXQoayk7cigpW0k+Pj4wPj4+MF09MCxoKz12Lmxlbmd0aCsxfSksMH1mdW5jdGlvbiB4aShuLGQpe2lmKEUpcmV0dXJuIHdlKDE5LDEsbixkKTtuPj4+PTAsZD4+Pj0wO3ZhciBoPV9pKCk7YygpW24+Pj4yPj4+MF09aC5sZW5ndGg7dmFyIHY9MDtyZXR1cm4gaC5mb3JFYWNoKEk9PnYrPUkubGVuZ3RoKzEpLGMoKVtkPj4+Mj4+PjBdPXYsMH1mdW5jdGlvbiBDaShuKXtyZXR1cm4gRT93ZSgyMCwxLG4pOjUyfWZ1bmN0aW9uIElpKG4sZCxoLHYpe3JldHVybiBFP3dlKDIxLDEsbixkLGgsdik6NTJ9ZnVuY3Rpb24gQWkobixkLGgsdil7cmV0dXJuIEU/d2UoMjIsMSxuLGQsaCx2KTo3MH12YXIgVGQ9W251bGwsW10sW11dO2Z1bmN0aW9uIFRpKG4sZCxoLHYpe2lmKEUpcmV0dXJuIHdlKDIzLDEsbixkLGgsdik7ZD4+Pj0wLGg+Pj49MCx2Pj4+PTA7Zm9yKHZhciBJPTAsaz0wO2s8aDtrKyspe3ZhciB6PWMoKVtkPj4+Mj4+PjBdLEc9YygpW2QrND4+PjI+Pj4wXTtkKz04O2Zvcih2YXIgWj0wO1o8RztaKyspe3ZhciBLPWEoKVt6K1o+Pj4wXSxhZT1UZFtuXTtLPT09MHx8Sz09PTEwPygobj09PTE/T2U6ZWUpKEVyKGFlLDApKSxhZS5sZW5ndGg9MCk6YWUucHVzaChLKX1JKz1HfXJldHVybiBjKClbdj4+PjI+Pj4wXT1JLDB9dmFyIEVpPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sT2k9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBFZChuKXt2YXIgZD1BcnJheShldChuKSsxKTtyZXR1cm4gTXIobixkLDAsZC5sZW5ndGgpLGR9dmFyIE9kPShuLGQpPT57cigpLnNldChuLGQ+Pj4wKX07ZnVuY3Rpb24ga2kobixkLGgsdil7ZnVuY3Rpb24gSShSLGxlLFRlKXtmb3IoUj10eXBlb2YgUj09XCJudW1iZXJcIj9SLnRvU3RyaW5nKCk6Unx8XCJcIjtSLmxlbmd0aDxsZTspUj1UZVswXStSO3JldHVybiBSfWZ1bmN0aW9uIGsoUixsZSl7cmV0dXJuIEkoUixsZSxcIjBcIil9ZnVuY3Rpb24geihSLGxlKXtmdW5jdGlvbiBUZShGaSl7cmV0dXJuIDA+Rmk/LTE6MDxGaT8xOjB9dmFyIHJyO3JldHVybihycj1UZShSLmdldEZ1bGxZZWFyKCktbGUuZ2V0RnVsbFllYXIoKSkpPT09MCYmKHJyPVRlKFIuZ2V0TW9udGgoKS1sZS5nZXRNb250aCgpKSk9PT0wJiYocnI9VGUoUi5nZXREYXRlKCktbGUuZ2V0RGF0ZSgpKSkscnJ9ZnVuY3Rpb24gRyhSKXtzd2l0Y2goUi5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShSLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBSO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoUi5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShSLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKFIuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoUi5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoUi5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBaKFIpe3ZhciBsZT1SLkFiO2ZvcihSPW5ldyBEYXRlKG5ldyBEYXRlKFIuQmIrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxsZTspe3ZhciBUZT1SLmdldE1vbnRoKCkscnI9KFd0KFIuZ2V0RnVsbFllYXIoKSk/RWk6T2kpW1RlXTtpZihsZT5yci1SLmdldERhdGUoKSlsZS09cnItUi5nZXREYXRlKCkrMSxSLnNldERhdGUoMSksMTE+VGU/Ui5zZXRNb250aChUZSsxKTooUi5zZXRNb250aCgwKSxSLnNldEZ1bGxZZWFyKFIuZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtSLnNldERhdGUoUi5nZXREYXRlKCkrbGUpO2JyZWFrfX1yZXR1cm4gVGU9bmV3IERhdGUoUi5nZXRGdWxsWWVhcigpKzEsMCw0KSxsZT1HKG5ldyBEYXRlKFIuZ2V0RnVsbFllYXIoKSwwLDQpKSxUZT1HKFRlKSwwPj16KGxlLFIpPzA+PXooVGUsUik/Ui5nZXRGdWxsWWVhcigpKzE6Ui5nZXRGdWxsWWVhcigpOlIuZ2V0RnVsbFllYXIoKS0xfW4+Pj49MCxkPj4+PTAsaD4+Pj0wLHY+Pj49MDt2YXIgSz1jKClbdis0MD4+PjI+Pj4wXTt2PXtsYzpvKClbdj4+PjI+Pj4wXSxrYzpvKClbdis0Pj4+Mj4+PjBdLEdiOm8oKVt2Kzg+Pj4yPj4+MF0sTGI6bygpW3YrMTI+Pj4yPj4+MF0sSGI6bygpW3YrMTY+Pj4yPj4+MF0sQmI6bygpW3YrMjA+Pj4yPj4+MF0sdmI6bygpW3YrMjQ+Pj4yPj4+MF0sQWI6bygpW3YrMjg+Pj4yPj4+MF0sdGM6bygpW3YrMzI+Pj4yPj4+MF0samM6bygpW3YrMzY+Pj4yPj4+MF0sbWM6Sz9QZShLKTpcIlwifSxoPVBlKGgpLEs9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIGFlIGluIEspaD1oLnJlcGxhY2UobmV3IFJlZ0V4cChhZSxcImdcIiksS1thZV0pO3ZhciBnZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLFNlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtLPXtcIiVhXCI6Uj0+Z2VbUi52Yl0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOlI9PmdlW1IudmJdLFwiJWJcIjpSPT5TZVtSLkhiXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6Uj0+U2VbUi5IYl0sXCIlQ1wiOlI9PmsoKFIuQmIrMTkwMCkvMTAwfDAsMiksXCIlZFwiOlI9PmsoUi5MYiwyKSxcIiVlXCI6Uj0+SShSLkxiLDIsXCIgXCIpLFwiJWdcIjpSPT5aKFIpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpSPT5aKFIpLFwiJUhcIjpSPT5rKFIuR2IsMiksXCIlSVwiOlI9PihSPVIuR2IsUj09MD9SPTEyOjEyPFImJihSLT0xMiksayhSLDIpKSxcIiVqXCI6Uj0+e2Zvcih2YXIgbGU9MCxUZT0wO1RlPD1SLkhiLTE7bGUrPShXdChSLkJiKzE5MDApP0VpOk9pKVtUZSsrXSk7cmV0dXJuIGsoUi5MYitsZSwzKX0sXCIlbVwiOlI9PmsoUi5IYisxLDIpLFwiJU1cIjpSPT5rKFIua2MsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjpSPT4wPD1SLkdiJiYxMj5SLkdiP1wiQU1cIjpcIlBNXCIsXCIlU1wiOlI9PmsoUi5sYywyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6Uj0+Ui52Ynx8NyxcIiVVXCI6Uj0+ayhNYXRoLmZsb29yKChSLkFiKzctUi52YikvNyksMiksXCIlVlwiOlI9Pnt2YXIgbGU9TWF0aC5mbG9vcigoUi5BYis3LShSLnZiKzYpJTcpLzcpO2lmKDI+PShSLnZiKzM3MS1SLkFiLTIpJTcmJmxlKyssbGUpbGU9PTUzJiYoVGU9KFIudmIrMzcxLVIuQWIpJTcsVGU9PTR8fFRlPT0zJiZXdChSLkJiKXx8KGxlPTEpKTtlbHNle2xlPTUyO3ZhciBUZT0oUi52Yis3LVIuQWItMSklNzsoVGU9PTR8fFRlPT01JiZXdChSLkJiJTQwMC0xKSkmJmxlKyt9cmV0dXJuIGsobGUsMil9LFwiJXdcIjpSPT5SLnZiLFwiJVdcIjpSPT5rKE1hdGguZmxvb3IoKFIuQWIrNy0oUi52Yis2KSU3KS83KSwyKSxcIiV5XCI6Uj0+KFIuQmIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOlI9PlIuQmIrMTkwMCxcIiV6XCI6Uj0+e1I9Ui5qYzt2YXIgbGU9MDw9UjtyZXR1cm4gUj1NYXRoLmFicyhSKS82MCwobGU/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoUi82MCoxMDArUiU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOlI9PlIubWMsXCIlJVwiOigpPT5cIiVcIn0saD1oLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIik7Zm9yKGFlIGluIEspaC5pbmNsdWRlcyhhZSkmJihoPWgucmVwbGFjZShuZXcgUmVnRXhwKGFlLFwiZ1wiKSxLW2FlXSh2KSkpO3JldHVybiBoPWgucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpLGFlPUVkKGgpLGFlLmxlbmd0aD5kPzA6KE9kKGFlLG4pLGFlLmxlbmd0aC0xKX1mZS5JYigpO2Zvcih2YXIgUGk9QXJyYXkoMjU2KSxDbj0wOzI1Nj5DbjsrK0NuKVBpW0NuXT1TdHJpbmcuZnJvbUNoYXJDb2RlKENuKTtXcj1QaSx0dD1sLkJpbmRpbmdFcnJvcj1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKG4pe3N1cGVyKG4pLHRoaXMubmFtZT1cIkJpbmRpbmdFcnJvclwifX0sbC5JbnRlcm5hbEVycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iobil7c3VwZXIobiksdGhpcy5uYW1lPVwiSW50ZXJuYWxFcnJvclwifX0sT2JqZWN0LmFzc2lnbihtci5wcm90b3R5cGUse2dldChuKXtyZXR1cm4gdGhpcy53YltuXX0saGFzKG4pe3JldHVybiB0aGlzLndiW25dIT09dm9pZCAwfSxLYihuKXt2YXIgZD10aGlzLk5iLnBvcCgpfHx0aGlzLndiLmxlbmd0aDtyZXR1cm4gdGhpcy53YltkXT1uLGR9LE1iKG4pe3RoaXMud2Jbbl09dm9pZCAwLHRoaXMuTmIucHVzaChuKX19KSxydC53Yi5wdXNoKHt2YWx1ZTp2b2lkIDB9LHt2YWx1ZTpudWxsfSx7dmFsdWU6ITB9LHt2YWx1ZTohMX0pLHJ0LkRiPXJ0LndiLmxlbmd0aCxsLmNvdW50X2VtdmFsX2hhbmRsZXM9KCk9Pntmb3IodmFyIG49MCxkPXJ0LkRiO2Q8cnQud2IubGVuZ3RoOysrZClydC53YltkXSE9PXZvaWQgMCYmKytuO3JldHVybiBufTt2YXIga2Q9W3V0LG9uLEJyLHVuLHd0LERyLHpyLGxuLGNyLGRuLGNuLHBuLGZuLFVyLFF0LG1uLGJpLHZpLFNpLHhpLENpLElpLEFpLFRpXSxQZD17dWE6ZnVuY3Rpb24obixkLGgpe3JldHVybiBqKGFzeW5jKCk9Pnthd2FpdCBsLmFjKG4sZCxoKX0pfSxiOmZ1bmN0aW9uKG4sZCxoKXt0aHJvdyBuPj4+PTAsbmV3IGhhKG4pLkliKGQ+Pj4wLGg+Pj4wKSxzbj1uLFJyKyssc259LGZhOmZ1bmN0aW9uKG4pe01pKG4+Pj4wLCFDLDEsIVQsMTMxMDcyLCExKSxmZS5UYigpfSxEOmZ1bmN0aW9uKG4pe24+Pj49MCxFP3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOm59KTpmZS5SYihmZS5wYltuXSl9LFg6WHQsejp1bixsYTp3dCxUOkRyLFY6enIsbWE6bG4samE6Y3IsY2E6ZG4saWE6Y24sSDpwbixVOmZuLFI6VXIsa2E6UXQsUzptbixLOmZ1bmN0aW9uKG4sZCxoLHYsSSl7bj4+Pj0wLGQ+Pj49MCxoPj4+PTAsZD1tdChkKTt2YXIgaz1kLmluZGV4T2YoXCJ1XCIpIT0tMTtrJiYoST0oMW48PDY0biktMW4pLHl0KG4se25hbWU6ZCxmcm9tV2lyZVR5cGU6ej0+eix0b1dpcmVUeXBlOmZ1bmN0aW9uKHosRyl7aWYodHlwZW9mIEchPVwiYmlnaW50XCImJnR5cGVvZiBHIT1cIm51bWJlclwiKXRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBjb252ZXJ0IFwiJHtwcihHKX1cIiB0byAke3RoaXMubmFtZX1gKTtpZihHPHZ8fEc+SSl0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXNzaW5nIGEgbnVtYmVyIFwiJHtwcihHKX1cIiBmcm9tIEpTIHNpZGUgdG8gQy9DKysgc2lkZSB0byBhbiBhcmd1bWVudCBvZiB0eXBlIFwiJHtkfVwiLCB3aGljaCBpcyBvdXRzaWRlIHRoZSB2YWxpZCByYW5nZSBbJHt2fSwgJHtJfV0hYCk7cmV0dXJuIEd9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6VnIoZCxoLCFrKSxDYjpudWxsfSl9LHNhOmZ1bmN0aW9uKG4sZCxoLHYpe24+Pj49MCxkPW10KGQ+Pj4wKSx5dChuLHtuYW1lOmQsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKEkpe3JldHVybiEhSX0sdG9XaXJlVHlwZTpmdW5jdGlvbihJLGspe3JldHVybiBrP2g6dn0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbihJKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoYSgpW0k+Pj4wXSl9LENiOm51bGx9KX0scmE6ZnVuY3Rpb24obixkKXtuPj4+PTAsZD1tdChkPj4+MCkseXQobix7bmFtZTpkLGZyb21XaXJlVHlwZTpoPT57dmFyIHY9WWUoaCk7cmV0dXJuIEp0KGgpLHZ9LHRvV2lyZVR5cGU6KGgsdik9Pm50KHYpLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6Z24sQ2I6bnVsbH0pfSxKOmZ1bmN0aW9uKG4sZCxoKXtuPj4+PTAsaD4+Pj0wLGQ9bXQoZD4+PjApLHl0KG4se25hbWU6ZCxmcm9tV2lyZVR5cGU6dj0+dix0b1dpcmVUeXBlOih2LEkpPT5JLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6eW4oZCxoKSxDYjpudWxsfSl9LHY6ZnVuY3Rpb24obixkLGgsdixJKXtpZihuPj4+PTAsaD4+Pj0wLGQ9bXQoZD4+PjApLEk9PT0tMSYmKEk9NDI5NDk2NzI5NSksST1HPT5HLHY9PT0wKXt2YXIgaz0zMi04Kmg7ST1HPT5HPDxrPj4+a312YXIgej1kLmluY2x1ZGVzKFwidW5zaWduZWRcIik/ZnVuY3Rpb24oRyxaKXtyZXR1cm4gWj4+PjB9OmZ1bmN0aW9uKEcsWil7cmV0dXJuIFp9O3l0KG4se25hbWU6ZCxmcm9tV2lyZVR5cGU6SSx0b1dpcmVUeXBlOnosYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpWcihkLGgsdiE9PTApLENiOm51bGx9KX0sbzpmdW5jdGlvbihuLGQsaCl7ZnVuY3Rpb24gdihrKXt2YXIgej1jKClbaz4+PjI+Pj4wXTtyZXR1cm4gaz1jKClbays0Pj4+Mj4+PjBdLG5ldyBJKHIoKS5idWZmZXIsayx6KX1uPj4+PTA7dmFyIEk9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQmlnVWludDY0QXJyYXldW2RdO2g9bXQoaD4+PjApLHl0KG4se25hbWU6aCxmcm9tV2lyZVR5cGU6dixhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOnZ9LHtZYjohMH0pfSxMOmZ1bmN0aW9uKG4sZCl7bj4+Pj0wLGQ9bXQoZD4+PjApO3ZhciBoPWQ9PT1cInN0ZDo6c3RyaW5nXCI7eXQobix7bmFtZTpkLGZyb21XaXJlVHlwZTpmdW5jdGlvbih2KXt2YXIgST1jKClbdj4+PjI+Pj4wXSxrPXYrNDtpZihoKWZvcih2YXIgej1rLEc9MDtHPD1JOysrRyl7dmFyIFo9aytHO2lmKEc9PUl8fGEoKVtaPj4+MF09PTApe2lmKHo9UGUoeixaLXopLEs9PT12b2lkIDApdmFyIEs9ejtlbHNlIEsrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCksSys9ejt6PVorMX19ZWxzZXtmb3IoSz1BcnJheShJKSxHPTA7RzxJOysrRylLW0ddPVN0cmluZy5mcm9tQ2hhckNvZGUoYSgpW2srRz4+PjBdKTtLPUsuam9pbihcIlwiKX1yZXR1cm4gSXQodiksS30sdG9XaXJlVHlwZTpmdW5jdGlvbih2LEkpe0kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKEk9bmV3IFVpbnQ4QXJyYXkoSSkpO3ZhciBrPXR5cGVvZiBJPT1cInN0cmluZ1wiO2lmKCEoa3x8SSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8SSBpbnN0YW5jZW9mIEludDhBcnJheSkpdGhyb3cgbmV3IHR0KFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKTt2YXIgej1oJiZrP2V0KEkpOkkubGVuZ3RoLEc9R3IoNCt6KzEpLFo9Rys0O2lmKGMoKVtHPj4+Mj4+PjBdPXosaCYmaylIdChJLFoseisxKTtlbHNlIGlmKGspZm9yKGs9MDtrPHo7KytrKXt2YXIgSz1JLmNoYXJDb2RlQXQoayk7aWYoMjU1PEspdGhyb3cgSXQoWiksbmV3IHR0KFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpO2EoKVtaK2s+Pj4wXT1LfWVsc2UgZm9yKGs9MDtrPHo7KytrKWEoKVtaK2s+Pj4wXT1JW2tdO3JldHVybiB2IT09bnVsbCYmdi5wdXNoKEl0LEcpLEd9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6Ym4sQ2Iodil7SXQodil9fSl9LEI6ZnVuY3Rpb24obixkLGgpe2lmKG4+Pj49MCxkPj4+PTAsaD4+Pj0wLGg9bXQoaCksZD09PTIpdmFyIHY9d24sST0kbixrPWhyLHo9KCk9PnMoKSxHPTE7ZWxzZSBkPT09NCYmKHY9eWEsST11ZSxrPV9uLHo9KCk9PmMoKSxHPTIpO3l0KG4se25hbWU6aCxmcm9tV2lyZVR5cGU6Wj0+e2Zvcih2YXIgSz1jKClbWj4+PjI+Pj4wXSxhZT16KCksZ2UsU2U9Wis0LFI9MDtSPD1LOysrUil7dmFyIGxlPVorNCtSKmQ7KFI9PUt8fGFlW2xlPj4+R109PTApJiYoU2U9dihTZSxsZS1TZSksZ2U9PT12b2lkIDA/Z2U9U2U6KGdlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLGdlKz1TZSksU2U9bGUrZCl9cmV0dXJuIEl0KFopLGdlfSx0b1dpcmVUeXBlOihaLEspPT57aWYodHlwZW9mIEshPVwic3RyaW5nXCIpdGhyb3cgbmV3IHR0KGBDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIEMrKyBzdHJpbmcgdHlwZSAke2h9YCk7dmFyIGFlPWsoSyksZ2U9R3IoNCthZStkKTtyZXR1cm4gYygpW2dlPj4+Ml09YWU+PkcsSShLLGdlKzQsYWUrZCksWiE9PW51bGwmJloucHVzaChJdCxnZSksZ2V9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6Z24sQ2IoWil7SXQoWil9fSl9LHRhOmZ1bmN0aW9uKG4sZCl7bj4+Pj0wLGQ9bXQoZD4+PjApLHl0KG4se1piOiEwLG5hbWU6ZCxhcmdQYWNrQWR2YW5jZTowLGZyb21XaXJlVHlwZTooKT0+e30sdG9XaXJlVHlwZTooKT0+e319KX0scWE6KCk9PjEsUDpmdW5jdGlvbihuLGQpe24+Pj49MCxuPT1kPj4+MD9zZXRUaW1lb3V0KCgpPT5lcigpKTpFP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6bixjbWQ6XCJjaGVja01haWxib3hcIn0pOihuPWZlLnBiW25dKSYmbi5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX0sWTpmdW5jdGlvbihuLGQsaCx2KXtkPj4+PTAsaC89Mixnci5sZW5ndGg9aCx2PXY+Pj4wPj4+Mztmb3IodmFyIEk9MDtJPGg7SSsrKWdyW0ldPWhlW3YrMipJXT9oZVt2KzIqSSsxXTptKClbdisyKkkrMT4+PjBdO3JldHVybiBuPTA+bj9adFstbi0xXTprZFtuXSxmZS5XYj1kLGQ9bi5hcHBseShudWxsLGdyKSxmZS5XYj0wLGR9LGVhOmx0LHBhOmZ1bmN0aW9uKG4pe1MmJmZlLnBiW24+Pj4wXS5yZWYoKX0sdDpmdW5jdGlvbihuLGQsaCl7cmV0dXJuIGQ+Pj49MCxoPj4+PTAsbj1ZZShuPj4+MCksZD15cihkLFwiZW12YWw6OmFzXCIpLEhyKGQsaCxuKX0seTpmdW5jdGlvbihuKXtyZXR1cm4gbj4+Pj0wLGooKCk9PihuPVllKG4pLG4udGhlbihudCkpKX0scDpmdW5jdGlvbihuLGQsaCx2KXtyZXR1cm4gaD4+Pj0wLHY+Pj49MCxuPXFbbj4+PjBdLGQ9WWUoZD4+PjApLG4obnVsbCxkLGgsdil9LGs6ZnVuY3Rpb24obixkLGgsdixJKXtyZXR1cm4gaD4+Pj0wLHY+Pj49MCxJPj4+PTAsbj1xW24+Pj4wXSxkPVllKGQ+Pj4wKSxoPW1lKGgpLG4oZCxkW2hdLHYsSSl9LGM6SnQsQzpmdW5jdGlvbihuLGQpe3JldHVybiBkPj4+PTAsbj1ZZShuPj4+MCksZD1ZZShkKSxuPT1kfSxuOmZ1bmN0aW9uKG4pe3JldHVybiBuPj4+PTAsbj09PTA/bnQoJGUoKSk6KG49bWUobiksbnQoJGUoKVtuXSkpfSxqOmZ1bmN0aW9uKG4sZCxoKXtkPW9lKG4sZD4+PjApO3ZhciB2PWQuc2hpZnQoKTtuLS07dmFyIEk9YHJldHVybiBmdW5jdGlvbiAob2JqLCBmdW5jLCBkZXN0cnVjdG9yc1JlZiwgYXJncykge1xuYCxrPTAsej1bXTtoPT09MCYmei5wdXNoKFwib2JqXCIpO2Zvcih2YXIgRz1bXCJyZXRUeXBlXCJdLFo9W3ZdLEs9MDtLPG47KytLKXoucHVzaChcImFyZ1wiK0spLEcucHVzaChcImFyZ1R5cGVcIitLKSxaLnB1c2goZFtLXSksSSs9YCAgdmFyIGFyZyR7S30gPSBhcmdUeXBlJHtLfS5yZWFkVmFsdWVGcm9tUG9pbnRlcihhcmdzJHtrP1wiK1wiK2s6XCJcIn0pO1xuYCxrKz1kW0tdLmFyZ1BhY2tBZHZhbmNlO2ZvcihJKz1gICB2YXIgcnYgPSAke2g9PT0xP1wibmV3IGZ1bmNcIjpcImZ1bmMuY2FsbFwifSgke3ouam9pbihcIiwgXCIpfSk7XG5gLEs9MDtLPG47KytLKWRbS10uZGVsZXRlT2JqZWN0JiYoSSs9YCAgYXJnVHlwZSR7S30uZGVsZXRlT2JqZWN0KGFyZyR7S30pO1xuYCk7cmV0dXJuIHYuWmJ8fChHLnB1c2goXCJlbXZhbF9yZXR1cm5WYWx1ZVwiKSxaLnB1c2goSHIpLEkrPWAgIHJldHVybiBlbXZhbF9yZXR1cm5WYWx1ZShyZXRUeXBlLCBkZXN0cnVjdG9yc1JlZiwgcnYpO1xuYCksRy5wdXNoKEkrYH07XG5gKSxuPVV0KEcpLmFwcGx5KG51bGwsWiksaD1gbWV0aG9kQ2FsbGVyPCgke2QubWFwKGFlPT5hZS5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke3YubmFtZX0+YCxQKEllKGgsbikpfSxzOmZ1bmN0aW9uKG4sZCl7cmV0dXJuIGQ+Pj49MCxuPVllKG4+Pj4wKSxkPVllKGQpLG50KG5bZF0pfSxlOmZ1bmN0aW9uKG4pe24+Pj49MCw0PG4mJihydC5nZXQobikuUWIrPTEpfSx3OmZ1bmN0aW9uKCl7cmV0dXJuIG50KFtdKX0sbTpmdW5jdGlvbihuKXtuPVllKG4+Pj4wKTtmb3IodmFyIGQ9QXJyYXkobi5sZW5ndGgpLGg9MDtoPG4ubGVuZ3RoO2grKylkW2hdPW5baF07cmV0dXJuIG50KGQpfSxmOmZ1bmN0aW9uKG4pe3JldHVybiBudChtZShuPj4+MCkpfSxsOmZ1bmN0aW9uKCl7cmV0dXJuIG50KHt9KX0saTpmdW5jdGlvbihuKXtuPj4+PTA7Zm9yKHZhciBkPVllKG4pO2QubGVuZ3RoOyl7dmFyIGg9ZC5wb3AoKTtkLnBvcCgpKGgpfUp0KG4pfSxoOmZ1bmN0aW9uKG4sZCxoKXtkPj4+PTAsaD4+Pj0wLG49WWUobj4+PjApLGQ9WWUoZCksaD1ZZShoKSxuW2RdPWh9LGQ6ZnVuY3Rpb24obixkKXtyZXR1cm4gZD4+Pj0wLG49eXIobj4+PjAsXCJfZW12YWxfdGFrZV92YWx1ZVwiKSxuPW4ucmVhZFZhbHVlRnJvbVBvaW50ZXIoZCksbnQobil9LCQ6ZnVuY3Rpb24obixkKXtuPS05MDA3MTk5MjU0NzQwOTkyPm58fDkwMDcxOTkyNTQ3NDA5OTI8bj9OYU46TnVtYmVyKG4pLGQ+Pj49MCxuPW5ldyBEYXRlKDFlMypuKSxvKClbZD4+PjI+Pj4wXT1uLmdldFVUQ1NlY29uZHMoKSxvKClbZCs0Pj4+Mj4+PjBdPW4uZ2V0VVRDTWludXRlcygpLG8oKVtkKzg+Pj4yPj4+MF09bi5nZXRVVENIb3VycygpLG8oKVtkKzEyPj4+Mj4+PjBdPW4uZ2V0VVRDRGF0ZSgpLG8oKVtkKzE2Pj4+Mj4+PjBdPW4uZ2V0VVRDTW9udGgoKSxvKClbZCsyMD4+PjI+Pj4wXT1uLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxvKClbZCsyND4+PjI+Pj4wXT1uLmdldFVUQ0RheSgpLG49KG4uZ2V0VGltZSgpLURhdGUuVVRDKG4uZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsbygpW2QrMjg+Pj4yPj4+MF09bn0sYWE6ZnVuY3Rpb24obixkKXtuPS05MDA3MTk5MjU0NzQwOTkyPm58fDkwMDcxOTkyNTQ3NDA5OTI8bj9OYU46TnVtYmVyKG4pLGQ+Pj49MCxuPW5ldyBEYXRlKDFlMypuKSxvKClbZD4+PjI+Pj4wXT1uLmdldFNlY29uZHMoKSxvKClbZCs0Pj4+Mj4+PjBdPW4uZ2V0TWludXRlcygpLG8oKVtkKzg+Pj4yPj4+MF09bi5nZXRIb3VycygpLG8oKVtkKzEyPj4+Mj4+PjBdPW4uZ2V0RGF0ZSgpLG8oKVtkKzE2Pj4+Mj4+PjBdPW4uZ2V0TW9udGgoKSxvKClbZCsyMD4+PjI+Pj4wXT1uLmdldEZ1bGxZZWFyKCktMTkwMCxvKClbZCsyND4+PjI+Pj4wXT1uLmdldERheSgpO3ZhciBoPShXdChuLmdldEZ1bGxZZWFyKCkpP2dpOnlpKVtuLmdldE1vbnRoKCldK24uZ2V0RGF0ZSgpLTF8MDtvKClbZCsyOD4+PjI+Pj4wXT1oLG8oKVtkKzM2Pj4+Mj4+PjBdPS0oNjAqbi5nZXRUaW1lem9uZU9mZnNldCgpKSxoPW5ldyBEYXRlKG4uZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHY9bmV3IERhdGUobi5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtuPShoIT12JiZuLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKHYsaCkpfDAsbygpW2QrMzI+Pj4yPj4+MF09bn0sYmE6ZnVuY3Rpb24obil7bj4+Pj0wO3ZhciBkPW5ldyBEYXRlKG8oKVtuKzIwPj4+Mj4+PjBdKzE5MDAsbygpW24rMTY+Pj4yPj4+MF0sbygpW24rMTI+Pj4yPj4+MF0sbygpW24rOD4+PjI+Pj4wXSxvKClbbis0Pj4+Mj4+PjBdLG8oKVtuPj4+Mj4+PjBdLDApLGg9bygpW24rMzI+Pj4yPj4+MF0sdj1kLmdldFRpbWV6b25lT2Zmc2V0KCksST1uZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGs9bmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSx6PU1hdGgubWluKGssSSk7cmV0dXJuIDA+aD9vKClbbiszMj4+PjI+Pj4wXT0rKEkhPWsmJno9PXYpOjA8aCE9KHo9PXYpJiYoST1NYXRoLm1heChrLEkpLGQuc2V0VGltZShkLmdldFRpbWUoKSs2ZTQqKCgwPGg/ejpJKS12KSkpLG8oKVtuKzI0Pj4+Mj4+PjBdPWQuZ2V0RGF5KCksaD0oV3QoZC5nZXRGdWxsWWVhcigpKT9naTp5aSlbZC5nZXRNb250aCgpXStkLmdldERhdGUoKS0xfDAsbygpW24rMjg+Pj4yPj4+MF09aCxvKClbbj4+PjI+Pj4wXT1kLmdldFNlY29uZHMoKSxvKClbbis0Pj4+Mj4+PjBdPWQuZ2V0TWludXRlcygpLG8oKVtuKzg+Pj4yPj4+MF09ZC5nZXRIb3VycygpLG8oKVtuKzEyPj4+Mj4+PjBdPWQuZ2V0RGF0ZSgpLG8oKVtuKzE2Pj4+Mj4+PjBdPWQuZ2V0TW9udGgoKSxvKClbbisyMD4+PjI+Pj4wXT1kLmdldFllYXIoKSxuPWQuZ2V0VGltZSgpLGlzTmFOKG4pPyhvKClbUmkoKT4+PjI+Pj4wXT02MSxuPS0xKTpuLz0xZTMsQmlnSW50KG4pfSxaOmJpLF86dmksTzpmdW5jdGlvbihuLGQsaCl7ZnVuY3Rpb24gdihLKXtyZXR1cm4oSz1LLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP0tbMV06XCJHTVRcIn1uPj4+PTAsZD4+Pj0wLGg+Pj49MDt2YXIgST1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksaz1uZXcgRGF0ZShJLDAsMSksej1uZXcgRGF0ZShJLDYsMSk7ST1rLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEc9ei5nZXRUaW1lem9uZU9mZnNldCgpLFo9TWF0aC5tYXgoSSxHKTtjKClbbj4+PjI+Pj4wXT02MCpaLG8oKVtkPj4+Mj4+PjBdPSsoSSE9Ryksbj12KGspLGQ9dih6KSxuPXdpKG4pLGQ9d2koZCksRzxJPyhjKClbaD4+PjI+Pj4wXT1uLGMoKVtoKzQ+Pj4yPj4+MF09ZCk6KGMoKVtoPj4+Mj4+PjBdPWQsYygpW2grND4+PjI+Pj4wXT1uKX0scTooKT0+e1Z0KFwiXCIpfSxnOmZ1bmN0aW9uKG4sZCxoKXtyZXR1cm4gbj4+Pj0wLGQ9JGkoZD4+PjAsaD4+PjApLFp0W25dLmFwcGx5KG51bGwsZCl9LE06ZnVuY3Rpb24obixkLGgpe3JldHVybiBuPj4+PTAsZD0kaShkPj4+MCxoPj4+MCksWnRbbl0uYXBwbHkobnVsbCxkKX0sRTooKT0+e30sSTooKT0+RGF0ZS5ub3coKSxvYTooKT0+e3Rocm93IEtlKz0xLFwidW53aW5kXCJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sdTooKT0+cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKSx4OigpPT5TPyhUbygpLEd0KEFvKSkuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSxOOmZ1bmN0aW9uKG4pe24+Pj49MDt2YXIgZD1hKCkubGVuZ3RoO2lmKG48PWR8fDQyOTQ5MDE3NjA8bilyZXR1cm4hMTtmb3IodmFyIGg9MTs0Pj1oO2gqPTIpe3ZhciB2PWQqKDErLjIvaCk7dj1NYXRoLm1pbih2LG4rMTAwNjYzMjk2KTt2YXIgST1NYXRoO3Y9TWF0aC5tYXgobix2KTtlOntJPShJLm1pbi5jYWxsKEksNDI5NDkwMTc2MCx2Kyg2NTUzNi12JTY1NTM2KSU2NTUzNiktYmUuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXtiZS5ncm93KEkpLFJlKCk7dmFyIGs9MTticmVhayBlfWNhdGNoe31rPXZvaWQgMH1pZihrKXJldHVybiEwfXJldHVybiExfSxnYTpTaSxoYTp4aSxXOmxyLEE6Q2ksRzpJaSxkYTpBaSxGOlRpLGE6YmV8fGwud2FzbU1lbW9yeSxuYTpraSxyOmZ1bmN0aW9uKG4sZCxoLHYpe3JldHVybiBraShuPj4+MCxkPj4+MCxoPj4+MCx2Pj4+MCl9fSxyZT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oaCx2KXtyZXR1cm4gcmU9aC5leHBvcnRzLHJlPVNuKCkscmU9UmQoKSxmZS5VYi5wdXNoKHJlLmJiKSxNdC51bnNoaWZ0KHJlLnZhKSxVZT12LHhyKCkscmV9dmFyIGQ9e2E6UGR9O2lmKE50KyssbC5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBsLmluc3RhbnRpYXRlV2FzbShkLG4pfWNhdGNoKGgpe2VlKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2h9YCksYihoKX1yZXR1cm4gSXIoZCxmdW5jdGlvbihoKXtuKGguaW5zdGFuY2UsaC5tb2R1bGUpfSkuY2F0Y2goYikse319KCk7bC5fT3J0SW5pdD0obixkKT0+KGwuX09ydEluaXQ9cmUud2EpKG4sZCksbC5fT3J0R2V0TGFzdEVycm9yPShuLGQpPT4obC5fT3J0R2V0TGFzdEVycm9yPXJlLnhhKShuLGQpLGwuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShuLGQsaCx2LEksayx6LEcsWixLKT0+KGwuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXJlLnlhKShuLGQsaCx2LEksayx6LEcsWixLKSxsLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0obixkKT0+KGwuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXJlLnphKShuLGQpLGwuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0obixkLGgpPT4obC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPXJlLkFhKShuLGQsaCksbC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShuLGQsaCk9PihsLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cmUuQmEpKG4sZCxoKSxsLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9bj0+KGwuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1yZS5DYSkobiksbC5fT3J0Q3JlYXRlU2Vzc2lvbj0obixkLGgpPT4obC5fT3J0Q3JlYXRlU2Vzc2lvbj1yZS5EYSkobixkLGgpLGwuX09ydFJlbGVhc2VTZXNzaW9uPW49PihsLl9PcnRSZWxlYXNlU2Vzc2lvbj1yZS5FYSkobiksbC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0obixkLGgpPT4obC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1yZS5GYSkobixkLGgpLGwuX09ydEdldElucHV0TmFtZT0obixkKT0+KGwuX09ydEdldElucHV0TmFtZT1yZS5HYSkobixkKSxsLl9PcnRHZXRPdXRwdXROYW1lPShuLGQpPT4obC5fT3J0R2V0T3V0cHV0TmFtZT1yZS5IYSkobixkKSxsLl9PcnRGcmVlPW49PihsLl9PcnRGcmVlPXJlLklhKShuKSxsLl9PcnRDcmVhdGVUZW5zb3I9KG4sZCxoLHYsSSxrKT0+KGwuX09ydENyZWF0ZVRlbnNvcj1yZS5KYSkobixkLGgsdixJLGspLGwuX09ydEdldFRlbnNvckRhdGE9KG4sZCxoLHYsSSk9PihsLl9PcnRHZXRUZW5zb3JEYXRhPXJlLkthKShuLGQsaCx2LEkpLGwuX09ydFJlbGVhc2VUZW5zb3I9bj0+KGwuX09ydFJlbGVhc2VUZW5zb3I9cmUuTGEpKG4pLGwuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KG4sZCxoLHYpPT4obC5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1yZS5NYSkobixkLGgsdiksbC5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KG4sZCxoKT0+KGwuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXJlLk5hKShuLGQsaCksbC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9bj0+KGwuX09ydFJlbGVhc2VSdW5PcHRpb25zPXJlLk9hKShuKSxsLl9PcnRDcmVhdGVCaW5kaW5nPW49PihsLl9PcnRDcmVhdGVCaW5kaW5nPXJlLlBhKShuKSxsLl9PcnRCaW5kSW5wdXQ9KG4sZCxoKT0+KGwuX09ydEJpbmRJbnB1dD1yZS5RYSkobixkLGgpLGwuX09ydEJpbmRPdXRwdXQ9KG4sZCxoLHYpPT4obC5fT3J0QmluZE91dHB1dD1yZS5SYSkobixkLGgsdiksbC5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9bj0+KGwuX09ydENsZWFyQm91bmRPdXRwdXRzPXJlLlNhKShuKSxsLl9PcnRSZWxlYXNlQmluZGluZz1uPT4obC5fT3J0UmVsZWFzZUJpbmRpbmc9cmUuVGEpKG4pLGwuX09ydFJ1bldpdGhCaW5kaW5nPShuLGQsaCx2LEkpPT4obC5fT3J0UnVuV2l0aEJpbmRpbmc9cmUuVWEpKG4sZCxoLHYsSSksbC5fT3J0UnVuPShuLGQsaCx2LEksayx6LEcpPT4obC5fT3J0UnVuPXJlLlZhKShuLGQsaCx2LEksayx6LEcpLGwuX09ydEVuZFByb2ZpbGluZz1uPT4obC5fT3J0RW5kUHJvZmlsaW5nPXJlLldhKShuKSxsLl9Kc2VwT3V0cHV0PShuLGQsaCk9PihsLl9Kc2VwT3V0cHV0PXJlLlhhKShuLGQsaCksbC5fSnNlcEdldE5vZGVOYW1lPW49PihsLl9Kc2VwR2V0Tm9kZU5hbWU9cmUuWWEpKG4pO3ZhciBSaT0oKT0+KFJpPXJlLlphKSgpLEluPWwuX3B0aHJlYWRfc2VsZj0oKT0+KEluPWwuX3B0aHJlYWRfc2VsZj1yZS5fYSkoKSxHcj1sLl9tYWxsb2M9bj0+KEdyPWwuX21hbGxvYz1yZS4kYSkobiksSXQ9bC5fZnJlZT1uPT4oSXQ9bC5fZnJlZT1yZS5hYikobik7bC5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9KCk9PihsLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1yZS5iYikoKTt2YXIgQmk9bj0+KEJpPXJlLmNiKShuKTtsLl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3M9KCk9PihsLl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3M9cmUuZGIpKCk7dmFyIE1pPWwuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PShuLGQsaCx2LEksayk9PihNaT1sLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1yZS5mYikobixkLGgsdixJLGspO2wuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPSgpPT4obC5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9cmUuZ2IpKCk7dmFyIERpPShuLGQsaCx2KT0+KERpPXJlLmhiKShuLGQsaCx2KSwkYT1uPT4oJGE9cmUuaWIpKG4pLF9hPWwuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PW49PihfYT1sLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1yZS5qYikobiksemk9KCk9Pih6aT1yZS5rYikoKSxVaT0obixkKT0+KFVpPXJlLmxiKShuLGQpLFNhPSgpPT4oU2E9cmUubWIpKCksQW49bj0+KEFuPXJlLm5iKShuKSx4YT1uPT4oeGE9cmUub2IpKG4pLFdpPWwuZHluQ2FsbF9paT0obixkKT0+KFdpPWwuZHluQ2FsbF9paT1yZS5xYikobixkKSxOaT1uPT4oTmk9cmUucmIpKG4pLFZpPSgpPT4oVmk9cmUuc2IpKCksSGk9bj0+KEhpPXJlLnRiKShuKSxMaT0oKT0+KExpPXJlLnViKSgpO2wuX19fc3RhcnRfZW1fanM9OTU4ODcxLGwuX19fc3RvcF9lbV9qcz05NTkwMzI7ZnVuY3Rpb24gUmQoKXt2YXIgbj1yZTtuPU9iamVjdC5hc3NpZ24oe30sbik7dmFyIGQ9dj0+KCk9PnYoKT4+PjAsaD12PT5JPT52KEkpPj4+MDtyZXR1cm4gbi5aYT1kKG4uWmEpLG4uX2E9ZChuLl9hKSxuLiRhPWgobi4kYSksbi5jYj1oKG4uY2IpLG4uZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkPWQobi5lbXNjcmlwdGVuX21haW5fcnVudGltZV90aHJlYWRfaWQpLG4ubWI9ZChuLm1iKSxuLm9iPWgobi5vYiksbn1sLndhc21NZW1vcnk9YmUsbC5zdGFja0FsbG9jPXhhLGwuc3RhY2tTYXZlPVNhLGwuc3RhY2tSZXN0b3JlPUFuLGwua2VlcFJ1bnRpbWVBbGl2ZT0oKT0+MDxLZSxsLlVURjhUb1N0cmluZz1QZSxsLnN0cmluZ1RvVVRGOD1IdCxsLmxlbmd0aEJ5dGVzVVRGOD1ldCxsLkV4aXRTdGF0dXM9QXIsbC5QVGhyZWFkPWZlO3ZhciBUbjtZdD1mdW5jdGlvbiBuKCl7VG58fEdpKCksVG58fChZdD1uKX07ZnVuY3Rpb24gR2koKXtpZighKDA8TnQpKWlmKEUpZyhsKSxFfHxkcihNdCksc3RhcnRXb3JrZXIobCk7ZWxzZXtpZihsLnByZVJ1bilmb3IodHlwZW9mIGwucHJlUnVuPT1cImZ1bmN0aW9uXCImJihsLnByZVJ1bj1bbC5wcmVSdW5dKTtsLnByZVJ1bi5sZW5ndGg7KUJ0LnVuc2hpZnQobC5wcmVSdW4uc2hpZnQoKSk7ZHIoQnQpLDA8TnR8fFRufHwoVG49ITAsbC5jYWxsZWRSdW49ITAscGV8fChFfHxkcihNdCksZyhsKSxFfHxkcihLdCkpKX19cmV0dXJuIEdpKCksdC5yZWFkeX19KSgpO3R5cGVvZiBPbz09XCJvYmplY3RcIiYmdHlwZW9mIE1hPT1cIm9iamVjdFwiP01hLmV4cG9ydHM9RW86dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9PkVvKX0pO3ZhciBQbz1icigoem0sTGQpPT57TGQuZXhwb3J0cz0nXCJ1c2Ugc3RyaWN0XCI7dmFyIE1vZHVsZT17fSxFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIjtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXt2YXIgbm9kZVdvcmtlclRocmVhZHM9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLHBhcmVudFBvcnQ9bm9kZVdvcmtlclRocmVhZHMucGFyZW50UG9ydDtwYXJlbnRQb3J0Lm9uKFwibWVzc2FnZVwiLGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpO3ZhciBmcz1yZXF1aXJlKFwiZnNcIiksdm09cmVxdWlyZShcInZtXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlLE1vZHVsZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6bm9kZVdvcmtlclRocmVhZHMuV29ya2VyLGltcG9ydFNjcmlwdHM6ZT0+dm0ucnVuSW5UaGlzQ29udGV4dChmcy5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikse2ZpbGVuYW1lOmV9KSxwb3N0TWVzc2FnZTplPT5wYXJlbnRQb3J0LnBvc3RNZXNzYWdlKGUpLHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpEYXRlLm5vd319KX12YXIgaW5pdGlhbGl6ZWRKUz0hMTtmdW5jdGlvbiB0aHJlYWRQcmludEVycigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7ZnMud3JpdGVTeW5jKDIsZStgXFxuYCk7cmV0dXJufWNvbnNvbGUuZXJyb3IoZSl9ZnVuY3Rpb24gdGhyZWFkQWxlcnQoKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6ZSx0aHJlYWRJZDpNb2R1bGUuX3B0aHJlYWRfc2VsZigpfSl9dmFyIGVycj10aHJlYWRQcmludEVycjtzZWxmLmFsZXJ0PXRocmVhZEFsZXJ0LE1vZHVsZS5pbnN0YW50aWF0ZVdhc209KGUsdCk9Pnt2YXIgYT1Nb2R1bGUud2FzbU1vZHVsZTtNb2R1bGUud2FzbU1vZHVsZT1udWxsO3ZhciByPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShhLGUpO3JldHVybiB0KHIpfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbnx8ZX07ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShlKXt0cnl7aWYoZS5kYXRhLmNtZD09PVwibG9hZFwiKXtsZXQgYT1bXTtzZWxmLm9ubWVzc2FnZT1yPT5hLnB1c2gociksc2VsZi5zdGFydFdvcmtlcj1yPT57TW9kdWxlPXIscG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRlZFwifSk7Zm9yKGxldCBzIG9mIGEpaGFuZGxlTWVzc2FnZShzKTtzZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlfSxNb2R1bGUud2FzbU1vZHVsZT1lLmRhdGEud2FzbU1vZHVsZTtmb3IoY29uc3QgciBvZiBlLmRhdGEuaGFuZGxlcnMpTW9kdWxlW3JdPSguLi5zKT0+e3Bvc3RNZXNzYWdlKHtjbWQ6XCJjYWxsSGFuZGxlclwiLGhhbmRsZXI6cixhcmdzOnN9KX07aWYoTW9kdWxlLndhc21NZW1vcnk9ZS5kYXRhLndhc21NZW1vcnksTW9kdWxlLmJ1ZmZlcj1Nb2R1bGUud2FzbU1lbW9yeS5idWZmZXIsTW9kdWxlLkVOVklST05NRU5UX0lTX1BUSFJFQUQ9ITAsdHlwZW9mIGUuZGF0YS51cmxPckJsb2I9PVwic3RyaW5nXCIpaW1wb3J0U2NyaXB0cyhlLmRhdGEudXJsT3JCbG9iKTtlbHNle3ZhciB0PVVSTC5jcmVhdGVPYmplY3RVUkwoZS5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyh0KSxVUkwucmV2b2tlT2JqZWN0VVJMKHQpfW9ydFdhc21UaHJlYWRlZChNb2R1bGUpfWVsc2UgaWYoZS5kYXRhLmNtZD09PVwicnVuXCIpe01vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQoZS5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0KGUuZGF0YS5wdGhyZWFkX3B0ciksTW9kdWxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxNb2R1bGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIoZS5kYXRhKSxNb2R1bGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksaW5pdGlhbGl6ZWRKU3x8KGluaXRpYWxpemVkSlM9ITApO3RyeXtNb2R1bGUuaW52b2tlRW50cnlQb2ludChlLmRhdGEuc3RhcnRfcm91dGluZSxlLmRhdGEuYXJnKX1jYXRjaChhKXtpZihhIT1cInVud2luZFwiKXRocm93IGF9fWVsc2UgZS5kYXRhLmNtZD09PVwiY2FuY2VsXCI/TW9kdWxlLl9wdGhyZWFkX3NlbGYoKSYmTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6ZS5kYXRhLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCJ8fChlLmRhdGEuY21kPT09XCJjaGVja01haWxib3hcIj9pbml0aWFsaXplZEpTJiZNb2R1bGUuY2hlY2tNYWlsYm94KCk6ZS5kYXRhLmNtZCYmKGVycihgd29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke2UuZGF0YS5jbWR9YCksZXJyKGUuZGF0YSkpKX1jYXRjaChhKXt0aHJvdyBNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPy4oKSxhfX1zZWxmLm9ubWVzc2FnZT1oYW5kbGVNZXNzYWdlO1xcbid9KTt2YXIgQm8sR2QsRGEsemEsem4sUm8sRmQscWQsamQsTW8sTmUsdnI9USgoKT0+e1widXNlIHN0cmljdFwiO0JvPXhvKCk7R2Q9a28oKSx6YT0hMSx6bj0hMSxSbz0hMSxGZD1lPT57aWYoZT09PTEpcmV0dXJuITE7aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiB0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCYmY29uc29sZS53YXJuKFwiZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gXCIrZStcIiwgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuIFNlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby5cIiksITE7dHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSYmY29uc29sZS53YXJuKFwiZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gXCIrZStcIiwgaG93ZXZlciwgY3VycmVudGx5IG9ubnhydW50aW1lLXdlYiBkb2VzIG5vdCBzdXBwb3J0IG11bHRpLXRocmVhZHMgaW4gTm9kZS5qcy4gUGxlYXNlIGNvbnNpZGVyIHVzaW5nIG9ubnhydW50aW1lLW5vZGUgZm9yIHBlcmZvcm1hbmNlIGNyaXRpY2FsIHNjZW5hcmlvcy5cIik7dHJ5e3JldHVybiB0eXBlb2YgTWVzc2FnZUNoYW5uZWw8XCJ1XCImJm5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LHFkPSgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LGpkPShlLHQpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXNpbWQud2FzbVwiOnQ/XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCIsTW89YXN5bmMgZT0+e2lmKHphKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZih6bil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihSbyl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTt6bj0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LHI9ZS5udW1UaHJlYWRzLGE9ZS5zaW1kLGk9RmQocikscz1hJiZxZCgpLG89ZS53YXNtUGF0aHMsYz10eXBlb2Ygbz09XCJzdHJpbmdcIj9vOnZvaWQgMCxwPWpkKHMsaSksbT10eXBlb2Ygbz09XCJvYmplY3RcIj9vW3BdOnZvaWQgMCxsPSExLGc9W107aWYodD4wJiZnLnB1c2gobmV3IFByb21pc2UoYj0+e3NldFRpbWVvdXQoKCk9PntsPSEwLGIoKX0sdCl9KSksZy5wdXNoKG5ldyBQcm9taXNlKChiLHcpPT57bGV0ICQ9aT9HZDpCbyx4PXtsb2NhdGVGaWxlOihULEMpPT57aWYoaSYmVC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJnR5cGVvZiBCbG9iPFwidVwiKXJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtQbygpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpO2lmKFQuZW5kc1dpdGgoXCIud2FzbVwiKSl7aWYobSlyZXR1cm4gbTtsZXQgUz1jPz9DO3JldHVybiBwPT09XCJvcnQtd2FzbS1zaW1kLndhc21cIj9TK1wib3J0LXdhc20tc2ltZC5qc2VwLndhc21cIjpwPT09XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIj9TK1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIjpTK3B9cmV0dXJuIEMrVH19O2lmKGkpaWYoeC5udW1UaHJlYWRzPXIsdHlwZW9mIEJsb2I+XCJ1XCIpeC5tYWluU2NyaXB0VXJsT3JCbG9iPSh2b2lkIDApKF9fZGlybmFtZSxcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7bGV0IFQ9YHZhciBvcnRXYXNtVGhyZWFkZWQ9JHskLnRvU3RyaW5nKCl9O2A7eC5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFtUXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9JCh4KS50aGVuKFQ9Pnt6bj0hMSx6YT0hMCxEYT1ULGIoKX0sVD0+e3puPSExLFJvPSEwLHcoVCl9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UoZyksbCl0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LE5lPSgpPT57aWYoemEmJkRhKXJldHVybiBEYTt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX19KTt2YXIgVmUsanIsTWUsVW49USgoKT0+e1widXNlIHN0cmljdFwiO3ZyKCk7VmU9KGUsdCk9PntsZXQgcj1OZSgpLGE9ci5sZW5ndGhCeXRlc1VURjgoZSkrMSxpPXIuX21hbGxvYyhhKTtyZXR1cm4gci5zdHJpbmdUb1VURjgoZSxpLGEpLHQucHVzaChpKSxpfSxqcj0oZSx0LHIsYSk9PntpZih0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwpe2lmKHIuaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtpLHNdKT0+e2xldCBvPXQ/dCtpOmk7aWYodHlwZW9mIHM9PVwib2JqZWN0XCIpanIocyxvK1wiLlwiLHIsYSk7ZWxzZSBpZih0eXBlb2Ygcz09XCJzdHJpbmdcInx8dHlwZW9mIHM9PVwibnVtYmVyXCIpYShvLHMudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2Ygcz09XCJib29sZWFuXCIpYShvLHM/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHN9YCl9KX0sTWU9ZT0+e2xldCB0PU5lKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgYT10LnN0YWNrQWxsb2MoOCk7dC5fT3J0R2V0TGFzdEVycm9yKGEsYSs0KTtsZXQgaT10LkhFQVAzMlthLzRdLHM9dC5IRUFQVTMyW2EvNCsxXSxvPXM/dC5VVEY4VG9TdHJpbmcocyk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtpfSwgRVJST1JfTUVTU0FHRTogJHtvfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fX0pO3ZhciBEbyx6bz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dnIoKTtVbigpO0RvPWU9PntsZXQgdD1OZSgpLHI9MCxhPVtdLGk9ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApaS5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApaS5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihpLnRlcm1pbmF0ZT0hMSk7bGV0IHM9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYocz1WZShlLnRhZyxhKSkscj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKGkubG9nU2V2ZXJpdHlMZXZlbCxpLmxvZ1ZlcmJvc2l0eUxldmVsLCEhaS50ZXJtaW5hdGUscykscj09PTAmJk1lKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxlPy5leHRyYSE9PXZvaWQgMCYmanIoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChvLGMpPT57bGV0IHA9VmUobyxhKSxtPVZlKGMsYSk7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkocixwLG0pIT09MCYmTWUoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7b30gLSAke2N9LmApfSksW3IsYV19Y2F0Y2gocyl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKHIpLGEuZm9yRWFjaChvPT50Ll9mcmVlKG8pKSxzfX19KTt2YXIgS2QsWWQsWmQsWGQsVW8sV289USgoKT0+e1widXNlIHN0cmljdFwiO3ZyKCk7VW4oKTtLZD1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSxZZD1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0sWmQ9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKHI9Pih0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LFhkPShlLHQscik9Pntmb3IobGV0IGEgb2YgdCl7bGV0IGk9dHlwZW9mIGE9PVwic3RyaW5nXCI/YTphLm5hbWU7c3dpdGNoKGkpe2Nhc2VcIndlYm5uXCI6aWYoaT1cIldFQk5OXCIsdHlwZW9mIGEhPVwic3RyaW5nXCIpe2xldCBvPWE7aWYobz8uZGV2aWNlVHlwZSl7bGV0IGM9VmUoXCJkZXZpY2VUeXBlXCIscikscD1WZShvLmRldmljZVR5cGUscik7TmUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsYyxwKSE9PTAmJk1lKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHtvLmRldmljZVR5cGV9LmApfWlmKG8/Lm51bVRocmVhZHMpe2xldCBjPW8ubnVtVGhyZWFkczsodHlwZW9mIGMhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGMpfHxjPDApJiYoYz0wKTtsZXQgcD1WZShcIm51bVRocmVhZHNcIixyKSxtPVZlKGMudG9TdHJpbmcoKSxyKTtOZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxwLG0pIT09MCYmTWUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnbnVtVGhyZWFkcycgLSAke28ubnVtVGhyZWFkc30uYCl9aWYobz8ucG93ZXJQcmVmZXJlbmNlKXtsZXQgYz1WZShcInBvd2VyUHJlZmVyZW5jZVwiLHIpLHA9VmUoby5wb3dlclByZWZlcmVuY2Uscik7TmUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsYyxwKSE9PTAmJk1lKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3Bvd2VyUHJlZmVyZW5jZScgLSAke28ucG93ZXJQcmVmZXJlbmNlfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYoaT1cIkpTXCIsdHlwZW9mIGEhPVwic3RyaW5nXCIpe2xldCBvPWE7aWYobz8ucHJlZmVycmVkTGF5b3V0KXtpZihvLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZvLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7by5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGM9VmUoXCJwcmVmZXJyZWRMYXlvdXRcIixyKSxwPVZlKG8ucHJlZmVycmVkTGF5b3V0LHIpO05lKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGMscCkhPT0wJiZNZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHtvLnByZWZlcnJlZExheW91dH0uYCl9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7aX1gKX1sZXQgcz1WZShpLHIpO05lKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUscykhPT0wJiZNZShgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtpfS5gKX19LFVvPWU9PntsZXQgdD1OZSgpLHI9MCxhPVtdLGk9ZXx8e307WmQoaSk7dHJ5e2xldCBzPUtkKGkuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD8/XCJhbGxcIiksbz1ZZChpLmV4ZWN1dGlvbk1vZGU/P1wic2VxdWVudGlhbFwiKSxjPXR5cGVvZiBpLmxvZ0lkPT1cInN0cmluZ1wiP1ZlKGkubG9nSWQsYSk6MCxwPWkubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwfHxwPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtwfWApO2xldCBtPWkubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIobSl8fG08MHx8bT40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bX1gKTtsZXQgbD10eXBlb2YgaS5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP1ZlKGkub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxhKTowO2lmKHI9dC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMocywhIWkuZW5hYmxlQ3B1TWVtQXJlbmEsISFpLmVuYWJsZU1lbVBhdHRlcm4sbywhIWkuZW5hYmxlUHJvZmlsaW5nLDAsYyxwLG0sbCkscj09PTAmJk1lKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksaS5leGVjdXRpb25Qcm92aWRlcnMmJlhkKHIsaS5leGVjdXRpb25Qcm92aWRlcnMsYSksaS5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbZyxiXW9mIE9iamVjdC5lbnRyaWVzKGkuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiBnIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke2d9YCk7aWYodHlwZW9mIGIhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGIpfHxiPDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7Yn1gKTtsZXQgdz1WZShnLGEpO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShyLHcsYikhPT0wJiZNZShgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7Z30gLSAke2J9LmApfXJldHVybiBpLmV4dHJhIT09dm9pZCAwJiZqcihpLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKGcsYik9PntsZXQgdz1WZShnLGEpLCQ9VmUoYixhKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocix3LCQpIT09MCYmTWUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2d9IC0gJHtifS5gKX0pLFtyLGFdfWNhdGNoKHMpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMociksYS5mb3JFYWNoKG89PnQuX2ZyZWUobykpLHN9fX0pO3ZhciBVYSxwdCxLcixXbixZcixObixXYSx6ZT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VWE9ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHB0PWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxLcj1lPT5bdm9pZCAwLDQsMSwxLDIsMiw0LDgsdm9pZCAwLDEsMiw4LDQsOCx2b2lkIDAsdm9pZCAwLHZvaWQgMF1bZV0sV249ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxZcj1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sTm49ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJib29sXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwidWludDMyXCIsV2E9ZT0+e3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7ZX1gKX19fSk7dmFyIFpyLE5hPVEoKCk9PntcInVzZSBzdHJpY3RcIjtacj1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYodHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSl0cnl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0KHZvaWQgMCkoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldCByPSh2b2lkIDApKGUpLGE9W107Zm9yIGF3YWl0KGxldCBpIG9mIHIpYS5wdXNoKGkpO3JldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KGEpKX10aHJvdyB0fWVsc2V7bGV0IHQ9YXdhaXQgZmV0Y2goZSk7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX1gKTtsZXQgcj10LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksYT1yP3BhcnNlSW50KHIsMTApOjA7aWYoYTwxMDczNzQxODI0KXJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCB0LmFycmF5QnVmZmVyKCkpO3tpZighdC5ib2R5KXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9LCBubyByZXNwb25zZSBib2R5LmApO2xldCBpPXQuYm9keS5nZXRSZWFkZXIoKSxzO3RyeXtzPW5ldyBBcnJheUJ1ZmZlcihhKX1jYXRjaChjKXtpZihjIGluc3RhbmNlb2YgUmFuZ2VFcnJvcil7bGV0IHA9TWF0aC5jZWlsKGEvNjU1MzYpO3M9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpwLG1heGltdW06cH0pLmJ1ZmZlcn1lbHNlIHRocm93IGN9bGV0IG89MDtmb3IoOzspe2xldHtkb25lOmMsdmFsdWU6cH09YXdhaXQgaS5yZWFkKCk7aWYoYylicmVhaztsZXQgbT1wLmJ5dGVMZW5ndGg7bmV3IFVpbnQ4QXJyYXkocyxvLG0pLnNldChwKSxvKz1tfXJldHVybiBuZXcgVWludDhBcnJheShzLDAsYSl9fWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiBCbG9iP25ldyBVaW50OEFycmF5KGF3YWl0IGUuYXJyYXlCdWZmZXIoKSk6ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/ZTpuZXcgVWludDhBcnJheShlKX19KTt2YXIgUWQsSmQsTm8sVm8sSG8sZWMsRGUscXQ9USgoKT0+e1widXNlIHN0cmljdFwiO3plKCk7UWQ9W1wiVlwiLFwiSVwiLFwiV1wiLFwiRVwiLFwiRlwiXSxKZD0oZSx0KT0+e2NvbnNvbGUubG9nKGBbJHtRZFtlXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7dH1gKX0sSG89KGUsdCk9PntObz1lLFZvPXR9LGVjPShlLHQpPT57bGV0IHI9WXIoZSksYT1ZcihObyk7cj49YSYmSmQocix0eXBlb2YgdD09XCJmdW5jdGlvblwiP3QoKTp0KX0sRGU9KC4uLmUpPT57Vm8mJmVjKC4uLmUpfX0pO3ZhciBMbyxHbz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtMbz0oZSx0KT0+bmV3KFduKHQpKShlKX0pO3ZhciBWbj1RKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgSG4sdGMsRm8sSGEsVmEsam8sS289USgoKT0+e1widXNlIHN0cmljdFwiO3F0KCk7Vm4oKTtIbj1lPT5NYXRoLmNlaWwoZS8xNikqMTYsdGM9MSxGbz0oKT0+dGMrKyxIYT1hc3luYyhlLHQscixhKT0+e2xldCBpPUhuKHIpLHM9ZS5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOmksdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR9KTt0cnl7bGV0IG89ZS5nZXRDb21tYW5kRW5jb2RlcigpO2UuZW5kQ29tcHV0ZVBhc3MoKSxvLmNvcHlCdWZmZXJUb0J1ZmZlcih0LDAscywwLGkpLGUuZmx1c2goKSxhd2FpdCBzLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7bGV0IGM9cy5nZXRNYXBwZWRSYW5nZSgpO2lmKGEpe2xldCBwPWEoKTtyZXR1cm4gcC5zZXQobmV3IFVpbnQ4QXJyYXkoYywwLHIpKSxwfWVsc2UgcmV0dXJuIG5ldyBVaW50OEFycmF5KGMuc2xpY2UoMCxyKSl9ZmluYWxseXtzLmRlc3Ryb3koKX19LFZhPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZz1bXSx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuZXh0ZXJuYWxCdWZmZXJzPW5ldyBNYXB9dXBsb2FkKHQscil7bGV0IGE9ci5idWZmZXIsaT1yLmJ5dGVPZmZzZXQscz1yLmJ5dGVMZW5ndGgsbz1IbihzKSxjPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKGMub3JpZ2luYWxTaXplIT09cyl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtjLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke3N9YCk7bGV0IHA9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTpvLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLG09cC5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KG0pLnNldChuZXcgVWludDhBcnJheShhLGkscykpLHAudW5tYXAoKTtsZXQgbD10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxsLmNvcHlCdWZmZXJUb0J1ZmZlcihwLDAsYy5ncHVEYXRhLmJ1ZmZlciwwLG8pLERlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7dH0pYCksdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZy5wdXNoKHApfW1lbWNweSh0LHIpe2xldCBhPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtsZXQgaT10aGlzLnN0b3JhZ2VDYWNoZS5nZXQocik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtpZihhLm9yaWdpbmFsU2l6ZSE9PWkub3JpZ2luYWxTaXplKXRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemVcIik7bGV0IHM9SG4oYS5vcmlnaW5hbFNpemUpLG89dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksby5jb3B5QnVmZmVyVG9CdWZmZXIoYS5ncHVEYXRhLmJ1ZmZlciwwLGkuZ3B1RGF0YS5idWZmZXIsMCxzKX1yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQscixhKXtsZXQgaTtpZihhKXtpZihpPXRoaXMuZXh0ZXJuYWxCdWZmZXJzLmdldChhKSxpPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGJ1ZmZlciBpcyBub3QgcmVnaXN0ZXJlZFwiKTtpZih0PT09YSlyZXR1cm4gRGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtpfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLGk7dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKGEpfWVsc2UgaT1GbygpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoaSx7Z3B1RGF0YTp7aWQ6aSx0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpyfSksdGhpcy5leHRlcm5hbEJ1ZmZlcnMuc2V0KHQsaSksRGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtpfSwgcmVnaXN0ZXJlZC5gKSxpfXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXtsZXQgcj10aGlzLmV4dGVybmFsQnVmZmVycy5nZXQodCk7ciE9PXZvaWQgMCYmKHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShyKSx0aGlzLmV4dGVybmFsQnVmZmVycy5kZWxldGUodCksRGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke3J9YCkpfWNyZWF0ZSh0LHI9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7bGV0IGE9SG4odCksaSxzPShyJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSxvPShyJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtpZihzfHxvKXtsZXQgcD1zP3RoaXMuZnJlZUJ1ZmZlcnM6dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMsbT1wLmdldChhKTttfHwobT1bXSxwLnNldChhLG0pKSxtLmxlbmd0aD4wP2k9bS5wb3AoKTppPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOmEsdXNhZ2U6cn0pfWVsc2UgaT10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTphLHVzYWdlOnJ9KTtsZXQgYz17aWQ6Rm8oKSx0eXBlOjAsYnVmZmVyOml9O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoYy5pZCx7Z3B1RGF0YTpjLG9yaWdpbmFsU2l6ZTp0fSksRGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3R9KSA9PiBpZD0ke2MuaWR9YCksY31nZXQodCl7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KT8uZ3B1RGF0YX1yZWxlYXNlKHQpe2xldCByPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdFwiKTtyZXR1cm4gRGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7dH0pLCBncHVEYXRhSWQ9JHtyLmdwdURhdGEuaWR9YCksdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaChyLmdwdURhdGEuYnVmZmVyKSxyLm9yaWdpbmFsU2l6ZX1hc3luYyBkb3dubG9hZCh0LHIpe2xldCBhPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2F3YWl0IEhhKHRoaXMuYmFja2VuZCxhLmdwdURhdGEuYnVmZmVyLGEub3JpZ2luYWxTaXplLHIpfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nKXQuZGVzdHJveSgpO3RoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc9W107Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFP3RoaXMuZnJlZUJ1ZmZlcnMuZ2V0KHQuc2l6ZSkucHVzaCh0KToodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0/dGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KHQuc2l6ZSkucHVzaCh0KTp0LmRlc3Ryb3koKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfWRpc3Bvc2UoKXt0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2godD0+e3QuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcH19LGpvPSguLi5lKT0+bmV3IFZhKC4uLmUpfSk7dmFyIExhLHhlLFhlPVEoKCk9PntcInVzZSBzdHJpY3RcIjtMYT1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMua2V5fHwodGhpcy5rZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLmtleX19LHhlPWU9Pm5ldyBMYShlKX0pO3ZhciBHYSxBdCxOLG9yLExuLEduLEZuLENlPVEoKCk9PntcInVzZSBzdHJpY3RcIjtHYT1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQscil7cmV0dXJuIHRbMV0hPT1yWzBdP3ZvaWQgMDpbdFswXSxyWzFdXX19LEF0PWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxyLGE9ITEpe2xldCBpPXQubGVuZ3RoLHM9ci5sZW5ndGg7aWYoaT09PTApcmV0dXJuIHI7aWYocz09PTApcmV0dXJuIHQ7bGV0IG89TWF0aC5tYXgodC5sZW5ndGgsci5sZW5ndGgpLGM9bmV3IEFycmF5KG8pO2lmKGEpe2lmKGk8Mnx8czwyKXJldHVybjtsZXQgcD1HYS5jYWxjTWF0TXVsU2hhcGUoW3RbaS0yXSx0W2ktMV1dLFtyW3MtMl0scltzLTFdXSk7aWYocD09PXZvaWQgMClyZXR1cm47W2Nbby0yXSxjW28tMV1dPXB9Zm9yKGxldCBwPWE/MzoxO3A8PW87cCsrKXtsZXQgbT1pLXA8MD8xOnRbaS1wXSxsPXMtcDwwPzE6cltzLXBdO2lmKG0hPT1sJiZtPjEmJmw+MSlyZXR1cm47Y1tvLXBdPU1hdGgubWF4KG0sbCl9cmV0dXJuIGN9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxyKXtsZXQgYT10Lmxlbmd0aCxpPXIubGVuZ3RoO2lmKGE+aSlyZXR1cm4hMTtmb3IobGV0IHM9MTtzPD1hO3MrKylpZih0W2Etc10hPT0xJiZ0W2Etc10hPT1yW2ktc10pcmV0dXJuITE7cmV0dXJuITB9fSxOPWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscix0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAscil9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLGEpe2xldCBpPTE7Zm9yKGxldCBzPXI7czxhO3MrKyl7aWYodFtzXTwwKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7aSo9dFtzXX1yZXR1cm4gaX1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IHI9dC5sZW5ndGg7aWYocj09PTApcmV0dXJuW107aWYocj09PTEpcmV0dXJuWzFdO2xldCBhPW5ldyBBcnJheShyKTthW3ItMV09MSxhW3ItMl09dFtyLTFdO2ZvcihsZXQgaT1yLTM7aT49MDstLWkpYVtpXT1hW2krMV0qdFtpKzFdO3JldHVybiBhfXN0YXRpYyBub3JtYWxpemVBeGlzKHQscil7aWYodDwtciYmdD49cil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K3I6dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LHIpe3JldHVybiB0Lm1hcChhPT50aGlzLm5vcm1hbGl6ZUF4aXMoYSxyPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxyKXtyZXR1cm4gcj9yLm1hcChhPT50W2FdKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LHIpe2xldCBhPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgoaSxzKT0+aStyW3NdK3JbcythXSl9c3RhdGljIGFyZUVxdWFsKHQscil7cmV0dXJuIHQubGVuZ3RoIT09ci5sZW5ndGg/ITE6dC5ldmVyeSgoYSxpKT0+YT09PXJbaV0pfX0sb3I9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxyLGEsaSxzLG8pe2lmKCF0JiZhLmxlbmd0aCE9PXIubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgYz0wO2M8ci5sZW5ndGgtMjtjKyspYz49YS5sZW5ndGg/YS5wdXNoKHJbYysyXSk6YVtjXT1yW2MrMl07Zm9yKGxldCBjPTA7YzxhLmxlbmd0aDtjKyspaWYoYzxpLmxlbmd0aCl7aWYoaVtjXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgaS5wdXNoKDEpO2ZvcihsZXQgYz0wO2M8YS5sZW5ndGg7YysrKWlmKGM8cy5sZW5ndGgpe2lmKHNbY108MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugcy5wdXNoKDEpO2ZvcihsZXQgYz0wO2M8YS5sZW5ndGgqMjtjKyspaWYoYzxvLmxlbmd0aCl7aWYob1tjXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBvLnB1c2goMCk7Zm9yKGxldCBjPTA7YzxhLmxlbmd0aDtjKyspe2lmKGFbY108PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKG9bY10+PWFbY118fG9bYythLmxlbmd0aF0+PWFbY10pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LHIsYSxpLHMsbyxjKXtpZihjKXtpZihzLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKGkubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBwPTA7cDx0Lmxlbmd0aC0yO3ArKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbcCsobz8xOjIpXSxyW3BdLGFbcF0saVtwXSxzLHAscCt0Lmxlbmd0aC0yLGMpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LHIsYSxpLHMsbyxjKXtpZihyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IHA9W3JbMF0sclsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQscixwLGEsaSxzLG8sYykscH1zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LHIsYSxpLHMsbyxjKXtpZih0Lmxlbmd0aDw9MHx8ci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgcD1bdFswXSxyWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxwLGEsaSxzLG8sYykscH1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQscixhLGkscyxvLGMscCl7aWYodClmb3IobGV0IG09MDttPHIubGVuZ3RoLTI7bSsrKWEucHVzaCgxKTtlbHNlIGZvcihsZXQgbT0wO208ci5sZW5ndGgtMjttKyspYS5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoclttKzJdLGlbbV0sc1ttXSxvW21dLGMsbSxtK3IubGVuZ3RoLTIscCkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LHIsYSxpLHMsbyxjLHApe2xldCBtPWEqKGktMSkrMTtpZihwJiZwIT09XCJOT1RTRVRcIilzd2l0Y2gocCl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gc1tvXT0wLHNbY109MCxNYXRoLmZsb29yKCh0LW0pL3IrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihhIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCBnPSgodCtyLTEpL3ItMSkqcitpLXQ7cmV0dXJuIHNbb109TWF0aC5mbG9vcihwPT09XCJTQU1FX0xPV0VSXCI/KGcrMSkvMjpnLzIpLHNbY109Zy1zW29dLE1hdGguZmxvb3IoKHQrZy1pKS9yKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQrc1tvXStzW2NdLW0pL3IrMSl9fSxMbj1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxyLGEsaSxzKXtpZih0Lmxlbmd0aCE9PTJ8fGEubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgbyxjLHA7cj8obz10WzFdLGM9dFswXSk6KG89dFswXSxjPXRbMV0pO2xldCBtPS0xO2lmKGk/KHA9YVswXSxtPTEpOihwPWFbMV0sbT0wKSxhW21dIT09Yyl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYobzw9MHx8cDw9MHx8Yzw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihzJiYhQXQuaXNWYWxpZEJyb2FkY2FzdChzLFtvLHBdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bbyxwLGNdfX0sR249LTM0MDI4MjM0NjYzODUyODg2ZTIyLEZuPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIHJjLHFhLEhlLF90LEwsTGUsUWUsU3QsZnQsY2UsamEsVyxKLHFuLEZhLFlvLHdyLF9lPVEoKCk9PntcInVzZSBzdHJpY3RcIjt6ZSgpO0NlKCk7cmM9NjQscWE9KGUsdCk9PntpZih0PT09Myl0aHJvdyBuZXcgRXJyb3IoXCJ2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkXCIpO3N3aXRjaChlKXtjYXNlIDEwOnJldHVybiB0PjE/YHZlYyR7dH08ZjE2PmA6XCJmMTZcIjtjYXNlIDE6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMzI+YDpcImYzMlwiO2Nhc2UgNjpyZXR1cm4gdD4xP2B2ZWMke3R9PGkzMj5gOlwiaTMyXCI7Y2FzZSAxMjpyZXR1cm4gdD4xP2B2ZWMke3R9PHUzMj5gOlwidTMyXCI7Y2FzZSA3OmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJpMzJcIl07Y2FzZSAxMzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwidTMyXCJdO2Nhc2UgOTppZih0IT09NCl0aHJvdyBuZXcgRXJyb3IoXCJib29sIG11c3QgYmUgdmVjNFwiKTtyZXR1cm5bXCJ1MzJcIixcInZlYzQ8Ym9vbD5cIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxIZT0oZSx0PTEpPT57bGV0IHI9cWEoZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzBdfSxfdD0oZSx0PTEpPT57bGV0IHI9cWEoZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzFdfSxMPWU9PmUubGVuZ3RoPT09MD9bXTpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOmV9LHt0eXBlOlwidWludDMyXCIsZGF0YTpOLmNvbXB1dGVTdHJpZGVzKGUpfV0sTGU9ZT0+ZSU0PT09MD80OmUlMj09PTA/MjoxLFFlPShlPVwiZjMyXCIsdCxyPVwiMFwiKT0+IXR8fHQ9PT0xP2Ake2V9KCR7cn0pYDpgdmVjJHt0fTwke2V9Pigke3J9KWAsU3Q9KGUsdCxyKT0+ZT09PVwiZjMyXCI/cjp0PT09MT9gZjMyKCR7cn0pYDpgdmVjJHt0fWYoJHtyfSlgLGZ0PShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLGNlPShlLHQscixhKT0+ZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZyPjQ/dHlwZW9mIHQ9PVwic3RyaW5nXCI/YT09PVwiZjE2XCI/YCR7ZX1bKCR7dH0pIC8gOF1bKCR7dH0pICUgOCAvIDRdWygke3R9KSAlIDggJSA0XWA6YCR7ZX1bKCR7dH0pIC8gNF1bKCR7dH0pICUgNF1gOmE9PT1cImYxNlwiP2Ake2V9WyR7TWF0aC5mbG9vcih0LzgpfV1bJHtNYXRoLmZsb29yKHQlOC80KX1dWyR7dCU4JTR9XWA6YCR7ZX1bJHtNYXRoLmZsb29yKHQvNCl9XVske3QlNH1dYDpyPjE/YCR7ZX1bJHt0fV1gOmUsamE9KGUsdCxyLGEsaSk9PntsZXQgcz10eXBlb2Ygcj09XCJudW1iZXJcIixvPXM/cjpyLmxlbmd0aCxjPVsuLi5uZXcgQXJyYXkobykua2V5cygpXSxwPW88Mj9cInUzMlwiOm88PTQ/YHZlYyR7b308dTMyPmA6YGFycmF5PHUzMiwgJHtvfT5gLG09cWEodCxpKSxsPXR5cGVvZiBtPT1cInN0cmluZ1wiP206bVsxXSxnPXR5cGVvZiBtPT1cInN0cmluZ1wiP206bVswXSxiPXtpbmRpY2VzOnAsdmFsdWU6bCxzdG9yYWdlOmcsdGVuc29yOnR9LHc9Rj0+dHlwZW9mIEY9PVwic3RyaW5nXCI/RjpgJHtGfXVgLCQ9e29mZnNldFRvSW5kaWNlczohMSxpbmRpY2VzVG9PZmZzZXQ6ITEsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ITEsc2V0OiExLHNldEJ5SW5kaWNlczohMSxnZXQ6ITEsZ2V0QnlJbmRpY2VzOiExfSx4PXM/XCJ1bmlmb3Jtcy5cIjpcIlwiLFQ9YCR7eH0ke2V9X3NoYXBlYCxDPWAke3h9JHtlfV9zdHJpZGVzYCxTPVwiXCI7Zm9yKGxldCBGPTA7RjxvLTE7RisrKVMrPWBcbiAgICBsZXQgZGltJHtGfSA9IGN1cnJlbnQgLyAke2NlKEMsRixvKX07XG4gICAgbGV0IHJlc3Qke0Z9ID0gY3VycmVudCAlICR7Y2UoQyxGLG8pfTtcbiAgICBpbmRpY2VzWyR7Rn1dID0gZGltJHtGfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7Rn07XG4gICAgYDtTKz1gaW5kaWNlc1ske28tMX1dID0gY3VycmVudDtgO2xldCBFPW88Mj9cIlwiOmBcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7Yi5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7Yi5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke1N9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gLE89Rj0+KCQub2Zmc2V0VG9JbmRpY2VzPSEwLG88Mj9GOmBvMmlfJHtlfSgke0Z9KWApLFU9W107aWYobz49Milmb3IobGV0IEY9by0xO0Y+PTA7Ri0tKVUucHVzaChgJHtjZShDLEYsbyl9ICogKGluZGljZXNbJHtGfV0pYCk7bGV0IEQ9bzwyP1wiXCI6YFxuICBmbiBpMm9fJHtlfShpbmRpY2VzOiAke2IuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgcmV0dXJuICR7VS5qb2luKFwiK1wiKX07XG4gIH1gLFY9Rj0+KCQuaW5kaWNlc1RvT2Zmc2V0PSEwLG88Mj9GOmBpMm9fJHtlfSgke0Z9KWApLFk9KC4uLkYpPT5vPT09MD9cIjB1XCI6YCR7Yi5pbmRpY2VzfSgke0YubWFwKHcpLmpvaW4oXCIsXCIpfSlgLHNlPShGLGllKT0+bzwyP2Ake0Z9YDpgJHtjZShGLGllLG8pfWAsQj0oRixpZSxoZSk9Pm88Mj9gJHtGfT0ke2hlfTtgOmAke2NlKEYsaWUsbyl9PSR7aGV9O2AsdGU9e30sa2U9KEYsaWUpPT57JC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgaGU9YCR7aWUubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKGhlIGluIHRlKXJldHVybmAke2hlfSgke0Z9KWA7bGV0IEplPVtdO2ZvcihsZXQgb3Q9by0xO290Pj0wO290LS0pe2xldCBSZT1pZS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLG90K2llLnJhbmstbyk7SmUucHVzaChgJHtzZShDLG90KX0gKiAoJHtSZX0gJSAke3NlKFQsb3QpfSlgKX1yZXR1cm4gdGVbaGVdPWBmbiAke2hlfShvdXRwdXRJbmRpY2VzOiAke2llLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICAgcmV0dXJuICR7SmUubGVuZ3RoPjA/SmUuam9pbihcIitcIik6XCIwdVwifTtcbiAgICAgICAgICAgfWAsYCR7aGV9KCR7Rn0pYH0sT2U9KEYsaWUpPT4oKCk9PntpZihiLnN0b3JhZ2U9PT1iLnZhbHVlKXJldHVybmAke2V9WyR7Rn1dPSR7aWV9O2A7aWYoYi5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmYi52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYCR7ZX1bJHtGfV09dmVjMjx1MzI+KHUzMigke2llfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7aWV9IDwgMCkpO2A7aWYoYi5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmYi52YWx1ZT09PVwidTMyXCIpcmV0dXJuYCR7ZX1bJHtGfV09dmVjMjx1MzI+KHUzMigke2llfSksIDB1KTtgO2lmKGIuc3RvcmFnZT09PVwidTMyXCImJmIudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gJHtlfVske0Z9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke2llfSkpO2A7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2Iuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtiLnZhbHVlfSB5ZXRgKX0pKCksZWU9Rj0+KCgpPT57aWYoYi5zdG9yYWdlPT09Yi52YWx1ZSlyZXR1cm5gJHtlfVske0Z9XWA7aWYoYi5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmYi52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYGkzMigke2V9WyR7Rn1dLngpYDtpZihiLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZiLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gdTMyKCR7ZX1bJHtGfV0ueClgO2lmKGIuc3RvcmFnZT09PVwidTMyXCImJmIudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gdmVjNDxib29sPihib29sKCR7ZX1bJHtGfV0gJiAweEZGdSksIGJvb2woJHtlfVske0Z9XSAmIDB4RkYwMHUpLCBib29sKCR7ZX1bJHtGfV0gJiAweEZGMDAwMHUpLCBib29sKCR7ZX1bJHtGfV0gJiAweEZGMDAwMDAwdSkpYDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7Yi5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2IudmFsdWV9IHlldGApfSkoKSxiZT1vPDI/XCJcIjpgXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7Yi5pbmRpY2VzfSkgLT4gJHtsfSB7XG4gICAgcmV0dXJuICR7ZWUoYGkyb18ke2V9KGluZGljZXMpYCl9O1xuICB9YCxVZT1vPDI/XCJcIjooKCk9PntsZXQgRj1jLm1hcChoZT0+YGQke2hlfTogdTMyYCkuam9pbihcIiwgXCIpLGllPWMubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gZ2V0XyR7ZX0oJHtGfSkgLT4gJHtsfSB7XG4gICAgcmV0dXJuIGdldF8ke2V9QnlJbmRpY2VzKCR7WShpZSl9KTtcbiAgfWB9KSgpLHBlPSguLi5GKT0+e2lmKEYubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtvfWApO2xldCBpZT1GLm1hcCh3KS5qb2luKFwiLFwiKTtyZXR1cm4gbz09PTA/ZWUoXCIwdVwiKTpvPT09MT9lZShpZVswXSk6KCQuZ2V0PSEwLCQuZ2V0QnlJbmRpY2VzPSEwLCQuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfSgke2llfSlgKX0seWU9Rj0+bzwyP2VlKEYpOigkLmdldEJ5SW5kaWNlcz0hMCwkLmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX1CeUluZGljZXMoJHtGfSlgKSxkZT1vPDI/XCJcIjpgXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7Yi5pbmRpY2VzfSwgdmFsdWU6ICR7bH0pIHtcbiAgICAke09lKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cbiAgfWAsdmU9bzwyP1wiXCI6KCgpPT57bGV0IEY9Yy5tYXAoaGU9PmBkJHtoZX06IHUzMmApLmpvaW4oXCIsIFwiKSxpZT1jLm1hcChoZT0+YGQke2hlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIHNldF8ke2V9KCR7Rn0sIHZhbHVlOiAke2x9KSB7XG4gICAgc2V0XyR7ZX1CeUluZGljZXMoJHtZKGllKX0sIHZhbHVlKTtcbiAgfWB9KSgpO3JldHVybntpbXBsOigpPT57bGV0IEY9W10saWU9ITE7cmV0dXJuICQub2Zmc2V0VG9JbmRpY2VzJiYoRi5wdXNoKEUpLGllPSEwKSwkLmluZGljZXNUb09mZnNldCYmKEYucHVzaChEKSxpZT0hMCksJC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCYmKE9iamVjdC52YWx1ZXModGUpLmZvckVhY2goaGU9PkYucHVzaChoZSkpLGllPSEwKSwkLnNldCYmKEYucHVzaCh2ZSksaWU9ITApLCQuc2V0QnlJbmRpY2VzJiYoRi5wdXNoKGRlKSxpZT0hMCksJC5nZXQmJihGLnB1c2goVWUpLGllPSEwKSwkLmdldEJ5SW5kaWNlcyYmKEYucHVzaChiZSksaWU9ITApLCFzJiZpZSYmRi51bnNoaWZ0KGBjb25zdCAke1R9ID0gJHtiLmluZGljZXN9KCR7ci5qb2luKFwiLFwiKX0pO2AsYGNvbnN0ICR7Q30gPSAke2IuaW5kaWNlc30oJHtOLmNvbXB1dGVTdHJpZGVzKHIpLmpvaW4oXCIsXCIpfSk7YCksRi5qb2luKGBcbmApfSx0eXBlOmIsb2Zmc2V0VG9JbmRpY2VzOk8saW5kaWNlc1RvT2Zmc2V0OlYsYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6a2UsaW5kaWNlczpZLGluZGljZXNHZXQ6c2UsaW5kaWNlc1NldDpCLHNldDooLi4uRik9PntpZihGLmxlbmd0aCE9PW8rMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtvfWApO2xldCBpZT1GW29dO2lmKHR5cGVvZiBpZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgaGU9Ri5zbGljZSgwLG8pLm1hcCh3KS5qb2luKFwiLFwiKTtyZXR1cm4gbz09PTA/T2UoXCIwdVwiLGllKTpvPT09MT9PZShoZVswXSxpZSk6KCQuc2V0PSEwLCQuc2V0QnlJbmRpY2VzPSEwLCQuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke2hlfSwgJHtpZX0pYCl9LHNldEJ5T2Zmc2V0Ok9lLHNldEJ5SW5kaWNlczooRixpZSk9Pm88Mj9PZShGLGllKTooJC5zZXRCeUluZGljZXM9ITAsJC5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7Rn0sICR7aWV9KTtgKSxnZXQ6cGUsZ2V0QnlPZmZzZXQ6ZWUsZ2V0QnlJbmRpY2VzOnllLHVzYWdlOmEsbmFtZTplLHN0cmlkZXM6QyxzaGFwZTpULHJhbms6b319LFc9KGUsdCxyLGE9MSk9PmphKGUsdCxyLFwiaW5wdXRcIixhKSxKPShlLHQscixhPTEpPT5qYShlLHQscixcIm91dHB1dFwiLGEpLHFuPShlLHQscixhPTEpPT5qYShlLHQscixcImludGVybmFsXCIsYSksRmE9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cD10O3RoaXMuaW50ZXJuYWxWYXJpYWJsZXM9W107dGhpcy52YXJpYWJsZXM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD1yYyl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLGE9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLGk9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdLHM9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLG89cz9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmA6YEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgbnVtX3dvcmtncm91cHMgOiB2ZWMzPHUzMj5gLGM9cz9cImxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7IGxldCBsb2NhbF9pZHggPSBsb2NhbF9pZC54O1wiOmBsZXQgZ2xvYmFsX2lkeCA9ICh3b3JrZ3JvdXBfaWQueiAqIG51bV93b3JrZ3JvdXBzWzBdICogbnVtX3dvcmtncm91cHNbMV0gK1xuICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueCkgKiAke3IqYSppfXUgKyBsb2NhbF9pZHg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7cn0sICR7YX0sICR7aX0pXG4gIGZuIG1haW4oJHtvfSkge1xuICAgICR7Y31cbiAgYH1hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpe3QucmFuayE9PTAmJih0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pKX1kZWNsYXJlVmFyaWFibGUodCxyKXtpZih0LnVzYWdlPT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLnZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KTtsZXQgYT10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLGk9dC50eXBlLnN0b3JhZ2U7cmV0dXJuYEBncm91cCgwKSBAYmluZGluZygke3J9KSB2YXI8c3RvcmFnZSwgJHthfT4gJHt0Lm5hbWV9OiBhcnJheTwke2l9PjtgfWRlY2xhcmVWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQubWFwKHI9PnRoaXMuZGVjbGFyZVZhcmlhYmxlKHIsdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKGBcbmApfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh0KXtpZih0LnVzYWdlIT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW5wdXQgb3Igb3V0cHV0IHZhcmlhYmxlIHdpdGggcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKCkuIHVzZSBkZWNsYXJlVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KX1yZWdpc3RlckludGVybmFsVmFyaWFibGVzKC4uLnQpe3JldHVybiB0LmZvckVhY2gocj0+dGhpcy5yZWdpc3RlckludGVybmFsVmFyaWFibGUocikpLHRoaXN9cmVnaXN0ZXJVbmlmb3JtKHQscixhPTEpe3JldHVybiB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dCx0eXBlOnIsbGVuZ3RoOmF9KSx0aGlzfXJlZ2lzdGVyVW5pZm9ybXModCl7cmV0dXJuIHRoaXMudW5pZm9ybXM9dGhpcy51bmlmb3Jtcy5jb25jYXQodCksdGhpc311bmlmb3JtRGVjbGFyYXRpb24oKXtpZih0aGlzLnVuaWZvcm1zLmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgdD1bXTtmb3IobGV0e25hbWU6cix0eXBlOmEsbGVuZ3RoOml9b2YgdGhpcy51bmlmb3JtcylpZihpJiZpPjQpYT09PVwiZjE2XCI/dC5wdXNoKGBAYWxpZ24oMTYpICR7cn06YXJyYXk8bWF0Mng0PCR7YX0+LCAke01hdGguY2VpbChpLzgpfT5gKTp0LnB1c2goYCR7cn06YXJyYXk8dmVjNDwke2F9PiwgJHtNYXRoLmNlaWwoaS80KX0+YCk7ZWxzZXtsZXQgcz1pPT1udWxsfHxpPT09MT9hOmB2ZWMke2l9PCR7YX0+YDt0LnB1c2goYCR7cn06JHtzfWApfXJldHVybmBcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dC5qb2luKFwiLCBcIil9IH07XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2B9Z2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKXtyZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSt0aGlzLnZhcmlhYmxlcy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxuYCkrdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxuYCl9fSxZbz1lPT5uZXcgRmEoZSksd3I9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxhPVtdO2ZvcihsZXQgaT0wO2k8cjtpKyspe2xldCBzPXItMS1pLG89ZVtzXXx8MTsodFt0Lmxlbmd0aC0xLWldfHwxKT4xJiZvPT09MSYmYS51bnNoaWZ0KHMpfXJldHVybiBhfX0pO3ZhciBuYyxabyxhYyxpYyx4dCxYbyxRbywkcj1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtYZSgpO19lKCk7bmM9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxabz0oZSx0KT0+dCYmdC5sZW5ndGghPT1lP1suLi5uZXcgQXJyYXkoZSkua2V5cygpXS5yZXZlcnNlKCk6dCxhYz0oZSx0KT0+Ti5zb3J0QmFzZWRPblBlcm0oZSxabyhlLmxlbmd0aCx0KSksaWM9KGUsdCxyLGEpPT57bGV0IGk9W107aS5wdXNoKGBmbiBwZXJtKGk6ICR7YS50eXBlLmluZGljZXN9KSAtPiAke3IudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2ApO2ZvcihsZXQgcz0wO3M8dDsrK3MpaS5wdXNoKHIuaW5kaWNlc1NldChcImFcIixlW3NdLGBpWyR7c31dYCkpO3JldHVybiBpLnB1c2goXCJyZXR1cm4gYTt9XCIpLGkuam9pbihgXG5gKX0seHQ9KGUsdCk9PntsZXQgcj1lLmRhdGFUeXBlLGE9ZS5kaW1zLmxlbmd0aCxpPVpvKGEsdCkscz1hYyhlLmRpbXMsaSksbz1KKFwib3V0cHV0XCIscixzLmxlbmd0aCksYz1XKFwiYVwiLHIsYSkscD1tPT5gXG4gICR7bS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYyxvKX1cblxuICAke2ljKGksYSxjLG8pfVxuXG4gICR7bS5tYWluU3RhcnQoKX1cbiAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke28ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7by5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixjLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWA7cmV0dXJue25hbWU6XCJUcmFuc3Bvc2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTptPT57bGV0IGw9Ti5zaXplKHMpO3JldHVybntvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOm1bMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6bH0sLi4uTChtWzBdLmRpbXMpLC4uLkwocyldfX0sZ2V0U2hhZGVyU291cmNlOnB9fSxYbz0oZSx0KT0+e25jKGUuaW5wdXRzKSxlLmNvbXB1dGUoeHQoZS5pbnB1dHNbMF0sdC5wZXJtKSl9LFFvPWU9PnhlKHtwZXJtOmUucGVybX0pfSk7dmFyIG9jLHNjLHVjLGxjLGRjLGNjLHBjLGZjLG1jLGhjLFR0LEpvLGVzLHRzLHJzLG5zLGFzLGlzLG9zLHNzLHVzLGxzPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO19lKCk7am4oKTskcigpO29jPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGV4cChjYW5kaWRhdGUpXCIsbDE6XCJiZXN0VmFsdWUgKyBhYnMoY2FuZGlkYXRlKVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LHNjPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwxOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0sdWM9e21heDpcIl9BW29mZnNldF1cIixtaW46XCJfQVtvZmZzZXRdXCIsbWVhbjpcIjBcIixzdW06XCIwXCIscHJvZDpcIjFcIixzdW1TcXVhcmU6XCIwXCIsbG9nU3VtRXhwOlwiMFwiLGwxOlwiMFwiLGwyOlwiMFwiLGxvZ1N1bTpcIjBcIn0sbGM9e21heDpcImJlc3RWYWx1ZVwiLG1pbjpcImJlc3RWYWx1ZVwiLHN1bTpcImJlc3RWYWx1ZVwiLHByb2Q6XCJiZXN0VmFsdWVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWVcIixsb2dTdW1FeHA6XCJsb2coYmVzdFZhbHVlKVwiLGwxOlwiYmVzdFZhbHVlXCIsbDI6XCJzcXJ0KGJlc3RWYWx1ZSlcIixsb2dTdW06XCJsb2coYmVzdFZhbHVlKVwifSxkYz0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgYT10LWU7YTx0OysrYSlyLnB1c2goYSk7cmV0dXJuIHJ9LGNjPShlLHQpPT57bGV0IHI9W10sYT1lLmxlbmd0aDtmb3IobGV0IHM9MDtzPGE7cysrKXQuaW5kZXhPZihzKT09PS0xJiZyLnB1c2goZVtzXSk7bGV0IGk9dC5tYXAocz0+ZVtzXSk7cmV0dXJuW3IsaV19LHBjPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgrdC5sZW5ndGgsYT1bXSxpPTA7Zm9yKGxldCBzPTA7czxyO3MrKyl0LmluZGV4T2Yocyk9PT0tMT9hLnB1c2goZVtpKytdKTphLnB1c2goMSk7cmV0dXJuIGF9LGZjPShlLHQpPT57Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpaWYoZVtlLmxlbmd0aC1yLTFdIT09dC0xLXIpcmV0dXJuITE7cmV0dXJuITB9LG1jPShlLHQpPT57bGV0IHI9W107aWYoIWZjKGUsdCkpe2ZvcihsZXQgYT0wO2E8dDsrK2EpZS5pbmRleE9mKGEpPT09LTEmJnIucHVzaChhKTtlLmZvckVhY2goYT0+ci5wdXNoKGEpKX1yZXR1cm4gcn0saGM9KGUsdCxyLGEsaSxzLG8pPT57bGV0IGM9clswXS5kaW1zLHA9Ti5zaXplKHMpLG09Ti5zaXplKG8pLGw9VyhcIl9BXCIsclswXS5kYXRhVHlwZSxjKSxnPUooXCJvdXRwdXRcIixpLHMpLGI9MzIsdz1gXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTwke2cudHlwZS5zdG9yYWdlfSwgJHtifT47XG4gICAgICAgYDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOng9PmBcbiAgICAgICAgJHt4LnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGwsZyl9XG4gICAgICAgICR7d31cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7eC5tYWluU3RhcnQoYil9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtifTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9ICR7Zy50eXBlLnN0b3JhZ2V9KCR7dWNbYV19KTtcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gbG9jYWxfaWR4OyBrIDwgTGVuZ3RoOyBrID0gayArICR7Yn0pIHtcbiAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9ICR7Zy50eXBlLnN0b3JhZ2V9KCR7bC5nZXRCeU9mZnNldChcIm9mZnNldCArIGtcIil9KTtcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtvY1thXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7Yn11KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke3NjW2FdfTtcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcbiAgICAgICAgICAke2cuc2V0QnlPZmZzZXQoXCJvdXRwdXRJbmRleFwiLGAke2E9PT1cIm1lYW5cIj9gYmVzdFZhbHVlIC8gJHtnLnR5cGUuc3RvcmFnZX0odW5pZm9ybXMucmVkdWNlU2l6ZSlgOmAke2xjW2FdfWB9YCl9O1xuICAgICAgICAgfVxuICAgICAgICB9YCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6aX1dLGRpc3BhdGNoR3JvdXA6e3g6cH0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6bX1dfSl9fSxUdD0oZSx0LHIsYSk9PntsZXQgaT1lLmlucHV0cy5sZW5ndGg9PT0xP3I6S2EoZS5pbnB1dHMscikscz1pLmF4ZXM7cy5sZW5ndGg9PT0wJiYhaS5ub29wV2l0aEVtcHR5QXhlcyYmKHM9ZS5pbnB1dHNbMF0uZGltcy5tYXAoKHcsJCk9PiQpKTtsZXQgbz1OLm5vcm1hbGl6ZUF4ZXMocyxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCksYz1vLHA9ZS5pbnB1dHNbMF0sbT1tYyhjLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTttLmxlbmd0aD4wJiYocD1lLmNvbXB1dGUoeHQoZS5pbnB1dHNbMF0sbSkse2lucHV0czpbMF0sb3V0cHV0czpbLTFdfSlbMF0sYz1kYyhjLmxlbmd0aCxwLmRpbXMubGVuZ3RoKSk7bGV0W2wsZ109Y2MocC5kaW1zLGMpLGI9bDtpLmtlZXBEaW1zJiYoYj1wYyhsLG8pKSxlLmNvbXB1dGUoaGModCx7aGludDppLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LFtwXSxhLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGIsZykse2lucHV0czpbcF19KX0sSm89KGUsdCk9PntUdChlLFwiUmVkdWNlTWVhblNoYXJlZFwiLHQsXCJtZWFuXCIpfSxlcz0oZSx0KT0+e1R0KGUsXCJSZWR1Y2VMMVNoYXJlZFwiLHQsXCJsMVwiKX0sdHM9KGUsdCk9PntUdChlLFwiUmVkdWNlTDJTaGFyZWRcIix0LFwibDJcIil9LHJzPShlLHQpPT57VHQoZSxcIlJlZHVjZUxvZ1N1bUV4cFNoYXJlZFwiLHQsXCJsb2dTdW1FeHBcIil9LG5zPShlLHQpPT57VHQoZSxcIlJlZHVjZU1heFNoYXJlZFwiLHQsXCJtYXhcIil9LGFzPShlLHQpPT57VHQoZSxcIlJlZHVjZU1pblNoYXJlZFwiLHQsXCJtaW5cIil9LGlzPShlLHQpPT57VHQoZSxcIlJlZHVjZVByb2RTaGFyZWRcIix0LFwicHJvZFwiKX0sb3M9KGUsdCk9PntUdChlLFwiUmVkdWNlU3VtU2hhcmVkXCIsdCxcInN1bVwiKX0sc3M9KGUsdCk9PntUdChlLFwiUmVkdWNlU3VtU3F1YXJlU2hhcmVkXCIsdCxcInN1bVNxdWFyZVwiKX0sdXM9KGUsdCk9PntUdChlLFwiUmVkdWNlTG9nU3VtU2hhcmVkXCIsdCxcImxvZ1N1bVwiKX19KTt2YXIgRXQsZ2MsS24sS2EsT3QseWMsYmMsdmMsd2MsJGMsX2MsU2MseGMsQ2MsSWMsa3QsZHMsY3MscHMsZnMsbXMsaHMsZ3MseXMsYnMsdnMsam49USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7WGUoKTtfZSgpO2xzKCk7RXQ9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MiYmZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGVzIGlucHV0IGRpbXMuXCIpfSxnYz1lPT5bXCJcIixcIlwiLGB2YXIgdmFsdWUgPSAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSxLbj0oZSx0LHIsYSxpLHMsbz0hMSxjPSExKT0+e2xldCBwPVtdLG09clswXS5kaW1zLGw9bS5sZW5ndGgsZz1OLm5vcm1hbGl6ZUF4ZXMoaSxsKSxiPSFjJiZnLmxlbmd0aD09PTA7bS5mb3JFYWNoKChULEMpPT57Ynx8Zy5pbmRleE9mKEMpPj0wP28mJnAucHVzaCgxKTpwLnB1c2goVCl9KTtsZXQgdz1wLmxlbmd0aCwkPU4uc2l6ZShwKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOlQ9PntsZXQgQz1bXSxTPVcoXCJfQVwiLHJbMF0uZGF0YVR5cGUsbCksRT1KKFwib3V0cHV0XCIscyx3KSxPPWEoUyxFLGcpLFU9T1syXTtmb3IobGV0IEQ9MCxWPTA7RDxsO0QrKylifHxnLmluZGV4T2YoRCk+PTA/KG8mJlYrKyxVPWBmb3IodmFyIGoke0R9OiB1MzIgPSAwOyBqJHtEfSA8ICR7bVtEXX07IGoke0R9KyspIHtcbiAgICAgICAgICAgICAgICAgICR7T1syXS5pbmNsdWRlcyhcImxhc3RfaW5kZXhcIik/YGxldCBsYXN0X2luZGV4ID0gaiR7RH07YDpcIlwifVxuICAgICAgICAgICAgICAgICAgJHtTLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsRCxgaiR7RH1gKX1cbiAgICAgICAgICAgICAgICAgICR7VX1cbiAgICAgICAgICAgICAgICB9YCk6KEMucHVzaChgJHtTLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsRCxFLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFYpKX07YCksVisrKTtyZXR1cm5gXG5cbiAgICAgICAgJHtULnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhTLEUpfVxuXG4gICAgICAgICR7VC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke1QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke1MudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke0Uub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAke0Muam9pbihgXG5gKX1cbiAgICAgICAgICAke09bMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAgICR7T1sxXX1cbiAgICAgICAgICAke1V9XG4gICAgICAgICAgJHtPWzNdfVxuICAgICAgICAgICR7Ty5sZW5ndGg9PT00P0Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKTpPLnNsaWNlKDQpLmpvaW4oYFxuYCl9XG4gICAgICAgIH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnAsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKCQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOlwidWludDMyXCIsZGF0YTokfSwuLi5MKG0pLC4uLkwocCldfSl9fSxLYT0oZSx0KT0+e2xldCByPVtdO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChhPT5yLnB1c2goTnVtYmVyKGEpKSkseGUoe2F4ZXM6cixrZWVwRGltczp0LmtlZXBEaW1zLG5vb3BXaXRoRW1wdHlBeGVzOnQubm9vcFdpdGhFbXB0eUF4ZXN9KX0sT3Q9KGUsdCxyLGEpPT57bGV0IGk9ZS5pbnB1dHMscz1pLmxlbmd0aD09PTE/cjpLYShpLHIpO2UuY29tcHV0ZShLbih0LHtoaW50OnMuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2lbMF1dLHMubm9vcFdpdGhFbXB0eUF4ZXMmJnMuYXhlcy5sZW5ndGg9PT0wP2djOmEscy5heGVzLGlbMF0uZGF0YVR5cGUscy5rZWVwRGltcyxzLm5vb3BXaXRoRW1wdHlBeGVzKSx7aW5wdXRzOlswXX0pfSx5Yz0oZSx0KT0+e0V0KGUuaW5wdXRzKSxPdChlLFwiUmVkdWNlTG9nU3VtXCIsdCwoYSxpKT0+W2B2YXIgdmFsdWUgPSAke2kudHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LGJjPShlLHQpPT57RXQoZS5pbnB1dHMpLE90KGUsXCJSZWR1Y2VMMVwiLHQsKGEsaSk9PltgdmFyIHZhbHVlID0gJHtpLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBhYnMoJHthLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdKX0sdmM9KGUsdCk9PntFdChlLmlucHV0cyksT3QoZSxcIlJlZHVjZUwyXCIsdCwoYSxpKT0+W2B2YXIgdCA9ICR7aS50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtpLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFwidmFsdWUgPSBzcXJ0KHZhbHVlKTtcIl0pfSx3Yz0oZSx0KT0+e0V0KGUuaW5wdXRzKSxPdChlLFwiUmVkdWNlTG9nU3VtRXhwXCIsdCwoYSxpKT0+W2B2YXIgdmFsdWUgPSAke2kudHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGV4cCgke2EuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sJGM9KGUsdCk9PntFdChlLmlucHV0cyksT3QoZSxcIlJlZHVjZU1heFwiLHQsKGEsaSxzKT0+e2xldCBvPVtdO2ZvcihsZXQgYz0wO2M8YS5yYW5rO2MrKykocy5pbmRleE9mKGMpPj0wfHxzLmxlbmd0aD09PTApJiZvLnB1c2goYS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGMsMCkpO3JldHVybltgJHtvLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHthLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWF4KHZhbHVlLCAke2EuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sX2M9KGUsdCk9PntFdChlLmlucHV0cyksT3QoZSxcIlJlZHVjZU1lYW5cIix0LChhLGkscyk9PntsZXQgbz0xO2ZvcihsZXQgYz0wO2M8YS5yYW5rO2MrKykocy5pbmRleE9mKGMpPj0wfHxzLmxlbmd0aD09PTApJiYobyo9ZS5pbnB1dHNbMF0uZGltc1tjXSk7cmV0dXJuW1widmFyIHN1bSA9IGYzMigwKTtcIixcIlwiLGBzdW0gKz0gZjMyKCR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxgbGV0IHZhbHVlID0gJHtpLnR5cGUudmFsdWV9KHN1bSAvICR7b30pO2BdfSl9LFNjPShlLHQpPT57RXQoZS5pbnB1dHMpLE90KGUsXCJSZWR1Y2VNaW5cIix0LChhLGkscyk9PntsZXQgbz1bXTtmb3IobGV0IGM9MDtjPGEucmFuaztjKyspKHMuaW5kZXhPZihjKT49MHx8cy5sZW5ndGg9PT0wKSYmby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7Y31dID0gMDtgKTtyZXR1cm5bYCR7by5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHthLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdfSl9LHhjPShlLHQpPT57RXQoZS5pbnB1dHMpLE90KGUsXCJSZWR1Y2VQcm9kXCIsdCwoYSxpKT0+W2B2YXIgdmFsdWUgPSAke2kudHlwZS5zdG9yYWdlfSgxKTtgLFwiXCIsYHZhbHVlICo9ICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sQ2M9KGUsdCk9PntFdChlLmlucHV0cyksT3QoZSxcIlJlZHVjZVN1bVwiLHQsKGEsaSk9PltgdmFyIHZhbHVlID0gJHtpLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke2EuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSl9LEljPShlLHQpPT57RXQoZS5pbnB1dHMpLE90KGUsXCJSZWR1Y2VTdW1TcXVhcmVcIix0LChhLGkpPT5bYHZhciB0ID0gJHtpLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke2kudHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHthLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSB0ICogdDtgLFwiXCJdKX0sa3Q9KGUsdCxyKT0+e2lmKHQubGVuZ3RoPT09MClyZXR1cm4gcjtsZXQgYT0xLGk9MTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl0LmluZGV4T2Yocyk9PT0tMT9hKj1lW3NdOmkqPWVbc107cmV0dXJuIGk8MzImJmE+MTAyNH0sZHM9KGUsdCk9PntrdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9fYyhlLHQpOkpvKGUsdCl9LGNzPShlLHQpPT57a3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/YmMoZSx0KTplcyhlLHQpfSxwcz0oZSx0KT0+e2t0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3ZjKGUsdCk6dHMoZSx0KX0sZnM9KGUsdCk9PntrdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT93YyhlLHQpOnJzKGUsdCl9LG1zPShlLHQpPT57a3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/JGMoZSx0KTpucyhlLHQpfSxocz0oZSx0KT0+e2t0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1NjKGUsdCk6YXMoZSx0KX0sZ3M9KGUsdCk9PntrdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT94YyhlLHQpOmlzKGUsdCl9LHlzPShlLHQpPT57a3QoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q2MoZSx0KTpvcyhlLHQpfSxicz0oZSx0KT0+e2t0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0ljKGUsdCk6c3MoZSx0KX0sdnM9KGUsdCk9PntrdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT95YyhlLHQpOnVzKGUsdCl9fSk7dmFyIHdzLCRzLF9zLFlhLFNzPVEoKCk9PntcInVzZSBzdHJpY3RcIjt6ZSgpO1hlKCk7am4oKTt3cz1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSwkcz0oZSx0KT0+e3dzKGUuaW5wdXRzKTtsZXQgcj0oYSxpLHMpPT57bGV0IG89W107Zm9yKGxldCBjPTA7YzxhLnJhbms7YysrKShzLmluZGV4T2YoYyk+PTB8fHMubGVuZ3RoPT09MCkmJm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2N9XSA9IDA7YCk7cmV0dXJuW2Ake28uam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke2EuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI8PVwiOlwiPFwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke2EuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsaS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoS24oXCJBcmdNaW5cIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0scixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LF9zPShlLHQpPT57d3MoZS5pbnB1dHMpO2xldCByPShhLGkscyk9PntsZXQgbz1bXTtmb3IobGV0IGM9MDtjPGEucmFuaztjKyspKHMuaW5kZXhPZihjKT49MHx8cy5sZW5ndGg9PT0wKSYmby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7Y31dID0gMDtgKTtyZXR1cm5bYCR7by5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHthLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIj49XCI6XCI+XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixpLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShLbihcImFyZ01heFwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxyLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sWWE9ZT0+eGUoZSl9KTt2YXIgQWMsVGMsRWMsT2MsWW4sa2MseHMsWmE9USgoKT0+e1widXNlIHN0cmljdFwiO3plKCk7Vm4oKTtfZSgpO0FjPShlLHQpPT57bGV0IHI9ZVswXSxhPWVbMV0saT1lWzJdLHM9ZVszXSxvPWVbNF0sYz1lWzVdO2lmKG8mJmMpdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgcmVsYXRpdmVfcG9zaXRpb25fYmlhc1wiKTtpZihyLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiaW5wdXRcIiBtdXN0IGhhdmUgMyBkaW1lbnNpb25zJyk7bGV0IHA9ci5kaW1zWzBdLG09ci5kaW1zWzFdLGw9ci5kaW1zWzJdO2lmKGkuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtpZihhLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7aWYoYS5kaW1zWzBdIT09bCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCAxIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAyIG9mIGlucHV0IDBcIik7aWYoaS5kaW1zWzBdIT09YS5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDEgb2YgaW5wdXQgXCJ3ZWlnaHRzXCInKTtsZXQgZz1pLmRpbXNbMF0vMyxiPWcsdz1iO2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoPjApe2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIGF0dHJpYnV0ZSBzaG91bGQgaGF2ZSAzIGVsZW1lbnRzXCIpO2ZvcihsZXQgRSBvZiB0LnFrdkhpZGRlblNpemVzKWlmKEUldC5udW1IZWFkcyE9PTApdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IG51bV9oZWFkc1wiKTtnPXQucWt2SGlkZGVuU2l6ZXNbMF0sYj10LnFrdkhpZGRlblNpemVzWzFdLHc9dC5xa3ZIaWRkZW5TaXplc1syXX1sZXQgJD1tO2lmKGchPT1iKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgZmlyc3QgZWxlbWVudCBzaG91bGQgYmUgc2FtZSBhcyB0aGUgc2Vjb25kXCIpO2lmKGkuZGltc1swXSE9PWcrYit3KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgc3VtIG9mIFEvSy9WIGhpZGRlbiBzaXplcycpO2xldCB4PTA7aWYobyl7aWYoYiE9PXcpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBleHBlY3Qga19oaWRkZW5fc2l6ZSA9PSB2X2hpZGRlbl9zaXplJyk7aWYoby5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7aWYoby5kaW1zWzBdIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDInKTtpZihvLmRpbXNbMV0hPT1wKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtpZihvLmRpbXNbMl0hPT10Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgbnVtX2hlYWRzJyk7aWYoby5kaW1zWzRdIT09Yi90Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlmdGggZGltZW5zaW9uIG11c3QgYmUga19oaWRkZW5fc2l6ZSAvIG51bV9oZWFkcycpO3QucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcnx8KHg9by5kaW1zWzNdKX1sZXQgVD0kK3gsQz0tMSxTPTA7aWYocyl0aHJvdyBuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIik7aWYobyl0aHJvdyBuZXcgRXJyb3IoXCJwYXN0IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoYyl0aHJvdyBuZXcgRXJyb3IoXCJyZWxhdGl2ZVBvc2l0aW9uQmlhcyBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybntiYXRjaFNpemU6cCxzZXF1ZW5jZUxlbmd0aDptLHBhc3RTZXF1ZW5jZUxlbmd0aDp4LGt2U2VxdWVuY2VMZW5ndGg6JCx0b3RhbFNlcXVlbmNlTGVuZ3RoOlQsbWF4U2VxdWVuY2VMZW5ndGg6QyxpbnB1dEhpZGRlblNpemU6bCxoaWRkZW5TaXplOmcsdkhpZGRlblNpemU6dyxoZWFkU2l6ZTpNYXRoLmZsb29yKGcvdC5udW1IZWFkcyksdkhlYWRTaXplOk1hdGguZmxvb3Iody90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6UyxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6ITEscGFzc1Bhc3RJbkt2OiExLHFrdkZvcm1hdDoxfX0sVGM9KGUsdCxyLGEpPT57bGV0IGk9TGUoYSkscz02NCxvPWEvaTtvPHM/cz0xOm8vODw2NCYmKHM9TWF0aC5jZWlsKG8vOCkpO2xldCBjPU1hdGguY2VpbChhL2kvcyksbT1be3R5cGU6cHQodC5kYXRhVHlwZSksZGF0YToxL2F9LHt0eXBlOlwidWludDMyXCIsZGF0YTpvfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6Y31dLGw9SGUodC5kYXRhVHlwZSxpKSxnPWI9PntsZXQgdz1KKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLGkpLCQ9XCJ0aHJlYWRfbWF4X3ZlY3RvclwiO2k9PT0yPyQ9XCJtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSlcIjppPT09NCYmKCQ9XCJtYXgobWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpLCBtYXgodGhyZWFkX21heF92ZWN0b3IueiwgdGhyZWFkX21heF92ZWN0b3IudykpXCIpO2xldCB4PV90KHQuZGF0YVR5cGUpLFQ9W3tuYW1lOlwiZF9pbnZcIix0eXBlOnh9LHtuYW1lOlwiZF9jb21wXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVsZW1lbnRzX3Blcl93Z1wiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gd2dNYXg6IGFycmF5PGYzMiwgJHtzfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHdnU3VtOiBhcnJheTxmMzIsICR7c30+O1xuICAke2IucmVnaXN0ZXJVbmlmb3JtcyhUKS5kZWNsYXJlVmFyaWFibGVzKHcpfVxuICAke2IubWFpblN0YXJ0KFtzLDEsMV0pfVxuICAgIGxldCBsb2NhbE9mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZztcbiAgICBsZXQgb2Zmc2V0OiB1MzIgPSB3b3JrZ3JvdXBfaWQueCAqIHVuaWZvcm1zLmRfY29tcCArIGxvY2FsT2Zmc2V0O1xuXG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHtRZShcImYzMlwiLGksXCItMy40MDI4MjNlKzM4ZlwiKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZyAmJiBpICsgbG9jYWxPZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHtTdCh4LGksXCJ4W29mZnNldCArIGldXCIpfSwgdGhyZWFkX21heF92ZWN0b3IpO1xuICAgIH1cbiAgICB3Z01heFtsb2NhbF9pZHhdID0gJHskfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgbWF4VmFsdWUgPSAtMy40MDI4MjNlKzM4ZjtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3N9OyBpKyspIHtcbiAgICAgIG1heFZhbHVlID0gbWF4KHdnTWF4W2ldLCBtYXhWYWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bVZlY3RvciA9ICR7UWUoXCJmMzJcIixpLFwiMFwiKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZyAmJiBpICsgbG9jYWxPZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgc3VtVmVjdG9yICs9IGV4cCgke1N0KHgsaSxcInhbb2Zmc2V0ICsgaV1cIil9IC0gbWF4VmFsdWUpO1xuICAgIH1cbiAgICB3Z1N1bVtsb2NhbF9pZHhdID0gJHtmdChcInN1bVZlY3RvclwiLGkpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgc3VtOiBmMzIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7c307IGkrKykge1xuICAgICAgc3VtICs9IHdnU3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl93ZyAmJiBpICsgbG9jYWxPZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgICB4W29mZnNldCArIGldID0gJHtRZSh4LGksXCJ1bmlmb3Jtcy5kX2ludlwiKX07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfd2cgJiYgaSArIGxvY2FsT2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcbiAgICAgICAgbGV0IGYzMmlucHV0ID0gJHtTdCh4LGksXCJ4W29mZnNldCArIGldXCIpfTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7dy50eXBlLnZhbHVlfShleHAoZjMyaW5wdXQgLSBtYXhWYWx1ZSkgLyBzdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblByb2JzU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke3N9OyR7bH07JHtpfWB9LGdldFNoYWRlclNvdXJjZTpnLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbXSxkaXNwYXRjaEdyb3VwOnt4OnJ9LHByb2dyYW1Vbmlmb3JtczptfSl9LHtpbnB1dHM6W3RdLG91dHB1dHM6W119KX0sRWM9KGUsdCxyLGEsaSxzKT0+e2xldCBvPVtpLmJhdGNoU2l6ZSxpLm51bUhlYWRzLGkuc2VxdWVuY2VMZW5ndGgsaS5rdlNlcXVlbmNlTGVuZ3RoK2kucGFzdFNlcXVlbmNlTGVuZ3RoXSxjPXMuc2NhbGU9PT0wPzEvTWF0aC5zcXJ0KGkuaGVhZFNpemUpOnMuc2NhbGUscD1MZShpLmhlYWRTaXplKSxtPWkuaGVhZFNpemUvcCxsPTEyLGc9e3g6TWF0aC5jZWlsKGkudG90YWxTZXF1ZW5jZUxlbmd0aC9sKSx5Ok1hdGguY2VpbChpLnNlcXVlbmNlTGVuZ3RoL2wpLHo6aS5iYXRjaFNpemUqaS5udW1IZWFkc30sYj1wdCh0LmRhdGFUeXBlKSx3PVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6aS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOm19LHt0eXBlOlwidWludDMyXCIsZGF0YTppLnRvdGFsU2VxdWVuY2VMZW5ndGh9LHt0eXBlOlwidWludDMyXCIsZGF0YTppLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOmIsZGF0YTpjfV0sJD1bdCxyXSx4PUM9PntsZXQgUz1XKFwicVwiLHQuZGF0YVR5cGUsdC5kaW1zLHApLEU9VyhcImtleVwiLHIuZGF0YVR5cGUsci5kaW1zLHApLE89SihcIm91dHB1dFwiLHQuZGF0YVR5cGUsbyksVT1IZSh0LmRhdGFUeXBlKSxEPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6VX1dO3JldHVybmBcbiAgY29uc3QgYmV0YTogJHtVfSA9IDEuMDtcbiAgY29uc3QgVElMRV9TSVpFID0gJHtsfXU7XG5cbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7Uy50eXBlLnN0b3JhZ2V9LCAke2wqbH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtTLnR5cGUuc3RvcmFnZX0sICR7bCpsfT47XG4gICR7Qy5yZWdpc3RlclVuaWZvcm1zKEQpLmRlY2xhcmVWYXJpYWJsZXMoUyxFLE8pfVxuICAke0MubWFpblN0YXJ0KFtsLGwsMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56O1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgbG0gPSBtICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbG4gPSBuICsgbG9jYWxfaWQueDtcblxuICAgIGxldCBxT2Zmc2V0ID0gdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKiBoZWFkSWR4ICsgbSAqIHVuaWZvcm1zLks7XG4gICAgbGV0IGtPZmZzZXQgPSB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LICogaGVhZElkeCArIG4gKiB1bmlmb3Jtcy5LO1xuXG4gICAgdmFyIHZhbHVlID0gJHtRZShVLHApfTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBxW3FPZmZzZXQgKyBsb2NhbF9pZC55ICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGtleVtrT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZUtbVElMRV9TSVpFICogbG9jYWxfaWQueCArIGtdO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRPZmZzZXQgPSBoZWFkSWR4ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgaWYgKGxtIDwgdW5pZm9ybXMuTSAmJiBsbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBoZWFkT2Zmc2V0ICsgbG0gKiB1bmlmb3Jtcy5OICsgbG47XG4gICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7ZnQoXCJ2YWx1ZVwiLHApfSAqIHVuaWZvcm1zLmFscGhhO1xuICAgIH1cbiAgfWB9LFQ9ZS5jb21wdXRlKHtuYW1lOlwiQXR0ZW50aW9uUHJvYnNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6Zyxwcm9ncmFtVW5pZm9ybXM6d30pLGdldFNoYWRlclNvdXJjZTp4fSx7aW5wdXRzOiQsb3V0cHV0czpbLTFdfSlbMF07cmV0dXJuIFRjKGUsVCxpLmJhdGNoU2l6ZSppLm51bUhlYWRzKmkuc2VxdWVuY2VMZW5ndGgsaS50b3RhbFNlcXVlbmNlTGVuZ3RoKSxUfSxPYz0oZSx0LHIsYSk9PntsZXQgaT1bYS5iYXRjaFNpemUsYS5zZXF1ZW5jZUxlbmd0aCxhLnZIaWRkZW5TaXplXSxzPTEyLG89e3g6TWF0aC5jZWlsKGEudkhlYWRTaXplL3MpLHk6TWF0aC5jZWlsKGEuc2VxdWVuY2VMZW5ndGgvcyksejphLmJhdGNoU2l6ZSphLm51bUhlYWRzfSxjPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6YS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOmEudG90YWxTZXF1ZW5jZUxlbmd0aH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOmEudkhlYWRTaXplfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6YS5udW1IZWFkc30se3R5cGU6XCJ1aW50MzJcIixkYXRhOmEudkhpZGRlblNpemV9XSxwPW09PntsZXQgbD1XKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcyksZz1XKFwidlwiLHIuZGF0YVR5cGUsci5kaW1zKSxiPUooXCJvdXRwdXRcIix0LmRhdGFUeXBlLGkpLHc9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInZfaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7c311O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtsLnR5cGUudmFsdWV9LCAke3Mqc30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtsLnR5cGUudmFsdWV9LCAke3Mqc30+O1xuICAke20ucmVnaXN0ZXJVbmlmb3Jtcyh3KS5kZWNsYXJlVmFyaWFibGVzKGwsZyxiKX1cbiAgJHttLm1haW5TdGFydChbcyxzLDFdKX1cbiAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLno7XG4gICBsZXQgbSA9IHdvcmtncm91cF9pZC55ICogVElMRV9TSVpFICsgbG9jYWxfaWQueTtcbiAgIGxldCBuID0gd29ya2dyb3VwX2lkLnggKiBUSUxFX1NJWkUgKyBsb2NhbF9pZC54O1xuXG4gICBsZXQgb2Zmc2V0QSA9IGhlYWRJZHggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XG4gICBsZXQgb2Zmc2V0QiA9IGhlYWRJZHggKiAodW5pZm9ybXMuTiAqIHVuaWZvcm1zLkspICsgbjtcblxuICAgdmFyIHZhbHVlID0gJHtsLnR5cGUuc3RvcmFnZX0oMCk7XG4gICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB2W29mZnNldEIgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZUtbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQgY3VycmVudEJhdGNoSGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGhlYWRPZmZzZXQgPSAoYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMubnVtX2hlYWRzICsgY3VycmVudEJhdGNoSGVhZE51bWJlcikgKiB1bmlmb3Jtcy5OO1xuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKnVuaWZvcm1zLnZfaGlkZGVuX3NpemUgKyBtICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZVxuICAgICAgICsgY3VycmVudEJhdGNoSGVhZE51bWJlciAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9IHZhbHVlO1xuICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblNjb3JlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XSxkaXNwYXRjaEdyb3VwOm8scHJvZ3JhbVVuaWZvcm1zOmN9KSxnZXRTaGFkZXJTb3VyY2U6cH0se2lucHV0czpbdCxyXSxvdXRwdXRzOlswXX0pWzBdfSxZbj0oZSx0LHIsYSxpLHMsbyxjLHAsbSxsKT0+e2xldCBnPUVjKGUsdCxyLHAsbSxsKTtPYyhlLGcsYSxtKX0sa2M9KGUsdCk9PntsZXQgcj1bdC5iYXRjaFNpemUsdC5udW1IZWFkcyx0LnNlcXVlbmNlTGVuZ3RoLHQuaGVhZFNpemVdLGE9dC5zZXF1ZW5jZUxlbmd0aCxpPXQuaW5wdXRIaWRkZW5TaXplLHM9dC5oZWFkU2l6ZSxvPTEyLGM9e3g6TWF0aC5jZWlsKHQuaGVhZFNpemUvbykseTpNYXRoLmNlaWwodC5zZXF1ZW5jZUxlbmd0aC9vKSx6OnQuYmF0Y2hTaXplKnQubnVtSGVhZHN9LHA9W2UuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxtPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6YX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOml9LHt0eXBlOlwidWludDMyXCIsZGF0YTpzfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5udW1IZWFkc30se3R5cGU6XCJ1aW50MzJcIixkYXRhOnQuaGVhZFNpemV9LHt0eXBlOlwidWludDMyXCIsZGF0YTp0LmhpZGRlblNpemV9LHt0eXBlOlwidWludDMyXCIsZGF0YTp0LmhpZGRlblNpemUrdC5oaWRkZW5TaXplK3QudkhpZGRlblNpemV9XSxsPWc9PntsZXQgYj1KKFwib3V0cHV0X3FcIixwWzBdLmRhdGFUeXBlLHIpLHc9SihcIm91dHB1dF9rXCIscFswXS5kYXRhVHlwZSxyKSwkPUooXCJvdXRwdXRfdlwiLHBbMF0uZGF0YVR5cGUscikseD1XKFwiaW5wdXRcIixwWzBdLmRhdGFUeXBlLHBbMF0uZGltcyksVD1XKFwid2VpZ2h0XCIscFsxXS5kYXRhVHlwZSxwWzFdLmRpbXMpLEM9VyhcImJpYXNcIixwWzJdLmRhdGFUeXBlLHBbMl0uZGltcyksUz14LnR5cGUuc3RvcmFnZSxFPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibGRiXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke299dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke1N9LCAke28qb30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHtTfSwgJHtvKm99PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7U30sICR7bypvfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke1N9LCAke28qb30+O1xuICAke2cucmVnaXN0ZXJVbmlmb3JtcyhFKS5kZWNsYXJlVmFyaWFibGVzKHgsVCxDLGIsdywkKX1cbiAgJHtnLm1haW5TdGFydChbbyxvLDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRSArIGxvY2FsX2lkLnk7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRSArIGxvY2FsX2lkLng7XG5cbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiYXRjaEluZGV4ICogKHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LKSArIG0gKiB1bmlmb3Jtcy5LO1xuICAgIGxldCBiaWFzT2Zmc2V0USA9IGhlYWROdW1iZXIgKiB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgbGV0IGJpYXNPZmZzZXRLID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0UTtcbiAgICBsZXQgYmlhc09mZnNldFYgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRLO1xuXG4gICAgdmFyIHZhbHVlUSA9ICR7U30oMCk7XG4gICAgdmFyIHZhbHVlSyA9ICR7U30oMCk7XG4gICAgdmFyIHZhbHVlViA9ICR7U30oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlSW5wdXRbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gaW5wdXRbaW5wdXRPZmZzZXQgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBuICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLmxkYjtcbiAgICAgICAgdGlsZVdlaWdodFFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRRICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodEtbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRLICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodFZbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRWICsgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgbGV0IGlucHV0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrO1xuICAgICAgICBsZXQgd2VpZ2h0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54O1xuICAgICAgICB2YWx1ZVEgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0UVt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVLICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodEtbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlViArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRWW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRPZmZzZXQgPSAobSAqIHVuaWZvcm1zLk4gKyBuKSAlIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICB2YWx1ZVEgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFFdO1xuICAgIHZhbHVlSyArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0S107XG4gICAgdmFsdWVWICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRWXTtcblxuICAgIGxldCBvZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgbGV0IG91dHB1dElkeCA9IG9mZnNldCArIG0gKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgIG91dHB1dF9xW291dHB1dElkeF0gPSB2YWx1ZVE7XG4gICAgICBvdXRwdXRfa1tvdXRwdXRJZHhdID0gdmFsdWVLO1xuICAgICAgb3V0cHV0X3Zbb3V0cHV0SWR4XSA9IHZhbHVlVjtcbiAgICB9XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiQXR0ZW50aW9uUHJlcGFyZVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSx7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XSxkaXNwYXRjaEdyb3VwOmMscHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6bH0se2lucHV0czpwLG91dHB1dHM6Wy0xLC0xLC0xXX0pfSx4cz0oZSx0KT0+e2xldCByPUFjKGUuaW5wdXRzLHQpLFthLGksc109a2MoZSxyKTtyZXR1cm4gWW4oZSxhLGkscyxlLmlucHV0c1s0XSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxlLmlucHV0c1s1XSxyLHQpfX0pO3ZhciBQYyxSYyxCYyxDcyxJcz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YnQoKTtDZSgpO1hlKCk7X2UoKTtQYz0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzXCIpO2xldCByPShhLGkscyk9PntsZXQgbz1pLmxlbmd0aDtpZihvIT09YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGAke3N9OiBudW0gZGltZW5zaW9ucyAhPSAke299YCk7aS5mb3JFYWNoKChjLHApPT57aWYoYyE9PWFbcF0pdGhyb3cgbmV3IEVycm9yKGAke3N9OiBkaW1bJHtwfV0gZG8gbm90IG1hdGNoYCl9KX07aWYoZVswXS5kaW1zLmxlbmd0aD4xKXtsZXQgYT10LmZvcm1hdD09PVwiTkhXQ1wiP3Quc3BhdGlhbD9lWzBdLmRpbXMuc2xpY2UoLTEpOmVbMF0uZGltcy5zbGljZSgtMSkuY29uY2F0KGVbMF0uZGltcy5zbGljZSgxLGVbMF0uZGltcy5sZW5ndGgtMSkpOmVbMF0uZGltcy5zbGljZSgxLHQuc3BhdGlhbD8yOnZvaWQgMCk7cihlWzFdLmRpbXMsYSxcIkludmFsaWQgaW5wdXQgc2NhbGVcIikscihlWzJdLmRpbXMsYSxcIkludmFsaWQgaW5wdXQgQlwiKSxyKGVbM10uZGltcyxhLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLHIoZVs0XS5kaW1zLGEsXCJJbnZhbGlkIGlucHV0IHZhclwiKX1lbHNlIHIoZVsxXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgc2NhbGVcIikscihlWzJdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBCXCIpLHIoZVszXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgbWVhblwiKSxyKGVbNF0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHZhclwiKX0sUmM9KGUsdCk9PntsZXR7ZXBzaWxvbjpyLHNwYXRpYWw6YSxmb3JtYXQ6aX09dCxzPWVbMF0uZGltcyxvPWE/TGUoc1tzLmxlbmd0aC0xXSk6MSxjPWk9PT1cIk5IV0NcIiYmcy5sZW5ndGg+MT9vOjEscD1OLnNpemUocykvbyxtPWEsbD1tP3MubGVuZ3RoOnMsZz1XKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLG8pLGI9VyhcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsYyksdz1XKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGMpLCQ9VyhcImlucHV0TWVhblwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLGMpLHg9VyhcImlucHV0VmFyXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsYyksVD1KKFwieVwiLGVbMF0uZGF0YVR5cGUsbCxvKSxDPSgpPT57bGV0IEU9XCJcIjtpZihhKUU9YGxldCBjT2Zmc2V0ID0gJHtzLmxlbmd0aD09PTE/XCIwdVwiOmk9PT1cIk5IV0NcIj9gb3V0cHV0SW5kaWNlc1ske3MubGVuZ3RoLTF9XSAvICR7b31gOlwib3V0cHV0SW5kaWNlc1sxXVwifTtgO2Vsc2UgaWYoaT09PVwiTkNIV1wiKUU9YFxuICAgICAgICAgICAgJHtULmluZGljZXNTZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCIwXCIsXCIwXCIpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke1QuaW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiKX07YDtlbHNle0U9YHZhciBjSW5kaWNlcyA9ICR7Yi50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAgICAgICAgICAgICAgICBjSW5kaWNlc1swXSA9IG91dHB1dEluZGljZXNbJHtzLmxlbmd0aC0xfV07YDtmb3IobGV0IE89MTtPPGIucmFuaztPKyspRSs9YGNJbmRpY2VzWyR7T31dID0gb3V0cHV0SW5kaWNlc1ske099XTtgO0UrPWBsZXQgY09mZnNldCA9ICR7Yi5pbmRpY2VzVG9PZmZzZXQoXCJjSW5kaWNlc1wiKX07YH1yZXR1cm4gRX0sUz1FPT5gXG4gIGNvbnN0IGVwc2lsb24gPSAke3J9O1xuICAke0UucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZyxiLHcsJCx4LFQpfVxuICAke0UubWFpblN0YXJ0KCl9XG4gICR7RS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7VC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke299YCl9O1xuICAgICR7QygpfVxuICAgIGxldCBzY2FsZSA9ICR7Yi5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBiaWFzID0gJHt3LmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7JC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7eC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCB4ID0gJHtnLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke1Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWA7cmV0dXJue25hbWU6XCJCYXRjaE5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmVwc2lsb259XyR7dC5mb3JtYXR9XyR7YX1fJHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6bT9bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdOnZvaWQgMH0sZ2V0U2hhZGVyU291cmNlOlMsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczplWzBdLmRpbXMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bT9be3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9LC4uLkwocyldOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH1dfSl9fSxCYz1lPT54ZShlKSxDcz0oZSx0KT0+e2xldHtpbnB1dHM6cixvdXRwdXRDb3VudDphfT1lLGk9QmMoey4uLnQsb3V0cHV0Q291bnQ6YX0pO2lmKEFlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmUGMocixpKSx0LnRyYWluaW5nTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gdHJhaW5pbmdNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtlLmNvbXB1dGUoUmMocixpKSl9fSk7dmFyIE1jLERjLEFzLFRzPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO19lKCk7TWM9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sRGM9ZT0+e2xldCB0PWVbMF0uZGltcyxyPWVbMF0uZGltc1syXSxhPU4uc2l6ZSh0KS80LGk9ZVswXS5kYXRhVHlwZSxzPVcoXCJpbnB1dFwiLGksdCw0KSxvPVcoXCJiaWFzXCIsaSxbcl0sNCksYz1XKFwicmVzaWR1YWxcIixpLHQsNCkscD1KKFwib3V0cHV0XCIsaSx0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9fSksZ2V0U2hhZGVyU291cmNlOmw9PmBcbiAgY29uc3QgY2hhbm5lbHMgPSAke3J9dSAvIDQ7XG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKHMsbyxjLHApfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhhKX1cbiAgICBsZXQgdmFsdWUgPSAke3MuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxuICAgICAgKyAke28uZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHtjLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfX0sQXM9ZT0+e01jKGUuaW5wdXRzKSxlLmNvbXB1dGUoRGMoZS5pbnB1dHMpKX19KTt2YXIgemMsRWUsRXMsT3Msa3MsUHMsUnMsQnMsTXMsRHMsenMsVWMsVXMsV3MsTnMsVnMsWm4sSHMsWG4sTHMsR3MsRnMscXMsanMsS3MsWXMsWnMsWHMsUXMsSnMsZXUsdHUscnUsbnUsYXUsaXUsb3Usc3UsWGE9USgoKT0+e1widXNlIHN0cmljdFwiO3plKCk7Q2UoKTtYZSgpO19lKCk7emM9KGUsdCxyLGEsaSxzKT0+e2xldCBvPU1hdGguY2VpbCh0LzQpLGM9XCJcIjt0eXBlb2YgaT09XCJzdHJpbmdcIj9jPWAke2l9KGEpYDpjPWkoXCJhXCIpO2xldCBwPVcoXCJpbnB1dERhdGFcIixyLFtvXSw0KSxtPUooXCJvdXRwdXREYXRhXCIsYSxbb10sNCk7cmV0dXJuYFxuICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhwLG0pfVxuXG4gICR7cz8/XCJcIn1cblxuICAke2UubWFpblN0YXJ0KCl9XG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cblxuICAgIGxldCBhID0gJHtwLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHttLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGMpfVxuICB9YH0sRWU9KGUsdCxyLGEsaSxzPWUuZGF0YVR5cGUpPT4oe25hbWU6dCxzaGFkZXJDYWNoZTp7aGludDppLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTpvPT56YyhvLE4uc2l6ZShlLmRpbXMpLGUuZGF0YVR5cGUscyxyLGEpLGdldFJ1bkRhdGE6bz0+KHtvdXRwdXRzOlt7ZGltczplLmRpbXMsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKE4uc2l6ZShvWzBdLmRpbXMpLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOlwidWludDMyXCIsZGF0YTpNYXRoLmNlaWwoTi5zaXplKGUuZGltcykvNCl9XX0pfSksRXM9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkFic1wiLFwiYWJzXCIpKX0sT3M9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkFjb3NcIixcImFjb3NcIikpfSxrcz1lPT57ZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiQWNvc2hcIixcImFjb3NoXCIpKX0sUHM9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkFzaW5cIixcImFzaW5cIikpfSxScz1lPT57ZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiQXNpbmhcIixcImFzaW5oXCIpKX0sQnM9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkF0YW5cIixcImF0YW5cIikpfSxNcz1lPT57ZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiQXRhbmhcIixcImF0YW5oXCIpKX0sRHM9ZT0+eGUoZSksenM9KGUsdCk9PntsZXQgcjtzd2l0Y2godC50byl7Y2FzZSAxMDpyPVwidmVjNDxmMTY+XCI7YnJlYWs7Y2FzZSAxOnI9XCJ2ZWM0PGYzMj5cIjticmVhaztjYXNlIDEyOnI9XCJ2ZWM0PHUzMj5cIjticmVhaztjYXNlIDY6cj1cInZlYzQ8aTMyPlwiO2JyZWFrO2Nhc2UgOTpyPVwidmVjNDxib29sPlwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHt0LnRvfWApfWUuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkNhc3RcIixyLHZvaWQgMCx0LmNhY2hlS2V5LHQudG8pKX0sVWM9ZT0+e2xldCB0PWUubGVuZ3RoPj0yJiZlWzFdLmRhdGEhPT0wP2VbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF06R24scj1lLmxlbmd0aD49MyYmZVsyXS5kYXRhIT09MD9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOkZuO3JldHVybiB4ZSh7bWluOnQsbWF4OnJ9KX0sVXM9KGUsdCk9PntsZXQgcj1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6VWMoZS5pbnB1dHMpLGE9X3QoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkNsaXBcIixpPT5gY2xhbXAoJHtpfSwgY2xpcF9taW5fLCBjbGlwX21heF8pYCxgXG4gICAgY29uc3QgY2xpcF9taW5fOiB2ZWM0PCR7YX0+ID0gdmVjNCgke2F9KCR7ci5taW59KSk7XG4gICAgY29uc3QgY2xpcF9tYXhfOiB2ZWM0PCR7YX0+ID0gdmVjNCgke2F9KCR7ci5tYXh9KSk7XG5gLHIuY2FjaGVLZXkpLHtpbnB1dHM6WzBdfSl9LFdzPWU9PntlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJDZWlsXCIsXCJjZWlsXCIpKX0sTnM9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkNvc1wiLFwiY29zXCIpKX0sVnM9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkNvc2hcIixcImNvc2hcIikpfSxabj1lPT54ZShlKSxIcz0oZSx0KT0+e2xldCByPV90KGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJFbHVcIixhPT5gZWx1X3ZmMzIoJHthfSlgLGBcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7cn0oJHt0LmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiAke3J9KSAtPiAke3J9IHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtyfT4pIC0+IHZlYzQ8JHtyfT4ge1xuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xuICB9YCx0LmNhY2hlS2V5KSl9LFhuPShlLHQ9XCJmMzJcIik9PmBcbmNvbnN0IHIwOiAke3R9ID0gMC4zMjc1OTExO1xuY29uc3QgcjE6ICR7dH0gPSAwLjI1NDgyOTU5MjtcbmNvbnN0IHIyOiAke3R9ID0gLTAuMjg0NDk2NzM2O1xuY29uc3QgcjM6ICR7dH0gPSAxLjQyMTQxMzc0MTtcbmNvbnN0IHI0OiAke3R9ID0gLTEuNDUzMTUyMDI3O1xuY29uc3QgcjU6ICR7dH0gPSAxLjA2MTQwNTQyOTtcblxuZm4gZXJmX3ZmMzIodjogJHtlfSkgLT4gJHtlfSB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gLExzPWU9PntsZXQgdD1fdChlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiRXJmXCIscj0+YGVyZl92ZjMyKCR7cn0pYCxYbihgdmVjNDwke3R9PmAsdCkpKX0sR3M9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkV4cFwiLFwiZXhwXCIpKX0sRnM9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkZsb29yXCIsXCJmbG9vclwiKSl9LHFzPWU9PntsZXQgdD1fdChlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiR2VsdVwiLHI9PmAwLjUgKiAke3J9ICogKDEuMCArIGVyZl92ZjMyKCR7cn0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsWG4oYHZlYzQ8JHt0fT5gLHQpKSl9LGpzPShlLHQpPT57bGV0IHI9X3QoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLGE9PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke2F9LCAke2F9LCAke2F9ID49IHZlYzQ8JHtyfT4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7cn0oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LEtzPWU9PntlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LFlzPWU9PntlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LFpzPWU9PntlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxYcz1lPT57bGV0IHQ9X3QoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIlJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8JHt0fT4oMC4wKSwgJHtyfSwgJHtyfSA+IHZlYzQ8JHt0fT4oMC4wKSlgKSl9LFFzPWU9PntlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSxKcz1lPT54ZShlKSxldT0oZSx0KT0+e2xldCByPV90KGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJIYXJkU2lnbW9pZFwiLGE9PmBtYXgodmVjNDwke3J9PigwLjApLCBtaW4odmVjNDwke3J9PigxLjApLCAke3QuYWxwaGF9ICogJHthfSArIHZlYzQ8JHtyfT4oJHt0LmJldGF9KSkpYCx2b2lkIDAsdC5jYWNoZUtleSkpfSx0dT1lPT57ZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxydT1lPT57ZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LG51PWU9PntlLmNvbXB1dGUoRWUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0sYXU9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0saXU9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIlRhbmhcIix0PT5gc2lnbigke3R9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7dH0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke3R9KSkpYCkpfSxvdT0oZSx0KT0+e2xldCByPV90KGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtyZXR1cm4gZS5jb21wdXRlKEVlKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIsYT0+YHNlbGVjdCh2ZWM0PCR7cn0+KDAuMCksICR7YX0sICR7YX0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtyfT4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMH0sc3U9ZT0+e2UuY29tcHV0ZShFZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX19KTt2YXIgTmMsVmMsdXUsbHU9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7X2UoKTtYYSgpO05jPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVsyNTYwLDUxMjAsMTAyNDBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwiaGlkZGVuIHN0YXRlIHNob3VsZCBiZSAyNTYwLCA1MTIwIG9yIDEwMjQwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LFZjPWU9PntsZXQgdD1lWzBdLmRpbXMuc2xpY2UoKTt0WzJdPXRbMl0vMjtsZXQgcj1XKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyw0KSxhPVcoXCJiaWFzXCIsZVswXS5kYXRhVHlwZSxbZVswXS5kaW1zWzJdXSw0KSxpPUooXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHQsNCkscz1OLnNpemUodCkvNCxvPUhlKGVbMF0uZGF0YVR5cGUpO3JldHVybntuYW1lOlwiQmlhc1NwbGl0R2VsdVwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9fSksZ2V0U2hhZGVyU291cmNlOnA9PmBcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtlWzBdLmRpbXNbMl0vNC8yfXU7XG5cbiAgJHtwLmRlY2xhcmVWYXJpYWJsZXMocixhLGkpfVxuXG4gICR7WG4oYHZlYzQ8JHtvfT5gLG8pfVxuXG4gICR7cC5tYWluU3RhcnQoKX1cbiAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke2kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sdXU9ZT0+e05jKGUuaW5wdXRzKSxlLmNvbXB1dGUoVmMoZS5pbnB1dHMpKX19KTt2YXIgSGMsTGMsUHQsZHUsY3UscHUsZnUsbXUsaHUsZ3UseXUsYnUsdnUsd3U9USgoKT0+e1widXNlIHN0cmljdFwiO3plKCk7Q2UoKTtfZSgpO0hjPShlLHQscixhLGkscyxvLGMscCxtLGwsZyk9PntsZXQgYix3O3R5cGVvZiBjPT1cInN0cmluZ1wiP2I9dz0oUyxFKT0+YCR7Y30oKCR7U30pLCgke0V9KSlgOnR5cGVvZiBjPT1cImZ1bmN0aW9uXCI/Yj13PWM6KGI9Yy5zY2FsYXIsdz1jLnZlY3Rvcik7bGV0ICQ9SihcIm91dHB1dERhdGFcIixsLGEubGVuZ3RoLDQpLHg9VyhcImFEYXRhXCIscCx0Lmxlbmd0aCw0KSxUPVcoXCJiRGF0YVwiLG0sci5sZW5ndGgsNCksQztpZihpKWlmKHMpe2xldCBTPU4uc2l6ZSh0KT09PTEsRT1OLnNpemUocik9PT0xLE89dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MCxVPXIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0lND09PTA7U3x8RT9DPSQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdyhTP2Ake3gudHlwZS52YWx1ZX0oJHt4LmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOnguZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLEU/YCR7VC50eXBlLnZhbHVlfSgke1QuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6VC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTpDPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHskLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIiwkKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7VC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIiwkKX07XG4gICAgICAgICAgICAkeyQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdyhvfHxPP3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIik6YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIil9W29mZnNldEEgJSA0dV0pYCxvfHxVP1QuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIik6YCR7VC50eXBlLnZhbHVlfSgke1QuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIil9W29mZnNldEIgJSA0dV0pYCkpfVxuICAgICAgICAgIGB9ZWxzZSBDPSQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdyh4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxULmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCBTPShFLE8sVT1cIlwiKT0+e2xldCBEPWBhRGF0YVtpbmRleEEke099XVtjb21wb25lbnRBJHtPfV1gLFY9YGJEYXRhW2luZGV4QiR7T31dW2NvbXBvbmVudEIke099XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke099ID0gJHskLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtPfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7T30gPSAke3guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke099YCwkKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7T30gPSAke1QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke099YCwkKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtPfSA9IG9mZnNldEEke099IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtPfSA9IG9mZnNldEIke099IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7T30gPSBvZmZzZXRBJHtPfSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke099ID0gb2Zmc2V0QiR7T30gJSA0dTtcbiAgICAgICAgICAgICR7RX1bJHtPfV0gPSAke1V9KCR7YihELFYpfSk7XG4gICAgICAgICAgYH07bD09PTk/Qz1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7UyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtTKFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke1MoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7UyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOkM9YFxuICAgICAgICAgICAgJHtTKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHtTKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHtTKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHtTKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHgsVCwkKX1cblxuICAgICAgICAke2c/P1wiXCJ9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAke0N9XG4gICAgICB9YH0sTGM9KGUsdCxyLGEsaSxzLG89ci5kYXRhVHlwZSk9PntsZXQgYz0hTi5hcmVFcXVhbChyLmRpbXMsYS5kaW1zKSxwPXIuZGltcyxtPU4uc2l6ZShyLmRpbXMpLGw9ITEsZz0hMSxiPVtjXTtpZihjKXtsZXQgdz1BdC5jYWxjU2hhcGUoci5kaW1zLGEuZGltcywhMSk7aWYoIXcpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7cD13LG09Ti5zaXplKHApO2xldCAkPU4uc2l6ZShyLmRpbXMpPT09MSx4PU4uc2l6ZShhLmRpbXMpPT09MSxUPXIuZGltcy5sZW5ndGg+MCYmci5kaW1zW3IuZGltcy5sZW5ndGgtMV0lND09PTAsQz1hLmRpbXMubGVuZ3RoPjAmJmEuZGltc1thLmRpbXMubGVuZ3RoLTFdJTQ9PT0wO2IucHVzaCgkKSxiLnB1c2goeCksYi5wdXNoKFQpLGIucHVzaChDKTtsZXQgUz0xO2ZvcihsZXQgRT0xO0U8cC5sZW5ndGg7RSsrKXtsZXQgTz1yLmRpbXNbci5kaW1zLmxlbmd0aC1FXT8/MSxVPWEuZGltc1thLmRpbXMubGVuZ3RoLUVdPz8xO2lmKE89PT1VKVMqPU87ZWxzZSBicmVha31TJTQ9PT0wPyhnPSEwLGw9ITApOigkfHx4fHxUfHxDKSYmKGw9ITApfWVsc2UgbD0hMDtyZXR1cm4gYi5wdXNoKGwpLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6dCtiLm1hcCh3PT53LnRvU3RyaW5nKCkpLmpvaW4oXCJfXCIpLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTp3PT5IYyh3LHIuZGltcyxhLmRpbXMscCxsLGMsZyxpLHIuZGF0YVR5cGUsYS5kYXRhVHlwZSxvLHMpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cCxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6TWF0aC5jZWlsKE4uc2l6ZShwKS80KX0sLi4uTChyLmRpbXMpLC4uLkwoYS5kaW1zKSwuLi5MKHApXX0pfX0sUHQ9KGUsdCxyLGEsaSxzKT0+e2UuY29tcHV0ZShMYyh0LGk/P1wiXCIsZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0scixhLHMpKX0sZHU9ZT0+e1B0KGUsXCJBZGRcIiwodCxyKT0+YCR7dH0rJHtyfWApfSxjdT1lPT57UHQoZSxcIkRpdlwiLCh0LHIpPT5gJHt0fS8ke3J9YCl9LHB1PWU9PntQdChlLFwiRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH09PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT09JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxmdT1lPT57UHQoZSxcIk11bFwiLCh0LHIpPT5gJHt0fSoke3J9YCl9LG11PWU9PntsZXQgdD1XKFwiaW5wdXRcIixlLmlucHV0c1swXS5kYXRhVHlwZSxlLmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO1B0KGUsXCJQb3dcIix7c2NhbGFyOihhLGkpPT5gcG93X2N1c3RvbSgke2F9LCR7aX0pYCx2ZWN0b3I6KGEsaSk9PmBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7aX0pYH0sYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dH0sIGIgOiAke3R9KSAtPiAke3R9IHtcbiAgICAgIGlmIChiID09ICR7dH0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0fSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0fSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0fSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0fSgyLjApKSkgIT0gMS4wKSAqICR7dH0oJHt0PT09XCJpMzJcIj9cInJvdW5kXCI6XCJcIn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dH0+LCBiIDogdmVjNDwke3R9PikgLT4gdmVjNDwke3R9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dH0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKX0saHU9ZT0+e1B0KGUsXCJTdWJcIiwodCxyKT0+YCR7dH0tJHtyfWApfSxndT1lPT57UHQoZSxcIkdyZWF0ZXJcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PiR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0seXU9ZT0+e1B0KGUsXCJMZXNzXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PCR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fTwke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGJ1PWU9PntQdChlLFwiR3JlYXRlck9yRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT49JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSx2dT1lPT57UHQoZSxcIkxlc3NPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PD0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX19KTt2YXIgRmMscWMsamMsS2MsJHUsX3UsU3U9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7WGUoKTtfZSgpO0ZjPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtsZXQgdD1lWzBdLmRhdGFUeXBlLHI9ZVswXS5kaW1zLmxlbmd0aDtmb3IobGV0IGEgb2YgZSl7aWYoYS5kYXRhVHlwZSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoYS5kaW1zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX19LHFjPShlLHQpPT5gXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtlfXU+KCR7dH0pO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbiAgfWAsamM9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxhPVtdO2ZvcihsZXQgaT0wO2k8cjsrK2kpe2xldCBzPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtpXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtyPT09MT9hLnB1c2gocyk6aT09PTA/YS5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke2l9dSkgeyAke3N9IH1gKTppPT09ci0xP2EucHVzaChgZWxzZSB7ICR7c30gfWApOmEucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke2l9KSB7ICR7c30gfWApfXJldHVybiBhLmpvaW4oYFxuYCl9LEtjPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLnNsaWNlKCk7aWYodD49ci5sZW5ndGh8fHQ8LTEqci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO2xldCBhPXQ8MD9yLmxlbmd0aCt0OnQsaT1yLnNsaWNlKDApO2ZvcihsZXQgQz0xO0M8ZS5sZW5ndGg7QysrKXtsZXQgUz1lW0NdLmRpbXMuc2xpY2UoKTtmb3IobGV0IEU9MDtFPHIubGVuZ3RoO0UrKylpZihFPT09YSlpW2FdKz1TW0VdO2Vsc2UgaWYocltFXSE9PVNbRV0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9bGV0IHM9Ti5zaXplKGkpLG89bmV3IEFycmF5KGUubGVuZ3RoKSxjPW5ldyBBcnJheShlLmxlbmd0aCkscD1lWzBdLmRhdGFUeXBlLG09MCxsPVtdLGc9W10sYj1be3R5cGU6XCJ1aW50MzJcIixkYXRhOnN9XTtmb3IobGV0IEM9MDtDPGUubGVuZ3RoOysrQyltKz1lW0NdLmRpbXNbYV0sb1tDXT1tLGcucHVzaChlW0NdLmRpbXMubGVuZ3RoKSxjW0NdPVcoYGlucHV0JHtDfWAscCxnW0NdKSxsLnB1c2goXCJyYW5rXCIpLGIucHVzaCh7dHlwZTpcInVpbnQzMlwiLGRhdGE6b1tDXX0pO2ZvcihsZXQgQz0wO0M8ZS5sZW5ndGg7KytDKWIucHVzaCguLi5MKGVbQ10uZGltcykpO2IucHVzaCguLi5MKGkpKTtsZXQgdz1KKFwib3V0cHV0XCIscCxpLmxlbmd0aCksJD13LmluZGljZXNHZXQoXCJpbmRpY2VzXCIsYSkseD1BcnJheS5mcm9tKEFycmF5KG8ubGVuZ3RoKS5rZXlzKCkpLm1hcChDPT5gdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7Q31gKS5qb2luKFwiLFwiKSxUPUM9PmBcblxuICAkeygoKT0+e0MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpO2ZvcihsZXQgUz0wO1M8ZS5sZW5ndGg7UysrKUMucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtTfWAsXCJ1MzJcIik7cmV0dXJuIEMuZGVjbGFyZVZhcmlhYmxlcyguLi5jLHcpfSkoKX1cblxuICAke3FjKG8ubGVuZ3RoLHgpfVxuXG4gICR7Qy5tYWluU3RhcnQoKX1cbiAgICAke0MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgkeyR9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7by5sZW5ndGh9dT4oJHt4fSk7XG4gICAgICAkeyR9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcbiAgICB9XG5cbiAgICAke2pjKGMsdyl9XG4gIH1gO3JldHVybntuYW1lOlwiQ29uY2F0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOmx9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9LHByb2dyYW1Vbmlmb3JtczpifSksZ2V0U2hhZGVyU291cmNlOlR9fSwkdT0oZSx0KT0+e0ZjKGUuaW5wdXRzKSxlLmNvbXB1dGUoS2MoZS5pbnB1dHMsdC5heGlzKSl9LF91PWU9PnhlKHtheGlzOmUuYXhpc30pfSk7dmFyIFJ0LFFuLGp0PVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1J0PShlLHQpPT57c3dpdGNoKGUuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnJldHVybmB2YWx1ZSA9IG1heCh2YWx1ZSwgJHt0fSgwLjApKTtgO2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm5gdmFsdWUgPSAoJHt0fSgxLjApIC8gKCR7dH0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtjYXNlXCJDbGlwXCI6cmV0dXJuYHZhbHVlID0gY2xhbXAodmFsdWUsICR7dH0odW5pZm9ybXMuY2xpcF9taW4pLCAke3R9KHVuaWZvcm1zLmNsaXBfbWF4KSk7YDtkZWZhdWx0OnJldHVyblwiXCJ9fSxRbj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJDbGlwXCIpe2xldFtyLGFdPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbR24sRm5dO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDphLGNsaXBNaW46cn19cmV0dXJue2FjdGl2YXRpb246dH19fSk7dmFyIGplLEpuLGVhPVEoKCk9PntcInVzZSBzdHJpY3RcIjtqZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxKbj1lPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgdGEsUWE9USgoKT0+e1widXNlIHN0cmljdFwiO3RhPWU9PmBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke2V9LngpLCBpMzIoJHtlfS55KSwgaTMyKCR7ZX0ueiksIDEpKTtcbn1cbmB9KTt2YXIgWWMsWmMsWHIseHUsWGMsUXIsUWMscmEsSnI9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7X2UoKTtqdCgpO2VhKCk7WWM9KGUsdCk9PmU/YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgOmBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGAsWmM9KGUsdCk9PmU/YFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7dD09PTM/XCJcIjpcImxldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107XCJ9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldO1wifVxuICAgICAgICB9YDpgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldO1wifVxuICAgICAgICB9YCxYcj0oZSx0LHI9XCJmMzJcIixhLGk9ITEscz0zMixvPSExLGM9MzIpPT57bGV0IHA9dFsxXSplWzFdLG09dFswXSplWzBdLGw9aT9wOnMsZz1pP3M6cCxiPWwvdFswXSx3PXMvdFsxXTtpZighKChpJiZiPT09NCYmZVsxXT09PTR8fCFpJiYoYj09PTN8fGI9PT00KSkmJmwldFswXT09PTAmJnMldFsxXT09PTAmJmVbMF09PT00KSl0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHtpfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7Yn0gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHtlWzFdfSBtdXN0IGJlIDQuXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHtifSBtdXN0IGJlIDMgb3IgNC5cbiAgdGlsZUFXaWR0aCAke2x9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHtzfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke2J9PCR7cn0+LCAke2wvYn0+LCAke2d9PjtcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHtyfT4sICR7bS9lWzBdfT4sICR7c30+O1xuXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke2J9O1xuY29uc3QgdGlsZUlubmVyID0gJHtzfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XG4gIGxldCBiYXRjaCA9ICR7bz9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgJHthP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcblxuICBsZXQgbnVtX3RpbGVzID0gJHtvP2Ake01hdGguY2VpbChjL3MpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICB2YXIga1N0YXJ0ID0gJHtvP2BpMzIoZ2xvYmFsSWQueikgKiAke2N9YDpcIjBcIn07XG5cbiAgdmFyIGFjYzogYXJyYXk8dmVjNDwke3J9Piwgcm93UGVyVGhyZWFkPjtcblxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke3d9O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICR7WWMoaSxhKX1cbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7d307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHthP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xuICAgICAgICAgICR7Yj09PTM/XCJcIjpcImxldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTtcIn1cblxuICAgICAgICAgICR7WmMoaSxiKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWB9LHh1PShlLHQpPT5lP2BcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYDpgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGAsWGM9ZT0+ZT9cImxldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddO1wiOlwibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107XCIsUXI9KGUsdCxyPVwiZjMyXCIsYSxpPSExLHM9MzIsbz0hMSxjPTMyLHA9ITEpPT57bGV0IG09ZVsxXSp0WzFdLGw9ZVswXSp0WzBdLGc9aT9tOnMsYj1pP3M6bTtpZighKGIldFsxXT09PTAmJmcldFswXT09PTAmJnMldFsxXT09PTApKXRocm93IG5ldyBFcnJvcihgdGlsZUFIaWdodCAke2J9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19LCB0aWxlQVdpZHRoICR7Z30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0sIHRpbGVJbm5lciAke3N9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3RbMV19YCk7bGV0IHc9Yi90WzFdLCQ9Zy90WzBdLHg9cy90WzFdLFQ9cD9gXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHttfTtcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke2x9O1xuXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2J9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7Z307IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgJHt4dShpLGEpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7c307IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7bH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke2E/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7dFswXX1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke2k/YG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dO2A6YG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dW2tdO2B9XG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfTtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt0WzBdfTtcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYDpgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke219O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7d307XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7JH07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7eH07XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHt3fTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHskfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHt4dShpLGEpfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7eH07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHthP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgfVxuICB9XG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICR7WGMoaSl9XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcbn1cblxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gIH1cbn1cbmA7cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHtnfT4sICR7Yn0+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHtsfT4sICR7c30+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke3N9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gICAgbGV0IGJhdGNoID0gJHtvP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAgICR7YT9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gICAgbGV0IG51bV90aWxlcyA9ICR7bz9gJHtNYXRoLmNlaWwoYy9zKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgICB2YXIga1N0YXJ0ID0gJHtvP2BpMzIoZ2xvYmFsSWQueikgKiAke2N9YDpcIjBcIn07XG5cbiAgICB2YXIgYWNjIDogYXJyYXk8YXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcblxuICAgIC8vIFdpdGhvdXQgdGhpcyBpbml0aWFsaXphdGlvbiBzdHJhbmdlIHZhbHVlcyBzaG93IHVwIGluIGFjYy5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSAwLjA7XG4gICAgICB9XG4gICAgfVxuICAgICR7VH1cbiAgfVxuYH0sUWM9KGUsdCxyLGEsaSxzPSExKT0+e2xldFtvLGMscF09aSxbbSxsLGcsYl09YSx3PXdyKG8scCksJD13cihjLHApLHg9SGUoYVswXS50eXBlLnRlbnNvciksVD0oKT0+e2xldCBFPWwucmFuayxPPW0ucmFuayxVPWB2YXIgYUluZGljZXM6ICR7bC50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBEPUUtMi0xLFY9Ty0xO0Q+PTA7RC0tLFYtLSlVKz1gXG5hSW5kaWNlc1ske0R9XSA9ICR7Tz4xP2BiYXRjaEluZGljZXNbJHtWfV1gOlwiYmF0Y2hJbmRpY2VzXCJ9O2A7cmV0dXJuIHcuZm9yRWFjaChEPT57VSs9YFxuYUluZGljZXNbJHtEfV0gPSAwO2B9KSxVKz1gXG5hSW5kaWNlc1ske0UtMn1dID0gdTMyKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgYUluZGljZXNbJHtFLTF9XSA9IHUzMihjb2xJbik7YCxVfSxDPSgpPT57bGV0IEU9Zy5yYW5rLE89bS5yYW5rLFU9YHZhciBiSW5kaWNlczogJHtnLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IEQ9RS0yLTEsVj1PLTE7RD49MDtELS0sVi0tKVUrPWBcbmJJbmRpY2VzWyR7RH1dID0gJHtPPjE/YGJhdGNoSW5kaWNlc1ske1Z9XWA6XCJiYXRjaEluZGljZXNcIn07YDtyZXR1cm4gJC5mb3JFYWNoKEQ9PntVKz1gXG5iSW5kaWNlc1ske0R9XSA9IDA7YH0pLFUrPWBcbmJJbmRpY2VzWyR7RS0yfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBiSW5kaWNlc1ske0UtMX1dID0gdTMyKGNvbEluKTtgLFV9O3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke20udHlwZS5pbmRpY2VzfSkgLT4gJHtqZShlLHgpfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke2plKGUseCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxuICAgICAge1xuICAgICAgICAke1QoKX1cbiAgICAgICAgdmFsdWUgPSAke2wuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7bS50eXBlLmluZGljZXN9KSAtPiAke2plKGUseCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7amUoZSx4KX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICAgICR7QygpfVxuICAgICAgICB2YWx1ZSA9ICR7Zy5nZXRCeUluZGljZXMoXCJiSW5kaWNlc1wiKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7amUoZSx4KX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7dD9gdmFsdWUgPSB2YWx1ZSArICR7cz9cImJpYXNbY29sSW5dXCI6YCR7amUoZSx4KX0oYmlhc1tyb3ddKWB9O2A6XCJcIn1cbiAgICAgICAgJHtyfVxuICAgICAgICAke2Iuc2V0QnlJbmRpY2VzKFwidmVjMzx1MzI+KGNvb3JkcylcIixcInZhbHVlXCIpfVxuICAgICAgfVxuICAgIH1cbiAgICBgfSxyYT0oZSx0LHIsYSxpPSExKT0+e2xldCBzPWVbMF0uZGltcyxvPWVbMV0uZGltcyxjPXMuc2xpY2UoMCwtMikscD1vLnNsaWNlKDAsLTIpLG09YT9hLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksbD1OLnNpemUobSksZz1zW3MubGVuZ3RoLTJdLGI9c1tzLmxlbmd0aC0xXSx3PW9bby5sZW5ndGgtMV0sJD1iJTQ9PT0wJiZ3JTQ9PT0wLHg9Zzw9OD9bNCwxLDFdOls0LDQsMV0sVD1bOCw4LDFdLEM9W01hdGguY2VpbCh3L1RbMF0veFswXSksTWF0aC5jZWlsKGcvVFsxXS94WzFdKSxNYXRoLmNlaWwobC9UWzJdL3hbMl0pXSxTPSQ/NDoxLEU9Wy4uLmMsZyxiL1NdLE89RS5sZW5ndGgsVT1bLi4ucCxiLHcvU10sRD1VLmxlbmd0aCxWPVtsLGcsdy9TXSxZPVt7dHlwZTpcImludDMyXCIsZGF0YTpnfSx7dHlwZTpcImludDMyXCIsZGF0YTp3fSx7dHlwZTpcImludDMyXCIsZGF0YTpifV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJlkucHVzaCh7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuY2xpcE1heH0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNaW59KSxZLnB1c2goLi4uTChtKSwuLi5MKEUpLC4uLkwoVSkpO2xldCBzZT1bXCJyYW5rXCIsXCJyYW5rXCJdLEI9ZS5sZW5ndGg+MjtCJiYoWS5wdXNoKC4uLkwoZVsyXS5kaW1zKSksc2UucHVzaChcInJhbmtcIikpLFkucHVzaCguLi5MKFYpKTtsZXQgdGU9a2U9PntsZXQgT2U9bS5sZW5ndGgsZWU9cW4oXCJiYXRjaERpbXNcIixlWzBdLmRhdGFUeXBlLE9lLDEpLGJlPUhlKGVbMF0uZGF0YVR5cGUpLFVlPVcoXCJhXCIsZVswXS5kYXRhVHlwZSxPLFMpLHBlPVcoXCJiXCIsZVsxXS5kYXRhVHlwZSxELFMpLHllPUooXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLFYubGVuZ3RoLFMpLGRlPVtVZSxwZV07aWYoQil7bGV0IEdlPWk/UzoxO2RlLnB1c2goVyhcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsR2UpKX1sZXQgdmU9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJnZlLnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pO2xldCBXZT1SdCh0LHllLnR5cGUudmFsdWUpLEJlPVFjKFMsQixXZSxbZWUsVWUscGUseWVdLFtjLHAsbV0saSk7cmV0dXJuYFxuICAke2tlLnJlZ2lzdGVyVW5pZm9ybXModmUpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoZWUpLmRlY2xhcmVWYXJpYWJsZXMoLi4uZGUseWUpfVxuICAke0JlfVxuICAkeyQ/WHIoeCxULGJlLGVlKTpRcih4LFQsYmUsZWUpfVxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHt0LmFjdGl2YXRpb259OyR7JH07JHtpfWAsaW5wdXREZXBlbmRlbmNpZXM6c2V9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpDWzBdLHk6Q1sxXSx6OkNbMl19LHByb2dyYW1Vbmlmb3JtczpZfSksZ2V0U2hhZGVyU291cmNlOnRlfX19KTt2YXIgSmMsQ3UsSXU9USgoKT0+e1widXNlIHN0cmljdFwiO3F0KCk7X2UoKTtqdCgpO2VhKCk7UWEoKTtKcigpO0pjPShlLHQscixhLGk9ITEscyxvPTQsYz00LHA9NCxtPVwiZjMyXCIpPT57bGV0IGw9Qj0+e3N3aXRjaChCKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHttfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7Qn0gaXMgbm90IHN1cHBvcnRlZC5gKX19LGc9Qj0+e3N3aXRjaChCKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0J9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxiPWU/YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XG4gICAgYCx3PWU/YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGAsJD1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIix4PWU/XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzNdKVwiLFQ9ZT9cInJvd1wiOlwiY29sXCIsQz1lP1wiY29sXCI6XCJyb3dcIixTPWBcbiAgICBsZXQgaW5DaGFubmVscyA9IGkzMih1bmlmb3Jtcy53X3NoYXBlWzJdKTtcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgbGV0IG91dFJvdyA9ICR7VH0gLyBvdXRXaWR0aDtcbiAgICBsZXQgb3V0Q29sID0gJHtUfSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAke0N9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHtDfSAvIGluQ2hhbm5lbHMgJSBpMzIodW5pZm9ybXMud19zaGFwZVsxXSk7XG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiB1bmlmb3Jtcy5zdHJpZGVbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvblswXSAqIFdSb3cgLSB1bmlmb3Jtcy5wYWRbMF07XG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiB1bmlmb3Jtcy5zdHJpZGVbMV0gKyB1bmlmb3Jtcy5kaWxhdGlvblsxXSAqIFdDb2wgLSB1bmlmb3Jtcy5wYWRbMV07XG4gICAgbGV0IHhDaCA9ICR7Q30gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHtqZShvLG0pfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHskfSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7eH0pIHtcbiAgICAgICR7Yn1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7bChvKX1cbiAgICB9XG4gICAgcmV0dXJuIHJlc0RhdGE7YCxFPWU/dCYmYT9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtvfTtcbiAgICAke1N9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtvfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke1N9XG4gICAgfVxuICAgIHJldHVybiAke2plKG8sbSl9KDAuMCk7YDphJiZyP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke299O1xuICAgICR7U31gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke299O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7U31cbiAgICB9XG4gICAgcmV0dXJuICR7amUobyxtKX0oMC4wKTtgLE89YCR7ZyhjKX1gLFU9amUocCxtKSxEPWU/amUobyxtKTpqZShjLG0pLFY9ZT9qZShjLG0pOmplKG8sbSksWT1SdChzLFUpO3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke0R9IHtcbiAgICAgICR7ZT9FOk99XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtWfSB7XG4gICAgICAke2U/TzpFfVxuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke1V9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke3B9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKVwifTtcbiAgICAgICR7d31cbiAgICAgICR7Sm4oaSl9XG4gICAgICAke1l9XG4gICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9YH0sQ3U9KGUsdCxyLGEsaSxzLG8sYyk9PntsZXQgcD10LmZvcm1hdD09PVwiTkhXQ1wiLG09cD9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGw9clswXSxnPXA/clsyXTpyWzNdLGI9cD9yWzFdOnJbMl0sdz1wP3JbM106clsxXSwkPXAmJihtJTQ9PT0wfHxtJTM9PT0wKSYmdyU0PT09MCx4PXA/dzpnKmIsVD1wP2cqYjp3LEM9WzgsOCwxXSxTPWE8PTg/WzQsMSwxXTpbNCw0LDFdLEU9W01hdGguY2VpbCh4L0NbMF0vU1swXSksTWF0aC5jZWlsKFQvQ1sxXS9TWzFdKSxNYXRoLmNlaWwobC9DWzJdL1NbMl0pXTtEZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7RX1gKTtsZXQgTz0kP3AmJm0lNCE9PTA/Mzo0OjEsVT1DWzFdKlNbMV0sRD1DWzBdKlNbMF0sVj1NYXRoLm1heChDWzBdKk8sQ1sxXSksWT1hJVU9PT0wLHNlPWklRD09PTAsQj1zJVY9PT0wLHRlPSQ/W08sNCw0XTpbMSwxLDFdLGtlPVt7dHlwZTpcImludDMyXCIsZGF0YTphfSx7dHlwZTpcImludDMyXCIsZGF0YTppfSx7dHlwZTpcImludDMyXCIsZGF0YTpzfSx7dHlwZTpcImludDMyXCIsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOlwiaW50MzJcIixkYXRhOnQuc3RyaWRlc30se3R5cGU6XCJpbnQzMlwiLGRhdGE6dC5kaWxhdGlvbnN9XTt0LmFjdGl2YXRpb249PT1cIkNsaXBcIiYma2UucHVzaCh7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuY2xpcE1heH0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNaW59KSxrZS5wdXNoKC4uLkwoZVswXS5kaW1zKSwuLi5MKGVbMV0uZGltcykpO2xldCBPZT1bXCJyYW5rXCIsXCJyYW5rXCJdO28mJihrZS5wdXNoKC4uLkwoZVsyXS5kaW1zKSksT2UucHVzaChcInJhbmtcIikpLGtlLnB1c2goLi4uTChyKSk7bGV0IGVlPWJlPT57bGV0IFVlPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJlVlLnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pO2xldCBwZT0kPzQ6MSx5ZT1IZShlWzBdLmRhdGFUeXBlKSxkZT1gXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAkeyQ/YHZlYzQ8JHt5ZX0+YDp5ZX0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAkeyQ/YHZlYzQ8JHt5ZX0+YDp5ZX0odmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHskP2B2ZWM0PCR7eWV9PmA6eWV9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7JD9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XG4gICAgICB9YCx2ZT1XKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxPPT09Mz8xOk8pLFdlPVcoXCJ3XCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLHBlKSxCZT1bdmUsV2VdLEdlPUooXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLHBlKTtpZihvKXtsZXQgRj1XKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxwZSk7QmUucHVzaChGKSxkZSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAkeyQ/YHZlYzQ8JHt5ZX0+YDp5ZX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke3A/XCJ3XCI6XCJ5XCJ9JHskP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1yZXR1cm5gXG4gICAgICAgICR7dGEoXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7YmUucmVnaXN0ZXJVbmlmb3JtcyhVZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5CZSxHZSl9XG4gICAgICAgICR7ZGV9XG4gICAgICAgICR7SmMocCxZLHNlLEIsbyx0LHRlWzBdLHRlWzFdLHRlWzJdLHllKX1cbiAgICAgICAgJHskP1hyKFMsQyx5ZSx2b2lkIDAsIXAsVik6UXIoUyxDLHllLHZvaWQgMCwhcCxWLCExLHZvaWQgMCxjKX1gfTtyZXR1cm57bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7T307JHskfTske1l9OyR7c2V9OyR7Qn07JHtVfTske0R9OyR7Vn1gLGlucHV0RGVwZW5kZW5jaWVzOk9lfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6RVswXSx5OkVbMV0sejpFWzJdfSxwcm9ncmFtVW5pZm9ybXM6a2V9KSxnZXRTaGFkZXJTb3VyY2U6ZWV9fX0pO3ZhciBKYSxBdT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtfZSgpO3RpKCk7anQoKTtKYT0oZSx0LHIpPT57bGV0IGE9ZS5sZW5ndGg+MixpPWE/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLHM9ZVswXS5kaW1zLG89ZVsxXS5kaW1zLGM9b1swXS90Lmdyb3VwLHA9dC5mb3JtYXQ9PT1cIk5IV0NcIixtPWVpKHMsbyx0LmRpbGF0aW9ucyx0LnBhZHMsdC5zdHJpZGVzLHApLGw9Ti5zaXplKG0pLGc9W3t0eXBlOlwidWludDMyXCIsZGF0YTpsfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5kaWxhdGlvbnN9LHt0eXBlOlwidWludDMyXCIsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOlwidWludDMyXCIsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOlwidWludDMyXCIsZGF0YTpjfV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJmcucHVzaCh7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuY2xpcE1heH0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNaW59KSxnLnB1c2goLi4uTChzKSwuLi5MKG8pLC4uLkwobSkpO2xldCBiPVtcInJhbmtcIixcInJhbmtcIl07YSYmKGcucHVzaCguLi5MKGVbMl0uZGltcykpLGIucHVzaChcInJhbmtcIikpLGcucHVzaCguLi5MKG0pKTtsZXQgdz0kPT57bGV0IHg9SihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbS5sZW5ndGgpLFQ9UnQodCx4LnR5cGUudmFsdWUpLEM9VyhcInhcIixlWzBdLmRhdGFUeXBlLHMubGVuZ3RoKSxTPVcoXCJ3XCIsZVsxXS5kYXRhVHlwZSxvLmxlbmd0aCksRT1bQyxTXTthJiZFLnB1c2goVyhcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcykpO2xldCBPPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5kaWxhdGlvbnMubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV07cmV0dXJuIHQuYWN0aXZhdGlvbj09PVwiQ2xpcFwiJiZPLnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pLGBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoTykuZGVjbGFyZVZhcmlhYmxlcyguLi5FLHgpfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke3gub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske3A/MzoxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtwPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7cD8yOjN9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcblxuICAgIHZhciB2YWx1ZTogJHt4LnR5cGUudmFsdWV9ID0gJHt4LnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogdW5pZm9ybXMud19zaGFwZVsxXSArIHdJbkNoYW5uZWw7XG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVske3A/MToyfV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbM107IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVske3A/MjozfV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB4VmFsID0gJHtwP0MuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKTpDLmdldChcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIil9O1xuICAgICAgICAgIGxldCB3VmFsID0gJHtTLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAke2l9XG4gICAgJHtUfVxuICAgICR7eC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH07cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6Yn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyP3IobSk6bSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpnfSksZ2V0U2hhZGVyU291cmNlOnd9fX0pO3ZhciByaSxlcCxUdSxuaT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtKcigpO19lKCk7anQoKTtyaT0oZSx0LHIsYSxpPSExKT0+e2xldCBzPWVbMF0uZGltcyxvPWVbMV0uZGltcyxjPXNbcy5sZW5ndGgtMl0scD1vW28ubGVuZ3RoLTFdLG09c1tzLmxlbmd0aC0xXSxsPUxlKHApLGc9TGUobSksYj1MZShjKSx3PU4uc2l6ZShyKS9sL2IsJD1lLmxlbmd0aD4yLHg9YT9hLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksQz1bTi5zaXplKHgpLGMscF0sUz1be3R5cGU6XCJ1aW50MzJcIixkYXRhOnd9LHt0eXBlOlwidWludDMyXCIsZGF0YTpjfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOm19XTt0LmFjdGl2YXRpb249PT1cIkNsaXBcIiYmUy5wdXNoKHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5jbGlwTWF4fSx7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuY2xpcE1pbn0pLFMucHVzaCguLi5MKHgpLC4uLkwocyksLi4uTChvKSksJCYmUy5wdXNoKC4uLkwoZVsyXS5kaW1zKSksUy5wdXNoKC4uLkwoQykpO2xldCBFPU89PntsZXQgVT1xbihcImJhdGNoX2RpbXNcIixlWzBdLmRhdGFUeXBlLHgubGVuZ3RoKSxEPVcoXCJhXCIsZVswXS5kYXRhVHlwZSxzLmxlbmd0aCxnKSxWPVcoXCJiXCIsZVsxXS5kYXRhVHlwZSxvLmxlbmd0aCxsKSxZPUooXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLEMubGVuZ3RoLGwpLHNlPVJ0KHQsWS50eXBlLnZhbHVlKSxCPVtELFZdLHRlPVwiXCI7aWYoJCl7bGV0IGRlPWk/bDoxO0IucHVzaChXKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxkZSkpLHRlPWAke2k/YHZhbHVlICs9IGJpYXNbY29sIC8gJHtkZX1dO2A6YHZhbHVlICs9ICR7WS50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgfWB9bGV0IGtlPXMuc2xpY2UoMCwtMiksT2U9by5zbGljZSgwLC0yKSxlZT13cihrZSx4KSxiZT13cihPZSx4KSxVZT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn1dO3QuYWN0aXZhdGlvbj09PVwiQ2xpcFwiJiZVZS5wdXNoKHtuYW1lOlwiY2xpcF9tYXhcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiY2xpcF9taW5cIix0eXBlOlwiZjMyXCJ9KTtsZXQgcGU9KGRlLHZlKT0+e2xldCBXZT1kZS5yYW5rLEJlPWRlLm5hbWU7aWYoV2U9PT0yKXJldHVybmB2YXIgJHtCZX1faW5kaWNlcyA9ICR7ZGUudHlwZS5pbmRpY2VzfSgwdSwgMHUpO2A7bGV0IEdlPVUucmFuayxGPWB2YXIgJHtCZX1faW5kaWNlczogJHtkZS50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBpZT1XZS0yLTEsaGU9R2UtMTtpZT49MDtpZS0tLGhlLS0pRis9YFxuJHtCZX1faW5kaWNlc1ske2llfV0gPSAke0dlPjE/YGJhdGNoX2luZGljZXNbJHtoZX1dYDpcImJhdGNoX2luZGljZXNcIn07YDtyZXR1cm4gdmUuZm9yRWFjaChpZT0+e0YrPWBcbiR7QmV9X2luZGljZXNbJHtpZX1dID0gMDtgfSksRis9YCR7QmV9X2luZGljZXNbJHtXZS0yfV0gPSAwdTtcbiAgICAgICAgICAgICAgICAgICAgICR7QmV9X2luZGljZXNbJHtXZS0xfV0gPSAwdTtgLEZ9LHllPSgpPT57bGV0IGRlPWB2YXIgYV9kYXRhOiAke0QudHlwZS52YWx1ZX07YDtmb3IobGV0IHZlPTA7dmU8Zzt2ZSsrKWRlKz1gXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke3ZlfSA9IGJbKGJfb2Zmc2V0ICsgKGsgKyAke3ZlfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7bH1dO2A7Zm9yKGxldCB2ZT0wO3ZlPGI7dmUrKyl7ZGUrPWBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke3ZlfSkgKiB1bmlmb3Jtcy5LICsgaykgLyAke2d9XTtgO2ZvcihsZXQgV2U9MDtXZTxnO1dlKyspZGUrPWBcbiAgICAgICAgICAgIHZhbHVlc1ske3ZlfV0gPSBmbWEoJHtWLnR5cGUudmFsdWV9KGFfZGF0YSR7Zz09PTE/XCJcIjpgWyR7V2V9XWB9KSwgYl9kYXRhJHtXZX0sIHZhbHVlc1ske3ZlfV0pO1xuYH1yZXR1cm4gZGV9O3JldHVybmBcbiAgJHtPLnJlZ2lzdGVyVW5pZm9ybXMoVWUpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoVSkuZGVjbGFyZVZhcmlhYmxlcyguLi5CLFkpfVxuICAke08ubWFpblN0YXJ0KCl9XG4gICAgJHtPLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7bH0pKSAqICR7bH07XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuTiAvICR7bH0pO1xuICAgIGxldCBzdHJpZGUxID0gdW5pZm9ybXMuTSAvICR7Yn07XG4gICAgbGV0IHJvdyA9IChpbmRleDEgJSBzdHJpZGUxKSAqICR7Yn07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gc3RyaWRlMTtcblxuICAgICR7ci5sZW5ndGg9PT0yP1wiXCI6YGxldCBiYXRjaF9pbmRpY2VzID0gJHtVLm9mZnNldFRvSW5kaWNlcyhcImJhdGNoXCIpfTtgfVxuICAgICR7cGUoRCxlZSl9XG4gICAgbGV0IGFfb2Zmc2V0ID0gJHtELmluZGljZXNUb09mZnNldChcImFfaW5kaWNlc1wiKX07XG4gICAgJHtwZShWLGJlKX1cbiAgICBsZXQgYl9vZmZzZXQgPSAke1YuaW5kaWNlc1RvT2Zmc2V0KFwiYl9pbmRpY2VzXCIpfTtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke1kudHlwZS52YWx1ZX0sICR7Yn0+O1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke2d9KSB7XG4gICAgICAke3llKCl9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7Yn11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7dGV9XG4gICAgICAke3NlfVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtZLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtZLmluZGljZXNUb09mZnNldChcImN1cl9pbmRpY2VzXCIpfTtcbiAgICAgICR7WS5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHtsfWAsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9XG4gIGB9O3JldHVybntuYW1lOlwiTWF0TXVsTmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmFjdGl2YXRpb259OyR7bH07JHtnfTske2J9OyR7aX1gLGlucHV0RGVwZW5kZW5jaWVzOiQ/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHcvNjQpfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpFfX0sZXA9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpfSxUdT1lPT57ZXAoZS5pbnB1dHMpO2xldCB0PUF0LmNhbGNTaGFwZShlLmlucHV0c1swXS5kaW1zLGUuaW5wdXRzWzFdLmRpbXMsITApO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IHI9dFt0Lmxlbmd0aC0xXSxhPWUuaW5wdXRzWzBdLmRpbXNbZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgtMV07cjw4JiZhPDg/ZS5jb21wdXRlKHJpKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCJ9LHQpKTplLmNvbXB1dGUocmEoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpfX0pO3ZhciBlaSxFdSx0cCxPdSxhaSxycCxucCxpaSx0aT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtJdSgpO0pyKCk7QXUoKTtqdCgpO25pKCk7JHIoKTtlaT0oZSx0LHIsYSxpLHMpPT57bGV0IG89ZVswXSxjPWUuc2xpY2Uocz8xOjIscz8zOjQpLHA9Yy5sZW5ndGgsbT10WzBdLGc9dC5zbGljZSgyKS5tYXAoKCQseCk9PiQrKCQtMSkqKHJbeF0tMSkpLHc9Yy5tYXAoKCQseCk9PiQrYVt4XSthW3grcF0pLm1hcCgoJCx4KT0+TWF0aC5mbG9vcigoJC1nW3hdK2lbeF0pL2lbeF0pKTtyZXR1cm4gdy5zcGxpY2UoMCwwLG8pLHcuc3BsaWNlKHM/MzoxLDAsbSksd30sRXU9WzIsMywxLDBdLHRwPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCBjb252IDFEIGFuZCAyRFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sYT1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihyIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgaT1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtpfURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5wYWRzLmxlbmd0aCE9PWkqMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7aSoyfURgKTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpfSxPdT0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtmb3IobGV0IHM9MjtzPHRbMV0uZGltcy5sZW5ndGg7KytzKXJbcy0yXT09PTAmJihyW3MtMl09dFsxXS5kaW1zW3NdKTtsZXQgYT1lLnBhZHMuc2xpY2UoKTtvci5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxyLGEsZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBpPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oaSx7a2VybmVsU2hhcGU6cixwYWRzOmF9KSxpfSxhaT1lPT57bGV0IHQ9UW4oZSkscj1lLmZvcm1hdCxhPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0saT1lLmRpbGF0aW9ucyxzPWUuZ3JvdXAsbz1lLmtlcm5lbF9zaGFwZSxjPWUucGFkcyxwPWUuc3RyaWRlcyxtPWUud19pc19jb25zdCgpO3JldHVybnthdXRvUGFkOmEsZm9ybWF0OnIsZGlsYXRpb25zOmksZ3JvdXA6cyxrZXJuZWxTaGFwZTpvLHBhZHM6YyxzdHJpZGVzOnAsd0lzQ29uc3Q6bSwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LHJwPShlLHQscik9PntsZXQgYT1PdShyLHQpLGk9ci5mb3JtYXQ9PT1cIk5IV0NcIjtpZihyLmdyb3VwIT09MSl7ZS5jb21wdXRlKEphKHQsYSkpO3JldHVybn1sZXQgcz10Lmxlbmd0aD09PTMsbz10WzBdLmRpbXNbaT8xOjJdLGM9dFswXS5kaW1zW2k/MjozXSxwPXRbMF0uZGltc1tpPzM6MV0sbT10WzFdLmRpbXNbMl0sbD10WzFdLmRpbXNbM10sZz1laSh0WzBdLmRpbXMsdFsxXS5kaW1zLHIuZGlsYXRpb25zLGEucGFkcyxyLnN0cmlkZXMsaSksYj1nW2k/MToyXSx3PWdbaT8yOjNdLCQ9Z1tpPzM6MV0seD1pJiZtPT09byYmbD09PWMmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTA7aWYoeHx8bT09PTEmJmw9PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MSYmci5zdHJpZGVzWzBdPT09MSYmci5zdHJpZGVzWzFdPT09MSYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MCl7bGV0IEQ9Z1swXSxWLFksc2UsQj1bXTtpZihpKXtsZXQgT2U9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoeHQodFsxXSxFdSkse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtpZihyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPU9lKSx4KXtsZXQgZWU9bypjKnA7Vj10WzBdLnJlc2hhcGUoWzEsRCxlZV0pLFk9T2UucmVzaGFwZShbMSxlZSwkXSksc2U9WzEsRCwkXX1lbHNlIFY9dFswXS5yZXNoYXBlKFtELG8qYyxwXSksWT1PZS5yZXNoYXBlKFsxLHAsJF0pLHNlPVtELGIqdywkXTtCLnB1c2goViksQi5wdXNoKFkpfWVsc2UgVj10WzBdLnJlc2hhcGUoW0QscCxvKmNdKSxZPXRbMV0ucmVzaGFwZShbMSwkLHBdKSxzZT1bRCwkLGIqd10sQi5wdXNoKFkpLEIucHVzaChWKTtzJiZCLnB1c2godFsyXSk7bGV0IHRlPXNlWzJdLGtlPUJbMF0uZGltc1tCWzBdLmRpbXMubGVuZ3RoLTFdO3RlPDgmJmtlPDg/ZS5jb21wdXRlKHJpKEIsYSxnLHNlLGkpLHtpbnB1dHM6Qn0pOmUuY29tcHV0ZShyYShCLGEsZyxzZSxpKSx7aW5wdXRzOkJ9KTtyZXR1cm59bGV0IFQ9ITAsQz1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZSh4dCh0WzFdLEV1KSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9Qyk7bGV0IFM9W3RbMF0sQ107cyYmUy5wdXNoKHRbMl0pO2xldCBFPWk/Yip3OiQsTz1pPyQ6Yip3LFU9bSpsKnA7ZS5jb21wdXRlKEN1KFMsYSxnLEUsTyxVLHMsVCkse2lucHV0czpTfSl9LG5wPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixhPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZhLnB1c2goZS5pbnB1dHNbMl0pO2xldCBpPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0scz1bMV0uY29uY2F0KHQuc3RyaWRlcyksbz1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSxjPVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSkscD1PdSh7Li4udCxwYWRzOmksc3RyaWRlczpzLGRpbGF0aW9uczpvLGtlcm5lbFNoYXBlOmN9LGEpO2UuY29tcHV0ZShKYShhLHAsbT0+cj9bbVswXSxtWzJdLG1bM11dOltdKSl9LGlpPShlLHQpPT57dHAoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zP25wKGUsdCk6cnAoZSxlLmlucHV0cyx0KX19KTt2YXIgYXAsa3UsUHU9USgoKT0+e1widXNlIHN0cmljdFwiO3F0KCk7X2UoKTtqdCgpO2VhKCk7UWEoKTtKcigpO2FwPShlLHQ9ITEscixhPTQpPT57bGV0IGk9amUoYSxcImYzMlwiKSxzPUM9Pntzd2l0Y2goQyl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1wiO2Nhc2UgNDpyZXR1cm5gXG4gICAgICAgICAgICBsZXQgY29vcmQxID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAxLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQyID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAyLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQzID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAzLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgdjAgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIGxldCB2MSA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQxLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIGxldCB2MiA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQyLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIGxldCB2MyA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQzLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIHJldHVybiB2ZWM0PGYzMj4odjAsIHYxLCB2MiwgdjMpO1xuICAgICAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0N9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxvPWU/YFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCBpWFIsIGlYQywgeENoKTtcbiAgICAgIGA6YFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIGlYUiwgaVhDKTtcbiAgICAgIGAsYz1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLHA9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIsbT1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIixsPWU/XCJyb3dcIjpcImNvbFwiLGc9ZT9cImNvbFwiOlwicm93XCIsYj1gXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzNdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pXCJ9O1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgICAgbGV0IG91dFJvdyA9ICR7bH0gLyBvdXRXaWR0aDtcbiAgICAgIGxldCBvdXRDb2wgPSAke2x9ICUgb3V0V2lkdGg7XG5cbiAgICAgIGxldCBXUm93ID0gJHtnfSAvICh1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXSAqIGluQ2hhbm5lbHMpO1xuICAgICAgbGV0IFdDb2wgPSAke2d9IC8gaW5DaGFubmVscyAlIHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdO1xuICAgICAgbGV0IHhSID0gZjMyKG91dFJvdyAtIHVuaWZvcm1zLnBhZHNbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvbnNbMF0gKiBXUm93KSAvIGYzMih1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgIGxldCB4QyA9IGYzMihvdXRDb2wgLSB1bmlmb3Jtcy5wYWRzWzFdICsgdW5pZm9ybXMuZGlsYXRpb25zWzFdICogV0NvbCkgLyBmMzIodW5pZm9ybXMuc3RyaWRlc1sxXSk7XG4gICAgICBpZiAoeFIgPCAwLjAgfHwgeFIgPj0gZjMyKCR7cH0pIHx8IGZyYWN0KHhSKSA+IDAuMCkge1xuICAgICAgICByZXR1cm4gJHtpfSgwLjApO1xuICAgICAgfVxuICAgICAgaWYgKHhDIDwgMC4wIHx8IHhDID49IGYzMigke219KSB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7aX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGxldCBpWFIgPSBpMzIoeFIpO1xuICAgICAgbGV0IGlYQyA9IGkzMih4Qyk7XG4gICAgICBsZXQgeENoID0gJHtnfSAlIGluQ2hhbm5lbHM7XG4gICAgICAke299XG4gICAgICByZXR1cm4geFtnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKS8ke2F9XTtgLHc9ZT9gXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2F9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgICAke2J9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHtpfSgwLjApO2A6YFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgJHtifVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7aX0oMC4wKTtgLCQ9YFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtlP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVsxXSlcIn07XG4gICAgICBsZXQgY29vcmRYID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF0gLSAxIC0gcm93IC8gKHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgY29vcmRZID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gLSAxIC0gKHJvdyAvIGluQ2hhbm5lbHMpICUgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV07XG4gICAgICBpZiAoJHtlP1wicm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyXCI6XCJyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXJcIn0gICYmIGNvb3JkWCA+PSAwICYmIGNvb3JkWSA+PSAwKSB7XG4gICAgICAgIGxldCByb3dJbm5lciA9IHJvdyAlIGluQ2hhbm5lbHM7XG4gICAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sLCByb3dJbm5lcik7XG4gICAgICAgICR7cyhhKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiAke2l9KDAuMCk7XG4gICAgICBgLHg9UnQocixpKTtyZXR1cm5gXG4gIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7aX0ge1xuICAgICR7ZT93OiR9XG4gIH1cblxuICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2l9IHtcbiAgICAke2U/JDp3fVxuICB9XG5cbiAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbnB1dCA6ICR7aX0pIHtcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2F9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbnB1dDtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKVwifTtcbiAgICAgICR7Y31cbiAgICAgICR7Sm4odCl9XG4gICAgICAke3h9XG4gICAgICByZXN1bHRbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzLCB2ZWM0PGkzMj4odW5pZm9ybXMucmVzdWx0X3NoYXBlKSkvJHthfV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1gfSxrdT0oZSx0LHIsYSxpLHMsbyxjKT0+e2xldCBwPXQuZm9ybWF0PT09XCJOSFdDXCIsbT1wP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sbD1yWzBdLGc9cD9yWzJdOnJbM10sYj1wP3JbMV06clsyXSx3PXA/clszXTpyWzFdLCQ9cD9tJTQ9PT0wJiZ3JTQ9PT0wOmclND09PTAmJnclND09PTAseD1wP3c6ZypiLFQ9cD9nKmI6dyxDPSQ/WzgsOCwxXTpbeDw9NHx8VDw9ND80OjE2LHg+NCYmVDw9ND80OjE2LDFdLFM9JD9bNCw0LDFdOlt4PD00PzE6NCx4PjQmJlQ8PTQ/MTo0LDFdLEU9W01hdGguY2VpbCh4L0NbMF0vU1swXSksTWF0aC5jZWlsKFQvQ1sxXS9TWzFdKSxNYXRoLmNlaWwobC9DWzJdL1NbMl0pXTtEZShcInZlcmJvc2VcIiwoKT0+YFtjb252X2JhY2twcm9wX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke0V9YCk7bGV0IE89JD80OjEsVT1NYXRoLm1heChDWzBdKk8sQ1sxXSksRD0kPzQ6MSxWPVt0Lmtlcm5lbFNoYXBlW3A/MToyXSx0Lmtlcm5lbFNoYXBlW3A/MjozXV0sWT1bVlswXSsodC5kaWxhdGlvbnNbMF08PTE/MDooVlswXS0xKSoodC5kaWxhdGlvbnNbMF0tMSkpLFZbMV0rKHQuZGlsYXRpb25zWzFdPD0xPzA6KFZbMV0tMSkqKHQuZGlsYXRpb25zWzFdLTEpKV0sc2U9W1lbMF0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMF0rdC5wYWRzWzJdKS8yKSxZWzFdLTEtTWF0aC5mbG9vcigodC5wYWRzWzFdK3QucGFkc1szXSkvMildLEI9W3t0eXBlOlwiaW50MzJcIixkYXRhOmF9LHt0eXBlOlwiaW50MzJcIixkYXRhOml9LHt0eXBlOlwiaW50MzJcIixkYXRhOnN9LHt0eXBlOlwiaW50MzJcIixkYXRhOnQuc3RyaWRlc30se3R5cGU6XCJpbnQzMlwiLGRhdGE6dC5kaWxhdGlvbnN9LHt0eXBlOlwiaW50MzJcIixkYXRhOlZ9LHt0eXBlOlwiaW50MzJcIixkYXRhOnNlfV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJkIucHVzaCh7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuY2xpcE1heH0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNaW59KSxCLnB1c2goLi4uTChlWzBdLmRpbXMpLC4uLkwoZVsxXS5kaW1zKSk7bGV0IHRlPVtcInJhbmtcIixcInJhbmtcIl07byYmKEIucHVzaCguLi5MKGVbMl0uZGltcykpLHRlLnB1c2goXCJyYW5rXCIpKSxCLnB1c2goLi4uTChyKSk7bGV0IGtlPU9lPT57bGV0IGVlPVcoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLEQpLGJlPVcoXCJ3XCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLDEpLFVlPUooXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLEQpLHBlPVtlZSxiZV0seWU9XCJcIjtpZihvKXtsZXQgdmU9VyhcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsRCk7cGUucHVzaCh2ZSkseWUrPWBcbiAgICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAkeyQ/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifSB7XG4gICAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtwP1wid1wiOlwieVwifSR7JD9cIi8gNFwiOlwiXCJ9XTtcbiAgICAgICAgICB9YH1sZXQgZGU9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpWLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpzZS5sZW5ndGh9XTtyZXR1cm4gdC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJmRlLnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pLGBcbiAgICAgICAgJHt0YShcInVuaWZvcm1zLnJlc3VsdF9zdHJpZGVzXCIpfVxuICAgICAgICAke09lLnJlZ2lzdGVyVW5pZm9ybXMoZGUpLmRlY2xhcmVWYXJpYWJsZXMoLi4ucGUsVWUpfTtcbiAgICAgICAgJHt5ZX1cbiAgICAgICAgJHthcChwLG8sdCxPKX1cbiAgICAgICAgJHskP1hyKFMsQyxcImYzMlwiLHZvaWQgMCwhcCxVKTpRcihTLEMsXCJmMzJcIix2b2lkIDAsIXAsVSwhMSx2b2lkIDAsYyl9YH07cmV0dXJue25hbWU6XCJDb252MkRUcmFuc3Bvc2VNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske1N9OyR7Q307JHskfWAsaW5wdXREZXBlbmRlbmNpZXM6dGV9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpFWzBdLHk6RVsxXSx6OkVbMl19LHByb2dyYW1Vbmlmb3JtczpCfSksZ2V0U2hhZGVyU291cmNlOmtlfX19KTt2YXIgaXAsb2ksUnU9USgoKT0+e1widXNlIHN0cmljdFwiO3F0KCk7Q2UoKTtfZSgpO2lwPShlLHQscixhLGkscz0hMSxvLGMscD0hMSk9PntsZXQgbT1wPzE6MixsPXA/MjozLGc9cD8zOjEsYj1zPzI6MSx3PWBcbiAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiB1MzIsIHZhbHVlIDogJHtzP2B2ZWM0PCR7b30+YDpvfSkge1xuICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtzP2B2ZWM0PCR7b30+YDpvfSh2YWx1ZSk7XG4gIH1gO2EmJih3Kz1gXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHtzP2B2ZWM0PCR7b30+YDpvfSB7XG4gICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtwP1wid1wiOlwieVwifSR7cz9cIi8gNFwiOlwiXCJ9XTtcbiAgICB9YCk7bGV0ICQ9cz80OjEseD1XKFwiV1wiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLmxlbmd0aCwkKSxUPVcoXCJEeVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLmxlbmd0aCwkKSxDPVtULHhdO2EmJkMucHVzaChXKFwiYmlhc1wiLHRbMl0uZGF0YVR5cGUsW3JbZ11dLmxlbmd0aCwkKSk7bGV0IFM9SihcInJlc3VsdFwiLHRbMF0uZGF0YVR5cGUsci5sZW5ndGgsJCksRT1ge1xuICAgICAgICBsZXQgYmF0Y2g6IHUzMiA9ICR7aT9cImdsb2JhbF9pZC56XCI6XCJ3b3JrZ3JvdXBfaWQuelwifSAvIHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsxXTtcbiAgICAgICAgbGV0IHIgPSAke2k/XCJnbG9iYWxfaWQuelwiOlwid29ya2dyb3VwX2lkLnpcIn0gJSB1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMV07XG4gICAgICAgIGxldCBjID0gJHtpP1wiZ2xvYmFsX2lkLnlcIjpcIndvcmtncm91cF9pZC55XCJ9ICogJHtifTtcbiAgICAgICAgbGV0IGQxOiB1MzIgPSAke2k/XCJnbG9iYWxfaWQueFwiOlwid29ya2dyb3VwX2lkLnhcIn0gKiA0O1xuXG4gICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB2ZWMyPGkzMj4odW5pZm9ybXMucGFkcyk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICB2YXIgZG90UHJvZDogYXJyYXk8dmVjNDwke299PiwgJHtifT47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtifTsgaSsrKSB7XG4gICAgICAgICAgZG90UHJvZFtpXSA9IHZlYzQ8JHtvfT4oMC4wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICB2YXIgZHlSID0gKCR7b30oZHlDb3JuZXIueCkgKyAke299KHdSKSkgLyAke299KHVuaWZvcm1zLnN0cmlkZXMueCk7XG4gICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdIC0gMSAtIHdSO1xuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7b30odW5pZm9ybXMuRHlfc2hhcGVbMV0pIHx8XG4gICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjAgfHwgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcblxuICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgbGV0IGR5QyA9ICgke299KGR5Q29ybmVyLnkpICsgJHtvfSh3QykpIC8gJHtvfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgbGV0IGR5QzIgPSAoJHtvfShkeUNvcm5lci55KSArIDEuMCArICR7b30od0MpKSAvICR7b30odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXSAtIDEgLSB3QztcbiAgICAgICAgICAgIGlmICh3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJEeUNWYWwgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGJEeUNWYWwyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7b30odW5pZm9ybXMuRHlfc2hhcGVbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBiRHlDVmFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHlDMiA8IDAuMCB8fCBkeUMyID49ICR7b30odW5pZm9ybXMuRHlfc2hhcGVbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDMikgPiAwLjApIHtcbiAgICAgICAgICAgICAgYkR5Q1ZhbDIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgbGV0IGlkeUMyOiB1MzIgPSB1MzIoZHlDMik7XG4gICAgICAgICAgICBpZiAoYkR5Q1ZhbCAmJiBiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDIgOnUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3guZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke3guZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDJcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7VC5nZXQoXCJiYXRjaFwiLFwiaWR5UlwiLFwiaWR5Q1wiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7b30+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcblxuICAgICAgICAgICAgICAgIHhWYWx1ZSA9ICAke1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XG5cbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHZlYzQ8JHtvfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJEeUNWYWwpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gdW5pZm9ybXMuRHlfc2hhcGVbJHtnfV07XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke3guZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke299Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gdW5pZm9ybXMuRHlfc2hhcGVbM107XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDFcIixcImQyXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke3guZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMSArIDNcIixcImQyXCIpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtvfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdG1wdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7Yn07IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2RbaV0gKyAke2E/XCJiaWFzW2MraV1cIjpgdmVjNDwke299PigwLjApYH07XG4gICAgICAgICAgJHtTLnNldChcImJhdGNoXCIsXCJyXCIsXCJjICsgaVwiLFwiZDFcIixcInZhbHVlXCIpfTtcbiAgICAgICAgfVxuICAgICAgfWAsTz1gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgbGV0IGJhdGNoID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsMCl9O1xuICAgICAgICAgIGxldCBkMSA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGcpfTtcbiAgICAgICAgICBsZXQgciA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLG0pfTtcbiAgICAgICAgICBsZXQgYyA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGwpfTtcbiAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICBsZXQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtvfSgwLjApO1xuICAgICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeVIgPSAoJHtvfShkeVJDb3JuZXIpICsgJHtvfSh3UikpIC8gJHtvfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke299KHVuaWZvcm1zLkR5X3NoYXBlWyR7bX1dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XG4gICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7b30oZHlDQ29ybmVyKSArICR7b30od0MpKSAvICR7b30odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtvfSh1bmlmb3Jtcy5EeV9zaGFwZVske2x9XSkgfHxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDsgZDIgPSBkMiArIDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtwP1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImlucHV0Q2hhbm5lbFwiKTpULmdldChcImJhdGNoXCIsXCJpbnB1dENoYW5uZWxcIixcImlkeVJcIixcImlkeUNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUgPSAke3guZ2V0KFwiaW5wdXRDaGFubmVsXCIsXCJ3T3V0Q2hhbm5lbFwiLFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIpfTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2QgKyAke2E/XCJiaWFzW2QxXVwiOmAke299KDAuMClgfTtcbiAgICAgICAgICAke1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICAgIGA7cmV0dXJuYFxuICAke2UucmVnaXN0ZXJVbmlmb3JtcyhjKS5kZWNsYXJlVmFyaWFibGVzKC4uLkMsUyl9XG4gICR7d31cblxuICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfTtcbiAgJHtzP0U6T319YH0sb2k9KGUsdCxyKT0+e2xldCBhPWUubGVuZ3RoPjIsaT10Lm91dHB1dFNoYXBlLHM9Ti5zaXplKGkpLG89W01hdGguY2VpbChzLzY0KSwxLDFdO0RlKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHtvfWApO2xldCBjPXQuZm9ybWF0PT09XCJOSFdDXCIscD1bXCJyYW5rXCIsXCJyYW5rXCJdLG09W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dLGw9W3Qua2VybmVsU2hhcGVbYz8xOjJdLHQua2VybmVsU2hhcGVbYz8yOjNdXSxnPVt0LmRpbGF0aW9uc1swXSx0LmRpbGF0aW9uc1sxXV0sYj1bbFswXSsodC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVtjPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpKSxsWzFdKyh0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2M/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSkpXSx3PVtiWzBdLTEtTWF0aC5mbG9vcigodC5wYWRzWzBdK3QucGFkc1syXSkvMiksYlsxXS0xLU1hdGguZmxvb3IodC5wYWRzWzFdK3QucGFkc1szXSkvMl0sJD0hMSx4PXQuZ3JvdXAsVD1lWzFdLmRpbXMsQz1UWzBdL3gsUz1UWzFdLEU9W3t0eXBlOlwiaW50MzJcIixkYXRhOnN9LHt0eXBlOlwidWludDMyXCIsZGF0YTptfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6bH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOmd9LHt0eXBlOlwidWludDMyXCIsZGF0YTpifSx7dHlwZTpcImludDMyXCIsZGF0YTp3fSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6Q30se3R5cGU6XCJ1aW50MzJcIixkYXRhOlN9LC4uLkwoZVswXS5kaW1zKSwuLi5MKGVbMV0uZGltcyldO2EmJihFLnB1c2goLi4uTChlWzJdLmRpbXMpKSxwLnB1c2goXCJyYW5rXCIpKSxFLnB1c2goLi4uTChpKSk7bGV0IE89b1sxXT09PTEmJm9bMl09PT0xLFU9RD0+e2xldCBWPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm0ubGVuZ3RofSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpsLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmwubGVuZ3RofSx7bmFtZTpcImVmZmVjdGl2ZV9maWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Yi5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dy5sZW5ndGh9LHtuYW1lOlwiaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XSxZPUhlKGVbMF0uZGF0YVR5cGUpO3JldHVybmAke2lwKEQsZSxpLGEsTywkLFksVixjKX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9O2AsaW5wdXREZXBlbmRlbmNpZXM6cH0sZ2V0UnVuRGF0YTooKT0+KHtkaXNwYXRjaEdyb3VwOnt4Om9bMF0seTpvWzFdLHo6b1syXX0sb3V0cHV0czpbe2RpbXM6cj9yKGkpOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLHByb2dyYW1Vbmlmb3JtczpFfSksZ2V0U2hhZGVyU291cmNlOlV9fX0pO3ZhciBvcCxzcCx1cCxCdSxNdSxscCxkcCxjcCxwcCxEdSx6dT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7UHUoKTtSdSgpO2p0KCk7JHIoKTtvcD0oZSx0LHIsYSxpLHMpPT4oZS0xKSp0K3IrKGEtMSkqaSsxLXMsc3A9KGUsdCxyLGEsaSk9PntsZXQgcz1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW2FdPXMscltpXT1lLXMpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbYV09ZS1zLHJbaV09cyl9LHVwPShlLHQscixhLGkscyxvLGMscCxtKT0+e2xldCBsPWUubGVuZ3RoLTIsZz1tLmxlbmd0aD09PTA7aWYocC5sZW5ndGg9PT0wKWZvcihsZXQgJD0wOyQ8bDsrKyQpcC5wdXNoKDApO2xldCBiPWVbMF0sdz10W2M/MzoxXSppO2ZvcihsZXQgJD0wLHg9ZS5sZW5ndGgtbC0oYz8xOjApOyQ8bDsrKyQsKyt4KXtsZXQgVD1lW3hdLEM9Zz9UKm9bJF06bVskXSxTPW9wKFQsb1skXSxzWyRdLHRbeF0sclskXSxDKTtzcChTLGEscywkLCQrbCksZyYmbS5wdXNoKG9bJF0qKFQtMSkrcFskXSsodFt4XS0xKSpyWyRdKzEtc1skXS1zWyQrbF0pfW0uc3BsaWNlKDAsMCxiKSxtLnNwbGljZShjPzM6MSwwLHcpfSxCdT0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKChnLGIpPT5nKmIsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgZz0yO2c8dFsxXS5kaW1zLmxlbmd0aDsrK2cpci5wdXNoKHRbMV0uZGltc1tnXSl9bGV0IGE9ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShhPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IGk9ZS5wYWRzLnNsaWNlKCkscz1lLm91dHB1dFNoYXBlLnNsaWNlKCksbz1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxjPXRbMF0uZGltcyxwPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYocC5yZWR1Y2UoKGcsYik9PmcrYiwwKT09PTApe2xldCBnPXRbMF0uZGltcy5sZW5ndGgtMjtwPW5ldyBBcnJheShnKS5maWxsKDEpfWxldCBtPWUuc3RyaWRlcy5zbGljZSgpO2lmKG0ucmVkdWNlKChnLGIpPT5nK2IsMCk9PT0wKXtsZXQgZz10WzBdLmRpbXMubGVuZ3RoLTI7bT1uZXcgQXJyYXkoZykuZmlsbCgxKX11cChjLHIscCxlLmF1dG9QYWQsZS5ncm91cCxpLG0sYSxvLHMpO2xldCBsPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obCx7a2VybmVsU2hhcGU6cixwYWRzOmksb3V0cHV0UGFkZGluZzpvLG91dHB1dFNoYXBlOnMsZGlsYXRpb25zOnAsc3RyaWRlczptfSksbH0sTXU9ZT0+e2xldCB0PVFuKGUpLHI9ZS5mb3JtYXQsYT1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLGk9ZS5kaWxhdGlvbnMscz1lLmdyb3VwLG89ZS5rZXJuZWxTaGFwZSxjPWUucGFkcyxwPWUuc3RyaWRlcyxtPWUud0lzQ29uc3QoKSxsPWUub3V0cHV0UGFkZGluZyxnPWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6YSxmb3JtYXQ6cixkaWxhdGlvbnM6aSxncm91cDpzLGtlcm5lbFNoYXBlOm8sb3V0cHV0UGFkZGluZzpsLG91dHB1dFNoYXBlOmcscGFkczpjLHN0cmlkZXM6cCx3SXNDb25zdDptLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sbHA9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sYT1lWzFdLmRpbXNbMF07aWYociE9PWEpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgaT1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09aSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBzPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKGwsZyk9PmwrZywwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3N9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKGwsZyk9PmwrZywwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c31EYCk7aWYodC5wYWRzLnJlZHVjZSgobCxnKT0+bCtnLDApPjAmJnQucGFkcy5sZW5ndGghPT1zKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3MqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXMmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c31EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKGwsZyk9PmwrZywwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LGRwPVsyLDMsMSwwXSxjcD0oZSx0LHIpPT57bGV0IGE9QnUocix0KSxpPXIuZm9ybWF0PT09XCJOSFdDXCIscz1hLm91dHB1dFNoYXBlLG89c1tpPzM6MV0sYz10WzBdLmRpbXNbaT8zOjFdO2lmKGEuZ3JvdXAhPT0xfHxvPT09MSYmYz09PTEpe2UuY29tcHV0ZShvaSh0LGEpKTtyZXR1cm59bGV0IHA9c1tpPzE6Ml0sbT1zW2k/MjozXSxsPXRbMV0uZGltc1syXSxnPXRbMV0uZGltc1szXSxiPWk/cCptOm8sdz1pP286cCptLCQ9bCpnKmMseD0hMCxUPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKHh0KHRbMV0sZHApLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1UKTtsZXQgQz1bdFswXSxUXSxTPXQubGVuZ3RoPT09MztTJiYoIWkmJnRbMl0uZGltcy5sZW5ndGg9PT0xP0MucHVzaCh0WzJdLnJlc2hhcGUoW3RbMl0uZGltc1swXSwxLDFdKSk6Qy5wdXNoKHRbMl0pKSxlLmNvbXB1dGUoa3UoQyxhLHMsYix3LCQsUyx4KSx7aW5wdXRzOkN9KX0scHA9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLGE9W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2EubGVuZ3RoPT09MyYmYS5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgaT10Lmtlcm5lbFNoYXBlOyhpLmxlbmd0aD09PTB8fGlbMF09PT0wKSYmKGk9W2UuaW5wdXRzWzFdLmRpbXNbMl1dKTtsZXQgcz10LmRpbGF0aW9uczsocy5sZW5ndGg9PT0wfHxzWzBdPT09MCkmJihzPVsxXSk7bGV0IG89dC5zdHJpZGVzOyhvLmxlbmd0aD09PTB8fG9bMF09PT0wKSYmKG89WzFdKTtsZXQgYz10LnBhZHM7Yy5sZW5ndGg9PT0wJiYoYz1bMCwwXSksYz1bMCxjWzBdLDAsY1sxXV0sbz1bMV0uY29uY2F0KG8pLHM9WzFdLmNvbmNhdChzKSxpPVsxXS5jb25jYXQoaSk7bGV0IHA9QnUoey4uLnQscGFkczpjLHN0cmlkZXM6byxkaWxhdGlvbnM6cyxrZXJuZWxTaGFwZTppfSxhKTtlLmNvbXB1dGUob2koYSxwLG09PnI/W21bMF0sbVsyXSxtWzNdXTpbbVswXSxtWzFdLG1bM11dKSl9LER1PShlLHQpPT57bHAoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zP3BwKGUsdCk6Y3AoZSxlLmlucHV0cyx0KX19KTt2YXIgZnAsVXUsV3UsTnU9USgoKT0+e1widXNlIHN0cmljdFwiO3plKCk7Q2UoKTtYZSgpO19lKCk7ZnA9KGUsdCxyLGEpPT57bGV0IGk9Ti5zaXplKHQpLHM9dC5sZW5ndGgsbz1XKFwiaW5wdXRcIixlLHMpLGM9SihcIm91dHB1dFwiLGUscykscD1yLmRhdGFUeXBlPT09Nj9yLmdldEludDMyQXJyYXkoKVswXTpOdW1iZXIoci5nZXRCaWdJbnQ2NEFycmF5KClbMF0pLG09Ti5ub3JtYWxpemVBeGlzKHAscyksbD1nPT57bGV0IGI9YCBpMzIoJHtvLmluZGljZXNHZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9KSBgLHc9Y2UoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLHMpLCQ9YS5yZXZlcnNlP2IrKGEuZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLHg9YS5yZXZlcnNlP3c6YisoYS5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxuICAgICAgICAgICAgICAgICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobyxjKX1cbiAgICAgICAgICAgICAgICAke2cubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtjLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7Yy50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7JH07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7eH07XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHtvLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7by5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtjLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDdW1TdW1cIixzaGFkZXJDYWNoZTp7aGludDphLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOml9LHt0eXBlOlwiaW50MzJcIixkYXRhOm19LC4uLkwodCksLi4uTCh0KV19KSxnZXRTaGFkZXJTb3VyY2U6bH19LFV1PShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0uZGltcyxhPWUuaW5wdXRzWzBdLmRhdGFUeXBlLGk9ZS5pbnB1dHNbMV07ZS5jb21wdXRlKGZwKGEscixpLHQpLHtpbnB1dHM6WzBdfSl9LFd1PWU9PntsZXQgdD1lLmV4Y2x1c2l2ZT09PTEscj1lLnJldmVyc2U9PT0xO3JldHVybiB4ZSh7ZXhjbHVzaXZlOnQscmV2ZXJzZTpyfSl9fSk7dmFyIHNpLG5hLFZ1LG1wLGhwLHVpLGxpLEh1LGdwLEx1LEd1LEZ1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1hlKCk7X2UoKTtzaT1cIlthLXpBLVpdfFxcXFwuXFxcXC5cXFxcLlwiLG5hPVwiKFwiK3NpK1wiKStcIixWdT1cIl5cIituYStcIiRcIixtcD1cIihcIituYStcIiwpKlwiK25hLGhwPVwiXlwiK21wK1wiJFwiLHVpPWNsYXNze2NvbnN0cnVjdG9yKHQ9LTEpe3RoaXMuc3ltYm9sVG9JbmRpY2VzPW5ldyBNYXAsdGhpcy5pbnB1dEluZGV4PXR9YWRkU3ltYm9sKHQscil7bGV0IGE9dGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHQpO2E9PT12b2lkIDA/YT1bcl06YS5wdXNoKHIpLHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldCh0LGEpfX0sbGk9Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLmVxdWF0aW9uPXI7dGhpcy5oYXNFbGxpcHNpcz0hMSx0aGlzLnN5bWJvbFRvSW5mbz1uZXcgTWFwLHRoaXMubGhzPW5ldyBBcnJheSx0aGlzLm91dHB1dERpbXM9W107bGV0W2EsaV09ci5pbmNsdWRlcyhcIi0+XCIpP3Iuc3BsaXQoXCItPlwiLDIpOltyLFwiXCJdO2lmKCFhLm1hdGNoKFJlZ0V4cChocCkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7aWYoYS5zcGxpdChcIixcIikuZm9yRWFjaCgoYyxwKT0+e2xldCBtPXRbcF0uZGltcy5zbGljZSgpO2lmKCFjLm1hdGNoKFJlZ0V4cChWdSkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IGw9dGhpcy5wcm9jZXNzVGVybShjLCEwLG0scCk7dGhpcy5saHMucHVzaChsKX0pLGk9PT1cIlwiKWkrPVsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldLmZpbHRlcigoW2MscF0pPT5wLmNvdW50PT09MXx8Yz09PVwiLi4uXCIpLm1hcCgoW2NdKT0+Yykuam9pbihcIlwiKTtlbHNlIGlmKCFpLm1hdGNoKFJlZ0V4cChuYSkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTXCIpO2kubWF0Y2goUmVnRXhwKHNpLFwiZ1wiKSk/LmZvckVhY2goYz0+e2lmKGM9PT1cIi4uLlwiKXRoaXMub3V0cHV0RGltcz10aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtlbHNle2xldCBwPXRoaXMuc3ltYm9sVG9JbmZvLmdldChjKTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTIHN5bWJvbFwiKTt0aGlzLm91dHB1dERpbXMucHVzaChwLmRpbVZhbHVlKX19KSx0aGlzLnJocz10aGlzLnByb2Nlc3NUZXJtKGksITEsdGhpcy5vdXRwdXREaW1zKX1hZGRTeW1ib2wodCxyLGEpe2xldCBpPXRoaXMuc3ltYm9sVG9JbmZvLmdldCh0KTtpZihpIT09dm9pZCAwKXtpZihpLmRpbVZhbHVlIT09ciYmaS5jb3VudCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc21hdGNoXCIpO2kuY291bnQrKyxpLmlucHV0SW5kaWNlcy5wdXNoKGEpfWVsc2UgaT17Y291bnQ6MSxkaW1WYWx1ZTpyLGlucHV0SW5kaWNlczpbYV19O3RoaXMuc3ltYm9sVG9JbmZvLnNldCh0LGkpfXByb2Nlc3NUZXJtKHQscixhLGk9LTEpe2xldCBzPWEubGVuZ3RoLG89ITEsYz1bXSxwPTA7aWYoIXQubWF0Y2goUmVnRXhwKFZ1KSkmJiFyJiZ0IT09XCJcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBtPXQubWF0Y2goUmVnRXhwKHNpLFwiZ1wiKSksbD1uZXcgdWkoaSk7cmV0dXJuIG0/LmZvckVhY2goKGcsYik9PntpZihnPT09XCIuLi5cIil7aWYobyl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBlbGxpcHNpcyBpcyBhbGxvd2VkIHBlciBpbnB1dCB0ZXJtXCIpO289ITA7bGV0IHc9cy1tLmxlbmd0aCsxO2lmKHc8MCl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBvdXQgb2YgYm91bmRzXCIpO2lmKGM9YS5zbGljZShwLHArdyksdGhpcy5oYXNFbGxpcHNpcyl7aWYodGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIT09Yy5sZW5ndGh8fHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkhPT1jLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaFwiKX1lbHNlIGlmKHIpdGhpcy5oYXNFbGxpcHNpcz0hMCx0aGlzLmVsbGlwc2lzRGltcz1jO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIU1wiKTtmb3IobGV0ICQ9MDskPGMubGVuZ3RoOyQrKyl7bGV0IHg9U3RyaW5nLmZyb21DaGFyQ29kZShcIjBcIi5jaGFyQ29kZUF0KDApKyQpO2wuYWRkU3ltYm9sKHgsYiskKSx0aGlzLmFkZFN5bWJvbCh4LGFbcCsrXSxpKX19ZWxzZSBsLmFkZFN5bWJvbChnLGIrKHRoaXMuaGFzRWxsaXBzaXM/dGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoLTE6MCkpLHRoaXMuYWRkU3ltYm9sKGcsYVtwKytdLGkpfSksbH19LEh1PWU9PmUrXCJfbWF4XCIsZ3A9KGUsdCxyLGEpPT57bGV0IHM9ZS5tYXAobD0+bC5sZW5ndGgpLm1hcCgobCxnKT0+VyhgaW5wdXQke2d9YCx0LGwpKSxvPU4uc2l6ZShhKSxjPUooXCJvdXRwdXRcIix0LGEubGVuZ3RoKSxwPVsuLi5yLnN5bWJvbFRvSW5mby5rZXlzKCldLmZpbHRlcihsPT4hci5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhsKSksbT1sPT57bGV0IGc9W10sYj1cInZhciBwcm9kID0gMS4wO1wiLHc9XCJ2YXIgc3VtID0gMC4wO1wiLCQ9XCJzdW0gKz0gcHJvZDtcIix4PVtdLFQ9W10sQz1bXSxTPVtdLEU9ci5zeW1ib2xUb0luZm8uc2l6ZT09PXIucmhzLnN5bWJvbFRvSW5kaWNlcy5zaXplO3Iuc3ltYm9sVG9JbmZvLmZvckVhY2goKFUsRCk9PntpZihyLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKEQpKXtsZXQgVj1yLnJocy5zeW1ib2xUb0luZGljZXMuZ2V0KEQpPy5bMF07ViE9PXZvaWQgMCYmci5saHMuZm9yRWFjaCgoWSxzZSk9PntpZihVLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhzZSkpe2xldCBCPVkuc3ltYm9sVG9JbmRpY2VzLmdldChEKTtpZihCPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0IuZm9yRWFjaCh0ZT0+e2cucHVzaChgJHtzW3NlXS5pbmRpY2VzU2V0KGBpbnB1dCR7c2V9SW5kaWNlc2AsdGUsYy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLFYpKX1gKX0pfX0pfWVsc2Ugci5saHMuZm9yRWFjaCgoVixZKT0+e2lmKFUuaW5wdXRJbmRpY2VzLmluY2x1ZGVzKFkpKXtsZXQgc2U9Vi5zeW1ib2xUb0luZGljZXMuZ2V0KEQpO2lmKHNlPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO3NlLmZvckVhY2goQj0+e3gucHVzaChgJHtzW1ldLmluZGljZXNTZXQoYGlucHV0JHtZfUluZGljZXNgLEIsYCR7RH1gKX1gKX0pLFMucHVzaChgcHJvZCAqPSAke3NbWV0uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7WX1JbmRpY2VzYCl9O2ApfX0pLFQucHVzaChgZm9yKHZhciAke0R9OiB1MzIgPSAwOyAke0R9IDwgdW5pZm9ybXMuJHtIdShEKX07ICR7RH0rKykge2ApLEMucHVzaChcIn1cIil9KTtsZXQgTz1FP1suLi5nLGBsZXQgc3VtID0gJHtzLm1hcCgoVSxEKT0+VS5nZXRCeUluZGljZXMoYGlucHV0JHtEfUluZGljZXNgKSkuam9pbihcIiAqIFwiKX07YF06Wy4uLmcsdywuLi5ULC4uLngsYiwuLi5TLCQsLi4uQ107cmV0dXJuYFxuICAgICAgICAgICAgJHtsLnJlZ2lzdGVyVW5pZm9ybXMocC5tYXAoVT0+KHtuYW1lOmAke0h1KFUpfWAsdHlwZTpcInUzMlwifSkpKS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyguLi5zLGMpfVxuXG4gICAgICAgICAgICAke2wubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7Yy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICR7cy5tYXAoKFUsRCk9PmB2YXIgaW5wdXQke0R9SW5kaWNlczogJHtzW0RdLnR5cGUuaW5kaWNlc307YCkuam9pbihgXG5gKX1cbiAgICAgICAgICAgICR7Ty5qb2luKGBcbmApfTtcbiAgICAgICAgICAgICR7Yy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInN1bVwiKX07XG4gICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiRWluc3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6ci5lcXVhdGlvbixpbnB1dERlcGVuZGVuY2llczplLm1hcCgoKT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT57bGV0IGw9cC5maWx0ZXIoYj0+ci5zeW1ib2xUb0luZm8uaGFzKGIpKS5tYXAoYj0+KHt0eXBlOlwidWludDMyXCIsZGF0YTpyLnN5bWJvbFRvSW5mby5nZXQoYik/LmRpbVZhbHVlfHwwfSkpO2wucHVzaCh7dHlwZTpcInVpbnQzMlwiLGRhdGE6b30pO2xldCBnPWUubWFwKChiLHcpPT5bLi4uTChiKV0pLnJlZHVjZSgoYix3KT0+Yi5jb25jYXQodyksbCk7cmV0dXJuIGcucHVzaCguLi5MKGEpKSx7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTp0fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3JtczpnfX0sZ2V0U2hhZGVyU291cmNlOm19fSxMdT0oZSx0KT0+e2xldCByPW5ldyBsaShlLmlucHV0cyx0LmVxdWF0aW9uKSxhPXIub3V0cHV0RGltcyxpPWUuaW5wdXRzLm1hcCgocyxvKT0+cy5kaW1zKTtlLmNvbXB1dGUoZ3AoaSxlLmlucHV0c1swXS5kYXRhVHlwZSxyLGEpKX0sR3U9ZT0+e2xldCB0PWUuZXF1YXRpb24ucmVwbGFjZSgvXFxzKy9nLFwiXCIpO3JldHVybiB4ZSh7ZXF1YXRpb246dH0pfX0pO3ZhciB5cCxxdSxicCx2cCxqdSxLdT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtDZSgpO19lKCk7eXA9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuXCIpO2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxhPXIubGVuZ3RoPHQubGVuZ3RoPzA6ci5sZW5ndGgtdC5sZW5ndGgsaT10Lmxlbmd0aDxyLmxlbmd0aD8wOnQubGVuZ3RoLXIubGVuZ3RoO2Zvcig7YTxyLmxlbmd0aCYmaTx0Lmxlbmd0aDsrK2EsKytpKWlmKHJbYV0hPT10W2ldJiZyW2FdIT09MSYmdFtpXSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIHNoYXBlIHRvIGJlIGJyb2FkY2FzdGFibGUgdG8gaW5wdXRcIil9LHF1PShlLHQpPT57bGV0IHI9ZS5sZW5ndGgtdC5sZW5ndGgsYT1bXTtmb3IobGV0IGk9MDtpPHI7KytpKWEucHVzaChlW2ldKTtmb3IobGV0IGk9MDtpPHQubGVuZ3RoOysraSlhLnB1c2godFtpXT09PTE/ZVtpK3JdOnRbaV0pO3JldHVybiBhfSxicD0oZSx0KT0+ZS5sZW5ndGg+dC5sZW5ndGg/cXUoZSx0KTpxdSh0LGUpLHZwPWU9PntsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksYT1icCh0LHIpLGk9ZVswXS5kYXRhVHlwZSxzPWk9PT05PzQ6MSxvPU1hdGguY2VpbChOLnNpemUoYSkvcyksYz1tPT57bGV0IGw9VyhcImlucHV0XCIsaSx0Lmxlbmd0aCxzKSxnPUooXCJvdXRwdXRcIixpLGEubGVuZ3RoLHMpLGI7aWYoaT09PTkpe2xldCB3PSgkLHgsVD1cIlwiKT0+YFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7Zy5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtsLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsZyl9O1xuICAgICAgICAgIGxldCBpbmRleCR7eH0gPSBvZmZzZXQke3h9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7eH0gPSBvZmZzZXQke3h9ICUgNHU7XG4gICAgICAgICAgJHskfVske3h9XSA9ICR7VH0oJHtsLmdldEJ5T2Zmc2V0KGBpbmRleCR7eH1gKX1bY29tcG9uZW50JHt4fV0pO1xuICAgICAgICBgO2I9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7c307XG4gICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3coXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgJHt3KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7dyhcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAke3coXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgJHtnLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGF0YVwiKX1cbiAgICAgIH1gfWVsc2UgYj1gXG4gICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICBsZXQgaW5wdXRPZmZzZXQgPSAke2wuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsZyl9O1xuICAgICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbC5nZXRCeU9mZnNldChcImlucHV0T2Zmc2V0XCIpKX1cbiAgICAgIH1gO3JldHVybmBcbiAgICAke20ucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGwsZyl9XG4gICAgJHttLm1haW5TdGFydCgpfVxuICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG4gICAgJHtifWB9LHA9W3t0eXBlOlwidWludDMyXCIsZGF0YTpvfSwuLi5MKHQpLC4uLkwoYSldO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7YS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6YyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pfX0sanU9ZT0+e3lwKGUuaW5wdXRzKSxlLmNvbXB1dGUodnAoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHdwLCRwLFl1LFp1LFh1PVEoKCk9PntcInVzZSBzdHJpY3RcIjt6ZSgpO0NlKCk7WGUoKTtfZSgpO3dwPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LCRwPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLGk9ci5sZW5ndGgscz1OLm5vcm1hbGl6ZUF4aXModC5heGlzLGkpLG89ci5zbGljZSgwKTtvLnNwbGljZShzLDEsLi4uYSk7bGV0IGM9cltzXSxwPWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxtPU1hdGguY2VpbChOLnNpemUobykvcCksbD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOm19LHt0eXBlOlwiaW50MzJcIixkYXRhOmN9LHt0eXBlOlwidWludDMyXCIsZGF0YTpzfSwuLi5MKGVbMF0uZGltcyksLi4uTChlWzFdLmRpbXMpLC4uLkwobyldLGc9Yj0+e2xldCB3PVcoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLHApLCQ9VyhcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCkseD1KKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCxwKSxUPVM9PntsZXQgRT1hLmxlbmd0aCxPPWB2YXIgaW5kaWNlc0luZGljZXMke1N9ICA9ICR7JC50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBVPTA7VTxFO1UrKylPKz1gJHtFPjE/YGluZGljZXNJbmRpY2VzJHtTfVske1V9XWA6YGluZGljZXNJbmRpY2VzJHtTfWB9ID0gJHtvLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHtTfVt1bmlmb3Jtcy5heGlzICsgJHtVfV1gOmBvdXRwdXRJbmRpY2VzJHtTfWB9O2A7Tys9YFxuICAgICAgICAgIHZhciBpZHgke1N9ID0gJHskLmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke1N9YCl9O1xuICAgICAgICAgIGlmIChpZHgke1N9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHtTfSA9IGlkeCR7U30gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7U30gPSAke3cudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgYDtmb3IobGV0IFU9MCxEPTA7VTxpO1UrKylVPT09cz8oTys9YCR7aT4xP2BkYXRhSW5kaWNlcyR7U31bJHtVfV1gOmBkYXRhSW5kaWNlcyR7U31gfSA9IHUzMihpZHgke1N9KTtgLEQrPUUpOihPKz1gJHtpPjE/YGRhdGFJbmRpY2VzJHtTfVske1V9XWA6YGRhdGFJbmRpY2VzJHtTfWB9ID0gJHtvLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHtTfVske0R9XWA6YG91dHB1dEluZGljZXMke1N9YH07YCxEKyspO3JldHVybiBPfSxDO2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgUz0oRSxPLFU9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7T30gPSAke3gub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke099dWApfTtcbiAgICAgICAgICAke1QoTyl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke099ID0gJHt3LmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke099YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7T30gPSBvZmZzZXQke099IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7T30gPSBvZmZzZXQke099ICUgNHU7XG4gICAgICAgICAgJHtFfVske099XSA9ICR7VX0oJHt3LmdldEJ5T2Zmc2V0KGBpbmRleCR7T31gKX1bY29tcG9uZW50JHtPfV0pO1xuICAgICAgICBgO0M9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7cH07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtTKFwidmFsdWVcIiwwLFwidTMyXCIpfVxuICAgICAgICAke1MoXCJ2YWx1ZVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7UyhcInZhbHVlXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHtTKFwidmFsdWVcIiwzLFwidTMyXCIpfVxuICAgICAgICAke3guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgICAgIGB9ZWxzZSBDPWBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt4Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHtUKFwiXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7dy5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAke3guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICBgO3JldHVybmBcbiAgICAgICR7Yi5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModywkLHgpfVxuICAgICAgJHtiLm1haW5TdGFydCgpfVxuICAgICAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICR7Q31cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KSxnZXRTaGFkZXJTb3VyY2U6Z319LFl1PWU9PnhlKHtheGlzOmUuYXhpc30pLFp1PShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7d3AociksZS5jb21wdXRlKCRwKGUuaW5wdXRzLHQpKX19KTt2YXIgX3AsU3AsUXUsSnUsZWw9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7WGUoKTtfZSgpO19wPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBiZSByYW5rID49IDEuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgaW5wdXQgdGVuc29ycyBiZSBvZiBzYW1lIHJhbmsuYCl9LFNwPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9ZVswXS5kYXRhVHlwZSxpPXIubGVuZ3RoLHM9ZVsxXS5kaW1zLG89ZVsxXS5kYXRhVHlwZSxjPU4ubm9ybWFsaXplQXhpcyh0LmF4aXMsaSkscD1yW2NdLG09cy5zbGljZSgwKSxsPU4uc2l6ZShtKSxnPVcoXCJpbnB1dFwiLGEsaSksYj1XKFwiaW5kaWNlc0lucHV0XCIsbyxzLmxlbmd0aCksdz1KKFwib3V0cHV0XCIsYSxtLmxlbmd0aCksJD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOmx9LHt0eXBlOlwiaW50MzJcIixkYXRhOnB9LHt0eXBlOlwidWludDMyXCIsZGF0YTpjfV07cmV0dXJuICQucHVzaCguLi5MKHIpKSwkLnB1c2goLi4uTChzKSksJC5wdXNoKC4uLkwobSkpLHtuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczptLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOiR9KSxnZXRTaGFkZXJTb3VyY2U6Qz0+YFxuICAgICAgJHtDLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhnLGIsdyl9XG4gICAgICAke0MubWFpblN0YXJ0KCl9XG4gICAgICAke0MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtiLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtnLnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke2cuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGlkeClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHtnLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG5cbiAgICAgICR7dy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9fSxRdT1lPT54ZSh7YXhpczplLmF4aXN9KSxKdT0oZSx0KT0+e2xldCByPWUuaW5wdXRzO19wKHIpLGUuY29tcHV0ZShTcChlLmlucHV0cyx0KSl9fSk7dmFyIHhwLENwLHRsLHJsLG5sPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO19lKCk7eHA9ZT0+e2lmKCFlKXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMl0uZGltcy5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoZVswXS5kYXRhVHlwZSE9PWVbMV0uZGF0YVR5cGV8fGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9LENwPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLnNsaWNlKCksYT1lWzFdLmRpbXMuc2xpY2UoKSxbaSxzLG9dPUxuLmdldFNoYXBlT2ZHZW1tUmVzdWx0KHIsdC50cmFuc0EsYSx0LnRyYW5zQixlLmxlbmd0aD09PTM/ZVsyXS5kaW1zOnZvaWQgMCksYz1baSxzXTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgcD1OLnNpemUoYyksbT1be3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9LHt0eXBlOlwidWludDMyXCIsZGF0YTppfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6c30se3R5cGU6XCJ1aW50MzJcIixkYXRhOm99LHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5hbHBoYX0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmJldGF9XSxsPVtcInR5cGVcIixcInR5cGVcIl07ZS5sZW5ndGg9PT0zJiYobS5wdXNoKC4uLkwoZVsyXS5kaW1zKSksbC5wdXNoKFwicmFua1wiKSksbS5wdXNoKC4uLkwoYykpO2xldCBnPWI9PntsZXQgdz1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj93PVwidmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOnQudHJhbnNBJiYhdC50cmFuc0I/dz1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIjohdC50cmFuc0EmJnQudHJhbnNCP3c9XCJ2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW24gKiB1bmlmb3Jtcy5LICsga107XCI6IXQudHJhbnNBJiYhdC50cmFuc0ImJih3PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dO1wiKTtsZXQgJD10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7XCIseD1XKFwiYVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxUPVcoXCJiXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLEM9eC50eXBlLnZhbHVlLFM9bnVsbCxFPVt4LFRdO2UubGVuZ3RoPT09MyYmKFM9VyhcImNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLEUucHVzaChTKSk7bGV0IE89SihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsYy5sZW5ndGgpO0UucHVzaChPKTtsZXQgVT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke2IucmVnaXN0ZXJVbmlmb3JtcyhVKS5kZWNsYXJlVmFyaWFibGVzKC4uLkUpfVxuXG4gICR7Yi5tYWluU3RhcnQoKX1cbiAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG0gPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuTjtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xuXG4gICAgdmFyIHZhbHVlID0gJHtDfSgwKTtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgJHt3fVxuICAgIH1cblxuICAgICR7JH1cbiAgICAkeygoKT0+UyE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke1MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsTyl9OyB2YWx1ZSArPSAke0N9KHVuaWZvcm1zLmJldGEpICogJHtTLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07YDpcIlwiKSgpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICB9YH07cmV0dXJue25hbWU6XCJHZW1tXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOmx9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOmd9fSx0bD1lPT57bGV0IHQ9ZS50cmFuc0Escj1lLnRyYW5zQixhPWUuYWxwaGEsaT1lLmJldGE7cmV0dXJue3RyYW5zQTp0LHRyYW5zQjpyLGFscGhhOmEsYmV0YTppLGNhY2hlS2V5OmAke2UudHJhbnNBfTske2UudHJhbnNCfTske2UuYWxwaGE9PT0xfWB9fSxybD0oZSx0KT0+e3hwKGUuaW5wdXRzKSxlLmNvbXB1dGUoQ3AoZS5pbnB1dHMsdCkpfX0pO3ZhciBJcCxBcCxUcCxhbCxpbD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtDZSgpO19lKCk7SXA9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsYT1yLGk9MixzPU4uc2l6ZVRvRGltZW5zaW9uKHIsaSksbz1OLnNpemVGcm9tRGltZW5zaW9uKHIsaSksYz1MZShvKSxwPW8vYyxtPVtyWzBdLHJbMV0scF0sbD1bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdLGc9W3t0eXBlOlwidWludDMyXCIsZGF0YTpvfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH1dO2cucHVzaCguLi5MKG0pLC4uLkwobSkpO2xldCBiPXc9PntsZXQgJD1XKFwieFwiLGVbMF0uZGF0YVR5cGUsbS5sZW5ndGgsYykseD1XKFwic2NhbGVcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksVD1XKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zKSxDPUooXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG0ubGVuZ3RoLGMpLFM9WyQseCxULENdLEU9JC50eXBlLnZhbHVlLE89Yz09PTE/XCJmMzJcIjpgdmVjJHtjfTxmMzI+YCxVPTY0LEQ9W3tuYW1lOlwibm9ybVNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibm9ybVBhY2tlZFNpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IG1lYW5TaGFyZWQgOiBmMzI7XG4gIHZhcjx3b3JrZ3JvdXA+IHNxdWFyZWROb3JtU2hhcmVkIDogZjMyO1xuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBTaGFyZWQgOiBhcnJheTwke099LCAke1V9PjtcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9ICR7VX11O1xuICAke3cucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLlMpfVxuICAke3cubWFpblN0YXJ0KFUpfVxuICAgIGxldCBub3JtID0gZ2xvYmFsX2lkeCAvIHdvcmtncm91cFNpemU7XG4gICAgbGV0IGJhdGNoID0gbm9ybSAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSBub3JtICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgbG9jYWxJbmRleCA9IGxvY2FsX2lkLng7XG5cbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgaW5pdGlhbCA9ICR7T30oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCB1bmlmb3Jtcy5ub3JtUGFja2VkU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArICR7T30oJHskLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSk7XG4gICAgfVxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtZWFuIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbEluZGV4ID09IDApIHtcbiAgICAgIG1lYW5TaGFyZWQgPSAke2Z0KFwid29ya2dyb3VwU2hhcmVkWzBdXCIsYyl9IC8gZjMyKHVuaWZvcm1zLm5vcm1TaXplKTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gcmVpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnkuXG4gICAgaW5pdGlhbCA9ICR7T30oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCB1bmlmb3Jtcy5ub3JtUGFja2VkU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBsZXQgZGV2aWF0aW9uID0gICR7T30oJHskLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSkgLSAke099KG1lYW5TaGFyZWQpO1xuICAgICAgaW5pdGlhbCA9IGluaXRpYWwgKyBkZXZpYXRpb24gKiBkZXZpYXRpb247XG4gICAgfVxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2Ygc3F1YXJlIG9mIGRldmlhdGlvbiBvZiBjdXJyZW50IGNoYW5uZWwgZGF0YS5cbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cFNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxJbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSArIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4ICsgY3VyclNpemVdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBpZiAobG9jYWxJbmRleCA9PSAwKSB7XG4gICAgICBzcXVhcmVkTm9ybVNoYXJlZCA9ICR7ZnQoXCJ3b3JrZ3JvdXBTaGFyZWRbMF1cIixjKX07XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGxldCBpbnZTdGREZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkTm9ybVNoYXJlZCAvIGYzMih1bmlmb3Jtcy5ub3JtU2l6ZSkgKyBmMzIoJHt0LmVwc2lsb259KSk7XG4gICAgbGV0IGNoYW5uZWxTY2FsZSA9IGludlN0ZERldiAqIGYzMigke3guZ2V0QnlPZmZzZXQoXCJjaGFubmVsXCIpfSk7XG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9IGYzMigke1QuZ2V0QnlPZmZzZXQoXCJjaGFubmVsXCIpfSkgLSBtZWFuU2hhcmVkICogY2hhbm5lbFNjYWxlO1xuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgdW5pZm9ybXMubm9ybVBhY2tlZFNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xuICAgICAgbGV0IHZhbHVlID0gJHskLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSAqICR7RX0oJHtPfShjaGFubmVsU2NhbGUpKSArICR7RX0oJHtPfShjaGFubmVsU2hpZnQpKTtcbiAgICAgICR7Qy5zZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5lcHNpbG9ufTske2N9YCxpbnB1dERlcGVuZGVuY2llczpsfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6c30scHJvZ3JhbVVuaWZvcm1zOmd9KSxnZXRTaGFkZXJTb3VyY2U6Yn19LEFwPShlLHQscixhLGkscyxvLGMpPT57bGV0IHA9TGUobyksbT02NCxsPXA9PT0xP1widmVjMmZcIjpgbWF0Mngke3B9ZmAsZz1wPT09MT9cImYzMlwiOmB2ZWMke3B9ZmAsYj0oRCxWKT0+YCR7bH0oJHtEfSwgJHtWfSlgLHc9aSpvL3AsJD1NYXRoLmNlaWwocy9tKSx4PVtcInR5cGVcIl0sVD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOiR9LHt0eXBlOlwidWludDMyXCIsZGF0YTpzfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6TWF0aC5mbG9vcihvL3ApfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6TWF0aC5mbG9vcihzKm8vcCl9XSxDPUQ9PntsZXQgVj1XKFwiaW5wdXRcIix0LmRhdGFUeXBlLHQuZGltcyxwKTtyZXR1cm5gXG4gICR7RC5kZWNsYXJlVmFyaWFibGVzKFYpfVxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7bH0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge3dnX3NpemU6dTMyLCBIOnUzMiwgQzp1MzIsIGltYWdlX3NpemU6dTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHtELm1haW5TdGFydChtKX1cbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvICR7bX0gLyB1bmlmb3Jtcy5DO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IChnbG9iYWxfaWR4IC8gJHttfSkgJSB1bmlmb3Jtcy5DO1xuICAgIGxldCB3Z0lkID0gZ2xvYmFsX2lkeCAlICR7bX07XG4gICAgbGV0IHdnT2Zmc2V0ID0gd2dJZCAqIHVuaWZvcm1zLndnX3NpemU7XG4gICAgaWYgKHdnT2Zmc2V0ID49IHVuaWZvcm1zLkgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgd2dNYXggPSBtaW4od2dPZmZzZXQgKyB1bmlmb3Jtcy53Z19zaXplLCB1bmlmb3Jtcy5IKTtcblxuICAgIGxldCBvZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiB1bmlmb3Jtcy5pbWFnZV9zaXplICsgY3VycmVudENoYW5uZWxOdW1iZXI7XG4gICAgdmFyIHN1bSA9ICR7UWUoXCJmMzJcIixwKX07XG4gICAgdmFyIHNxdWFyZWRTdW0gPSAke1FlKFwiZjMyXCIscCl9O1xuICAgIGZvciAodmFyIGk6IHUzMiA9IHdnT2Zmc2V0OyBpIDwgd2dNYXg7IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSAke2d9KGlucHV0W29mZnNldCArIGkgKiB1bmlmb3Jtcy5DXSk7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgc3F1YXJlZFN1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2IoXCJzdW1cIixcInNxdWFyZWRTdW1cIil9O1xuICB9YH0sUz1lLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1Db21wdXRlTWVhblwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9YCxpbnB1dERlcGVuZGVuY2llczp4fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOltpLG8sbSwyXSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDppKm8vcH0scHJvZ3JhbVVuaWZvcm1zOlR9KSxnZXRTaGFkZXJTb3VyY2U6Q30se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF0sRT1be3R5cGU6XCJ1aW50MzJcIixkYXRhOnd9LHt0eXBlOlwidWludDMyXCIsZGF0YTpzfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6TWF0aC5mbG9vcihvL3ApfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6TWF0aC5mbG9vcihtKm8vcCl9XSxPPVtcInR5cGVcIixcInR5cGVcIixcInR5cGVcIl0sVT1EPT57bGV0IFY9VyhcInNjYWxlXCIsci5kYXRhVHlwZSxyLmRpbXMscCksWT1XKFwiYmlhc1wiLGEuZGF0YVR5cGUsYS5kaW1zLHApO3JldHVybmBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7bH0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlIDogYXJyYXk8JHtWLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJpYXMgOiBhcnJheTwke1kudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtsfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7dW5pdHNfb2Zfd29yayA6IHUzMiwgSDogdTMyLCBDIDogdTMyLCBpbWFnZV9zaXplIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDQpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHtELm1haW5TdGFydCgpfVxuICAgICR7RC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudW5pdHNfb2Zfd29ya1wiKX1cbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLkM7XG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XG5cbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogdW5pZm9ybXMuaW1hZ2Vfc2l6ZTtcbiAgICB2YXIgc3VtID0gJHtRZShcImYzMlwiLHApfTtcbiAgICB2YXIgc3F1YXJlZFN1bSA9ICR7UWUoXCJmMzJcIixwKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7bX07IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dFtvZmZzZXQgKyBpICsgY3VycmVudENoYW5uZWxOdW1iZXIgKiAke219XTtcbiAgICAgICAgc3VtICs9IHZhbHVlWzBdO1xuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlWzFdO1xuICAgIH1cbiAgICBzdW0gPSBzdW0gLyBmMzIodW5pZm9ybXMuSCk7XG4gICAgc3F1YXJlZFN1bSA9IHNxdWFyZWRTdW0gLyBmMzIodW5pZm9ybXMuSCk7XG4gICAgbGV0IGludlN0ZERldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRTdW0gLSBzdW0gKiBzdW0gKyBmMzIoJHtjfSkpO1xuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiAke2d9KHNjYWxlW2N1cnJlbnRDaGFubmVsTnVtYmVyXSk7XG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9ICR7Z30oYmlhc1tjdXJyZW50Q2hhbm5lbE51bWJlcl0pIC0gc3VtICogY2hhbm5lbFNjYWxlO1xuXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtiKFwiY2hhbm5lbFNjYWxlXCIsXCJjaGFubmVsU2hpZnRcIil9O1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9OyR7Y31gLGlucHV0RGVwZW5kZW5jaWVzOk99LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6W2ksbywyXSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwody82NCl9LHByb2dyYW1Vbmlmb3JtczpFfSksZ2V0U2hhZGVyU291cmNlOlV9LHtpbnB1dHM6W1MscixhXSxvdXRwdXRzOlstMV19KVswXX0sVHA9KGUsdCxyKT0+e2xldCBhPXRbMF0uZGltcyxpPWEscz1hWzBdLG89YVthLmxlbmd0aC0xXSxjPU4uc2l6ZUZyb21EaW1lbnNpb24oYSwxKS9vLHA9TGUobyksbT1OLnNpemUoaSkvcCxsPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6Y30se3R5cGU6XCJ1aW50MzJcIixkYXRhOk1hdGguZmxvb3Ioby9wKX1dLGc9W1widHlwZVwiLFwidHlwZVwiXSxiPUFwKGUsdFswXSx0WzFdLHRbMl0scyxjLG8sci5lcHNpbG9uKSx3PSQ9PntsZXQgeD1IZSh0WzBdLmRhdGFUeXBlKSxUPXA9PT0xP1widmVjMmZcIjpgbWF0Mngke3B9ZmAsQz1wPT09MT94OmB2ZWMke3B9PCR7eH0+YCxTPVcoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLHApLEU9SihcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsaSxwKTtyZXR1cm5gXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke1MudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVJbnB1dCA6IGFycmF5PCR7VH0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7RS50eXBlLnN0b3JhZ2V9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHtIOiB1MzIsIEMgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IHNjYWxlT2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlSW5wdXRbc2NhbGVPZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtDfShzY2FsZVswXSksICR7Q30oc2NhbGVbMV0pKTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbk5IV0NcIixzaGFkZXJDYWNoZTp7aGludDpgJHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KSxnZXRTaGFkZXJTb3VyY2U6d30se2lucHV0czpbdFswXSxiXX0pfSxhbD0oZSx0KT0+e3QuZm9ybWF0PT09XCJOSFdDXCI/VHAoZSxlLmlucHV0cyx0KTplLmNvbXB1dGUoSXAoZS5pbnB1dHMsdCkpfX0pO3ZhciBFcCxPcCxvbCxzbD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtDZSgpO19lKCk7RXA9ZT0+e2lmKCFlfHxlLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy5cIil9LE9wPShlLHQscik9PntsZXQgYT1lWzBdLmRpbXMsaT1lWzFdLHM9ZVsyXSxvPWEsYz1OLm5vcm1hbGl6ZUF4aXModC5heGlzLGEubGVuZ3RoKSxwPU4uc2l6ZVRvRGltZW5zaW9uKGEsYyksbT1OLnNpemVGcm9tRGltZW5zaW9uKGEsYyksbD1OLnNpemUoaS5kaW1zKSxnPXM/Ti5zaXplKHMuZGltcyk6MDtpZihsIT09bXx8cyYmZyE9PW0pdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHttfS5cbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7bH0gYW5kIGJpYXMgc2l6ZSBvZiAke2d9YCk7bGV0IGI9W107Zm9yKGxldCBPPTA7TzxhLmxlbmd0aDsrK08pTzxjP2IucHVzaChhW09dKTpiLnB1c2goMSk7bGV0IHc9TGUobSksJD1bXCJ0eXBlXCIsXCJ0eXBlXCJdLHg9W3t0eXBlOlwidWludDMyXCIsZGF0YTpwfSx7dHlwZTpcImZsb2F0MzJcIixkYXRhOm19LHt0eXBlOlwidWludDMyXCIsZGF0YTpNYXRoLmZsb29yKG0vdyl9LHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5lcHNpbG9ufV07cyYmJC5wdXNoKFwidHlwZVwiKTtsZXQgVD1yPjEsQz1yPjIsUz1PPT57bGV0IFU9SGUoZVswXS5kYXRhVHlwZSksRD1bVyhcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyx3KSxXKFwic2NhbGVcIixpLmRhdGFUeXBlLGkuZGltcyx3KV07cyYmRC5wdXNoKFcoXCJiaWFzXCIscy5kYXRhVHlwZSxzLmRpbXMsdykpLEQucHVzaChKKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLHcpKSxUJiZELnB1c2goSihcIm1lYW5fZGF0YV9vdXRwdXRcIiwxLGIpKSxDJiZELnB1c2goSihcImludl9zdGRfb3V0cHV0XCIsMSxiKSk7bGV0IFY9W3tuYW1lOlwibm9ybV9jb3VudFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJub3JtX3NpemVcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwibm9ybV9zaXplX3ZlY3Rvcml6ZWRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHtPLnJlZ2lzdGVyVW5pZm9ybXMoVikuZGVjbGFyZVZhcmlhYmxlcyguLi5EKX1cbiAgJHtPLm1haW5TdGFydCgpfVxuICAgICR7Ty5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMubm9ybV9jb3VudFwiKX1cbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkO1xuICAgIHZhciBtZWFuVmVjdG9yID0gJHtRZShcImYzMlwiLHcpfTtcbiAgICB2YXIgbWVhblNxdWFyZVZlY3RvciA9ICR7UWUoXCJmMzJcIix3KX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7U3QoVSx3LFwieFtoICsgb2Zmc2V0XVwiKX07XG4gICAgICBtZWFuVmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhblNxdWFyZVZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbWVhbiA9ICR7ZnQoXCJtZWFuVmVjdG9yXCIsdyl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZTdGREZXYgPVxuICAgICAgICBpbnZlcnNlU3FydCgke2Z0KFwibWVhblNxdWFyZVZlY3RvclwiLHcpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZSAtIG1lYW4gKiBtZWFuICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtTdChVLHcsXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7U3QoVSx3LFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtEWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAtIG1lYW4pICogaW52U3RkRGV2ICogZjMyc2NhbGVcbiAgICAgICAgJHtzP2ArICR7U3QoVSx3LFwiYmlhc1tqXVwiKX1gOlwiXCJ9XG4gICAgICApO1xuICAgIH1cblxuICAgICR7VD9cIm1lYW5fZGF0YV9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuXCI6XCJcIn07XG4gICAgJHtDP1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZTdGREZXZcIjpcIlwifTtcbiAgfWB9LEU9W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiBUJiZFLnB1c2goe2RpbXM6YixkYXRhVHlwZToxfSksQyYmRS5wdXNoKHtkaW1zOmIsZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7d307JHtyfWAsaW5wdXREZXBlbmRlbmNpZXM6JH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOkUsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3Jtczp4fSksZ2V0U2hhZGVyU291cmNlOlN9fSxvbD0oZSx0KT0+e0VwKGUuaW5wdXRzKSxlLmNvbXB1dGUoT3AoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50KSl9fSk7dmFyIGtwLGxsLHVsLFBwLGRpLGRsLGNsPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1hlKCk7Vm4oKTtaYSgpO19lKCk7JHIoKTtrcD0oZSx0KT0+e2xldCByPWVbMF0sYT1lWzFdLGk9ZVsyXSxzPWVbM10sbz1lWzRdLGM9ZVs1XSxwPWVbNl0sbT1lWzddO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBsPSExLGc9ci5kaW1zWzBdLGI9ci5kaW1zWzFdLHc9ci5kaW1zLmxlbmd0aD09PTM/bD9yLmRpbXNbMl0vMzpyLmRpbXNbMl06dC5udW1IZWFkcypyLmRpbXNbNF0sJD1iLHg9MCxUPTAsQz1NYXRoLmZsb29yKHcvdC5udW1IZWFkcyk7aWYocCYmbSl7aWYocC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihtLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7eD1wLmRpbXNbMl0sVD1wLmRpbXNbMl19ZWxzZSBpZihwfHxtKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtsZXQgUztpZihhKXtpZihyLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO2lmKGEuZGltcy5sZW5ndGg8M3x8YS5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PWEuZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7aWYoYS5kaW1zLmxlbmd0aD09PTMpe2lmKGEuZGltc1syXSE9PXIuZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKGhpZGRlbl9zaXplKScpO1M9MiwkPWEuZGltc1sxXX1lbHNlIGlmKGEuZGltcy5sZW5ndGg9PT01KXtpZihhLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxhLmRpbXNbM10hPT0yfHxhLmRpbXNbNF0hPT1DKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtpZihpKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtTPTUsJD1hLmRpbXNbMV19ZWxzZXtpZihhLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxhLmRpbXNbM10hPT1DKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO1M9MCwkPWEuZGltc1syXX19ZWxzZXtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKHIuZGltcy5sZW5ndGg9PT01JiYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7Uz0zfWlmKHMpe2lmKHMuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO2lmKGkmJnIuZGltcy5sZW5ndGg9PT01JiZyLmRpbXNbM109PT0yKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdi5cIil9bGV0IEU9MDtpZihvKXtFPTg7bGV0IFk9by5kaW1zO3Rocm93IFkubGVuZ3RoPT09MT9ZWzBdPT09Zz9FPTE6WVswXT09PTMqZysyJiYoRT0zKTpZLmxlbmd0aD09PTImJllbMF09PT1nJiZZWzFdPT09JCYmKEU9NSksRT09PTg/bmV3IEVycm9yKCdJbnB1dCBcImtleV9wYWRkaW5nX21hc2tcIiBzaGFwZSBzaGFsbCBiZSAoYmF0Y2hfc2l6ZSkgb3IgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCknKTpuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIil9bGV0IE89ITEsVT13O2lmKGkpe2lmKGkuZGltcy5sZW5ndGghPT0zJiZpLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09aS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO2lmKGkuZGltcy5sZW5ndGg9PT0zKXtpZigkIT09aS5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtVPWkuZGltc1syXX1lbHNle2lmKCQhPT1pLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtVPWkuZGltc1sxXSppLmRpbXNbM10sTz0hMH19bGV0IEQ9eCskLFY9ITE7aWYobyl0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoYyl0aHJvdyBuZXcgRXJyb3IoXCJleHRyYUFkZFFrIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYocCl0aHJvdyBuZXcgRXJyb3IoXCJwYXN0S2V5IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYobSl0aHJvdyBuZXcgRXJyb3IoXCJwYXN0VmFsdWUgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm57YmF0Y2hTaXplOmcsc2VxdWVuY2VMZW5ndGg6YixwYXN0U2VxdWVuY2VMZW5ndGg6eCxrdlNlcXVlbmNlTGVuZ3RoOiQsdG90YWxTZXF1ZW5jZUxlbmd0aDpELG1heFNlcXVlbmNlTGVuZ3RoOlQsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTp3LHZIaWRkZW5TaXplOlUsaGVhZFNpemU6Qyx2SGVhZFNpemU6TWF0aC5mbG9vcihVL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpFLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczpWLHBhc3NQYXN0SW5LdjpPLHFrdkZvcm1hdDpTfX0sbGw9ZT0+eGUoey4uLmV9KSx1bD14ZSh7cGVybTpbMCwyLDEsM119KSxQcD0oZSx0LHIsYSxpLHMsbyk9PntsZXQgYz1bYSxpLHNdLHA9Ti5zaXplKGMpLG09W3t0eXBlOlwidWludDMyXCIsZGF0YTpwfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6b30se3R5cGU6XCJ1aW50MzJcIixkYXRhOnN9XSxsPWc9PntsZXQgYj1KKFwicWt2X3dpdGhfYmlhc1wiLHQuZGF0YVR5cGUsYyksdz1XKFwicWt2XCIsdC5kYXRhVHlwZSxjKSwkPVcoXCJiaWFzXCIsci5kYXRhVHlwZSxjKSx4PVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfb2Zmc2V0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke2cucmVnaXN0ZXJVbmlmb3Jtcyh4KS5kZWNsYXJlVmFyaWFibGVzKHcsJCxiKX1cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIk11bHRpSGVhZEF0dGVudGlvbkFkZEJpYXNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpjLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTpsfSx7aW5wdXRzOlt0LHJdLG91dHB1dHM6Wy0xXX0pWzBdfSxkaT0oZSx0LHIsYSxpLHMsbyxjKT0+e2xldCBwPXM7aWYobyl7aWYoYT09PTEpdGhyb3cgbmV3IEVycm9yKFwiQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWXCIpO3JldHVybiBwPVBwKGUscyxvLHQsYSxyKmksYykscD1wLnJlc2hhcGUoW3QsYSxyLGldKSxlLmNvbXB1dGUoeHQocCx1bC5wZXJtKSx7aW5wdXRzOltwXSxvdXRwdXRzOlstMV19KVswXX1lbHNlIHJldHVybiBzLmRpbXMubGVuZ3RoPT09MyYmKHA9cy5yZXNoYXBlKFt0LGEscixpXSkpLGUuY29tcHV0ZSh4dChwLHVsLnBlcm0pLHtpbnB1dHM6W3BdLG91dHB1dHM6Wy0xXX0pWzBdfSxkbD0oZSx0KT0+e2xldCByPWtwKGUuaW5wdXRzLHQpO2lmKGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihlLmlucHV0c1sxXT8uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7bGV0IGE9ZS5pbnB1dHNbMV0mJmUuaW5wdXRzWzJdJiZlLmlucHV0c1sxXS5kaW1zLmxlbmd0aD09PTQmJmUuaW5wdXRzWzJdLmRpbXMubGVuZ3RoPT09NCxpPWRpKGUsci5iYXRjaFNpemUsci5udW1IZWFkcyxyLnNlcXVlbmNlTGVuZ3RoLHIuaGVhZFNpemUsZS5pbnB1dHNbMF0sZS5pbnB1dHNbM10sMCk7aWYoYSlyZXR1cm4gWW4oZSxpLGUuaW5wdXRzWzFdLGUuaW5wdXRzWzJdLGUuaW5wdXRzWzRdLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGUuaW5wdXRzWzVdLHIsdCk7bGV0IHM9ZGkoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLGUuaW5wdXRzWzFdLGUuaW5wdXRzWzNdLHIuaGlkZGVuU2l6ZSksbz1kaShlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5rdlNlcXVlbmNlTGVuZ3RoLHIudkhlYWRTaXplLGUuaW5wdXRzWzJdLGUuaW5wdXRzWzNdLDIqci5oaWRkZW5TaXplKTtZbihlLGkscyxvLGUuaW5wdXRzWzRdLHZvaWQgMCxlLmlucHV0c1s2XSxlLmlucHV0c1s3XSxlLmlucHV0c1s1XSxyLHQpfX0pO3ZhciBScCxCcCxNcCxEcCx6cCxVcCxXcCxOcCxwbCxmbD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtDZSgpO19lKCk7UnA9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIlRvbyBmZXcgaW5wdXRzXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xJiZlWzBdLmRhdGFUeXBlIT09MTApdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZSBtdXN0IGJlIGZsb2F0IG9yIGZsb2F0MTYuXCIpO2lmKGUubGVuZ3RoPj0yKXtsZXQgdD1lWzBdLmRpbXMubGVuZ3RoKjI9PT1lWzFdLmRpbXNbMF07aWYoZS5sZW5ndGg9PT00JiYodD1lWzNdLmRpbXNbMF0qMj09PWVbMV0uZGltc1swXSksIXQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhZHMgc2hvdWxkIGJlIGEgMUQgdGVuc29yIG9mIHNoYXBlIFsyICogaW5wdXRfcmFua10gb3IgWzIgKiBudW1fYXhlc10uXCIpfX0sQnA9KGUsdCxyKT0+e2xldCBhPVwiXCI7Zm9yKGxldCBpPXQtMTtpPj0wOy0taSlhKz1gXG4gICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGkpfSkgLSAke2NlKFwidW5pZm9ybXMucGFkc1wiLGkscil9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsaSx0KX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtjZShcInVuaWZvcm1zLnhfc3RyaWRlc1wiLGksdCl9KTtcbiAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgdmFsdWUgPSAke2UudHlwZS52YWx1ZX0odW5pZm9ybXMuY29uc3RhbnRfdmFsdWUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICR7YX1cbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgIGB9LE1wPShlLHQscik9PntsZXQgYT1cIlwiO2ZvcihsZXQgaT10LTE7aT49MDstLWkpYSs9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsaSl9KSAtICR7Y2UoXCJ1bmlmb3Jtcy5wYWRzXCIsaSxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsaSx0KX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtjZShcInVuaWZvcm1zLnhfc2hhcGVcIixpLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IF8ybl8xIC0gaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtjZShcInVuaWZvcm1zLnhfc3RyaWRlc1wiLGksdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2F9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LERwPShlLHQscik9PntsZXQgYT1cIlwiO2ZvcihsZXQgaT10LTE7aT49MDstLWkpYSs9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsaSl9KSAtICR7Y2UoXCJ1bmlmb3Jtcy5wYWRzXCIsaSxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsaSx0KX0pKSB7XG4gICAgICAgICAgICAgICAgICBrID0gaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsaSx0KX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtjZShcInVuaWZvcm1zLnhfc3RyaWRlc1wiLGksdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2F9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHpwPShlLHQscik9PntsZXQgYT1cIlwiO2ZvcihsZXQgaT10LTE7aT49MDstLWkpYSs9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsaSl9KSAtICR7Y2UoXCJ1bmlmb3Jtcy5wYWRzXCIsaSxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSAge1xuICAgICAgICAgICAgICAgICAgayArPSBpMzIoJHtjZShcInVuaWZvcm1zLnhfc2hhcGVcIixpLHQpfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtjZShcInVuaWZvcm1zLnhfc2hhcGVcIixpLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsaSx0KX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2NlKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsaSx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7YX1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sVXA9KGUsdCxyKT0+e3N3aXRjaChyLm1vZGUpe2Nhc2UgMDpyZXR1cm4gQnAoZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMTpyZXR1cm4gTXAoZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMjpyZXR1cm4gRHAoZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMzpyZXR1cm4genAoZSx0LHIucGFkcy5sZW5ndGgpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sV3A9KGUsdCk9PntsZXQgcj1OLnBhZFNoYXBlKGVbMF0uZGltcy5zbGljZSgpLHQucGFkcyksYT1lWzBdLmRpbXMscz1be3R5cGU6XCJ1aW50MzJcIixkYXRhOk4uc2l6ZShyKX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnQucGFkc31dO2lmKHQubW9kZT09PTApe2xldCBwPXB0KGVbMF0uZGF0YVR5cGUpO3MucHVzaCh7dHlwZTpwLGRhdGE6dC52YWx1ZX0pfXMucHVzaCguLi5MKGVbMF0uZGltcyksLi4uTChyKSk7bGV0IG89W1wicmFua1wiXSxjPXA9PntsZXQgbT1KKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxyLmxlbmd0aCksbD1XKFwieFwiLGVbMF0uZGF0YVR5cGUsYS5sZW5ndGgpLGc9bC50eXBlLnZhbHVlLGI9VXAobSxhLmxlbmd0aCx0KSx3PVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOnQucGFkcy5sZW5ndGh9XTtyZXR1cm4gdC5tb2RlPT09MCYmdy5wdXNoKHtuYW1lOlwiY29uc3RhbnRfdmFsdWVcIix0eXBlOmd9KSxgXG4gICAgICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3Jtcyh3KS5kZWNsYXJlVmFyaWFibGVzKGwsbSl9XG4gICAgICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtnfSgwKTtcbiAgICAgICAgICAgICR7Yn1cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9YCxpbnB1dERlcGVuZGVuY2llczpvfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKE4uc2l6ZShyKS82NCl9LHByb2dyYW1Vbmlmb3JtczpzfSksZ2V0U2hhZGVyU291cmNlOmN9fSxOcD0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLGE9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsaT1lWzBdLmRpbXMubGVuZ3RoLHM9bmV3IEludDMyQXJyYXkoMippKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgYz1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IHA9MDtwPGMubGVuZ3RoO3ArKylzW051bWJlcihjW3BdKV09TnVtYmVyKHJbcF0pLHNbTnVtYmVyKGNbcF0pK2ldPU51bWJlcihyW3ArYy5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgoYyxwKT0+c1tOdW1iZXIocCldPU51bWJlcihjKSk7bGV0IG89W107cmV0dXJuIHMuZm9yRWFjaChjPT5vLnB1c2goYykpLHttb2RlOnQubW9kZSx2YWx1ZTphLHBhZHM6b319ZWxzZSByZXR1cm4gdH0scGw9KGUsdCk9PntScChlLmlucHV0cyk7bGV0IHI9TnAoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKFdwKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIGFhLG1sLGhsLGdsLHlsLFZwLEhwLGJsLHZsLHdsLCRsLF9sLFNsLHhsLENsLElsLEFsLFRsLEVsLE9sPVEoKCk9PntcInVzZSBzdHJpY3RcIjtidCgpO0NlKCk7X2UoKTthYT1lPT57aWYoQWUud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiYoIWV8fGUubGVuZ3RoIT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIil9LG1sPShlLHQscik9PntsZXQgYT10LmZvcm1hdD09PVwiTkhXQ1wiLGk9ZS5kaW1zLnNsaWNlKCk7YSYmaS5zcGxpY2UoMSwwLGkucG9wKCkpO2xldCBzPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIiksbz10Lmtlcm5lbFNoYXBlLnNsaWNlKCksYz10LnN0cmlkZXMuc2xpY2UoKSxwPXM/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxtPXQucGFkcy5zbGljZSgpO29yLmFkanVzdFBvb2xBdHRyaWJ1dGVzKHIsaSxvLGMscCxtKTtsZXQgbD1vci5jb21wdXRlUG9vbE91dHB1dFNoYXBlKHIsaSxjLHAsbyxtLHQuYXV0b1BhZCksZz1PYmplY3QuYXNzaWduKHt9LHQpO3M/T2JqZWN0LmFzc2lnbihnLHtrZXJuZWxTaGFwZTpvLHN0cmlkZXM6YyxwYWRzOm0sZGlsYXRpb25zOnAsY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24oZyx7a2VybmVsU2hhcGU6byxzdHJpZGVzOmMscGFkczptLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTtsZXQgYj1sLnNsaWNlKCk7cmV0dXJuIGIucHVzaChiLnNwbGljZSgxLDEpWzBdKSxbZyxhP2I6bF19LGhsPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixhPU4uc2l6ZShlKSxpPU4uc2l6ZSh0Lmtlcm5lbFNoYXBlKSxzPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6YX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOml9XSxvPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgYz10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLHA9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0sbT10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLGw9dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0sZz0hIShtK2wpO3MucHVzaCh7dHlwZTpcInVpbnQzMlwiLGRhdGE6Y30se3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9LHt0eXBlOlwidWludDMyXCIsZGF0YTptfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6bH0pLG8ucHVzaCh7bmFtZTpcImt3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3U3RhcnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdFbmRcIix0eXBlOlwidTMyXCJ9KTtsZXQgYj0hMTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCB3PXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMl0sJD10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0yXSx4PXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMl0sVD10LnBhZHNbdC5wYWRzLmxlbmd0aC0yXTtiPSEhKHgrVCkscy5wdXNoKHt0eXBlOlwidWludDMyXCIsZGF0YTp3fSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6JH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnh9LHt0eXBlOlwidWludDMyXCIsZGF0YTpUfSksby5wdXNoKHtuYW1lOlwia2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaEVuZFwiLHR5cGU6XCJ1MzJcIn0pfXJldHVybltzLG8sITAsZyxiXX1lbHNle2lmKHIpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBjPU4uY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSk7cy5wdXNoKHt0eXBlOlwidWludDMyXCIsZGF0YTpjfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5wYWRzfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5zdHJpZGVzfSksby5wdXNoKHtuYW1lOlwia2VybmVsU3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Yy5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSk7bGV0IHA9dC5wYWRzLnJlZHVjZSgobSxsKT0+bStsKTtyZXR1cm5bcyxvLCEhcCwhMSwhMV19fSxnbD0oZSx0LHIsYSxpLHMsbyxjLHAsbSxsLGcpPT57bGV0IGI9aS5mb3JtYXQ9PT1cIk5IV0NcIix3PXQudHlwZS52YWx1ZSwkPUooXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLGEpO2lmKGkua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgeD1cIlwiLFQ9XCJcIixDPVwiXCIsUz1yLShiPzI6MSk7aWYobD94PWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7U31dID0gaW5kaWNlc1ske1N9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtTfV0gPCAwIHx8IHhJbmRpY2VzWyR7U31dXG4gICAgICAgICAgICAgICAgICAgICAgPj0gdW5pZm9ybXMueF9zaGFwZVske1N9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtzfVxuICAgICAgICAgICAgICAgIH1gOng9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtTfV0gPSBpbmRpY2VzWyR7U31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke3N9XG4gICAgICAgICAgICAgICAgfWAsaS5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgTz1yLShiPzM6Mik7Zz9UPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7T31dID0gaW5kaWNlc1ske099XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtPfV0gPCAwIHx8IHhJbmRpY2VzWyR7T31dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtPfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgOlQ9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtPfV0gPSBpbmRpY2VzWyR7T31dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICBgLEM9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKHApLmRlY2xhcmVWYXJpYWJsZXModCwkKX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke3d9KCR7Y30pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtUfVxuICAgICAgICAgICAgICAke3h9XG4gICAgICAgICAgICAgICR7Q31cbiAgICAgICAgICAgICAgJHtvfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9ZWxzZXtpZihiKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgeD1pLmtlcm5lbFNoYXBlLmxlbmd0aCxUPWkucGFkcy5sZW5ndGgsQz1cIlwiO3JldHVybiBtP0M9YFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAke3N9XG4gICAgICAgICAgICAgIH1gOkM9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICR7c31cbiAgICAgICAgICAgIGAsYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMocCkuZGVjbGFyZVZhcmlhYmxlcyh0LCQpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke3h9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke3d9KCR7Y30pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke3gtMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke2NlKFwidW5pZm9ybXMua2VybmVsU3RyaWRlc1wiLFwialwiLHgpfTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICogJHtjZShcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIix4KX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHt4LTF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7ci14fXU7IGogPCAke3J9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke2NlKFwidW5pZm9ybXMuc3RyaWRlc1wiLGBqIC0gJHtyLXh9dWAseCl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtyLXh9dV0gLSAke2NlKFwidW5pZm9ybXMucGFkc1wiLFwiaiAtIDJ1XCIsVCl9O1xuICAgICAgICAgICAgICAgICAgJHtDfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7b31cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gfX0seWw9ZT0+YCR7ZS5mb3JtYXR9OyR7ZS5jZWlsTW9kZX07JHtlLmF1dG9QYWR9OyR7ZS5rZXJuZWxTaGFwZS5sZW5ndGh9YCxWcD1lPT5gJHt5bChlKX07JHtlLmNvdW50SW5jbHVkZVBhZH1gLEhwPWU9PmAke3lsKGUpfTske2Uuc3RvcmFnZU9yZGVyfTske2UuZGlsYXRpb25zfWAsYmw9ZT0+KHtmb3JtYXQ6ZS5mb3JtYXQsYXV0b1BhZDpbXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLGNlaWxNb2RlOmUuY2VpbF9tb2RlLGtlcm5lbFNoYXBlOmUua2VybmVsX3NoYXBlLHN0cmlkZXM6ZS5zdHJpZGVzLHBhZHM6ZS5wYWRzfSksdmw9KGUsdCxyLGEpPT57bGV0W2ksc109bWwodCxhLHIpLG89VyhcInhcIix0LmRhdGFUeXBlLHQuZGltcy5sZW5ndGgpLGM9by50eXBlLnZhbHVlLHA9XCJ2YWx1ZSArPSB4X3ZhbDtcIixtPVwiXCI7aS5jb3VudEluY2x1ZGVQYWQ/bSs9YHZhbHVlIC89ICR7Y30odW5pZm9ybXMua2VybmVsU2l6ZSk7YDptKz1gdmFsdWUgLz0gJHtjfShpMzIodW5pZm9ybXMua2VybmVsU2l6ZSkgLSBwYWQpO2A7bGV0W2wsZyxiLHcsJF09aGwocyxpKTtsLnB1c2goLi4uTCh0LmRpbXMpLC4uLkwocykpO2xldCB4PVtcInJhbmtcIl07cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHthLmNhY2hlS2V5fTske2J9OyR7d307JHskfWAsaW5wdXREZXBlbmRlbmNpZXM6eH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChOLnNpemUocykvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bH0pLGdldFNoYWRlclNvdXJjZTpUPT5nbChULG8sdC5kaW1zLmxlbmd0aCxzLmxlbmd0aCxpLHAsbSwwLGcsYix3LCQpfX0sd2w9ZT0+e2xldCB0PWUuY291bnRfaW5jbHVkZV9wYWQhPT0wLHI9YmwoZSk7aWYoci5jZWlsTW9kZSE9PTApdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtsZXQgYT17Y291bnRJbmNsdWRlUGFkOnQsLi4ucixjYWNoZUtleTpcIlwifTtyZXR1cm57Li4uYSxjYWNoZUtleTpWcChhKX19LCRsPShlLHQpPT57YWEoZS5pbnB1dHMpLGUuY29tcHV0ZSh2bChcIkF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxfbD17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W119LFNsPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4uX2wsY2FjaGVLZXk6dH19LHhsPShlLHQpPT57YWEoZS5pbnB1dHMpLGUuY29tcHV0ZSh2bChcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfSxDbD0oZSx0LHIsYSk9PntsZXRbaSxzXT1tbCh0LGEsciksbz1gXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xuICAgIGAsYz1cIlwiLHA9VyhcInhcIix0LmRhdGFUeXBlLHQuZGltcy5sZW5ndGgpLG09W1wicmFua1wiXSxbbCxnLGIsdywkXT1obChzLGkpO3JldHVybiBsLnB1c2goLi4uTCh0LmRpbXMpLC4uLkwocykpLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7YS5jYWNoZUtleX07JHtifTske3d9OyR7JH1gLGlucHV0RGVwZW5kZW5jaWVzOm19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoTi5zaXplKHMpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmx9KSxnZXRTaGFkZXJTb3VyY2U6eD0+Z2woeCxwLHQuZGltcy5sZW5ndGgscy5sZW5ndGgsaSxvLGMsLTFlNSxnLGIsdywkKX19LElsPShlLHQpPT57YWEoZS5pbnB1dHMpLGUuY29tcHV0ZShDbChcIk1heFBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LEFsPWU9PntsZXQgdD1lLnN0b3JhZ2Vfb3JkZXIscj1lLmRpbGF0aW9ucyxhPWJsKGUpO2lmKHQhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKGEuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtsZXQgaT17c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOnIsLi4uYSxjYWNoZUtleTpcIlwifTtyZXR1cm57Li4uaSxjYWNoZUtleTpIcChpKX19LFRsPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4uX2wsY2FjaGVLZXk6dH19LEVsPShlLHQpPT57YWEoZS5pbnB1dHMpLGUuY29tcHV0ZShDbChcIkdsb2JhbE1heFBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9fSk7dmFyIEdwLEZwLGtsLFBsPVEoKCk9PntcInVzZSBzdHJpY3RcIjtidCgpO3plKCk7X2UoKTtHcD0oZSx0LHIpPT57bGV0IGE9ZT09PXQsaT1lPHQmJnI8MCxzPWU+dCYmcj4wO2lmKGF8fGl8fHMpdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LEZwPShlLHQscixhKT0+e2xldCBpPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9yKSkscz1baV0sbz1pLGM9cHQoYSkscD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOm99LHt0eXBlOmMsZGF0YTplfSx7dHlwZTpjLGRhdGE6cn0sLi4uTChzKV0sbT1sPT57bGV0IGc9SihcIm91dHB1dFwiLGEscy5sZW5ndGgpLGI9Zy50eXBlLnZhbHVlLHc9W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdGFydFwiLHR5cGU6Yn0se25hbWU6XCJkZWx0YVwiLHR5cGU6Yn1dO3JldHVybmBcbiAgICAgICAgJHtsLnJlZ2lzdGVyVW5pZm9ybXModykuZGVjbGFyZVZhcmlhYmxlcyhnKX1cbiAgICAgICAgJHtsLm1haW5TdGFydCgpfVxuICAgICAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHVuaWZvcm1zLnN0YXJ0ICsgJHtifShnbG9iYWxfaWR4KSAqIHVuaWZvcm1zLmRlbHRhO1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiUmFuZ2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHthfWB9LGdldFNoYWRlclNvdXJjZTptLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3JtczpwfSl9fSxrbD1lPT57bGV0IHQ9MCxyPTAsYT0wO2UuaW5wdXRzWzBdLmRhdGFUeXBlPT09Nj8odD1lLmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRJbnQzMkFycmF5KClbMF0sYT1lLmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF0pOmUuaW5wdXRzWzBdLmRhdGFUeXBlPT09MSYmKHQ9ZS5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF0scj1lLmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxhPWUuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdKSxBZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJkdwKHQscixhKSxlLmNvbXB1dGUoRnAodCxyLGEsZS5pbnB1dHNbMF0uZGF0YVR5cGUpLHtpbnB1dHM6W119KX19KTt2YXIgcXAsanAsS3AsWXAsWnAsWHAsUXAsSnAsZWYsdGYscmYsUmwsbmYsYWYsb2Ysc2YsdWYsQmwsTWwsRGw9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7WGUoKTtfZSgpO3FwPShlLHQpPT57aWYoZS5ldmVyeShyPT5yPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTN8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MXx8ZS5sZW5ndGg9PT01JiZlWzBdPT09MSYmZVsxXT09PTEpKXRocm93IG5ldyBFcnJvcihgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSxqcD0oZSx0LHIpPT57dC5ldmVyeShpPT5pPj0wJiZpPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IGE9bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgoaSxzKT0+YVtpXT1lW3NdKSxhfSxLcD0oZSx0LHIsYSxpLHMpPT57bGV0W28sYyxwXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0sbT1lWzBdLmRpbXMubGVuZ3RoO2lmKG8+MCYmZS5sZW5ndGg+byYmZVtvXS5kaW1zLmxlbmd0aD4wKWVbb10uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChsPT5zLnB1c2gobCkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoYz4wJiZlLmxlbmd0aD5jJiZlW2NdLmRpbXMubGVuZ3RoPjApe2lmKGVbY10uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChsPT5hLnB1c2gobCkpLGEubGVuZ3RoIT09MCYmYS5sZW5ndGghPT1tJiZyPj0xOCYmYS5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7cXAoYSx0KSx0LmF4ZXMubGVuZ3RoPjAmJmpwKGEsdC5heGVzLG0pLmZvckVhY2goKGwsZyk9PmFbZ109bCl9aWYocD4wJiZlLmxlbmd0aD5wJiYoZVtwXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChsPT5pLnB1c2goTnVtYmVyKGwpKSksaS5sZW5ndGghPT1tfHxyPj0xOCYmaS5sZW5ndGg9PT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihhLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihpLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzaXplc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgcmFuayBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyl9aWYodHlwZW9mIGE8XCJ1XCImJnR5cGVvZiBpPFwidVwiJiZhLmxlbmd0aD4wJiZpLmxlbmd0aD5tKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBvbmx5IG9mIHNjYWxlcyBvciBzaXplcyB0byBiZSBzcGVjaWZpZWRcIil9LFlwPShlLHQpPT5gZm4gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKHhSZXNpemVkOiB1MzIsIHhTY2FsZTogZjMyLCBsZW5ndGhSZXNpemVkOiB1MzIsXG4gICAgIGxlbmd0aE9yaWdpbmFsOiB1MzIsIHJvaVN0YXJ0OiBmMzIsIHJvaUVuZDogZjMyKSAtPiAke3R9IHsgYCsoKCk9Pntzd2l0Y2goZSl7Y2FzZVwiYXN5bW1ldHJpY1wiOnJldHVybmByZXR1cm4gJHt0fSh4UmVzaXplZCkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpIC0gMC41O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCI6cmV0dXJuYHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpO2A7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd2hvbGUgcGFydCBhbmQgdGhlIGZyYWN0aW9uYWwgcGFydCBhcmUgY2FsY3VsYXRlZCBzZXBhcmF0ZWx5IGR1ZSB0byBpbmFjY3VyYWN5IG9mIGZsb2F0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50IGRpdmlzaW9uLiBBcyBhbiBleGFtcGxlLCBmMzIoMjEpIC8gZjMyKDcpIG1heSBldmFsdWF0ZSB0byAyLjk5Li4uIGluc3RlYWQgb2YgMywgY2F1c2luZyBhblxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQtYnktb25lIGVycm9yIGxhdGVyIGluIGZsb29yKCkuXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aG9sZSA9ICR7dH0oeFJlc2l6ZWQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSAvIChsZW5ndGhSZXNpemVkIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJhY3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJHt0fSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpICUgKGxlbmd0aFJlc2l6ZWQgLSAxKSkgLyAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdob2xlICsgZnJhY3Q7XG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAke3R9KHJvaVN0YXJ0KSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJHt0fSh4UmVzaXplZCkgKiAke3R9KHJvaUVuZCAtIHJvaVN0YXJ0KSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgJHt0fShsZW5ndGhSZXNpemVkIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogJHt0fShyb2lTdGFydCArIHJvaUVuZCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJoYWxmX3BpeGVsX3N5bW1ldHJpY1wiOnJldHVybmBjb25zdCBvdXRwdXRXaWR0aCA9ICR7dH14U2NhbGUgKiAke3R9KGxlbmd0aFJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9ICR7dH0obGVuZ3RoUmVzaXplZCkgLyBvdXRwdXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9ICR7dH0obGVuZ3RoT3JpZ2luYWwpIC8gMjtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGNlbnRlciAqICgxIC0gYWRqdXN0bWVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgKCgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkpIC0gMC41O2A7Y2FzZVwiaGFsZl9waXhlbFwiOnJldHVybmByZXR1cm4gKCgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkpIC0gMC41O2A7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixacD0oZSx0LHIpPT5gZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtyfSwgaXNEb3duU2FtcGxlOiBib29sKSAtPiAke3J9IHtgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJyb3VuZF9wcmVmZXJfY2VpbFwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgIH1cIjtjYXNlXCJmbG9vclwiOnJldHVyblwicmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7XCI7Y2FzZVwiY2VpbFwiOnJldHVyblwicmV0dXJuIGNlaWwoeE9yaWdpbmFsKTtcIjtjYXNlXCJyb3VuZF9wcmVmZXJfZmxvb3JcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9vcih4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwic2ltcGxlXCI6ZGVmYXVsdDppZih0PDExKXJldHVyblwiaWYgKGlzRG93blNhbXBsZSkgICAgICAgICAgICAgICAgICAgICB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyAgICAgICAgICAgICAgICAgICAgIH1cIjt0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLFhwPShlLHQscik9PntsZXQgYT1uZXcgQXJyYXkocikuZmlsbCgwKS5jb25jYXQobmV3IEFycmF5KHIpLmZpbGwoMSkpLGk9ZS5sZW5ndGg9PT0wP2E6ZS5zbGljZSgpO3JldHVybiB0Lmxlbmd0aD4wPyh0LmZvckVhY2goKHMsbyk9PnthW3NdPWlbb10sYVtvK3JdPWlbdC5sZW5ndGgrb119KSxhKTppfSxRcD0oZSx0LHIsYSk9PntsZXQgaT1bXTtpZihyLmxlbmd0aD4wKWlmKGEubGVuZ3RoPjApe2lmKGUuZm9yRWFjaChzPT5pLnB1c2gocykpLE1hdGgubWF4KC4uLmEpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMgaXMgb3V0IG9mIGJvdW5kXCIpO2EuZm9yRWFjaCgocyxvKT0+aVtzXT1yW29dKX1lbHNlIHIuZm9yRWFjaChzPT5pLnB1c2gocykpO2Vsc2V7aWYodC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLlwiKTtpPWUubWFwKChzLG8pPT5NYXRoLnJvdW5kKHMqdFtvXSkpfXJldHVybiBpfSxKcD0oZSx0LHIpPT57bGV0IGE9KCgpPT57c3dpdGNoKHIua2VlcEFzcGVjdFJhdGlvUG9saWN5KXtjYXNlXCJub3RfbGFyZ2VyXCI6cmV0dXJuIHIuYXhlcy5sZW5ndGg+MD9NYXRoLm1pbiguLi5yLmF4ZXMubWFwKHM9PnRbc10pLE51bWJlci5NQVhfVkFMVUUpOk1hdGgubWluKC4uLnQsTnVtYmVyLk1BWF9WQUxVRSk7Y2FzZVwibm90X3NtYWxsZXJcIjpyZXR1cm4gci5heGVzLmxlbmd0aD4wP01hdGgubWF4KC4uLnIuYXhlcy5tYXAocz0+dFtzXSksTnVtYmVyLk1JTl9WQUxVRSk6TWF0aC5tYXgoLi4udCxOdW1iZXIuTUlOX1ZBTFVFKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgS2VlcCBhc3BlY3QgcmF0aW8gcG9saWN5ICR7ci5rZWVwQXNwZWN0UmF0aW9Qb2xpY3l9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpO3QuZmlsbCgxLDAsdC5sZW5ndGgpO2xldCBpPWUuc2xpY2UoKTtyZXR1cm4gci5heGVzLmxlbmd0aD4wPyhyLmF4ZXMuZm9yRWFjaChzPT50W3NdPWEpLHIuYXhlcy5mb3JFYWNoKHM9Pmlbc109TWF0aC5yb3VuZChlW3NdKnRbc10pKSk6KHQuZmlsbChhLDAsdC5sZW5ndGgpLGkuZm9yRWFjaCgocyxvKT0+aVtvXT1NYXRoLnJvdW5kKHMqdFtvXSkpKSxpfSxlZj0oZSx0LHIsYSxpKT0+YFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke3IubGVuZ3RofT4ge1xuICAgICAgdmFyIG9yaWdpbmFsX2luZGljZXM6IGFycmF5PCR7ZS50eXBlLnZhbHVlfSwgJHtyLmxlbmd0aH0+O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtlLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7Y2UoXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixhKX07XG4gICAgICAgIHZhciByb2lfbG93ID0gJHtjZShcInVuaWZvcm1zLnJvaVwiLFwiaVwiLGkpfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5yb2lcIixgaSArICR7dC5sZW5ndGh9YCxpKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtlLnR5cGUudmFsdWV9KG91dHB1dF9pbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlucHV0X3NoYXBlX2kgPSAke2NlKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YCx0Zj0oZSx0LHIsYSxpLHMsbyk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7YS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtjZShcInVuaWZvcm1zLnNjYWxlc1wiLFwiaVwiLGkpfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIGlucHV0X2luZGV4ID0gb3V0cHV0X2luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByb2lfbG93ID0gJHtjZShcInVuaWZvcm1zLnJvaVwiLFwiaVwiLHMpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtjZShcInVuaWZvcm1zLnJvaVwiLGBpICsgJHtyLmxlbmd0aH1gLHMpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG91dHB1dF9zaGFwZV9pID0gJHtjZShcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLGEubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG9yaWdpbmFsX2lkeCA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgICAgaWYgKCEke299IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcIiBpbnB1dF9pbmRleFwiKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gLHJmPShlLHQpPT5gXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcImlucHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICBpZiAoaW5wdXRfaW5kZXggPCAwIHx8IGlucHV0X2luZGV4ID49ICR7Y2UoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHQubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gLFJsPShlLHQscixhKT0+ZS5yYW5rPmE/YFxuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHQsXCJjaGFubmVsXCIpfTtcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixyLFwiYmF0Y2hcIil9O1xuYDpcIlwiLG5mPShlLHQscixhLGkpPT57bGV0W28sYyxwLG1dPXIubGVuZ3RoPT09Mj9bLTEsMCwxLC0xXTpbMCwyLDMsMV0sbD1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7bH0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsYyxgbWF4KDAsIG1pbihyb3csICR7cltjXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixwLGBtYXgoMCwgbWluKGNvbCwgJHtyW3BdfSAtIDEpKWApfTtcbiAgICAgICR7UmwoZSxtLG8sMil9XG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7bH0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciByb3c6JHtsfSA9IG9yaWdpbmFsSW5kaWNlc1ske2N9XTtcbiAgICAgIHZhciBjb2w6JHtsfSA9IG9yaWdpbmFsSW5kaWNlc1ske3B9XTtcbiAgICAgICR7YT9gaWYgKHJvdyA8IDAgfHwgcm93ID4gKCR7cltjXX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke3JbcF19IC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICR7aX07XG4gICAgICB9YDpcIlwifTtcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke3JbY119IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7cltwXX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHttfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHtvfV0pYDpcIjBcIn07XG4gICAgICB2YXIgeDExOiAke2x9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiAke2x9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke2x9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiAke2x9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiAke2x9ID0gYWJzKHJvdyAtICR7bH0ocm93MSkpO1xuICAgICAgdmFyIGR4MjogJHtsfSA9IGFicygke2x9KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7bH0gPSBhYnMoY29sIC0gJHtsfShjb2wxKSk7XG4gICAgICB2YXIgZHkyOiAke2x9ID0gYWJzKCR7bH0oY29sMikgLSBjb2wpO1xuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWB9LGFmPShlLHQscixhLGkscyxvLGMscCxtKT0+e2xldCBsPXIubGVuZ3RoPT09MixnPSEwLFtiLHddPWw/WzAsMV06Zz9bMiwzXTpbMSwyXSwkPWUudHlwZS52YWx1ZSx4PVQ9PntsZXQgQz1UPT09Yj9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxuICAgICAgZm4gJHtDfUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAkeyR9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixUKX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHskfSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7aVtUXX0sXG4gICAgICAgICR7YVtUXX0sICR7cltUXX0sICR7c1tUXX0sICR7c1tUXX0gKyAke3IubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAkeyR9ID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xuXG4gICAgICAgIGlmICgke2N9ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtyW1RdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke3B9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwkeyR9LCA0PiA9IGFycmF5PCR7JH0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyICR7Q306ICR7JH0gPSBvcmlnaW5hbElkeCArICR7JH0oaSk7XG4gICAgICAgICAgaWYgKCR7Q30gPCAwIHx8ICR7Q30gPj0gJHtyW1RdfSkge1xuICAgICAgICAgICAgJHsoKCk9Pm0/YGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A6Yz9gcmV0dXJuICR7cH07YDpgJHtDfSA9IG1heCgwLCBtaW4oJHtDfSwgJHtyW1RdfSAtIDEpKTtgKSgpfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNfY29weVwiLFQsYHUzMigke0N9KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7VD09PWI/ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIik6XCJyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcylcIn07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gfTtyZXR1cm5gXG4gICAgJHt4KGIpfTtcbiAgICAke3godyl9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiAkeyR9KSAtPiBhcnJheTwkeyR9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHskfSwgND4gPSBhcnJheTwkeyR9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7JH0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7JH0gPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogJHskfSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke299ICogb25lUGx1c0Fic1MgLSA1ICogJHtvfSkgKiBvbmVQbHVzQWJzUyArIDggKiAke299KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7b307XG4gICAgY29lZmZzWzFdID0gKCgke299ICsgMikgKiBhYnNTIC0gKCR7b30gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke299ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHtvfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke299ICogdHdvTWludXNBYnNTIC0gNSAqICR7b30pICogdHdvTWludXNBYnNTICsgOCAqICR7b30pICogdHdvTWludXNBYnNTIC0gNCAqICR7b307XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7JH0sIDQ+LCBjb2VmczogYXJyYXk8JHskfSwgND4pIC0+ICR7JH0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHskfSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHskfSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XG4gIH1cbiAgICBgfSxvZj0oZSx0LHIsYSxpKT0+e2xldFtvLGMscCxtLGxdPXIubGVuZ3RoPT09Mz9bLTEsMCwxLDIsLTFdOlswLDIsMyw0LDFdLGc9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHtnfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixjLGBtYXgoMCwgbWluKGRlcHRoLCAke3JbY119IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIscCxgbWF4KDAsIG1pbihoZWlnaHQsICR7cltwXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixtLGBtYXgoMCwgbWluKHdpZHRoLCAke3JbbV19IC0gMSkpYCl9O1xuICAgICAgJHtSbChlLGwsbywzKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7Z30ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke2d9ID0gb3JpZ2luYWxJbmRpY2VzWyR7Y31dO1xuICAgICAgdmFyIGhlaWdodDoke2d9ID0gb3JpZ2luYWxJbmRpY2VzWyR7cH1dO1xuICAgICAgdmFyIHdpZHRoOiR7Z30gPSBvcmlnaW5hbEluZGljZXNbJHttfV07XG4gICAgICAke2E/YGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtyW2NdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7cltwXX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtyW21dfSAtIDEpKSB7XG4gICAgICByZXR1cm4gJHtpfTtcbiAgICAgICAgfWA6XCJcIn07XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7cltjXX0gLSAxKSk7XG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtyW3BdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtyW21dfSAtIDEpKTtcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7bH1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7b31dKWA6XCIwXCJ9O1xuXG4gICAgICB2YXIgeDExMTogJHtnfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke2d9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7Z30gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDEyMjogJHtnfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke2d9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7Z30gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDIyMTogJHtnfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke2d9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHtnfSA9IGFicyhkZXB0aCAtICR7Z30oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke2d9ID0gYWJzKCR7Z30oZGVwdGgyKSAtIGRlcHRoKTtcbiAgICAgIHZhciBkeTE6ICR7Z30gPSBhYnMoaGVpZ2h0IC0gJHtnfShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke2d9ID0gYWJzKCR7Z30oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHtnfSA9IGFicyh3aWR0aCAtICR7Z30od2lkdGgxKSk7XG4gICAgICB2YXIgZHoyOiAke2d9ID0gYWJzKCR7Z30od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gfSxzZj0oZSx0LHIsYSxpLHMpPT57bGV0IG89ZS5kaW1zLGM9WHAocyx0LmF4ZXMsby5sZW5ndGgpLHA9UXAobyxhLGksdC5heGVzKSxtPWEuc2xpY2UoKTthLmxlbmd0aD09PTAmJihtPW8ubWFwKChTLEUpPT5TPT09MD8xOnBbRV0vUyksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKHA9SnAobyxtLHQpKSk7bGV0IGw9SihcIm91dHB1dFwiLGUuZGF0YVR5cGUscC5sZW5ndGgpLGc9VyhcImlucHV0XCIsZS5kYXRhVHlwZSxvLmxlbmd0aCksYj1OLnNpemUocCksdz1vLmxlbmd0aD09PXAubGVuZ3RoJiZvLmV2ZXJ5KChTLEUpPT5TPT09cFtFXSksJD10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIix4PXQuZXh0cmFwb2xhdGlvblZhbHVlLFQ9Zy50eXBlLnZhbHVlLEM9Uz0+YFxuICAgICAgJHt3P1wiXCI6YFxuICAgICAgJHtZcCh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLFQpfTtcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtyZihnLG8pfTtcbiAgICAgICAgICAgICAgJHtacCh0Lm5lYXJlc3RNb2RlLHIsVCl9O1xuICAgICAgICAgICAgICAke3RmKGcsbCxvLHAsbS5sZW5ndGgsYy5sZW5ndGgsJCl9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtlZihsLG8scCxtLmxlbmd0aCxjLmxlbmd0aCl9O1xuICAgICAgICAgICAgICAkeygoKT0+e2lmKG8ubGVuZ3RoPT09Mnx8by5sZW5ndGg9PT00KXJldHVybmAke25mKGcsbCxvLCQseCl9YDtpZihvLmxlbmd0aD09PTN8fG8ubGVuZ3RoPT09NSlyZXR1cm5gJHtvZihnLGwsbywkLHgpfWA7dGhyb3cgRXJyb3IoXCJMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcbiAgICAgICAgICAgICR7KCgpPT57aWYoby5sZW5ndGg9PT0yfHxvLmxlbmd0aD09PTQpcmV0dXJuYCR7YWYoZyxsLG8scCxtLGMsdC5jdWJpY0NvZWZmQSwkLHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfWA7dGhyb3cgRXJyb3IoXCJDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xuICAgICAgYH1cbiAgICAgICR7Uy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNjYWxlc1wiLFwiZjMyXCIsbS5sZW5ndGgpLnJlZ2lzdGVyVW5pZm9ybShcInJvaVwiLFwiZjMyXCIsYy5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoZyxsKX1cbiAgICAgICR7Uy5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgJHt3P1wib3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XCI6YFxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2cudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2cuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVybmBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke28ubGVuZ3RoPT09Mnx8by5sZW5ndGg9PT00P1wiYmlsaW5lYXJJbnRlcnBvbGF0aW9uXCI6XCJ0cmlsaW5lYXJJbnRlcnBvbGF0aW9uXCJ9KG91dHB1dF9pbmRpY2VzKTtgO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xuYH1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke20ubGVuZ3RoPjA/bTpcIlwifXwke2kubGVuZ3RoPjA/aTpcIlwifXwke2MubGVuZ3RoPjA/YzpcIlwifXwke3d9fCR7b31gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpDLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cCxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYi82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOmJ9LHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6bX0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTpjfSwuLi5MKG8pLC4uLkwocCldfSl9fSx1Zj1lPT57bGV0IHQ9ZS5jdXN0b21EYXRhQnVmZmVyO3JldHVybiBuZXcgVWludDMyQXJyYXkodCx0LmJ5dGVPZmZzZXQsMSlbMF19LEJsPShlLHQpPT57bGV0IHI9W10sYT1bXSxpPVtdLHM9dWYoZSk7aWYodC5hbnRpYWxpYXMhPT0wKXRocm93IEVycm9yKFwiT25seSBkZWZhdWx0IHZhbHVlICgwKSBmb3IgQW50aWFsaWFzIGF0dHJpYnV0ZSBpcyBzdXBwb3J0ZWRcIik7S3AoZS5pbnB1dHMsdCxzLHIsYSxpKSxlLmNvbXB1dGUoc2YoZS5pbnB1dHNbMF0sdCxzLHIsYSxpKSx7aW5wdXRzOlswXX0pfSxNbD1lPT57bGV0IHQ9ZS5hbnRpYWxpYXMscj1lLmF4ZXMsYT1lLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLGk9ZS5jdWJpY0NvZWZmQSxzPWUuZXhjbHVkZU91dHNpZGUhPT0wLG89ZS5leHRyYXBvbGF0aW9uVmFsdWUsYz1lLmtlZXBBc3BlY3RSYXRpb1BvbGljeSxwPWUubW9kZSxtPWUubmVhcmVzdE1vZGU9PT1cIlwiP1wic2ltcGxlXCI6ZS5uZWFyZXN0TW9kZTtyZXR1cm4geGUoe2FudGlhbGlhczp0LGF4ZXM6cixjb29yZGluYXRlVHJhbnNmb3JtTW9kZTphLGN1YmljQ29lZmZBOmksZXhjbHVkZU91dHNpZGU6cyxleHRyYXBvbGF0aW9uVmFsdWU6byxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6Yyxtb2RlOnAsbmVhcmVzdE1vZGU6bX0pfX0pO3ZhciBsZixkZix6bCxVbD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtDZSgpO19lKCk7bGY9ZT0+e2lmKCFlfHxlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAzIGlucHV0cy5cIik7bGV0IHQ9ZVswXSxyPWVbMV0sYT1lWzJdO2lmKHQuZGF0YVR5cGUhPT1yLmRhdGFUeXBlfHx0LmRhdGFUeXBlIT09YS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGVcIik7aWYodC5kaW1zLmxlbmd0aCE9PTMmJnQuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgMkQgb3IgM0RcIik7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBiZSAyRCBvciAzRFwiKTtsZXQgaT10LmRpbXNbdC5kaW1zLmxlbmd0aC0xXSxzPXQuZGltc1t0LmRpbXMubGVuZ3RoLTJdO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTFdIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0yXSE9PXMpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0XCIpO2lmKGEuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgYmUgMURcIik7aWYoYS5kaW1zW2EuZGltcy5sZW5ndGgtMV0hPT1pKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihlLmxlbmd0aD4zKXtsZXQgbz1lWzNdO2lmKG8uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBiZSAxRFwiKTtpZihvLmRpbXNbby5kaW1zLmxlbmd0aC0xXSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9aWYoZS5sZW5ndGg+NCl7bGV0IG89ZVs0XTtpZihvLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgYmUgMURcIik7aWYoby5kaW1zW28uZGltcy5sZW5ndGgtMV0hPT1pKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfX0sZGY9KGUsdCxyLGEpPT57bGV0IGk9ZVswXS5kaW1zLHM9Ti5zaXplKGkpLG89aSxjPXMscD1pLnNsaWNlKC0xKVswXSxtPWE/aS5zbGljZSgwLC0xKS5jb25jYXQoMSk6W10sbD1lLmxlbmd0aD4zLGc9ZS5sZW5ndGg+NCxiPWEmJnI+MSx3PWEmJnI+MiwkPXI+Myx4PUxlKHApLFQ9W3t0eXBlOlwidWludDMyXCIsZGF0YTpjfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6eH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9LHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5lcHNpbG9ufV0sQz1FPT57bGV0IE89W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiY29tcG9uZW50c1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV0sVT1bVyhcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyx4KSxXKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLHgpLFcoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLHgpXTtsJiZVLnB1c2goVyhcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyx4KSksZyYmVS5wdXNoKFcoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMseCkpLFUucHVzaChKKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLHgpKSxiJiZVLnB1c2goSihcIm1lYW5fb3V0cHV0XCIsMSxtKSksdyYmVS5wdXNoKEooXCJpbnZfc3RkX291dHB1dFwiLDEsbSkpLCQmJlUucHVzaChKKFwiaW5wdXRfc2tpcF9iaWFzX3N1bVwiLGVbMF0uZGF0YVR5cGUsbyx4KSk7bGV0IEQ9SGUoZVswXS5kYXRhVHlwZSk7cmV0dXJuYFxuXG4gICAgICAke0UucmVnaXN0ZXJVbmlmb3JtcyhPKS5kZWNsYXJlVmFyaWFibGVzKC4uLlUpfVxuXG4gICAgICAke0UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7RS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemUgLyB1bmlmb3Jtcy5oaWRkZW5fc2l6ZVwiKX1cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkO1xuICAgICAgICB2YXIgc3VtID0gJHtRZShcImYzMlwiLHgpfTtcbiAgICAgICAgdmFyIHNxdWFyZVN1bSA9ICR7UWUoXCJmMzJcIix4KX07XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke2c/XCJiaWFzW2ldXCI6XCIwLjBcIn07XG4gICAgICAgICAgbGV0IGlucHV0X3ZhbHVlID0geFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dF92YWx1ZSArIHNraXBfdmFsdWUgKyBiaWFzX3ZhbHVlO1xuICAgICAgICAgICR7JD9cImlucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcIjpcIlwifVxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xuICAgICAgICAgIGxldCBmMzJfdmFsdWUgPSAke1N0KEQseCxcInZhbHVlXCIpfTtcbiAgICAgICAgICBzdW0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHNxdWFyZVN1bSArPSBmMzJfdmFsdWUgKiBmMzJfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lYW4gPSAke2Z0KFwic3VtXCIseCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtmdChcInNxdWFyZVN1bVwiLHgpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgLSBtZWFuICogbWVhbiArIHVuaWZvcm1zLmVwc2lsb24pO1xuICAgICAgICAke2I/XCJtZWFuX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW47XCI6XCJcIn1cbiAgICAgICAgJHt3P1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldjtcIjpcIlwifVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgaGlkZGVuX3NpemVfdmVjdG9yaXplZDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAtICR7RH0obWVhbikpICogJHtEfShpbnZfc3RkX2RldikgKiBnYW1tYVtpXSArICR7bD9cImJldGFbaV1cIjpcIjAuMFwifTtcbiAgICAgICAgfVxuICAgICAgfWB9LFM9W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiByPjEmJlMucHVzaCh7ZGltczptLGRhdGFUeXBlOjF9KSxyPjImJlMucHVzaCh7ZGltczptLGRhdGFUeXBlOjF9KSxyPjMmJlMucHVzaCh7ZGltczppLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KSx7bmFtZTpcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt4fTske2J9OyR7d307JHskfWAsaW5wdXREZXBlbmRlbmNpZXM6ZS5tYXAoKEUsTyk9PlwidHlwZVwiKX0sZ2V0U2hhZGVyU291cmNlOkMsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlMsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYy9wLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlR9KX19LHpsPShlLHQpPT57bGYoZS5pbnB1dHMpO2xldCBhPVswXTtlLm91dHB1dENvdW50PjEmJmEucHVzaCgtMyksZS5vdXRwdXRDb3VudD4yJiZhLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MyYmYS5wdXNoKDMpLGUuY29tcHV0ZShkZihlLmlucHV0cyx0LGUub3V0cHV0Q291bnQsITEpLHtvdXRwdXRzOmF9KX19KTt2YXIgY2YsaWEscGYsV2wsZmYsbWYsTmwsVmwsSGw9USgoKT0+e1widXNlIHN0cmljdFwiO3plKCk7Q2UoKTtYZSgpO19lKCk7Y2Y9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtpZih0LmF4ZXMubGVuZ3RoIT09MCl7aWYodC5heGVzLmxlbmd0aCE9PXQuc3RhcnRzLmxlbmd0aHx8dC5heGVzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcywgc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIil9ZWxzZSBpZih0LnN0YXJ0cy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO2Uuc2xpY2UoMSkuZm9yRWFjaCgocixhKT0+e2lmKGVbYSsxXS5kYXRhVHlwZSE9PTYmJmVbYSsxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke2F9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKX0pfSxpYT0oZSx0KT0+e2xldCByPVtdO2lmKGUubGVuZ3RoPnQpaWYoZVt0XS5kYXRhVHlwZT09PTcpZVt0XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChhPT5yLnB1c2goTnVtYmVyKGEpKSk7ZWxzZSBpZihlW3RdLmRhdGFUeXBlPT09NillW3RdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKGE9PnIucHVzaChOdW1iZXIoYSkpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHt0fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7cmV0dXJuIHJ9LHBmPShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IHI9aWEoZSwxKSxhPWlhKGUsMiksaT1pYShlLDMpO3JldHVybiBpLmxlbmd0aD09PTAmJihpPVsuLi5BcnJheShlWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldKSx4ZSh7c3RhcnRzOnIsZW5kczphLGF4ZXM6aX0pfWVsc2UgcmV0dXJuIHR9LFdsPShlLHQscixhLGkpPT57bGV0IHM9ZTtyZXR1cm4gZTwwJiYocys9clthW3RdXSksaVt0XTwwP01hdGgubWF4KDAsTWF0aC5taW4ocyxyW2FbdF1dLTEpKTpNYXRoLm1heCgwLE1hdGgubWluKHMsclthW3RdXSkpfSxmZj0oZSx0LHIpPT5gZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtyLmxlbmd0aH07IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfc2hhcGVfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5zdGVwc1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5zaWduc1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RhcnRzX2kgPSAke2NlKFwidW5pZm9ybXMuc3RhcnRzXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X2luZGV4ICUgaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgICB9YCxtZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxhPU4uc2l6ZShyKSxpPXQuYXhlcy5sZW5ndGg+MD9OLm5vcm1hbGl6ZUF4ZXModC5heGVzLHIubGVuZ3RoKTpbLi4uQXJyYXkoci5sZW5ndGgpLmtleXMoKV0scz1pYShlLDQpO3MuZm9yRWFjaChDPT5DIT09MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwic3RlcCBjYW5ub3QgYmUgMFwiKX0pKSxzLmxlbmd0aD09PTAmJihzPUFycmF5KGkubGVuZ3RoKS5maWxsKDEpKTtsZXQgbz10LnN0YXJ0cy5tYXAoKEMsUyk9PldsKEMsUyxyLGkscykpLGM9dC5lbmRzLm1hcCgoQyxTKT0+V2woQyxTLHIsaSxzKSk7aWYoaS5sZW5ndGghPT1vLmxlbmd0aHx8aS5sZW5ndGghPT1jLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCwgZW5kcyBhbmQgYXhlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcIik7aWYoaS5sZW5ndGghPT1yLmxlbmd0aClmb3IobGV0IEM9MDtDPHIubGVuZ3RoOysrQylpLmluY2x1ZGVzKEMpfHwoby5zcGxpY2UoQywwLDApLGMuc3BsaWNlKEMsMCxyW0NdKSxzLnNwbGljZShDLDAsMSkpO2xldCBwPXMubWFwKEM9Pk1hdGguc2lnbihDKSk7cy5mb3JFYWNoKChDLFMsRSk9PntpZihDPDApe2xldCBPPShjW1NdLW9bU10pL0MsVT1vW1NdLEQ9VStPKnNbU107b1tTXT1ELGNbU109VSxFW1NdPS1DfX0pO2xldCBtPXIuc2xpY2UoMCk7aS5mb3JFYWNoKChDLFMpPT57bVtDXT1NYXRoLmNlaWwoKGNbQ10tb1tDXSkvc1tDXSl9KTtsZXQgbD17ZGltczptLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9LGc9SihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbS5sZW5ndGgpLGI9VyhcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSx3PU4uc2l6ZShtKSwkPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzaWduc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6cC5sZW5ndGh9LHtuYW1lOlwic3RlcHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnMubGVuZ3RofV0seD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOnd9LHt0eXBlOlwidWludDMyXCIsZGF0YTpvfSx7dHlwZTpcImludDMyXCIsZGF0YTpwfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6c30sLi4uTChlWzBdLmRpbXMpLC4uLkwobSldLFQ9Qz0+YFxuICAgICAgJHtDLnJlZ2lzdGVyVW5pZm9ybXMoJCkuZGVjbGFyZVZhcmlhYmxlcyhiLGcpfVxuICAgICAgICAke2ZmKGIsZyxyKX1cbiAgICAgICAgJHtDLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7Qy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICR7Zy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixiLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJTbGljZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3AubGVuZ3RofV8ke28ubGVuZ3RofV8ke3MubGVuZ3RofWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOlQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltsXSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnh9KX19LE5sPShlLHQpPT57Y2YoZS5pbnB1dHMsdCk7bGV0IHI9cGYoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKG1mKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9LFZsPWU9PntsZXQgdD1lLnN0YXJ0cyxyPWUuZW5kcyxhPWUuYXhlcztyZXR1cm4geGUoe3N0YXJ0czp0LGVuZHM6cixheGVzOmF9KX19KTt2YXIgaGYsZ2YsTGwsR2wsRmw9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7WGUoKTtfZSgpO2hmPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LGdmPShlLHQpPT57bGV0IHI9ZS5kaW1zLGE9Ti5zaXplKHIpLGk9NjQscz10LmF4aXM7aWYoczwwJiYocz1yLmxlbmd0aCtzKSxzPHIubGVuZ3RoLTEpdGhyb3cgbmV3IEVycm9yKFwic29mdG1heCBvbmx5IHN1cHBvcnRzIGxhc3QgYXhpcyBmb3Igbm93LlwiKTtsZXQgbz1yW3NdLGM9YS9vLHA9TGUobyksbT1vL3AsbD0oVCxDKT0+Qz09PTQ/YG1heChtYXgoJHtUfS54LCAke1R9LnkpLCBtYXgoJHtUfS56LCAke1R9LncpKWA6Qz09PTI/YG1heCgke1R9LngsICR7VH0ueSlgOkM9PT0zP2BtYXgobWF4KCR7VH0ueCwgJHtUfS55KSwgJHtUfS56KWA6VCxnPVcoXCJ4XCIsZS5kYXRhVHlwZSxlLmRpbXMscCksYj1KKFwicmVzdWx0XCIsZS5kYXRhVHlwZSxlLmRpbXMscCksdz1nLnR5cGUudmFsdWUsJD1IZShlLmRhdGFUeXBlKT09PVwiZjMyXCI/YHZhciB0aHJlYWRNYXggPSAke3d9KC0zLjQwMjgyM2UrMzhmKTtgOmB2YXIgdGhyZWFkTWF4ID0gJHt3fSgtNjU1MDQuMGgpO2AseD1UPT5gXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke3d9O1xuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHt3fTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7d30sICR7aX0+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt3fSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke3d9KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgICR7VC5yZWdpc3RlclVuaWZvcm0oXCJwYWNrZWRDb2xzXCIsXCJpMzJcIikuZGVjbGFyZVZhcmlhYmxlcyhnLGIpfVxuICAgICAgJHtULm1haW5TdGFydCgpfVxuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZHgpO1xuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkeCk7XG4gICAgICAgIGNvbnN0IHdnID0gJHtpfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAkeyR9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7d30oJHtsKFwidGhyZWFkU2hhcmVkWzBdXCIscCl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7d30oMC4wKTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcbiAgICAgICAgfVxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7d30oJHtmdChcInRocmVhZFNoYXJlZFswXVwiLHApfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNvZnRtYXhcIixzaGFkZXJDYWNoZTp7aGludDpgJHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OmN9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOm19XX0pLGdldFNoYWRlclNvdXJjZTp4fX0sTGw9KGUsdCk9PntoZihlLmlucHV0cyksZS5jb21wdXRlKGdmKGUuaW5wdXRzWzBdLHQpKX0sR2w9ZT0+eGUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgeWYsYmYsdmYsd2YsJGYscWwsamwsS2w9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7WGUoKTtfZSgpO3lmPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sYmY9KGUsdCk9PntsZXQgcj1bXSxhPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKGk9PnIucHVzaChOdW1iZXIoaSkpKSxhPXIubGVuZ3RoKSx4ZSh7bnVtT3V0cHV0czphLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6cn0pfSx2Zj1lPT5gXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtjZShcInVuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpc1wiLFwiaVwiLGUpfSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbn1gLHdmPWU9PntsZXQgdD1lLmxlbmd0aCxyPVtdO2ZvcihsZXQgYT0wO2E8dDsrK2Epe2xldCBpPWVbYV0uc2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiLFwiaW5wdXRbZ2xvYmFsX2lkeF1cIik7dD09PTE/ci5wdXNoKGkpOmE9PT0wP3IucHVzaChgaWYgKG91dHB1dF9udW1iZXIgPT0gJHthfXUpIHsgJHtpfSB9YCk6YT09PXQtMT9yLnB1c2goYGVsc2UgeyAke2l9IH1gKTpyLnB1c2goYGVsc2UgaWYgKG91dHB1dF9udW1iZXIgPT0gJHthfSkgeyAke2l9IH1gKX1yZXR1cm5gXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke2VbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7ci5qb2luKGBcbmApfVxuICAgICAgfWB9LCRmPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLGE9Ti5zaXplKHIpLGk9ZVswXS5kYXRhVHlwZSxzPU4ubm9ybWFsaXplQXhpcyh0LmF4aXMsci5sZW5ndGgpLG89bmV3IEFycmF5KHQubnVtT3V0cHV0cyksYz1XKFwiaW5wdXRcIixpLHIpLHA9bmV3IEFycmF5KHQubnVtT3V0cHV0cyksbT1bXSxsPVtdLGc9MCxiPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6YX1dO2ZvcihsZXQgJD0wOyQ8dC5udW1PdXRwdXRzOyQrKyl7Zys9dC5zcGxpdFNpemVzWyRdLHBbJF09ZztsZXQgeD1yLnNsaWNlKCk7eFt0LmF4aXNdPXQuc3BsaXRTaXplc1skXSxsLnB1c2goeCksb1skXT1KKGBvdXRwdXQkeyR9YCxpLHgpLG0ucHVzaCh7ZGltczpsWyRdLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX1iLnB1c2goe3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9KSxiLnB1c2goLi4uTChyKSksbC5mb3JFYWNoKCQ9PmIucHVzaCguLi5MKCQpKSk7bGV0IHc9JD0+YFxuICAkeyQucmVnaXN0ZXJVbmlmb3JtKFwiaW5wdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNpemVfaW5fc3BsaXRfYXhpc1wiLFwidTMyXCIscC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoYywuLi5vKX1cbiAgJHt2ZihwLmxlbmd0aCl9XG4gICR7d2Yobyl9XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMuaW5wdXRfc2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtjLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIHZhciBpbmRleCA9ICR7Yy5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLHMpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke2NlKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJvdXRwdXRfbnVtYmVyIC0gMXVcIixwLmxlbmd0aCl9O1xuICAgICAgJHtjLmluZGljZXNTZXQoXCJpbmRpY2VzXCIscyxcImluZGV4XCIpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6dyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6bSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmJ9KX19LHFsPShlLHQpPT57eWYoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDpiZihlLmlucHV0cyx0KTtlLmNvbXB1dGUoJGYoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0samw9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxhPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihhIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiB4ZSh7YXhpczp0LG51bU91dHB1dHM6YSxzcGxpdFNpemVzOnJ9KX19KTt2YXIgWWwsX2YsU2YseGYsWmwsWGw9USgoKT0+e1widXNlIHN0cmljdFwiO3plKCk7Q2UoKTtfZSgpO1lsPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxfZj1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTYmJmVbMF0uZGF0YVR5cGUhPT0xMil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlc1wiKTtpZihlWzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLURcIik7aWYoWWwoZVsxXSkubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yXCIpfSxTZj0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7KythKXIucHVzaChlW2FdKnRbYV0pO3JldHVybiByfSx4Zj1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9WWwoZVsxXSksYT1TZih0LHIpLGk9Ti5zaXplKGEpLHM9ZVswXS5kYXRhVHlwZSxvPVcoXCJpbnB1dFwiLHMsdC5sZW5ndGgpLGM9SihcIm91dHB1dFwiLHMsYS5sZW5ndGgpLHA9bT0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7by5pbmRpY2VzKC4uLnQpfTtcbiAgICAgICR7bS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobyxjKX1cbiAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtvLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtvLmluZGljZXNHZXQoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke2MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke28uaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2RpbV92YWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7Yy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixvLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3J9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOlwidWludDMyXCIsZGF0YTppfSwuLi5MKGVbMF0uZGltcyksLi4uTChhKV19KSxnZXRTaGFkZXJTb3VyY2U6cH19LFpsPWU9PntfZihlLmlucHV0cyksZS5jb21wdXRlKHhmKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBDZixJZixRbCxKbD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtDZSgpO19lKCk7Q2Y9KGUsdCxyLGEsaSk9PntsZXQgcz1KKFwib3V0cHV0X2RhdGFcIixpLHIubGVuZ3RoLDQpLG89VyhcImFfZGF0YVwiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLmxlbmd0aCw0KSxjPVcoXCJiX2RhdGFcIix0WzJdLmRhdGFUeXBlLHRbMl0uZGltcy5sZW5ndGgsNCkscD1XKFwiY19kYXRhXCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMubGVuZ3RoLDQpLG0sbD0oZyxiLHcpPT5gc2VsZWN0KCR7Yn0sICR7Z30sICR7d30pYDtpZighYSltPXMuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbChvLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxjLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxwLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7bGV0IGc9KGIsdywkPVwiXCIpPT57bGV0IHg9YGFfZGF0YVtpbmRleF9hJHt3fV1bY29tcG9uZW50X2Eke3d9XWAsVD1gYl9kYXRhW2luZGV4X2Ike3d9XVtjb21wb25lbnRfYiR7d31dYCxDPWBib29sKGNfZGF0YVtpbmRleF9jJHt3fV0gJiAkezQyNzgxOTAwODA+Pj4oMy13KSo4fXUpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke3d9ID0gJHtzLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHt3fXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke3d9ID0gJHtvLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7d31gLHMpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7d30gPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt3fWAscyl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHt3fSA9ICR7cC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3d9YCxzKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7d30gPSBvZmZzZXRfYSR7d30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHt3fSA9IG9mZnNldF9iJHt3fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke3d9ID0gb2Zmc2V0X2Mke3d9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke3d9ID0gb2Zmc2V0X2Eke3d9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike3d9ID0gb2Zmc2V0X2Ike3d9ICUgNHU7XG4gICAgICAgICAgICAke2J9WyR7d31dID0gJHskfSgke2woeCxULEMpfSk7XG4gICAgICAgICAgYH07aT09PTk/bT1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7ZyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtnKFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2coXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7ZyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDptPWBcbiAgICAgICAgICAgICR7ZyhcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke2coXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHtnKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7ZyhcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMocCxvLGMscyl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHttfVxuICAgICAgfWB9LElmPWU9PntsZXQgdD1lWzFdLmRpbXMscj1lWzJdLmRpbXMsYT1lWzBdLmRpbXMsaT1lWzFdLmRhdGFUeXBlLHM9IShOLmFyZUVxdWFsKHQscikmJk4uYXJlRXF1YWwocixhKSksbz10LGM9Ti5zaXplKHQpO2lmKHMpe2xldCBtPUF0LmNhbGNTaGFwZShBdC5jYWxjU2hhcGUodCxyLCExKSxhLCExKTtpZighbSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO289bSxjPU4uc2l6ZShvKX1sZXQgcD1NYXRoLmNlaWwoYy80KTtyZXR1cm57bmFtZTpcIldoZXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTptPT5DZihtLGUsbyxzLGkpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTppfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYy82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH0sLi4uTChhKSwuLi5MKHQpLC4uLkwociksLi4uTChvKV19KX19LFFsPWU9PntlLmNvbXB1dGUoSWYoZS5pbnB1dHMpKX19KTt2YXIgZWQsdGQ9USgoKT0+e1widXNlIHN0cmljdFwiO1NzKCk7WmEoKTtJcygpO1RzKCk7bHUoKTt3dSgpO1N1KCk7dGkoKTt6dSgpO051KCk7RnUoKTtLdSgpO1h1KCk7ZWwoKTtubCgpO2lsKCk7c2woKTtuaSgpO2NsKCk7ZmwoKTtPbCgpO1BsKCk7am4oKTtEbCgpO1VsKCk7SGwoKTtGbCgpO0tsKCk7WGwoKTskcigpO1hhKCk7SmwoKTtlZD1uZXcgTWFwKFtbXCJBYnNcIixbRXNdXSxbXCJBY29zXCIsW09zXV0sW1wiQWNvc2hcIixba3NdXSxbXCJBZGRcIixbZHVdXSxbXCJBcmdNYXhcIixbX3MsWWFdXSxbXCJBcmdNaW5cIixbJHMsWWFdXSxbXCJBc2luXCIsW1BzXV0sW1wiQXNpbmhcIixbUnNdXSxbXCJBdGFuXCIsW0JzXV0sW1wiQXRhbmhcIixbTXNdXSxbXCJBdHRlbnRpb25cIixbeHNdXSxbXCJBdmVyYWdlUG9vbFwiLFskbCx3bF1dLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFtDc11dLFtcIkJpYXNBZGRcIixbQXNdXSxbXCJCaWFzU3BsaXRHZWx1XCIsW3V1XV0sW1wiQ2FzdFwiLFt6cyxEc11dLFtcIkNlaWxcIixbV3NdXSxbXCJDbGlwXCIsW1VzXV0sW1wiQ29uY2F0XCIsWyR1LF91XV0sW1wiQ29udlwiLFtpaSxhaV1dLFtcIkNvbnZUcmFuc3Bvc2VcIixbRHUsTXVdXSxbXCJDb3NcIixbTnNdXSxbXCJDb3NoXCIsW1ZzXV0sW1wiQ3VtU3VtXCIsW1V1LFd1XV0sW1wiRGl2XCIsW2N1XV0sW1wiRWluc3VtXCIsW0x1LEd1XV0sW1wiRWx1XCIsW0hzLFpuXV0sW1wiRXF1YWxcIixbcHVdXSxbXCJFcmZcIixbTHNdXSxbXCJFeHBcIixbR3NdXSxbXCJFeHBhbmRcIixbanVdXSxbXCJGbG9vclwiLFtGc11dLFtcIkZ1c2VkQ29udlwiLFtpaSxhaV1dLFtcIkdhdGhlclwiLFtadSxZdV1dLFtcIkdhdGhlckVsZW1lbnRzXCIsW0p1LFF1XV0sW1wiR2VsdVwiLFtxc11dLFtcIkdlbW1cIixbcmwsdGxdXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFt4bCxTbF1dLFtcIkdsb2JhbE1heFBvb2xcIixbRWwsVGxdXSxbXCJHcmVhdGVyXCIsW2d1XV0sW1wiR3JlYXRlck9yRXF1YWxcIixbYnVdXSxbXCJIYXJkU2lnbW9pZFwiLFtldSxKc11dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFthbF1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtvbF1dLFtcIkxlYWt5UmVsdVwiLFtqcyxabl1dLFtcIkxlc3NcIixbeXVdXSxbXCJMZXNzT3JFcXVhbFwiLFt2dV1dLFtcIkxvZ1wiLFtzdV1dLFtcIk1hdE11bFwiLFtUdV1dLFtcIk1heFBvb2xcIixbSWwsQWxdXSxbXCJNdWxcIixbZnVdXSxbXCJNdWx0aUhlYWRBdHRlbnRpb25cIixbZGwsbGxdXSxbXCJOZWdcIixbWXNdXSxbXCJOb3RcIixbS3NdXSxbXCJQYWRcIixbcGxdXSxbXCJQb3dcIixbbXVdXSxbXCJSYW5nZVwiLFtrbF1dLFtcIlJlY2lwcm9jYWxcIixbWnNdXSxbXCJSZWR1Y2VNaW5cIixbaHNdXSxbXCJSZWR1Y2VNZWFuXCIsW2RzXV0sW1wiUmVkdWNlTWF4XCIsW21zXV0sW1wiUmVkdWNlU3VtXCIsW3lzXV0sW1wiUmVkdWNlUHJvZFwiLFtnc11dLFtcIlJlZHVjZUwxXCIsW2NzXV0sW1wiUmVkdWNlTDJcIixbcHNdXSxbXCJSZWR1Y2VMb2dTdW1cIixbdnNdXSxbXCJSZWR1Y2VMb2dTdW1FeHBcIixbZnNdXSxbXCJSZWR1Y2VTdW1TcXVhcmVcIixbYnNdXSxbXCJSZWx1XCIsW1hzXV0sW1wiUmVzaXplXCIsW0JsLE1sXV0sW1wiU2lnbW9pZFwiLFtRc11dLFtcIlNpblwiLFt0dV1dLFtcIlNpbmhcIixbcnVdXSxbXCJTbGljZVwiLFtObCxWbF1dLFtcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixbemxdXSxbXCJTcGxpdFwiLFtxbCxqbF1dLFtcIlNxcnRcIixbbnVdXSxbXCJTb2Z0bWF4XCIsW0xsLEdsXV0sW1wiU3ViXCIsW2h1XV0sW1wiVGFuXCIsW2F1XV0sW1wiVGFuaFwiLFtpdV1dLFtcIlRocmVzaG9sZGVkUmVsdVwiLFtvdSxabl1dLFtcIlRpbGVcIixbWmxdXSxbXCJUcmFuc3Bvc2VcIixbWG8sUW9dXSxbXCJXaGVyZVwiLFtRbF1dXSl9KTt2YXIgb2EscmQ9USgoKT0+e1widXNlIHN0cmljdFwiO2J0KCk7cXQoKTtfZSgpO29hPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMucmVwbz1uZXcgTWFwLHRoaXMuYXR0cmlidXRlc0JvdW5kPSExfWdldEFydGlmYWN0KHQpe3JldHVybiB0aGlzLnJlcG8uZ2V0KHQpfXNldEFydGlmYWN0KHQscil7dGhpcy5yZXBvLnNldCh0LHIpfXJ1bih0LHIsYSxpLHMpe2R0KHQucHJvZ3JhbUluZm8ubmFtZSk7bGV0IG89dGhpcy5iYWNrZW5kLmRldmljZSxjPXRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTt0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKSxjLnNldFBpcGVsaW5lKHQuY29tcHV0ZVBpcGVsaW5lKTtsZXQgcD1bXTtmb3IobGV0IGwgb2YgcilwLnB1c2goe2JpbmRpbmc6cC5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpsLmJ1ZmZlcn19KTtmb3IobGV0IGwgb2YgYSlwLnB1c2goe2JpbmRpbmc6cC5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpsLmJ1ZmZlcn19KTtzJiZwLnB1c2goe2JpbmRpbmc6cC5sZW5ndGgscmVzb3VyY2U6c30pO2xldCBtPW8uY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6dC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6cCxsYWJlbDp0LnByb2dyYW1JbmZvLm5hbWV9KTtjLnNldEJpbmRHcm91cCgwLG0pLGMuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmkpLHRoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMSksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXJ8fHRoaXMuYmFja2VuZC5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmJhY2tlbmQuZmx1c2goKSxjdCh0LnByb2dyYW1JbmZvLm5hbWUpfWRpc3Bvc2UoKXt9YnVpbGQodCxyKXtkdCh0Lm5hbWUpO2xldCBhPXRoaXMuYmFja2VuZC5kZXZpY2UsaT1bXTthLmZlYXR1cmVzLmhhcyhcInNoYWRlci1mMTZcIikmJmkucHVzaChcImVuYWJsZSBmMTY7XCIpO2xldCBzPVlvKHIpLG89dC5nZXRTaGFkZXJTb3VyY2UocyksYz1gJHtpLmpvaW4oYFxuYCl9XG4ke3MuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cbiR7b31gLHA9YS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6YyxsYWJlbDp0Lm5hbWV9KTtEZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdICR7dC5uYW1lfSBzaGFkZXIgY29kZTogJHtjfWApO2xldCBtPWEuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6cCxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCIsbGFiZWw6dC5uYW1lfSk7cmV0dXJuIGN0KHQubmFtZSkse3Byb2dyYW1JbmZvOnQsY29tcHV0ZVBpcGVsaW5lOm19fW5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKHQpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC54LGE9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnl8fDEsaT10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQuenx8MSxzPXRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO2lmKHI8PXMmJmE8PXMmJmk8PXMpcmV0dXJuW3IsYSxpXTtsZXQgbz1yKmEqaSxjPU1hdGguY2VpbChNYXRoLnNxcnQobykpO2lmKGM+cyl7aWYoYz1NYXRoLmNlaWwoTWF0aC5jYnJ0KG8pKSxjPnMpdGhyb3cgbmV3IEVycm9yKFwiVG90YWwgZGlzcGF0Y2ggc2l6ZSBleGNlZWRzIFdlYkdQVSBtYXhpbXVtLlwiKTtyZXR1cm5bYyxjLGNdfWVsc2UgcmV0dXJuW2MsYywxXX19fSk7dmFyIEFmLFRmLHNhLG5kPVEoKCk9PntcInVzZSBzdHJpY3RcIjtidCgpO3plKCk7cXQoKTtHbygpO0tvKCk7dGQoKTtyZCgpO0FmPShlLHQpPT57aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke3QubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke2UubGVuZ3RofS5gKTtsZXQgcj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoOysrYSl7bGV0IGk9ZVthXS5kYXRhVHlwZTtzd2l0Y2godFthXSl7Y2FzZVwibm9uZVwiOntyLnB1c2goXCJcIik7YnJlYWt9Y2FzZVwidHlwZVwiOntyLnB1c2goYCR7aX1gKTticmVha31jYXNlXCJyYW5rXCI6e2xldCBzPWVbYV0uZGltcy5sZW5ndGg7ci5wdXNoKGAke2l9OyR7c31gKTticmVha31jYXNlXCJkaW1zXCI6e2xldCBzPWVbYV0uZGltcy5qb2luKFwiLFwiKTtyLnB1c2goYCR7aX07JHtzfWApO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke3RbYV19YCl9fXJldHVybiByLmpvaW4oXCJ8XCIpfSxUZj0oZSx0LHIpPT57bGV0IGE9ZS5uYW1lO3JldHVybiBlLnNoYWRlckNhY2hlPy5oaW50JiYoYSs9XCJbXCIrZS5zaGFkZXJDYWNoZS5oaW50K1wiXVwiKSxhKz1cIjpcIityK2A6JHtBZih0LGUuc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzPz9uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoXCJkaW1zXCIpKX1gLGF9LHNhPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLm1heERpc3BhdGNoTnVtYmVyPTE2O3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5wZW5kaW5nS2VybmVscz1bXTt0aGlzLnBlbmRpbmdRdWVyaWVzPW5ldyBNYXA7dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZz1uZXcgTWFwfWdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpe2lmKHRoaXMuY3VycmVudEtlcm5lbElkPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKVwiKTtsZXQgdD10aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtyZXR1cm4gdHx8KHQ9e30sdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCx0KSksdH1hc3luYyBpbml0aWFsaXplKHQscil7dGhpcy5lbnY9dDtsZXQgYT1bXSxpPXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6ci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLG1heEJ1ZmZlclNpemU6ci5saW1pdHMubWF4QnVmZmVyU2l6ZSxtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6ci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafSxyZXF1aXJlZEZlYXR1cmVzOmF9O3IuZmVhdHVyZXMuaGFzKFwiY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCIpP2EucHVzaChcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKTpyLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmYS5wdXNoKFwidGltZXN0YW1wLXF1ZXJ5XCIpLHIuZmVhdHVyZXMuaGFzKFwic2hhZGVyLWYxNlwiKSYmYS5wdXNoKFwic2hhZGVyLWYxNlwiKSx0aGlzLmRldmljZT1hd2FpdCByLnJlcXVlc3REZXZpY2UoaSksdGhpcy5ncHVEYXRhTWFuYWdlcj1qbyh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBvYSh0aGlzKSx0aGlzLmtlcm5lbHM9bmV3IE1hcCx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhPW5ldyBNYXAsdGhpcy5rZXJuZWxDdXN0b21EYXRhPW5ldyBNYXAsSG8odC5sb2dMZXZlbCwhIXQuZGVidWcpLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPXM9PntzLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke3MuZXJyb3IubWVzc2FnZX1gKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImRldmljZVwiLHt2YWx1ZTp0aGlzLmRldmljZX0pLHRoaXMuc2V0UXVlcnlUeXBlKCl9ZGlzcG9zZSgpe3R5cGVvZiB0aGlzLnF1ZXJ5U2V0PFwidVwiJiZ0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKSx0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKX1nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe2lmKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcil7bGV0IHQ9e307dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiJiYodC50aW1lc3RhbXBXcml0ZXM9e3F1ZXJ5U2V0OnRoaXMucXVlcnlTZXQsYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLGVuZE9mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxfSksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9dGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLmJlZ2luQ29tcHV0ZVBhc3ModCl9cmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyfWVuZENvbXB1dGVQYXNzKCl7dGhpcy5jb21wdXRlUGFzc0VuY29kZXImJih0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsKX1mbHVzaCgpe2lmKCF0aGlzLmNvbW1hbmRFbmNvZGVyKXJldHVybjtkdCgpLHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtsZXQgdDt0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiYodGhpcy5jb21tYW5kRW5jb2Rlci5yZXNvbHZlUXVlcnlTZXQodGhpcy5xdWVyeVNldCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIsdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCksdD10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfSksdGhpcy5wZW5kaW5nUXVlcmllcy5zZXQodCx0aGlzLnBlbmRpbmdLZXJuZWxzKSx0aGlzLnBlbmRpbmdLZXJuZWxzPVtdLHRoaXMuY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDAsdCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCkpLHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5jb21tYW5kRW5jb2Rlci5maW5pc2goKV0pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCksdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTAsdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdC5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCk9PntsZXQgcj1uZXcgQmlnVWludDY0QXJyYXkodC5nZXRNYXBwZWRSYW5nZSgpKSxhPXRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KHQpO2ZvcihsZXQgaT0wO2k8ci5sZW5ndGgvMjtpKyspe2xldCBzPWFbaV0sbz1zLmtlcm5lbElkLGM9dGhpcy5rZXJuZWxzLmdldChvKSxwPWMua2VybmVsVHlwZSxtPWMua2VybmVsTmFtZSxsPXMucHJvZ3JhbU5hbWUsZz1zLmlucHV0VGVuc29yVmlld3MsYj1zLm91dHB1dFRlbnNvclZpZXdzLHc9cltpKjJdLCQ9cltpKjIrMV07dHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZT5cInVcIiYmKHRoaXMucXVlcnlUaW1lQmFzZT13KTtsZXQgeD1OdW1iZXIody10aGlzLnF1ZXJ5VGltZUJhc2UpLFQ9TnVtYmVyKCQtdGhpcy5xdWVyeVRpbWVCYXNlKTtpZighTnVtYmVyLmlzU2FmZUludGVnZXIoeCl8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihUKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2VcIik7aWYodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKXRoaXMuZW52LndlYmdwdS5wcm9maWxpbmcub25kYXRhKHt2ZXJzaW9uOjEsaW5wdXRzTWV0YWRhdGE6Zy5tYXAoQz0+KHtkaW1zOkMuZGltcyxkYXRhVHlwZTpwdChDLmRhdGFUeXBlKX0pKSxvdXRwdXRzTWV0YWRhdGE6Yi5tYXAoQz0+KHtkaW1zOkMuZGltcyxkYXRhVHlwZTpwdChDLmRhdGFUeXBlKX0pKSxrZXJuZWxJZDpvLGtlcm5lbFR5cGU6cCxrZXJuZWxOYW1lOm0scHJvZ3JhbU5hbWU6bCxzdGFydFRpbWU6eCxlbmRUaW1lOlR9KTtlbHNle2xldCBDPVwiXCI7Zy5mb3JFYWNoKChFLE8pPT57Qys9YGlucHV0WyR7T31dOiBbJHtFLmRpbXN9XSB8ICR7cHQoRS5kYXRhVHlwZSl9LCBgfSk7bGV0IFM9XCJcIjtiLmZvckVhY2goKEUsTyk9PntTKz1gb3V0cHV0WyR7T31dOiBbJHtFLmRpbXN9XSB8ICR7cHQoRS5kYXRhVHlwZSl9LCBgfSksY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7b318JHtwfXwke219fCR7bH1cIiAke0N9JHtTfWV4ZWN1dGlvbiB0aW1lOiAke1QteH0gbnNgKX1xcihcIkdQVVwiLGAke2x9Ojoke3d9OjokeyR9YCl9dC51bm1hcCgpLHRoaXMucGVuZGluZ1F1ZXJpZXMuZGVsZXRlKHQpfSksY3QoKX1ydW4odCxyLGEsaSxzKXtkdCh0Lm5hbWUpO2xldCBvPVtdO2ZvcihsZXQgUz0wO1M8ci5sZW5ndGg7KytTKXtsZXQgRT10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChyW1NdLmRhdGEpO2lmKCFFKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke3JbU10uZGF0YX1gKTtvW1NdPUV9bGV0e291dHB1dHM6YyxkaXNwYXRjaEdyb3VwOnAscHJvZ3JhbVVuaWZvcm1zOm19PXQuZ2V0UnVuRGF0YShyKSxsPWEubGVuZ3RoPT09MD9jLm1hcCgoUyxFKT0+RSk6YTtpZihsLmxlbmd0aCE9PWMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHtsLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke2MubGVuZ3RofS5gKTtsZXQgZz1bXSxiPVtdO2ZvcihsZXQgUz0wO1M8Yy5sZW5ndGg7KytTKXtpZighTnVtYmVyLmlzSW50ZWdlcihsW1NdKXx8bFtTXTwtM3x8bFtTXT49Yy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHtsW1NdfWApO2lmKGxbU109PT0tMyljb250aW51ZTtsZXQgRT1sW1NdPT09LTEsTz1sW1NdPT09LTIsVT1FfHxPP3MoY1tTXS5kYXRhVHlwZSxjW1NdLmRpbXMpOmkobFtTXSxjW1NdLmRhdGFUeXBlLGNbU10uZGltcyksRD10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChVLmRhdGEpO2lmKCFEKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHtVLmRhdGF9YCk7aWYoRSYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goRCksTyl7bGV0IFY9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO1Z8fChWPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLFYpKSxWLnB1c2goRCl9Zy5wdXNoKFUpLGIucHVzaChEKX1sZXQgdztpZihtKXtsZXQgUz0wLEU9W107bS5mb3JFYWNoKFY9PntsZXQgWT10eXBlb2YgVi5kYXRhPT1cIm51bWJlclwiP1tWLmRhdGFdOlYuZGF0YTtpZihZLmxlbmd0aD09PTApcmV0dXJuO2xldCBzZT1WLnR5cGU9PT1cImZsb2F0MTZcIj8yOjQsQix0ZTtWLnR5cGU9PT1cImZsb2F0MTZcIj8odGU9WS5sZW5ndGg+ND8xNjpZLmxlbmd0aD4yPzg6WS5sZW5ndGgqc2UsQj1ZLmxlbmd0aD40PzE2OnNlKlkubGVuZ3RoKToodGU9WS5sZW5ndGg8PTI/WS5sZW5ndGgqc2U6MTYsQj0xNiksUz1NYXRoLmNlaWwoUy90ZSkqdGUsRS5wdXNoKFMpO2xldCBrZT1WLnR5cGU9PT1cImZsb2F0MTZcIj84OjQ7Uys9WS5sZW5ndGg+ND9NYXRoLmNlaWwoWS5sZW5ndGgva2UpKkI6WS5sZW5ndGgqc2V9KTtsZXQgTz0xNjtTPU1hdGguY2VpbChTL08pKk87bGV0IFU9bmV3IEFycmF5QnVmZmVyKFMpO20uZm9yRWFjaCgoVixZKT0+e2xldCBzZT1FW1ldLEI9dHlwZW9mIFYuZGF0YT09XCJudW1iZXJcIj9bVi5kYXRhXTpWLmRhdGE7Vi50eXBlPT09XCJpbnQzMlwiP25ldyBJbnQzMkFycmF5KFUsc2UsQi5sZW5ndGgpLnNldChCKTpWLnR5cGU9PT1cInVpbnQzMlwiP25ldyBVaW50MzJBcnJheShVLHNlLEIubGVuZ3RoKS5zZXQoQik6Vi50eXBlPT09XCJmbG9hdDE2XCI/bmV3IFVpbnQxNkFycmF5KFUsc2UsQi5sZW5ndGgpLnNldChCKTpuZXcgRmxvYXQzMkFycmF5KFUsc2UsQi5sZW5ndGgpLnNldChCKX0pO2xldCBEPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKFMsR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoRC5idWZmZXIsMCxVLDAsUyksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKEQuaWQpLHc9e29mZnNldDowLHNpemU6UyxidWZmZXI6RC5idWZmZXJ9fWxldCAkPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUocCkseD0kWzFdPT09MSYmJFsyXT09PTEsVD1UZih0LHIseCksQz10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KFQpO2lmKEN8fChDPXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCwkKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KFQsQyksRGUoXCJpbmZvXCIsKCk9PmBbYXJ0aWZhY3RdIGtleTogJHtUfSwgcHJvZ3JhbU5hbWU6ICR7dC5uYW1lfWApKSxEZShcImluZm9cIiwoKT0+YFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHt0Lm5hbWV9XCIgKGtleT0ke1R9KSB3aXRoICR7JFswXX14JHskWzFdfXgkeyRbMl19YCksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIil7bGV0IFM9e2tlcm5lbElkOnRoaXMuY3VycmVudEtlcm5lbElkLHByb2dyYW1OYW1lOkMucHJvZ3JhbUluZm8ubmFtZSxpbnB1dFRlbnNvclZpZXdzOnIsb3V0cHV0VGVuc29yVmlld3M6Z307dGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKFMpfXJldHVybiB0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bihDLG8sYiwkLHcpLGN0KHQubmFtZSksZ311cGxvYWQodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZCh0LHIpfW1lbWNweSh0LHIpe3RoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHQscil9YXN5bmMgZG93bmxvYWQodCxyKXthd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKHQscil9YWxsb2ModCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHQpLmlkfWZyZWUodCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh0KX1jcmVhdGVLZXJuZWwodCxyLGEsaSl7bGV0IHM9ZWQuZ2V0KHQpO2lmKCFzKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHt0fWApO2xldCBvPXtrZXJuZWxUeXBlOnQsa2VybmVsTmFtZTppLGtlcm5lbEVudHJ5OnNbMF0sYXR0cmlidXRlczpbc1sxXSxhXX07dGhpcy5rZXJuZWxzLnNldChyLG8pfXJlbGVhc2VLZXJuZWwodCl7bGV0IHI9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodCk7aWYocil7Zm9yKGxldCBhIG9mIHIpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGEuaWQpO3RoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKHQpfXRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUodCksdGhpcy5rZXJuZWxzLmRlbGV0ZSh0KX1jb21wdXRlS2VybmVsKHQscixhKXtsZXQgaT10aGlzLmtlcm5lbHMuZ2V0KHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke3R9YCk7bGV0IHM9aS5rZXJuZWxUeXBlLG89aS5rZXJuZWxOYW1lLGM9aS5rZXJuZWxFbnRyeSxwPWkuYXR0cmlidXRlcztpZih0aGlzLmN1cnJlbnRLZXJuZWxJZCE9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHtzfV0gJHtvfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO3RoaXMuY3VycmVudEtlcm5lbElkPXQscFswXSYmKHBbMV09cFswXShwWzFdKSxwWzBdPXZvaWQgMCksRGUoXCJpbmZvXCIsKCk9PmBbV2ViR1BVXSBTdGFydCB0byBydW4ga2VybmVsIFwiWyR7c31dICR7b31cIi4uLmApO2xldCBtPXRoaXMuZW52LmRlYnVnO3RoaXMudGVtcG9yYXJ5RGF0YT1bXTt0cnl7cmV0dXJuIG0mJnRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKFwidmFsaWRhdGlvblwiKSxjKHIscFsxXSksMH1jYXRjaChsKXtyZXR1cm4gYS5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7c31dICR7b31cIiBmYWlsZWQuICR7bH1gKSksMX1maW5hbGx5e20mJmEucHVzaCh0aGlzLmRldmljZS5wb3BFcnJvclNjb3BlKCkudGhlbihsPT5sP2BHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7c31dICR7b31cIjogJHtsLm1lc3NhZ2V9YDpudWxsKSk7Zm9yKGxldCBsIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UobC5pZCk7dGhpcy50ZW1wb3JhcnlEYXRhPVtdLHRoaXMuY3VycmVudEtlcm5lbElkPW51bGx9fXJlZ2lzdGVyQnVmZmVyKHQscixhLGkpe2xldCBzPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO3N8fChzPW5ldyBNYXAsdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQodCxzKSk7bGV0IG89cy5nZXQociksYz10aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYSxpLG8/LlsxXSk7cmV0dXJuIHMuc2V0KHIsW2MsYV0pLGN9dW5yZWdpc3RlckJ1ZmZlcnModCl7bGV0IHI9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7ciYmKHIuZm9yRWFjaChhPT50aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihhWzFdKSksdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUodCkpfWdldEJ1ZmZlcih0KXtsZXQgcj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7dH1gKTtyZXR1cm4gci5idWZmZXJ9Y3JlYXRlRG93bmxvYWRlcih0LHIsYSl7cmV0dXJuIGFzeW5jKCk9PntsZXQgaT1hd2FpdCBIYSh0aGlzLHQscik7cmV0dXJuIExvKGkuYnVmZmVyLGEpfX13cml0ZVRpbWVzdGFtcCh0KXt0aGlzLnF1ZXJ5VHlwZT09PVwiaW5zaWRlLXBhc3Nlc1wiJiZ0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci53cml0ZVRpbWVzdGFtcCh0aGlzLnF1ZXJ5U2V0LHQpfXNldFF1ZXJ5VHlwZSgpe3RoaXMucXVlcnlUeXBlPVwibm9uZVwiLCh0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlPT09XCJkZWZhdWx0XCJ8fHRoaXMuZW52Lndhc20udHJhY2UpJiYodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwiY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCIpP3RoaXMucXVlcnlUeXBlPVwiaW5zaWRlLXBhc3Nlc1wiOnRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmKHRoaXMucXVlcnlUeXBlPVwiYXQtcGFzc2VzXCIpLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnR5cGVvZiB0aGlzLnF1ZXJ5U2V0PlwidVwiJiYodGhpcy5xdWVyeVNldD10aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7dHlwZTpcInRpbWVzdGFtcFwiLGNvdW50OnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMn0pLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyPXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFfSkpKX1vblJ1blN0YXJ0KCl7dGhpcy5zZXRRdWVyeVR5cGUoKX19fSk7dmFyIGFkPXt9O25yKGFkLHtpbml0OigpPT5FZn0pO3ZhciBlbixjaSxFZixpZD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emUoKTtuZCgpO3F0KCk7Q2UoKTtlbj1jbGFzcyBle2NvbnN0cnVjdG9yKHQscixhLGkpe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1yO3RoaXMuZGF0YT1hO3RoaXMuZGltcz1pfWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PU4uc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9Ti5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PU4uc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoTi5zaXplKHQpIT09Ti5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0sY2k9Y2xhc3N7Y29uc3RydWN0b3IodCxyLGEpe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPXI7dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO2xldCBpPXQuSEVBUFUzMixzPWE+Pj4yO3RoaXMub3BLZXJuZWxDb250ZXh0PWlbcysrXTtsZXQgbz1pW3MrK107dGhpcy5vdXRwdXRDb3VudD1pW3MrK10sdGhpcy5jdXN0b21EYXRhT2Zmc2V0PWlbcysrXSx0aGlzLmN1c3RvbURhdGFTaXplPWlbcysrXTtsZXQgYz1bXTtmb3IobGV0IHA9MDtwPG87cCsrKXtsZXQgbT1pW3MrK10sbD1pW3MrK10sZz1pW3MrK10sYj1bXTtmb3IobGV0IHc9MDt3PGc7dysrKWIucHVzaChpW3MrK10pO2MucHVzaChuZXcgZW4odCxtLGwsYikpfXRoaXMuaW5wdXRzPWN9Z2V0IGtlcm5lbEN1c3RvbURhdGEoKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhfWdldCBjdXN0b21EYXRhQnVmZmVyKCl7cmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsdGhpcy5jdXN0b21EYXRhT2Zmc2V0K3RoaXMuY3VzdG9tRGF0YVNpemUpfWNvbXB1dGUodCxyKXtsZXQgYT1yPy5pbnB1dHM/Lm1hcChjPT50eXBlb2YgYz09XCJudW1iZXJcIj90aGlzLmlucHV0c1tjXTpjKT8/dGhpcy5pbnB1dHMsaT1yPy5vdXRwdXRzPz9bXSxzPShjLHAsbSk9Pm5ldyBlbih0aGlzLm1vZHVsZSxwLHRoaXMub3V0cHV0KGMsbSksbSksbz0oYyxwKT0+e2xldCBtPUtyKGMpO2lmKCFtKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2N9YCk7bGV0IGw9bSpOLnNpemUocCk7cmV0dXJuIG5ldyBlbih0aGlzLm1vZHVsZSxjLHRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUobCkuaWQscCl9O3JldHVybiB0aGlzLmJhY2tlbmQucnVuKHQsYSxpLHMsbyl9b3V0cHV0KHQscil7bGV0IGE9dGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7dHJ5e2xldCBpPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErci5sZW5ndGgpKjQpLHM9aT4+Mjt0aGlzLm1vZHVsZS5IRUFQVTMyW3MrK109ci5sZW5ndGg7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspdGhpcy5tb2R1bGUuSEVBUFUzMltzKytdPXJbb107cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQsaSl9Y2F0Y2goaSl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtyfV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtpfWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKGEpfX19LEVmPWFzeW5jKGUsdCxyKT0+e2xldCBhPWUuanNlcEluaXQ7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuXCIpO2xldCBpPW5ldyBzYTthd2FpdCBpLmluaXRpYWxpemUodCxyKSxhKGkscz0+aS5hbGxvYyhzKSxzPT5pLmZyZWUocyksKHMsbyxjLHA9ITEpPT57aWYocClEZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke3N9LCBkc3Q9JHtvfSwgc2l6ZT0ke2N9YCksaS5tZW1jcHkocyxvKTtlbHNle0RlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke3N9LCBncHVEYXRhSWQ9JHtvfSwgc2l6ZT0ke2N9YCk7bGV0IG09ZS5IRUFQVTguc3ViYXJyYXkocz4+PjAsKHM+Pj4wKStjKTtpLnVwbG9hZChvLG0pfX0sYXN5bmMocyxvLGMpPT57RGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtzfSwgZGF0YU9mZnNldD0ke299LCBzaXplPSR7Y31gKSxhd2FpdCBpLmRvd25sb2FkKHMsKCk9PmUuSEVBUFU4LnN1YmFycmF5KG8+Pj4wLChvPj4+MCkrYykpfSwocyxvLGMpPT5pLmNyZWF0ZUtlcm5lbChzLG8sYyxlLlVURjhUb1N0cmluZyhlLl9Kc2VwR2V0Tm9kZU5hbWUobykpKSxzPT5pLnJlbGVhc2VLZXJuZWwocyksKHMsbyxjLHApPT57RGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7Y30sIGtlcm5lbD0ke3N9LCBjb250ZXh0RGF0YU9mZnNldD0ke299YCk7bGV0IG09bmV3IGNpKGUsaSxvKTtyZXR1cm4gaS5jb21wdXRlS2VybmVsKHMsbSxwKX0pfX0pO3ZhciBPZixzZCx1ZCx0bixrZixwaSxsZCxkZCxvZCxjZCxwZCxmZCxtZD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7em8oKTtXbygpO3plKCk7dnIoKTtVbigpO05hKCk7T2Y9KGUsdCk9PntOZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZNZShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxzZD1hc3luYyBlPT57T2YoZS53YXNtLm51bVRocmVhZHMsWXIoZS5sb2dMZXZlbCkpfSx1ZD1hc3luYyhlLHQpPT57aWYodD09PVwid2ViZ3B1XCJ8fHQ9PT1cIndlYm5uXCIpe2lmKHR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCJ8fCFuYXZpZ2F0b3IuZ3B1KXRocm93IG5ldyBFcnJvcihcIldlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7bGV0IHI9YXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpO2lmKCFyKXRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicpO2lmKCFlLndhc20uc2ltZCl0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIGZvciBXZWJHUFU9T04gYW5kIFNJTUQ9T0ZGLiBQbGVhc2Ugc2V0IGBlbnYud2FzbS5zaW1kYCB0byB0cnVlIHdoZW4gdXNpbmcgYHdlYmdwdWAgRVBcIik7bGV0IGE9KGlkKCksR3QoYWQpKS5pbml0O2F3YWl0IGEoTmUoKSxlLHIpfX0sdG49bmV3IE1hcCxrZj1lPT57bGV0IHQ9TmUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBhPXQuc3RhY2tBbGxvYyg4KTtyZXR1cm4gdC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLGEsYSs0KSE9PTAmJk1lKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKSxbdC5IRUFQMzJbYS80XSx0LkhFQVAzMlthLzQrMV1dfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSxwaT1lPT57bGV0IHQ9TmUoKSxyPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKHI9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSxsZD1hc3luYyhlLHQpPT57bGV0IHIsYSxpPU5lKCk7QXJyYXkuaXNBcnJheShlKT9bcixhXT1lOmUuYnVmZmVyPT09aS5IRUFQVTguYnVmZmVyP1tyLGFdPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbcixhXT1waShlKTtsZXQgcz0wLG89MCxjPTAscD1bXSxtPVtdLGw9W107dHJ5e2lmKFtvLHBdPVVvKHQpLHQ/LmV4dGVybmFsRGF0YSYmaS5tb3VudEV4dGVybmFsRGF0YSl7bGV0IEM9W107Zm9yKGxldCBTIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgRT10eXBlb2YgUz09XCJzdHJpbmdcIj9TOlMucGF0aDtDLnB1c2goWnIodHlwZW9mIFM9PVwic3RyaW5nXCI/UzpTLmRhdGEpLnRoZW4oTz0+e2kubW91bnRFeHRlcm5hbERhdGEoRSxPKX0pKX1hd2FpdCBQcm9taXNlLmFsbChDKX1zPWF3YWl0IGkuX09ydENyZWF0ZVNlc3Npb24ocixhLG8pLHM9PT0wJiZNZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpO2xldFtnLGJdPWtmKHMpLHc9W10sJD1bXSx4PVtdO2ZvcihsZXQgQz0wO0M8ZztDKyspe2xldCBTPWkuX09ydEdldElucHV0TmFtZShzLEMpO1M9PT0wJiZNZShcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxtLnB1c2goUyksdy5wdXNoKGkuVVRGOFRvU3RyaW5nKFMpKX1mb3IobGV0IEM9MDtDPGI7QysrKXtsZXQgUz1pLl9PcnRHZXRPdXRwdXROYW1lKHMsQyk7Uz09PTAmJk1lKFwiQ2FuJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxsLnB1c2goUyk7bGV0IEU9aS5VVEY4VG9TdHJpbmcoUyk7JC5wdXNoKEUpO3tsZXQgTz10eXBlb2YgdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PVwic3RyaW5nXCI/dC5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbjp0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW0VdPz9cImNwdVwiO2lmKE8hPT1cImNwdVwiJiZPIT09XCJjcHUtcGlubmVkXCImJk8hPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtPfS5gKTt4LnB1c2goTyl9fWxldCBUPW51bGw7cmV0dXJuIHguc29tZShDPT5DPT09XCJncHUtYnVmZmVyXCIpJiYoYz1pLl9PcnRDcmVhdGVCaW5kaW5nKHMpLGM9PT0wJiZNZShcIkNhbid0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSxUPXtoYW5kbGU6YyxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6eCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOngubWFwKEM9PldhKEMpKX0pLHRuLnNldChzLFtzLG0sbCxUXSksW3MsdywkXX1jYXRjaChnKXt0aHJvdyBtLmZvckVhY2goYj0+aS5fT3J0RnJlZShiKSksbC5mb3JFYWNoKGI9PmkuX09ydEZyZWUoYikpLGMhPT0wJiZpLl9PcnRSZWxlYXNlQmluZGluZyhjKSxzIT09MCYmaS5fT3J0UmVsZWFzZVNlc3Npb24ocyksZ31maW5hbGx5e2kuX2ZyZWUociksbyE9PTAmJmkuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSxwLmZvckVhY2goZz0+aS5fZnJlZShnKSksaS51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKX19LGRkPWU9PntsZXQgdD1OZSgpLHI9dG4uZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W2EsaSxzLG9dPXI7byYmdC5fT3J0UmVsZWFzZUJpbmRpbmcoby5oYW5kbGUpLHQuanNlcFVucmVnaXN0ZXJCdWZmZXJzPy4oZSksaS5mb3JFYWNoKGM9PnQuX09ydEZyZWUoYykpLHMuZm9yRWFjaChjPT50Ll9PcnRGcmVlKGMpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihhKSx0bi5kZWxldGUoZSl9LG9kPShlLHQscixhLGkpPT57aWYoIWUpe3QucHVzaCgwKTtyZXR1cm59bGV0IHM9TmUoKSxvPWVbMF0sYz1lWzFdLHA9ZVszXSxtLGw7aWYobz09PVwic3RyaW5nXCImJnA9PT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihwPT09XCJncHUtYnVmZmVyXCIpe2xldCB3PWVbMl0uZ3B1QnVmZmVyLCQ9S3IoVWEobykpO2w9Yy5yZWR1Y2UoKHgsVCk9PngqVCwxKSokLG09cy5qc2VwUmVnaXN0ZXJCdWZmZXIoYSxpLHcsbCl9ZWxzZXtsZXQgdz1lWzJdO2lmKEFycmF5LmlzQXJyYXkodykpe2w9NCp3Lmxlbmd0aCxtPXMuX21hbGxvYyhsKSxyLnB1c2gobSk7bGV0ICQ9bS80O2ZvcihsZXQgeD0wO3g8dy5sZW5ndGg7eCsrKXtpZih0eXBlb2Ygd1t4XSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke3h9IGlzIG5vdCBhIHN0cmluZ2ApO3MuSEVBUFUzMlskKytdPVZlKHdbeF0scil9fWVsc2UgbD13LmJ5dGVMZW5ndGgsbT1zLl9tYWxsb2MobCksci5wdXNoKG0pLHMuSEVBUFU4LnNldChuZXcgVWludDhBcnJheSh3LmJ1ZmZlcix3LmJ5dGVPZmZzZXQsbCksbSl9bGV0IGc9cy5zdGFja1NhdmUoKSxiPXMuc3RhY2tBbGxvYyg0KmMubGVuZ3RoKTt0cnl7bGV0IHc9Yi80O2MuZm9yRWFjaCh4PT5zLkhFQVAzMlt3KytdPXgpO2xldCAkPXMuX09ydENyZWF0ZVRlbnNvcihVYShvKSxtLGwsYixjLmxlbmd0aCxXYShwKSk7JD09PTAmJk1lKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHthfSwgaW5kZXg9JHtpfS5gKSx0LnB1c2goJCl9ZmluYWxseXtzLnN0YWNrUmVzdG9yZShnKX19LGNkPWFzeW5jKGUsdCxyLGEsaSxzKT0+e2xldCBvPU5lKCksYz10bi5nZXQoZSk7aWYoIWMpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W3AsbSxsLGddPWMsYj10Lmxlbmd0aCx3PWEubGVuZ3RoLCQ9MCx4PVtdLFQ9W10sQz1bXSxTPVtdLEU9by5zdGFja1NhdmUoKSxPPW8uc3RhY2tBbGxvYyhiKjQpLFU9by5zdGFja0FsbG9jKGIqNCksRD1vLnN0YWNrQWxsb2Modyo0KSxWPW8uc3RhY2tBbGxvYyh3KjQpO3RyeXtbJCx4XT1EbyhzKTtmb3IobGV0IGVlPTA7ZWU8YjtlZSsrKW9kKHJbZWVdLFQsUyxlLHRbZWVdKTtmb3IobGV0IGVlPTA7ZWU8dztlZSsrKW9kKGlbZWVdLEMsUyxlLGIrYVtlZV0pO2xldCBZPU8vNCxzZT1VLzQsQj1ELzQsdGU9Vi80O2ZvcihsZXQgZWU9MDtlZTxiO2VlKyspby5IRUFQVTMyW1krK109VFtlZV0sby5IRUFQVTMyW3NlKytdPW1bdFtlZV1dO2ZvcihsZXQgZWU9MDtlZTx3O2VlKyspby5IRUFQVTMyW0IrK109Q1tlZV0sby5IRUFQVTMyW3RlKytdPWxbYVtlZV1dO2lmKGcpe2xldHtoYW5kbGU6ZWUsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOmJlLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6VWV9PWc7aWYobS5sZW5ndGghPT1iKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtifSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7bS5sZW5ndGh9KS5gKTtmb3IobGV0IHBlPTA7cGU8YjtwZSsrKXtsZXQgeWU9dFtwZV07YXdhaXQgby5fT3J0QmluZElucHV0KGVlLG1beWVdLFRbcGVdKSE9PTAmJk1lKGBDYW4ndCBiaW5kIGlucHV0WyR7cGV9XSBmb3Igc2Vzc2lvbj0ke2V9LmApfWZvcihsZXQgcGU9MDtwZTx3O3BlKyspe2xldCB5ZT1hW3BlXTtpW3BlXT8uWzNdP28uX09ydEJpbmRPdXRwdXQoZWUsbFt5ZV0sQ1twZV0sMCkhPT0wJiZNZShgQ2FuJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske3BlfV0gZm9yIHNlc3Npb249JHtlfS5gKTpvLl9PcnRCaW5kT3V0cHV0KGVlLGxbeWVdLDAsVWVbeWVdKSE9PTAmJk1lKGBDYW4ndCBiaW5kIG91dHB1dFske3BlfV0gdG8gJHtiZVtwZV19IGZvciBzZXNzaW9uPSR7ZX0uYCl9fW8uanNlcE9uUnVuU3RhcnQ/LigpO2xldCBrZTtnP2tlPWF3YWl0IG8uX09ydFJ1bldpdGhCaW5kaW5nKHAsZy5oYW5kbGUsdyxELCQpOmtlPWF3YWl0IG8uX09ydFJ1bihwLFUsTyxiLFYsdyxELCQpLGtlIT09MCYmTWUoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IE9lPVtdO2ZvcihsZXQgZWU9MDtlZTx3O2VlKyspe2xldCBiZT1vLkhFQVBVMzJbRC80K2VlXTtpZihiZT09PUNbZWVdKXtPZS5wdXNoKGlbZWVdKTtjb250aW51ZX1sZXQgVWU9by5zdGFja1NhdmUoKSxwZT1vLnN0YWNrQWxsb2MoNCo0KSx5ZT0hMSxkZSx2ZT0wO3RyeXtvLl9PcnRHZXRUZW5zb3JEYXRhKGJlLHBlLHBlKzQscGUrOCxwZSsxMikhPT0wJiZNZShgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke2VlfS5gKTtsZXQgQmU9cGUvNCxHZT1vLkhFQVBVMzJbQmUrK107dmU9by5IRUFQVTMyW0JlKytdO2xldCBGPW8uSEVBUFUzMltCZSsrXSxpZT1vLkhFQVBVMzJbQmUrK10saGU9W107Zm9yKGxldCBSZT0wO1JlPGllO1JlKyspaGUucHVzaChvLkhFQVBVMzJbRi80K1JlXSk7by5fT3J0RnJlZShGKTtsZXQgSmU9aGUucmVkdWNlKChSZSxGZSk9PlJlKkZlLDEpO2RlPXB0KEdlKTtsZXQgb3Q9Zz8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW2FbZWVdXTtpZihkZT09PVwic3RyaW5nXCIpe2lmKG90PT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IFJlPVtdLEZlPXZlLzQ7Zm9yKGxldCBCdD0wO0J0PEplO0J0Kyspe2xldCBNdD1vLkhFQVBVMzJbRmUrK10sS3Q9QnQ9PT1KZS0xP3ZvaWQgMDpvLkhFQVBVMzJbRmVdLU10O1JlLnB1c2goby5VVEY4VG9TdHJpbmcoTXQsS3QpKX1PZS5wdXNoKFtkZSxoZSxSZSxcImNwdVwiXSl9ZWxzZSBpZihvdD09PVwiZ3B1LWJ1ZmZlclwiJiZKZT4wKXtsZXQgUmU9by5qc2VwR2V0QnVmZmVyKHZlKSxGZT1LcihHZSk7aWYoRmU9PT12b2lkIDB8fCFObihkZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZGV9YCk7eWU9ITAsT2UucHVzaChbZGUsaGUse2dwdUJ1ZmZlcjpSZSxkb3dubG9hZDpvLmpzZXBDcmVhdGVEb3dubG9hZGVyKFJlLEplKkZlLGRlKSxkaXNwb3NlOigpPT57by5fT3J0UmVsZWFzZVRlbnNvcihiZSl9fSxcImdwdS1idWZmZXJcIl0pfWVsc2V7bGV0IFJlPVduKGRlKSxGZT1uZXcgUmUoSmUpO25ldyBVaW50OEFycmF5KEZlLmJ1ZmZlcixGZS5ieXRlT2Zmc2V0LEZlLmJ5dGVMZW5ndGgpLnNldChvLkhFQVBVOC5zdWJhcnJheSh2ZSx2ZStGZS5ieXRlTGVuZ3RoKSksT2UucHVzaChbZGUsaGUsRmUsXCJjcHVcIl0pfX1maW5hbGx5e28uc3RhY2tSZXN0b3JlKFVlKSxkZT09PVwic3RyaW5nXCImJnZlJiZvLl9mcmVlKHZlKSx5ZXx8by5fT3J0UmVsZWFzZVRlbnNvcihiZSl9fXJldHVybiBnJiZvLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhnLmhhbmRsZSksT2V9ZmluYWxseXtvLnN0YWNrUmVzdG9yZShFKSxULmZvckVhY2goWT0+by5fT3J0UmVsZWFzZVRlbnNvcihZKSksQy5mb3JFYWNoKFk9Pm8uX09ydFJlbGVhc2VUZW5zb3IoWSkpLFMuZm9yRWFjaChZPT5vLl9mcmVlKFkpKSwkIT09MCYmby5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoJCkseC5mb3JFYWNoKFk9Pm8uX2ZyZWUoWSkpfX0scGQ9ZT0+e2xldCB0PU5lKCkscj10bi5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBhPXJbMF0saT10Ll9PcnRFbmRQcm9maWxpbmcoYSk7aT09PTAmJk1lKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKGkpfSxmZD1lPT57bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpe2xldCBhPXJbMl07IUFycmF5LmlzQXJyYXkoYSkmJlwiYnVmZmVyXCJpbiBhJiZ0LnB1c2goYS5idWZmZXIpfXJldHVybiB0fX0pO3ZhciBoZD1icigoaHcsUmYpPT57UmYuZXhwb3J0cz0nLyohXFxuICogT05OWCBSdW50aW1lIFdlYiB2MS4xOC4wLWRldi4yMDI0MDEzMC05ZjY4YTI3YzdhXFxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcbiAqL1xcblwidXNlIHN0cmljdFwiOygoKT0+e3ZhciBlbz1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIGtsPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIFJsPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBCbD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBRPShlLHQpPT4oKT0+KGUmJih0PWUoZT0wKSksdCk7dmFyIEJyPShlLHQpPT4oKT0+KHR8fGUoKHQ9e2V4cG9ydHM6e319KS5leHBvcnRzLHQpLHQuZXhwb3J0cyksaG49KGUsdCk9Pntmb3IodmFyIHIgaW4gdCllbyhlLHIse2dldDp0W3JdLGVudW1lcmFibGU6ITB9KX0sRGw9KGUsdCxyLG8pPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBpIG9mIFJsKHQpKSFCbC5jYWxsKGUsaSkmJmkhPT1yJiZlbyhlLGkse2dldDooKT0+dFtpXSxlbnVtZXJhYmxlOiEobz1rbCh0LGkpKXx8by5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciB1cj1lPT5EbChlbyh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgdG89e307aG4odG8se2NyZWF0ZVJlYWRTdHJlYW06KCk9PnlpLHJlYWRGaWxlOigpPT5NbCxyZWFkRmlsZVN5bmM6KCk9PnpsfSk7dmFyIE1sLHpsLHlpLHJvPVEoKCk9PntNbD12b2lkIDAsemw9dm9pZCAwLHlpPXZvaWQgMH0pO3ZhciBubz17fTtobihubyx7am9pbjooKT0+VWx9KTt2YXIgVWwsb289USgoKT0+e1VsPXZvaWQgMH0pO3ZhciB2aT1Ccigod2ksaW8pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGJpPSgoKT0+e3ZhciBlPXR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lPFwidVwiJiYoZT1lfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbih0PXt9KXt2YXIgcj10LG8saTtyLnJlYWR5PW5ldyBQcm9taXNlKChzLGMpPT57bz1zLGk9Y30pLHIubW91bnRFeHRlcm5hbERhdGE9KHMsYyk9Pnsoci5nYnx8KHIuZ2I9bmV3IE1hcCkpLnNldChzLGMpfSxyLnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgci5nYn0sci5qc2VwSW5pdD0ocyxjLGcsJCxJLEQsSCxYKT0+e3IuRmI9cyxyLnZiPWMsci54Yj1nLHIub2I9JCxyLndiPUksci5TYT1ELHIueWI9SCxyLnpiPVgsYz0ocSxqLG5lKT0+KC4uLmZlKT0+e2xldCAkZT1KZSxrPWo/LigpO2ZlPXEoLi4uZmUpO2xldCBhZT1qPy4oKTtyZXR1cm4gayE9PWFlJiYocT1hZSxuZShrKSxqPW5lPW51bGwpLEplIT0kZT9acigpOmZlfSxnPXE9PmFzeW5jKC4uLmopPT57dHJ5e2lmKHIuZmIpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIGFscmVhZHkgc3RhcnRlZFwiKTtsZXQgbmU9ci5mYj17QWI6alswXSxlcnJvcnM6W119LGZlPWF3YWl0IHEoLi4uaik7aWYoci5mYiE9PW5lKXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTtzLmZsdXNoKCk7bGV0ICRlPW5lLmVycm9ycztpZigwPCRlLmxlbmd0aCl7bGV0IGs9YXdhaXQgUHJvbWlzZS5hbGwoJGUpO2lmKGs9ay5maWx0ZXIoYWU9PmFlKSwwPGsubGVuZ3RoKXRocm93IEVycm9yKGsuam9pbihgXFxuYCkpfXJldHVybiBmZX1maW5hbGx5e3IuZmI9bnVsbH19LHIuX09ydENyZWF0ZVNlc3Npb249YyhyLl9PcnRDcmVhdGVTZXNzaW9uLCgpPT5yLl9PcnRDcmVhdGVTZXNzaW9uLHE9PnIuX09ydENyZWF0ZVNlc3Npb249cSksci5fT3J0UnVuPWcoYyhyLl9PcnRSdW4sKCk9PnIuX09ydFJ1bixxPT5yLl9PcnRSdW49cSkpLHIuX09ydFJ1bldpdGhCaW5kaW5nPWcoYyhyLl9PcnRSdW5XaXRoQmluZGluZywoKT0+ci5fT3J0UnVuV2l0aEJpbmRpbmcscT0+ci5fT3J0UnVuV2l0aEJpbmRpbmc9cSkpLHIuX09ydEJpbmRJbnB1dD1jKHIuX09ydEJpbmRJbnB1dCwoKT0+ci5fT3J0QmluZElucHV0LHE9PnIuX09ydEJpbmRJbnB1dD1xKSxyLmpzZXBSZWdpc3RlckJ1ZmZlcj0ocSxqLG5lLGZlKT0+cy5yZWdpc3RlckJ1ZmZlcihxLGosbmUsZmUpLHIuanNlcFVucmVnaXN0ZXJCdWZmZXJzPXE9PntzLnVucmVnaXN0ZXJCdWZmZXJzKHEpfSxyLmpzZXBHZXRCdWZmZXI9cT0+cy5nZXRCdWZmZXIocSksci5qc2VwQ3JlYXRlRG93bmxvYWRlcj0ocSxqLG5lKT0+cy5jcmVhdGVEb3dubG9hZGVyKHEsaixuZSksci5qc2VwT25SdW5TdGFydD0oKT0+cy5vblJ1blN0YXJ0KCl9O3ZhciB1PU9iamVjdC5hc3NpZ24oe30sciksYT1cIi4vdGhpcy5wcm9ncmFtXCIscD0ocyxjKT0+e3Rocm93IGN9LG09dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIixoPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsZD10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIseT1cIlwiLHcsXyx2O2lmKGQpe3ZhciB4PShybygpLHVyKHRvKSksVD0ob28oKSx1cihubykpO3k9aD9ULmRpcm5hbWUoeSkrXCIvXCI6X19kaXJuYW1lK1wiL1wiLHc9KHMsYyk9PihzPWllKHMpP25ldyBVUkwocyk6VC5ub3JtYWxpemUocykseC5yZWFkRmlsZVN5bmMocyxjP3ZvaWQgMDpcInV0ZjhcIikpLHY9cz0+KHM9dyhzLCEwKSxzLmJ1ZmZlcnx8KHM9bmV3IFVpbnQ4QXJyYXkocykpLHMpLF89KHMsYyxnLCQ9ITApPT57cz1pZShzKT9uZXcgVVJMKHMpOlQubm9ybWFsaXplKHMpLHgucmVhZEZpbGUocywkP3ZvaWQgMDpcInV0ZjhcIiwoSSxEKT0+e0k/ZyhJKTpjKCQ/RC5idWZmZXI6RCl9KX0sIXIudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKGE9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscD0ocyxjKT0+e3Rocm93IHByb2Nlc3MuZXhpdENvZGU9cyxjfSxyLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn1lbHNlKG18fGgpJiYoaD95PXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJih5PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxlJiYoeT1lKSx5LmluZGV4T2YoXCJibG9iOlwiKSE9PTA/eT15LnN1YnN0cigwLHkucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6eT1cIlwiLHc9cz0+e3ZhciBjPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gYy5vcGVuKFwiR0VUXCIscywhMSksYy5zZW5kKG51bGwpLGMucmVzcG9uc2VUZXh0fSxoJiYodj1zPT57dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBjLm9wZW4oXCJHRVRcIixzLCExKSxjLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsYy5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGMucmVzcG9uc2UpfSksXz0ocyxjLGcpPT57dmFyICQ9bmV3IFhNTEh0dHBSZXF1ZXN0OyQub3BlbihcIkdFVFwiLHMsITApLCQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIiwkLm9ubG9hZD0oKT0+eyQuc3RhdHVzPT0yMDB8fCQuc3RhdHVzPT0wJiYkLnJlc3BvbnNlP2MoJC5yZXNwb25zZSk6ZygpfSwkLm9uZXJyb3I9ZywkLnNlbmQobnVsbCl9KTt2YXIgQz1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFM9Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24ocix1KSx1PW51bGwsdHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZHZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIEUsTz0hMSxVLE0sTixZLHNlLEIsdGUsUGUsRWUsZWUsYmU7ZnVuY3Rpb24gTWUoKXt2YXIgcz1FLmJ1ZmZlcjtyLkhFQVA4PU09bmV3IEludDhBcnJheShzKSxyLkhFQVAxNj1ZPW5ldyBJbnQxNkFycmF5KHMpLHIuSEVBUFU4PU49bmV3IFVpbnQ4QXJyYXkocyksci5IRUFQVTE2PXNlPW5ldyBVaW50MTZBcnJheShzKSxyLkhFQVAzMj1CPW5ldyBJbnQzMkFycmF5KHMpLHIuSEVBUFUzMj10ZT1uZXcgVWludDMyQXJyYXkocyksci5IRUFQRjMyPVBlPW5ldyBGbG9hdDMyQXJyYXkocyksci5IRUFQRjY0PWJlPW5ldyBGbG9hdDY0QXJyYXkocyksci5IRUFQNjQ9RWU9bmV3IEJpZ0ludDY0QXJyYXkocyksci5IRUFQVTY0PWVlPW5ldyBCaWdVaW50NjRBcnJheShzKX12YXIgcGU9W10seWU9W10sZGU9W10sd2U9MCx6ZT1udWxsLFJlPW51bGw7ZnVuY3Rpb24gR2Uocyl7dGhyb3cgcz1cIkFib3J0ZWQoXCIrcytcIilcIixTKHMpLE89ITAsVT0xLHM9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihzK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxpKHMpLHN9dmFyIEY9cz0+cy5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKSxpZT1zPT5zLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpLGhlO2lmKGhlPVwib3J0LXdhc20tc2ltZC53YXNtXCIsIUYoaGUpKXt2YXIgWGU9aGU7aGU9ci5sb2NhdGVGaWxlP3IubG9jYXRlRmlsZShYZSx5KTp5K1hlfWZ1bmN0aW9uIG50KHMpe2lmKHYpcmV0dXJuIHYocyk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24ga2Uocyl7aWYobXx8aCl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFpZShzKSlyZXR1cm4gZmV0Y2gocyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihjPT57aWYoIWMub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrcytcIlxcJ1wiO3JldHVybiBjLmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+bnQocykpO2lmKF8pcmV0dXJuIG5ldyBQcm9taXNlKChjLGcpPT57XyhzLCQ9PmMobmV3IFVpbnQ4QXJyYXkoJCkpLGcpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pm50KHMpKX1mdW5jdGlvbiBMZShzLGMsZyl7cmV0dXJuIGtlKHMpLnRoZW4oJD0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoJCxjKSkudGhlbigkPT4kKS50aGVuKGcsJD0+e1MoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7JH1gKSxHZSgkKX0pfWZ1bmN0aW9uIEl0KHMsYyl7dmFyIGc9aGU7cmV0dXJuIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxGKGcpfHxpZShnKXx8ZHx8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/TGUoZyxzLGMpOmZldGNoKGcse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oJD0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoJCxzKS50aGVuKGMsZnVuY3Rpb24oSSl7cmV0dXJuIFMoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke0l9YCksUyhcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLExlKGcscyxjKX0pKX12YXIgVHQ9ezk0NTE2ODoocyxjLGcsJCk9PntpZih0eXBlb2Ygcj5cInVcInx8IXIuZ2IpcmV0dXJuIDE7aWYocz1GZShzPj4+MCkscy5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSxzPXIuZ2IuZ2V0KHMpLCFzKXJldHVybiAyO2lmKGM+Pj49MCxnPj4+PTAsYytnPnMuYnl0ZUxlbmd0aClyZXR1cm4gMzt0cnl7cmV0dXJuIE4uc2V0KHMuc3ViYXJyYXkoYyxjK2cpLCQ+Pj4wPj4+MCksMH1jYXRjaHtyZXR1cm4gNH19LDk0NTY2OTpzPT5yLnZiKHMpLDk0NTcwMjpzPT5yLnhiKHMpLDk0NTczNDoocyxjLGcpPT57ci5vYihzLGMsZywhMCl9LDk0NTc3MzoocyxjLGcpPT57ci5vYihzLGMsZyl9LDk0NTgwNjpzPT57ci5TYShcIkFic1wiLHMsdm9pZCAwKX0sOTQ1ODU3OnM9PntyLlNhKFwiTmVnXCIscyx2b2lkIDApfSw5NDU5MDg6cz0+e3IuU2EoXCJGbG9vclwiLHMsdm9pZCAwKX0sOTQ1OTYxOnM9PntyLlNhKFwiQ2VpbFwiLHMsdm9pZCAwKX0sOTQ2MDEzOnM9PntyLlNhKFwiUmVjaXByb2NhbFwiLHMsdm9pZCAwKX0sOTQ2MDcxOnM9PntyLlNhKFwiU3FydFwiLHMsdm9pZCAwKX0sOTQ2MTIzOnM9PntyLlNhKFwiRXhwXCIscyx2b2lkIDApfSw5NDYxNzQ6cz0+e3IuU2EoXCJFcmZcIixzLHZvaWQgMCl9LDk0NjIyNTpzPT57ci5TYShcIlNpZ21vaWRcIixzLHZvaWQgMCl9LDk0NjI4MDoocyxjLGcpPT57ci5TYShcIkhhcmRTaWdtb2lkXCIscyx7YWxwaGE6YyxiZXRhOmd9KX0sOTQ2MzU5OnM9PntyLlNhKFwiTG9nXCIscyx2b2lkIDApfSw5NDY0MTA6cz0+e3IuU2EoXCJTaW5cIixzLHZvaWQgMCl9LDk0NjQ2MTpzPT57ci5TYShcIkNvc1wiLHMsdm9pZCAwKX0sOTQ2NTEyOnM9PntyLlNhKFwiVGFuXCIscyx2b2lkIDApfSw5NDY1NjM6cz0+e3IuU2EoXCJBc2luXCIscyx2b2lkIDApfSw5NDY2MTU6cz0+e3IuU2EoXCJBY29zXCIscyx2b2lkIDApfSw5NDY2Njc6cz0+e3IuU2EoXCJBdGFuXCIscyx2b2lkIDApfSw5NDY3MTk6cz0+e3IuU2EoXCJTaW5oXCIscyx2b2lkIDApfSw5NDY3NzE6cz0+e3IuU2EoXCJDb3NoXCIscyx2b2lkIDApfSw5NDY4MjM6cz0+e3IuU2EoXCJBc2luaFwiLHMsdm9pZCAwKX0sOTQ2ODc2OnM9PntyLlNhKFwiQWNvc2hcIixzLHZvaWQgMCl9LDk0NjkyOTpzPT57ci5TYShcIkF0YW5oXCIscyx2b2lkIDApfSw5NDY5ODI6cz0+e3IuU2EoXCJUYW5oXCIscyx2b2lkIDApfSw5NDcwMzQ6cz0+e3IuU2EoXCJOb3RcIixzLHZvaWQgMCl9LDk0NzA4NToocyxjLGcpPT57ci5TYShcIkNsaXBcIixzLHttaW46YyxtYXg6Z30pfSw5NDcxNTQ6cz0+e3IuU2EoXCJDbGlwXCIscyx2b2lkIDApfSw5NDcyMDY6KHMsYyk9PntyLlNhKFwiRWx1XCIscyx7YWxwaGE6Y30pfSw5NDcyNjQ6cz0+e3IuU2EoXCJSZWx1XCIscyx2b2lkIDApfSw5NDczMTY6KHMsYyk9PntyLlNhKFwiTGVha3lSZWx1XCIscyx7YWxwaGE6Y30pfSw5NDczODA6KHMsYyk9PntyLlNhKFwiVGhyZXNob2xkZWRSZWx1XCIscyx7YWxwaGE6Y30pfSw5NDc0NTA6KHMsYyk9PntyLlNhKFwiQ2FzdFwiLHMse3RvOmN9KX0sOTQ3NTA4OnM9PntyLlNhKFwiQWRkXCIscyx2b2lkIDApfSw5NDc1NTk6cz0+e3IuU2EoXCJTdWJcIixzLHZvaWQgMCl9LDk0NzYxMDpzPT57ci5TYShcIk11bFwiLHMsdm9pZCAwKX0sOTQ3NjYxOnM9PntyLlNhKFwiRGl2XCIscyx2b2lkIDApfSw5NDc3MTI6cz0+e3IuU2EoXCJQb3dcIixzLHZvaWQgMCl9LDk0Nzc2MzpzPT57ci5TYShcIkVxdWFsXCIscyx2b2lkIDApfSw5NDc4MTY6cz0+e3IuU2EoXCJHcmVhdGVyXCIscyx2b2lkIDApfSw5NDc4NzE6cz0+e3IuU2EoXCJHcmVhdGVyT3JFcXVhbFwiLHMsdm9pZCAwKX0sOTQ3OTMzOnM9PntyLlNhKFwiTGVzc1wiLHMsdm9pZCAwKX0sOTQ3OTg1OnM9PntyLlNhKFwiTGVzc09yRXF1YWxcIixzLHZvaWQgMCl9LDk0ODA0NDoocyxjLGcsJCxJKT0+e3IuU2EoXCJSZWR1Y2VNZWFuXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZyxheGVzOiQ/QXJyYXkuZnJvbShCLnN1YmFycmF5KCQ+Pj4wLEk+Pj4wKSk6W119KX0sOTQ4MjAzOihzLGMsZywkLEkpPT57ci5TYShcIlJlZHVjZU1heFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWcsYXhlczokP0FycmF5LmZyb20oQi5zdWJhcnJheSgkPj4+MCxJPj4+MCkpOltdfSl9LDk0ODM2MToocyxjLGcsJCxJKT0+e3IuU2EoXCJSZWR1Y2VNaW5cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFnLGF4ZXM6JD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJD4+PjAsST4+PjApKTpbXX0pfSw5NDg1MTk6KHMsYyxnLCQsSSk9PntyLlNhKFwiUmVkdWNlUHJvZFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWcsYXhlczokP0FycmF5LmZyb20oQi5zdWJhcnJheSgkPj4+MCxJPj4+MCkpOltdfSl9LDk0ODY3ODoocyxjLGcsJCxJKT0+e3IuU2EoXCJSZWR1Y2VTdW1cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFnLGF4ZXM6JD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJD4+PjAsST4+PjApKTpbXX0pfSw5NDg4MzY6KHMsYyxnLCQsSSk9PntyLlNhKFwiUmVkdWNlTDFcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFnLGF4ZXM6JD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJD4+PjAsST4+PjApKTpbXX0pfSw5NDg5OTM6KHMsYyxnLCQsSSk9PntyLlNhKFwiUmVkdWNlTDJcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFnLGF4ZXM6JD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJD4+PjAsST4+PjApKTpbXX0pfSw5NDkxNTA6KHMsYyxnLCQsSSk9PntyLlNhKFwiUmVkdWNlTG9nU3VtXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZyxheGVzOiQ/QXJyYXkuZnJvbShCLnN1YmFycmF5KCQ+Pj4wLEk+Pj4wKSk6W119KX0sOTQ5MzExOihzLGMsZywkLEkpPT57ci5TYShcIlJlZHVjZVN1bVNxdWFyZVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWcsYXhlczokP0FycmF5LmZyb20oQi5zdWJhcnJheSgkPj4+MCxJPj4+MCkpOltdfSl9LDk0OTQ3NToocyxjLGcsJCxJKT0+e3IuU2EoXCJSZWR1Y2VMb2dTdW1FeHBcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFnLGF4ZXM6JD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJD4+PjAsST4+PjApKTpbXX0pfSw5NDk2Mzk6cz0+e3IuU2EoXCJXaGVyZVwiLHMsdm9pZCAwKX0sOTQ5NjkyOihzLGMsZyk9PntyLlNhKFwiVHJhbnNwb3NlXCIscyx7cGVybTpjP0FycmF5LmZyb20oQi5zdWJhcnJheShjPj4+MCxnPj4+MCkpOltdfSl9LDk0OTgwMDoocyxjLGcsJCxJLEQsSCxYLHEsaixuZSxmZSwkZSxrLGFlKT0+e3IuU2EoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0OnE/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZ10sZ3JvdXA6JCxrZXJuZWxfc2hhcGU6W0ldLHBhZHM6W0QsSF0sc3RyaWRlczpbWF0sd0lzQ29uc3Q6KCk9PiEhTVtqPj4+MF0sb3V0cHV0UGFkZGluZzpuZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkobmU+Pj4wLGZlPj4+MCkpOltdLG91dHB1dFNoYXBlOiRlP0FycmF5LmZyb20oQi5zdWJhcnJheSgkZT4+PjAsaz4+PjApKTpbXSxhY3RpdmF0aW9uOkZlKGFlKX0pfSw5NTAyMDI6KHMsYyxnLCQsSSxELEgsWCxxLGosbmUsZmUsJGUsayk9PntyLlNhKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpYP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShCLnN1YmFycmF5KGc+Pj4wLChnPj4+MCkrMj4+PjApKSxncm91cDokLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oQi5zdWJhcnJheShJPj4+MCwoST4+PjApKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKEIuc3ViYXJyYXkoRD4+PjAsKEQ+Pj4wKSs0Pj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShCLnN1YmFycmF5KEg+Pj4wLChIPj4+MCkrMj4+PjApKSx3SXNDb25zdDooKT0+ISFNW3E+Pj4wXSxvdXRwdXRQYWRkaW5nOmo/QXJyYXkuZnJvbShCLnN1YmFycmF5KGo+Pj4wLG5lPj4+MCkpOltdLG91dHB1dFNoYXBlOmZlP0FycmF5LmZyb20oQi5zdWJhcnJheShmZT4+PjAsJGU+Pj4wKSk6W10sYWN0aXZhdGlvbjpGZShrKX0pfSw5NTA3Njc6KHMsYyxnLCQsSSxELEgsWCxxLGosbmUsZmUsJGUsayxhZSk9PntyLlNhKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpxP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6W2ddLGdyb3VwOiQsa2VybmVsX3NoYXBlOltJXSxwYWRzOltELEhdLHN0cmlkZXM6W1hdLHdJc0NvbnN0OigpPT4hIU1baj4+PjBdLG91dHB1dFBhZGRpbmc6bmU/QXJyYXkuZnJvbShCLnN1YmFycmF5KG5lPj4+MCxmZT4+PjApKTpbXSxvdXRwdXRTaGFwZTokZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJGU+Pj4wLGs+Pj4wKSk6W10sYWN0aXZhdGlvbjpGZShhZSl9KX0sOTUxMTY5OihzLGMsZywkLEksRCxILFgscSxqLG5lLGZlLCRlLGspPT57ci5TYShcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6WD9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20oQi5zdWJhcnJheShnPj4+MCwoZz4+PjApKzI+Pj4wKSksZ3JvdXA6JCxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKEIuc3ViYXJyYXkoST4+PjAsKEk+Pj4wKSsyPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShCLnN1YmFycmF5KEQ+Pj4wLChEPj4+MCkrND4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oQi5zdWJhcnJheShIPj4+MCwoSD4+PjApKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhTVtxPj4+MF0sb3V0cHV0UGFkZGluZzpqP0FycmF5LmZyb20oQi5zdWJhcnJheShqPj4+MCxuZT4+PjApKTpbXSxvdXRwdXRTaGFwZTpmZT9BcnJheS5mcm9tKEIuc3ViYXJyYXkoZmU+Pj4wLCRlPj4+MCkpOltdLGFjdGl2YXRpb246RmUoayl9KX0sOTUxNzM0OihzLGMpPT57ci5TYShcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTUxODI1OihzLGMsZywkLEksRCxILFgscSxqLG5lLGZlLCRlLGssYWUsQWUpPT57ci5TYShcIkF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OkFlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmcsY291bnRfaW5jbHVkZV9wYWQ6JCxzdG9yYWdlX29yZGVyOkksZGlsYXRpb25zOltELEhdLGtlcm5lbF9zaGFwZTpbWCxxXSxwYWRzOltqLG5lLGZlLCRlXSxzdHJpZGVzOltrLGFlXX0pfSw5NTIxMDk6KHMsYyk9PntyLlNhKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTIyMDA6KHMsYyxnLCQsSSxELEgsWCxxLGosbmUsZmUsJGUsayxhZSxBZSk9PntyLlNhKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6QWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zyxjb3VudF9pbmNsdWRlX3BhZDokLHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W0QsSF0sa2VybmVsX3NoYXBlOltYLHFdLHBhZHM6W2osbmUsZmUsJGVdLHN0cmlkZXM6W2ssYWVdfSl9LDk1MjQ4NDoocyxjKT0+e3IuU2EoXCJHbG9iYWxNYXhQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTUyNTcxOihzLGMsZywkLEksRCxILFgscSxqLG5lLGZlLCRlLGssYWUsQWUpPT57ci5TYShcIk1heFBvb2xcIixzLHtmb3JtYXQ6QWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zyxjb3VudF9pbmNsdWRlX3BhZDokLHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W0QsSF0sa2VybmVsX3NoYXBlOltYLHFdLHBhZHM6W2osbmUsZmUsJGVdLHN0cmlkZXM6W2ssYWVdfSl9LDk1Mjg1MToocyxjKT0+e3IuU2EoXCJHbG9iYWxNYXhQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTUyOTM4OihzLGMsZywkLEksRCxILFgscSxqLG5lLGZlLCRlLGssYWUsQWUpPT57ci5TYShcIk1heFBvb2xcIixzLHtmb3JtYXQ6QWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zyxjb3VudF9pbmNsdWRlX3BhZDokLHN0b3JhZ2Vfb3JkZXI6SSxkaWxhdGlvbnM6W0QsSF0sa2VybmVsX3NoYXBlOltYLHFdLHBhZHM6W2osbmUsZmUsJGVdLHN0cmlkZXM6W2ssYWVdfSl9LDk1MzIxODoocyxjLGcsJCxJKT0+e3IuU2EoXCJHZW1tXCIscyx7YWxwaGE6YyxiZXRhOmcsdHJhbnNBOiQsdHJhbnNCOkl9KX0sOTUzMzIyOnM9PntyLlNhKFwiTWF0TXVsXCIscyx2b2lkIDApfSw5NTMzNzY6KHMsYyxnLCQpPT57ci5TYShcIkFyZ01heFwiLHMse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFnLGF4aXM6JH0pfSw5NTM0ODQ6KHMsYyxnLCQpPT57ci5TYShcIkFyZ01pblwiLHMse2tlZXBEaW1zOiEhYyxzZWxlY3RMYXN0SW5kZXg6ISFnLGF4aXM6JH0pfSw5NTM1OTI6KHMsYyk9PntyLlNhKFwiU29mdG1heFwiLHMse2F4aXM6Y30pfSw5NTM2NTU6KHMsYyk9PntyLlNhKFwiQ29uY2F0XCIscyx7YXhpczpjfSl9LDk1MzcxNToocyxjLGcsJCxJKT0+e3IuU2EoXCJTcGxpdFwiLHMse2F4aXM6YyxudW1PdXRwdXRzOmcsc3BsaXRTaXplczokP0FycmF5LmZyb20oQi5zdWJhcnJheSgkPj4+MCxJPj4+MCkpOltdfSl9LDk1Mzg1NTpzPT57ci5TYShcIkV4cGFuZFwiLHMsdm9pZCAwKX0sOTUzOTA5OihzLGMpPT57ci5TYShcIkdhdGhlclwiLHMse2F4aXM6TnVtYmVyKGMpfSl9LDk1Mzk4MDoocyxjKT0+e3IuU2EoXCJHYXRoZXJFbGVtZW50c1wiLHMse2F4aXM6TnVtYmVyKGMpfSl9LDk1NDA1OToocyxjLGcsJCxJLEQsSCxYLHEsaixuZSk9PntyLlNhKFwiUmVzaXplXCIscyx7YW50aWFsaWFzOmMsYXhlczpnP0FycmF5LmZyb20oQi5zdWJhcnJheShnPj4+MCwkPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOkZlKEkpLGN1YmljQ29lZmZBOkQsZXhjbHVkZU91dHNpZGU6SCxleHRyYXBvbGF0aW9uVmFsdWU6WCxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6RmUocSksbW9kZTpGZShqKSxuZWFyZXN0TW9kZTpGZShuZSl9KX0sOTU0NDA1OihzLGMsZywkLEksRCxIKT0+e3IuU2EoXCJTbGljZVwiLHMse3N0YXJ0czpjP0FycmF5LmZyb20oQi5zdWJhcnJheShjPj4+MCxnPj4+MCkpOltdLGVuZHM6JD9BcnJheS5mcm9tKEIuc3ViYXJyYXkoJD4+PjAsST4+PjApKTpbXSxheGVzOkQ/QXJyYXkuZnJvbShCLnN1YmFycmF5KEQ+Pj4wLEg+Pj4wKSk6W119KX0sOTU0NjIxOnM9PntyLlNhKFwiVGlsZVwiLHMsdm9pZCAwKX0sOTU0NjczOihzLGMsZyk9PntyLlNhKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7YXhpczpOdW1iZXIoYyksZXBzaWxvbjpOdW1iZXIoZyl9KX0sOTU0NzgwOihzLGMsZyk9PntyLlNhKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLGZvcm1hdDpnP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1NDg5NDoocyxjLGcpPT57ci5TYShcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxmb3JtYXQ6Zz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTUwMDg6cz0+e3IuU2EoXCJSYW5nZVwiLHMsdm9pZCAwKX0sOTU1MDYxOihzLGMpPT57ci5TYShcIkVpbnN1bVwiLHMse2VxdWF0aW9uOkZlKGMpfSl9LDk1NTE0MjoocyxjLGcsJCxJKT0+e3IuU2EoXCJQYWRcIixzLHttb2RlOmMsdmFsdWU6ZyxwYWRzOiQ/QXJyYXkuZnJvbShCLnN1YmFycmF5KCQ+Pj4wLEk+Pj4wKSk6W119KX0sOTU1MjY5OihzLGMsZywkLEksRCk9PntyLlNhKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLG1vbWVudHVtOmcsc3BhdGlhbDohIUksdHJhaW5pbmdNb2RlOiEhJCxmb3JtYXQ6RD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTU0Mzg6KHMsYyxnLCQsSSxEKT0+e3IuU2EoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsbW9tZW50dW06ZyxzcGF0aWFsOiEhSSx0cmFpbmluZ01vZGU6ISEkLGZvcm1hdDpEP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1NTYwNzoocyxjLGcpPT57ci5TYShcIkN1bVN1bVwiLHMse2V4Y2x1c2l2ZTpOdW1iZXIoYykscmV2ZXJzZTpOdW1iZXIoZyl9KX0sOTU1NzA0OihzLGMsZywkLEksRCxILFgscSk9PntyLlNhKFwiQXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxpc1VuaWRpcmVjdGlvbmFsOmcsbWFza0ZpbHRlclZhbHVlOiQsc2NhbGU6SSxkb1JvdGFyeTpELHFrdkhpZGRlblNpemVzOkg/QXJyYXkuZnJvbShCLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKFgpK0g+Pj4wKSk6W10scGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohIXF9KX0sOTU1OTc2OnM9PntyLlNhKFwiR2VsdVwiLHMsdm9pZCAwKX0sOTU2MDI4OihzLGMsZywkLEksRCk9PntyLlNhKFwiTXVsdGlIZWFkQXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxpc1VuaWRpcmVjdGlvbmFsOmcsbWFza0ZpbHRlclZhbHVlOiQsc2NhbGU6SSxkb1JvdGFyeTpEfSl9LDk1NjE4NzpzPT57ci5TYShcIkJpYXNBZGRcIixzLHZvaWQgMCl9LDk1NjI0MjpzPT57ci5TYShcIkJpYXNTcGxpdEdlbHVcIixzLHZvaWQgMCl9LDk1NjMwMzoocyxjKT0+e3IuU2EoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjfSl9LDk1NjM4NDoocyxjLGcsJCxJLEQsSCxYLHEsaixuZSxmZSwkZSk9PntyLlNhKFwiQ29udlwiLHMse2Zvcm1hdDpxP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsZGlsYXRpb25zOltnXSxncm91cDokLGtlcm5lbF9zaGFwZTpbSV0scGFkczpEP0FycmF5LmZyb20oQi5zdWJhcnJheShEPj4+MCxIPj4+MCkpOltdLHN0cmlkZXM6W1hdLHdfaXNfY29uc3Q6KCk9PiEhTVtqPj4+MF0sYWN0aXZhdGlvbjpGZShuZSksYWN0aXZhdGlvbl9wYXJhbXM6ZmU/QXJyYXkuZnJvbShQZS5zdWJhcnJheShmZT4+PjAsJGU+Pj4wKSk6W119KX0sOTU2NzU0OihzLGMsZywkLEksRCxILFgscSxqLG5lLGZlLCRlLGssYWUsQWUpPT57ci5TYShcIkNvbnZcIixzLHtmb3JtYXQ6ZmU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6W2csJF0sZ3JvdXA6SSxrZXJuZWxfc2hhcGU6W0QsSF0scGFkczpYP0FycmF5LmZyb20oQi5zdWJhcnJheShYPj4+MCxxPj4+MCkpOltdLHN0cmlkZXM6W2osbmVdLHdfaXNfY29uc3Q6KCk9PiEhTVskZT4+PjBdLGFjdGl2YXRpb246RmUoayksYWN0aXZhdGlvbl9wYXJhbXM6YWU/QXJyYXkuZnJvbShQZS5zdWJhcnJheShhZT4+PjAsQWU+Pj4wKSk6W119KX0sOTU3MTQ1OnM9PntyLnliKHMpfSw5NTcxNzk6KHMsYyk9PnIuemIocyxjLHIuZmIuQWIsci5mYi5lcnJvcnMpfTtmdW5jdGlvbiBWdChzKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7c30pYCx0aGlzLnN0YXR1cz1zfWZ1bmN0aW9uIFJ0KHMpe3RoaXMuY2I9cy0yNCx0aGlzLnJiPWZ1bmN0aW9uKGMpe3RlW3RoaXMuY2IrND4+PjI+Pj4wXT1jfSx0aGlzLnFiPWZ1bmN0aW9uKGMpe3RlW3RoaXMuY2IrOD4+PjI+Pj4wXT1jfSx0aGlzLmtiPWZ1bmN0aW9uKGMsZyl7dGhpcy5qYigpLHRoaXMucmIoYyksdGhpcy5xYihnKX0sdGhpcy5qYj1mdW5jdGlvbigpe3RlW3RoaXMuY2IrMTY+Pj4yPj4+MF09MH19dmFyIEp0PTAsV3Q9MCxtcj10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsQnQ9KHMsYyxnKT0+e2M+Pj49MDt2YXIgJD1jK2c7Zm9yKGc9YztzW2ddJiYhKGc+PSQpOykrK2c7aWYoMTY8Zy1jJiZzLmJ1ZmZlciYmbXIpcmV0dXJuIG1yLmRlY29kZShzLnN1YmFycmF5KGMsZykpO2ZvcigkPVwiXCI7YzxnOyl7dmFyIEk9c1tjKytdO2lmKEkmMTI4KXt2YXIgRD1zW2MrK10mNjM7aWYoKEkmMjI0KT09MTkyKSQrPVN0cmluZy5mcm9tQ2hhckNvZGUoKEkmMzEpPDw2fEQpO2Vsc2V7dmFyIEg9c1tjKytdJjYzO0k9KEkmMjQwKT09MjI0PyhJJjE1KTw8MTJ8RDw8NnxIOihJJjcpPDwxOHxEPDwxMnxIPDw2fHNbYysrXSY2Myw2NTUzNj5JPyQrPVN0cmluZy5mcm9tQ2hhckNvZGUoSSk6KEktPTY1NTM2LCQrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ST4+MTAsNTYzMjB8SSYxMDIzKSl9fWVsc2UgJCs9U3RyaW5nLmZyb21DaGFyQ29kZShJKX1yZXR1cm4gJH0sRmU9KHMsYyk9PihzPj4+PTApP0J0KE4scyxjKTpcIlwiLEV0PXM9Pntmb3IodmFyIGM9MCxnPTA7ZzxzLmxlbmd0aDsrK2cpe3ZhciAkPXMuY2hhckNvZGVBdChnKTsxMjc+PSQ/YysrOjIwNDc+PSQ/Yys9Mjo1NTI5Njw9JCYmNTczNDM+PSQ/KGMrPTQsKytnKTpjKz0zfXJldHVybiBjfSxidD0ocyxjLGcsJCk9PntpZihnPj4+PTAsISgwPCQpKXJldHVybiAwO3ZhciBJPWc7JD1nKyQtMTtmb3IodmFyIEQ9MDtEPHMubGVuZ3RoOysrRCl7dmFyIEg9cy5jaGFyQ29kZUF0KEQpO2lmKDU1Mjk2PD1IJiY1NzM0Mz49SCl7dmFyIFg9cy5jaGFyQ29kZUF0KCsrRCk7SD02NTUzNisoKEgmMTAyMyk8PDEwKXxYJjEwMjN9aWYoMTI3Pj1IKXtpZihnPj0kKWJyZWFrO2NbZysrPj4+MF09SH1lbHNle2lmKDIwNDc+PUgpe2lmKGcrMT49JClicmVhaztjW2crKz4+PjBdPTE5MnxIPj42fWVsc2V7aWYoNjU1MzU+PUgpe2lmKGcrMj49JClicmVhaztjW2crKz4+PjBdPTIyNHxIPj4xMn1lbHNle2lmKGcrMz49JClicmVhaztjW2crKz4+PjBdPTI0MHxIPj4xOCxjW2crKz4+PjBdPTEyOHxIPj4xMiY2M31jW2crKz4+PjBdPTEyOHxIPj42JjYzfWNbZysrPj4+MF09MTI4fEgmNjN9fXJldHVybiBjW2c+Pj4wXT0wLGctSX0sZnI9cz0+e2lmKHM9PT1udWxsKXJldHVyblwibnVsbFwiO3ZhciBjPXR5cGVvZiBzO3JldHVybiBjPT09XCJvYmplY3RcInx8Yz09PVwiYXJyYXlcInx8Yz09PVwiZnVuY3Rpb25cIj9zLnRvU3RyaW5nKCk6XCJcIitzfSxHcixvdD1zPT57Zm9yKHZhciBjPVwiXCI7TltzPj4+MF07KWMrPUdyW05bcysrPj4+MF1dO3JldHVybiBjfSxocj17fSxOdD17fSxncj17fSxjdDtmdW5jdGlvbiBMcihzLGMsZz17fSl7dmFyICQ9Yy5uYW1lO2lmKCFzKXRocm93IG5ldyBjdChgdHlwZSBcIiR7JH1cIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7aWYoTnQuaGFzT3duUHJvcGVydHkocykpe2lmKGcudGIpcmV0dXJuO3Rocm93IG5ldyBjdChgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgXFwnJHskfVxcJyB0d2ljZWApfU50W3NdPWMsZGVsZXRlIGdyW3NdLGhyLmhhc093blByb3BlcnR5KHMpJiYoYz1ocltzXSxkZWxldGUgaHJbc10sYy5mb3JFYWNoKEk9PkkoKSkpfWZ1bmN0aW9uIHFlKHMsYyxnPXt9KXtpZighKFwiYXJnUGFja0FkdmFuY2VcImluIGMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlXCIpO0xyKHMsYyxnKX12YXIgeXI9KHMsYyxnKT0+e3N3aXRjaChjKXtjYXNlIDE6cmV0dXJuIGc/JD0+TVskPj4+MD4+PjBdOiQ9Pk5bJD4+PjA+Pj4wXTtjYXNlIDI6cmV0dXJuIGc/JD0+WVskPj4+MT4+PjBdOiQ9PnNlWyQ+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBnPyQ9PkJbJD4+PjI+Pj4wXTokPT50ZVskPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gZz8kPT5FZVskPj4+M106JD0+ZWVbJD4+PjNdO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke2N9KTogJHtzfWApfX07ZnVuY3Rpb24gYnIoKXt0aGlzLiRhPVt2b2lkIDBdLHRoaXMubmI9W119dmFyIE9lPW5ldyBicjtmdW5jdGlvbiB3cihzKXtzPj4+PTAscz49T2UuY2ImJi0tT2UuZ2V0KHMpLnBiPT09MCYmT2UuamIocyl9dmFyIHZlPXM9PntpZighcyl0aHJvdyBuZXcgY3QoXCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSBcIitzKTtyZXR1cm4gT2UuZ2V0KHMpLnZhbHVlfSxpdD1zPT57c3dpdGNoKHMpe2Nhc2Ugdm9pZCAwOnJldHVybiAxO2Nhc2UgbnVsbDpyZXR1cm4gMjtjYXNlITA6cmV0dXJuIDM7Y2FzZSExOnJldHVybiA0O2RlZmF1bHQ6cmV0dXJuIE9lLmtiKHtwYjoxLHZhbHVlOnN9KX19O2Z1bmN0aW9uIFF0KHMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShCW3M+Pj4yPj4+MF0pfXZhciB2cj0ocyxjKT0+e3N3aXRjaChjKXtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKGcpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShQZVtnPj4+Mj4+PjBdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbihnKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoYmVbZz4+PjM+Pj4wXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtjfSk6ICR7c31gKX19O2Z1bmN0aW9uIEhuKHMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZSh0ZVtzPj4+Mj4+PjBdKX12YXIgJHI9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnZvaWQgMCxHbj0ocyxjKT0+e2Zvcih2YXIgZz1zPj4xLCQ9ZytjLzI7IShnPj0kKSYmc2VbZz4+PjBdOykrK2c7aWYoZzw8PTEsMzI8Zy1zJiYkcilyZXR1cm4gJHIuZGVjb2RlKE4uc3ViYXJyYXkocz4+PjAsZz4+PjApKTtmb3IoZz1cIlwiLCQ9MDshKCQ+PWMvMik7KyskKXt2YXIgST1ZW3MrMiokPj4+MT4+PjBdO2lmKEk9PTApYnJlYWs7Zys9U3RyaW5nLmZyb21DaGFyQ29kZShJKX1yZXR1cm4gZ30sbWU9KHMsYyxnKT0+e2lmKGc/Pz0yMTQ3NDgzNjQ3LDI+ZylyZXR1cm4gMDtnLT0yO3ZhciAkPWM7Zz1nPDIqcy5sZW5ndGg/Zy8yOnMubGVuZ3RoO2Zvcih2YXIgST0wO0k8ZzsrK0kpWVtjPj4+MT4+PjBdPXMuY2hhckNvZGVBdChJKSxjKz0yO3JldHVybiBZW2M+Pj4xPj4+MF09MCxjLSR9LGVyPXM9PjIqcy5sZW5ndGgsRnI9KHMsYyk9Pntmb3IodmFyIGc9MCwkPVwiXCI7IShnPj1jLzQpOyl7dmFyIEk9QltzKzQqZz4+PjI+Pj4wXTtpZihJPT0wKWJyZWFrOysrZyw2NTUzNjw9ST8oSS09NjU1MzYsJCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxJPj4xMCw1NjMyMHxJJjEwMjMpKTokKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEkpfXJldHVybiAkfSxMbj0ocyxjLGcpPT57aWYoYz4+Pj0wLGc/Pz0yMTQ3NDgzNjQ3LDQ+ZylyZXR1cm4gMDt2YXIgJD1jO2c9JCtnLTQ7Zm9yKHZhciBJPTA7STxzLmxlbmd0aDsrK0kpe3ZhciBEPXMuY2hhckNvZGVBdChJKTtpZig1NTI5Njw9RCYmNTczNDM+PUQpe3ZhciBIPXMuY2hhckNvZGVBdCgrK0kpO0Q9NjU1MzYrKChEJjEwMjMpPDwxMCl8SCYxMDIzfWlmKEJbYz4+PjI+Pj4wXT1ELGMrPTQsYys0PmcpYnJlYWt9cmV0dXJuIEJbYz4+PjI+Pj4wXT0wLGMtJH0sanI9cz0+e2Zvcih2YXIgYz0wLGc9MDtnPHMubGVuZ3RoOysrZyl7dmFyICQ9cy5jaGFyQ29kZUF0KGcpOzU1Mjk2PD0kJiY1NzM0Mz49JCYmKytnLGMrPTR9cmV0dXJuIGN9LF9yPShzLGMpPT57dmFyIGc9TnRbc107aWYoZz09PXZvaWQgMCl0aHJvdyBzPUZ0KHMpLGc9b3QocyksYXQocyksbmV3IGN0KGMrXCIgaGFzIHVua25vd24gdHlwZSBcIitnKTtyZXR1cm4gZ30sU3I9KHMsYyxnKT0+e3ZhciAkPVtdO3JldHVybiBzPXMudG9XaXJlVHlwZSgkLGcpLCQubGVuZ3RoJiYodGVbYz4+PjI+Pj4wXT1pdCgkKSksc30sSHQ9cz0+e3RyeXtzKCl9Y2F0Y2goYyl7R2UoYyl9fTtmdW5jdGlvbiBxcigpe3ZhciBzPXVlLGM9e307Zm9yKGxldFtnLCRdb2YgT2JqZWN0LmVudHJpZXMocykpY1tnXT10eXBlb2YgJD09XCJmdW5jdGlvblwiP2Z1bmN0aW9uKCl7RHQucHVzaChnKTt0cnl7cmV0dXJuICQuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZpbmFsbHl7T3x8KER0LnBvcCgpLEplJiZtdD09PTEmJkR0Lmxlbmd0aD09PTAmJihtdD0wLEh0KGxuKSx0eXBlb2YgRmliZXJzPFwidVwiJiZGaWJlcnMuSGIoKSkpfX06JDtyZXR1cm4gY312YXIgbXQ9MCxKZT1udWxsLHhyPTAsRHQ9W10sQ3I9e30sQXI9e30sS3I9MCx0cj1udWxsLFlyPVtdO2Z1bmN0aW9uIFpyKCl7cmV0dXJuIG5ldyBQcm9taXNlKChzLGMpPT57dHI9e3Jlc29sdmU6cyxyZWplY3Q6Y319KX1mdW5jdGlvbiBYcigpe3ZhciBzPU10KDY1NTQ4KSxjPXMrMTI7dGVbcz4+PjI+Pj4wXT1jLHRlW3MrND4+PjI+Pj4wXT1jKzY1NTM2LGM9RHRbMF07dmFyIGc9Q3JbY107cmV0dXJuIGc9PT12b2lkIDAmJihnPUtyKyssQ3JbY109ZyxBcltnXT1jKSxCW3MrOD4+PjI+Pj4wXT1nLHN9ZnVuY3Rpb24gSnIocyl7aWYoIU8pe2lmKG10PT09MCl7dmFyIGM9ITEsZz0hMTtzKCgkPTApPT57aWYoIU8mJih4cj0kLGM9ITAsZykpe210PTIsSHQoKCk9PmZ0KEplKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIubGIuc2ImJkJyb3dzZXIubGIucmVzdW1lKCksJD0hMTt0cnl7dmFyIEk9KDAsdWVbQXJbQltKZSs4Pj4+Mj4+PjBdXV0pKCl9Y2F0Y2goWCl7ST1YLCQ9ITB9dmFyIEQ9ITE7aWYoIUplKXt2YXIgSD10cjtIJiYodHI9bnVsbCwoJD9ILnJlamVjdDpILnJlc29sdmUpKEkpLEQ9ITApfWlmKCQmJiFEKXRocm93IEl9fSksZz0hMCxjfHwobXQ9MSxKZT1YcigpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLmxiLnNiJiZCcm93c2VyLmxiLnBhdXNlKCksSHQoKCk9Pmp0KEplKSkpfWVsc2UgbXQ9PT0yPyhtdD0wLEh0KGR0KSxhdChKZSksSmU9bnVsbCxZci5mb3JFYWNoKCQ9PntpZighTyl0cnl7JCgpO3RyeXtVPVU9JD1VLHIub25FeGl0Py4oJCksTz0hMCxwKCQsbmV3IFZ0KCQpKX1jYXRjaChJKXtJIGluc3RhbmNlb2YgVnR8fEk9PVwidW53aW5kXCJ8fHAoMSxJKX19Y2F0Y2goSSl7SSBpbnN0YW5jZW9mIFZ0fHxJPT1cInVud2luZFwifHxwKDEsSSl9fSkpOkdlKGBpbnZhbGlkIHN0YXRlOiAke210fWApO3JldHVybiB4cn19ZnVuY3Rpb24gSXIocyl7cmV0dXJuIEpyKGM9PntzKCkudGhlbihjKX0pfXZhciBHdD1bXSxRcj17fSxycj1zPT57dmFyIGM9UXJbc107cmV0dXJuIGM9PT12b2lkIDA/b3Qocyk6Y30sVHI9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLGx0PXM9Pnt2YXIgYz1HdC5sZW5ndGg7cmV0dXJuIEd0LnB1c2gocyksY30sRXI9KHMsYyk9Pntmb3IodmFyIGc9QXJyYXkocyksJD0wOyQ8czsrKyQpZ1skXT1fcih0ZVtjKzQqJD4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIiskKTtyZXR1cm4gZ30sbnI9KHMsYyk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwibmFtZVwiLHt2YWx1ZTpzfSk7ZnVuY3Rpb24gRm4ocyl7dmFyIGM9RnVuY3Rpb247aWYoIShjIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IG5ldyBUeXBlRXJyb3IoYG5ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAke3R5cGVvZiBjfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciBnPW5yKGMubmFtZXx8XCJ1bmtub3duRnVuY3Rpb25OYW1lXCIsZnVuY3Rpb24oKXt9KTtyZXR1cm4gZy5wcm90b3R5cGU9Yy5wcm90b3R5cGUsZz1uZXcgZyxzPWMuYXBwbHkoZyxzKSxzIGluc3RhbmNlb2YgT2JqZWN0P3M6Z312YXIgUWU9cz0+cyU0PT09MCYmKHMlMTAwIT09MHx8cyU0MDA9PT0wKSxlbj1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxwdD1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XSxQcj1zPT57dmFyIGM9RXQocykrMSxnPU10KGMpO3JldHVybiBnJiZidChzLE4sZyxjKSxnfSxvcj1bXSxldD0ocyxjKT0+e29yLmxlbmd0aD0wO2Zvcih2YXIgZztnPU5bcysrPj4+MF07KXt2YXIgJD1nIT0xMDU7JCY9ZyE9MTEyLGMrPSQmJmMlOD80OjAsb3IucHVzaChnPT0xMTI/dGVbYz4+PjI+Pj4wXTpnPT0xMDY/RWVbYz4+PjNdOmc9PTEwNT9CW2M+Pj4yPj4+MF06YmVbYz4+PjM+Pj4wXSksYys9JD84OjR9cmV0dXJuIG9yfSxMdD17fSxLZT0oKT0+e2lmKCF0dCl7dmFyIHM9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86YXx8XCIuL3RoaXMucHJvZ3JhbVwifSxjO2ZvcihjIGluIEx0KUx0W2NdPT09dm9pZCAwP2RlbGV0ZSBzW2NdOnNbY109THRbY107dmFyIGc9W107Zm9yKGMgaW4gcylnLnB1c2goYCR7Y309JHtzW2NdfWApO3R0PWd9cmV0dXJuIHR0fSx0dCx0bj1bbnVsbCxbXSxbXV0scm49WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxubj1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIG9uKHMpe3ZhciBjPUFycmF5KEV0KHMpKzEpO3JldHVybiBidChzLGMsMCxjLmxlbmd0aCksY31mdW5jdGlvbiBhbihzLGMsZywkKXtmdW5jdGlvbiBJKGssYWUsQWUpe2ZvcihrPXR5cGVvZiBrPT1cIm51bWJlclwiP2sudG9TdHJpbmcoKTprfHxcIlwiO2subGVuZ3RoPGFlOylrPUFlWzBdK2s7cmV0dXJuIGt9ZnVuY3Rpb24gRChrLGFlKXtyZXR1cm4gSShrLGFlLFwiMFwiKX1mdW5jdGlvbiBIKGssYWUpe2Z1bmN0aW9uIEFlKGt0KXtyZXR1cm4gMD5rdD8tMTowPGt0PzE6MH12YXIgT3Q7cmV0dXJuKE90PUFlKGsuZ2V0RnVsbFllYXIoKS1hZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYoT3Q9QWUoay5nZXRNb250aCgpLWFlLmdldE1vbnRoKCkpKT09PTAmJihPdD1BZShrLmdldERhdGUoKS1hZS5nZXREYXRlKCkpKSxPdH1mdW5jdGlvbiBYKGspe3N3aXRjaChrLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGsuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIGs7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShrLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGsuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoay5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShrLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShrLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIHEoayl7dmFyIGFlPWsuYWI7Zm9yKGs9bmV3IERhdGUobmV3IERhdGUoay5iYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPGFlOyl7dmFyIEFlPWsuZ2V0TW9udGgoKSxPdD0oUWUoay5nZXRGdWxsWWVhcigpKT9ybjpubilbQWVdO2lmKGFlPk90LWsuZ2V0RGF0ZSgpKWFlLT1PdC1rLmdldERhdGUoKSsxLGsuc2V0RGF0ZSgxKSwxMT5BZT9rLnNldE1vbnRoKEFlKzEpOihrLnNldE1vbnRoKDApLGsuc2V0RnVsbFllYXIoay5nZXRGdWxsWWVhcigpKzEpKTtlbHNle2suc2V0RGF0ZShrLmdldERhdGUoKSthZSk7YnJlYWt9fXJldHVybiBBZT1uZXcgRGF0ZShrLmdldEZ1bGxZZWFyKCkrMSwwLDQpLGFlPVgobmV3IERhdGUoay5nZXRGdWxsWWVhcigpLDAsNCkpLEFlPVgoQWUpLDA+PUgoYWUsayk/MD49SChBZSxrKT9rLmdldEZ1bGxZZWFyKCkrMTprLmdldEZ1bGxZZWFyKCk6ay5nZXRGdWxsWWVhcigpLTF9cz4+Pj0wLGM+Pj49MCxnPj4+PTAsJD4+Pj0wO3ZhciBqPXRlWyQrNDA+Pj4yPj4+MF07JD17RGI6QlskPj4+Mj4+PjBdLENiOkJbJCs0Pj4+Mj4+PjBdLGhiOkJbJCs4Pj4+Mj4+PjBdLG1iOkJbJCsxMj4+PjI+Pj4wXSxpYjpCWyQrMTY+Pj4yPj4+MF0sYmI6QlskKzIwPj4+Mj4+PjBdLFdhOkJbJCsyND4+PjI+Pj4wXSxhYjpCWyQrMjg+Pj4yPj4+MF0sR2I6QlskKzMyPj4+Mj4+PjBdLEJiOkJbJCszNj4+PjI+Pj4wXSxFYjpqP0ZlKGopOlwiXCJ9LGc9RmUoZyksaj17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgbmUgaW4gailnPWcucmVwbGFjZShuZXcgUmVnRXhwKG5lLFwiZ1wiKSxqW25lXSk7dmFyIGZlPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksJGU9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2o9e1wiJWFcIjprPT5mZVtrLldhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6az0+ZmVbay5XYV0sXCIlYlwiOms9PiRlW2suaWJdLnN1YnN0cmluZygwLDMpLFwiJUJcIjprPT4kZVtrLmliXSxcIiVDXCI6az0+RCgoay5iYisxOTAwKS8xMDB8MCwyKSxcIiVkXCI6az0+RChrLm1iLDIpLFwiJWVcIjprPT5JKGsubWIsMixcIiBcIiksXCIlZ1wiOms9PnEoaykudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOms9PnEoayksXCIlSFwiOms9PkQoay5oYiwyKSxcIiVJXCI6az0+KGs9ay5oYixrPT0wP2s9MTI6MTI8ayYmKGstPTEyKSxEKGssMikpLFwiJWpcIjprPT57Zm9yKHZhciBhZT0wLEFlPTA7QWU8PWsuaWItMTthZSs9KFFlKGsuYmIrMTkwMCk/cm46bm4pW0FlKytdKTtyZXR1cm4gRChrLm1iK2FlLDMpfSxcIiVtXCI6az0+RChrLmliKzEsMiksXCIlTVwiOms9PkQoay5DYiwyKSxcIiVuXCI6KCk9PmBcXG5gLFwiJXBcIjprPT4wPD1rLmhiJiYxMj5rLmhiP1wiQU1cIjpcIlBNXCIsXCIlU1wiOms9PkQoay5EYiwyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6az0+ay5XYXx8NyxcIiVVXCI6az0+RChNYXRoLmZsb29yKChrLmFiKzctay5XYSkvNyksMiksXCIlVlwiOms9Pnt2YXIgYWU9TWF0aC5mbG9vcigoay5hYis3LShrLldhKzYpJTcpLzcpO2lmKDI+PShrLldhKzM3MS1rLmFiLTIpJTcmJmFlKyssYWUpYWU9PTUzJiYoQWU9KGsuV2ErMzcxLWsuYWIpJTcsQWU9PTR8fEFlPT0zJiZRZShrLmJiKXx8KGFlPTEpKTtlbHNle2FlPTUyO3ZhciBBZT0oay5XYSs3LWsuYWItMSklNzsoQWU9PTR8fEFlPT01JiZRZShrLmJiJTQwMC0xKSkmJmFlKyt9cmV0dXJuIEQoYWUsMil9LFwiJXdcIjprPT5rLldhLFwiJVdcIjprPT5EKE1hdGguZmxvb3IoKGsuYWIrNy0oay5XYSs2KSU3KS83KSwyKSxcIiV5XCI6az0+KGsuYmIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOms9PmsuYmIrMTkwMCxcIiV6XCI6az0+e2s9ay5CYjt2YXIgYWU9MDw9aztyZXR1cm4gaz1NYXRoLmFicyhrKS82MCwoYWU/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoay82MCoxMDArayU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOms9PmsuRWIsXCIlJVwiOigpPT5cIiVcIn0sZz1nLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpO2ZvcihuZSBpbiBqKWcuaW5jbHVkZXMobmUpJiYoZz1nLnJlcGxhY2UobmV3IFJlZ0V4cChuZSxcImdcIiksaltuZV0oJCkpKTtyZXR1cm4gZz1nLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIiksbmU9b24oZyksbmUubGVuZ3RoPmM/MDooTS5zZXQobmUscz4+PjApLG5lLmxlbmd0aC0xKX1mb3IodmFyIHNuPUFycmF5KDI1NiksaXI9MDsyNTY+aXI7Kytpcilzbltpcl09U3RyaW5nLmZyb21DaGFyQ29kZShpcik7R3I9c24sY3Q9ci5CaW5kaW5nRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihzKXtzdXBlcihzKSx0aGlzLm5hbWU9XCJCaW5kaW5nRXJyb3JcIn19LHIuSW50ZXJuYWxFcnJvcj1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHMpe3N1cGVyKHMpLHRoaXMubmFtZT1cIkludGVybmFsRXJyb3JcIn19LE9iamVjdC5hc3NpZ24oYnIucHJvdG90eXBlLHtnZXQocyl7cmV0dXJuIHRoaXMuJGFbc119LGhhcyhzKXtyZXR1cm4gdGhpcy4kYVtzXSE9PXZvaWQgMH0sa2Iocyl7dmFyIGM9dGhpcy5uYi5wb3AoKXx8dGhpcy4kYS5sZW5ndGg7cmV0dXJuIHRoaXMuJGFbY109cyxjfSxqYihzKXt0aGlzLiRhW3NdPXZvaWQgMCx0aGlzLm5iLnB1c2gocyl9fSksT2UuJGEucHVzaCh7dmFsdWU6dm9pZCAwfSx7dmFsdWU6bnVsbH0se3ZhbHVlOiEwfSx7dmFsdWU6ITF9KSxPZS5jYj1PZS4kYS5sZW5ndGgsci5jb3VudF9lbXZhbF9oYW5kbGVzPSgpPT57Zm9yKHZhciBzPTAsYz1PZS5jYjtjPE9lLiRhLmxlbmd0aDsrK2MpT2UuJGFbY10hPT12b2lkIDAmJisrcztyZXR1cm4gc307dmFyIGpuPXtpYTpmdW5jdGlvbihzLGMsZyl7cmV0dXJuIElyKGFzeW5jKCk9Pnthd2FpdCByLndiKHMsYyxnKX0pfSxhOmZ1bmN0aW9uKHMsYyxnKXt0aHJvdyBzPj4+PTAsbmV3IFJ0KHMpLmtiKGM+Pj4wLGc+Pj4wKSxKdD1zLFd0KyssSnR9LHg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sYmE6ZnVuY3Rpb24oKXt9LE86ZnVuY3Rpb24oKXt9LFE6ZnVuY3Rpb24oKXt9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LCQ6ZnVuY3Rpb24oKXt9LFc6ZnVuY3Rpb24oKXt9LF86ZnVuY3Rpb24oKXt9LEQ6ZnVuY3Rpb24oKXt9LFA6ZnVuY3Rpb24oKXt9LE06ZnVuY3Rpb24oKXt9LGFhOmZ1bmN0aW9uKCl7fSxOOmZ1bmN0aW9uKCl7fSxHOmZ1bmN0aW9uKHMsYyxnLCQsSSl7Yz4+Pj0wLGM9b3QoYyk7dmFyIEQ9Yy5pbmRleE9mKFwidVwiKSE9LTE7RCYmKEk9KDFuPDw2NG4pLTFuKSxxZShzPj4+MCx7bmFtZTpjLGZyb21XaXJlVHlwZTpIPT5ILHRvV2lyZVR5cGU6ZnVuY3Rpb24oSCxYKXtpZih0eXBlb2YgWCE9XCJiaWdpbnRcIiYmdHlwZW9mIFghPVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke2ZyKFgpfVwiIHRvICR7dGhpcy5uYW1lfWApO2lmKFg8JHx8WD5JKXRocm93IG5ldyBUeXBlRXJyb3IoYFBhc3NpbmcgYSBudW1iZXIgXCIke2ZyKFgpfVwiIGZyb20gSlMgc2lkZSB0byBDL0MrKyBzaWRlIHRvIGFuIGFyZ3VtZW50IG9mIHR5cGUgXCIke2N9XCIsIHdoaWNoIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIFskeyR9LCAke0l9XSFgKTtyZXR1cm4gWH0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjp5cihjLGc+Pj4wLCFEKSxlYjpudWxsfSl9LGdhOmZ1bmN0aW9uKHMsYyxnLCQpe2M9b3QoYz4+PjApLHFlKHM+Pj4wLHtuYW1lOmMsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKEkpe3JldHVybiEhSX0sdG9XaXJlVHlwZTpmdW5jdGlvbihJLEQpe3JldHVybiBEP2c6JH0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbihJKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoTltJPj4+MF0pfSxlYjpudWxsfSl9LGZhOmZ1bmN0aW9uKHMsYyl7Yz1vdChjPj4+MCkscWUocz4+PjAse25hbWU6Yyxmcm9tV2lyZVR5cGU6Zz0+e3ZhciAkPXZlKGcpO3JldHVybiB3cihnKSwkfSx0b1dpcmVUeXBlOihnLCQpPT5pdCgkKSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOlF0LGViOm51bGx9KX0sRjpmdW5jdGlvbihzLGMsZyl7Yz1vdChjPj4+MCkscWUocz4+PjAse25hbWU6Yyxmcm9tV2lyZVR5cGU6JD0+JCx0b1dpcmVUeXBlOigkLEkpPT5JLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6dnIoYyxnPj4+MCksZWI6bnVsbH0pfSx0OmZ1bmN0aW9uKHMsYyxnLCQsSSl7aWYocz4+Pj0wLGc+Pj49MCxjPW90KGM+Pj4wKSxJPT09LTEmJihJPTQyOTQ5NjcyOTUpLEk9WD0+WCwkPT09MCl7dmFyIEQ9MzItOCpnO0k9WD0+WDw8RD4+PkR9dmFyIEg9Yy5pbmNsdWRlcyhcInVuc2lnbmVkXCIpP2Z1bmN0aW9uKFgscSl7cmV0dXJuIHE+Pj4wfTpmdW5jdGlvbihYLHEpe3JldHVybiBxfTtxZShzLHtuYW1lOmMsZnJvbVdpcmVUeXBlOkksdG9XaXJlVHlwZTpILGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6eXIoYyxnLCQhPT0wKSxlYjpudWxsfSl9LG46ZnVuY3Rpb24ocyxjLGcpe2Z1bmN0aW9uICQoRCl7cmV0dXJuIG5ldyBJKE0uYnVmZmVyLHRlW0QrND4+PjI+Pj4wXSx0ZVtEPj4+Mj4+PjBdKX12YXIgST1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXksQmlnSW50NjRBcnJheSxCaWdVaW50NjRBcnJheV1bY107Zz1vdChnPj4+MCkscWUocz4+PjAse25hbWU6Zyxmcm9tV2lyZVR5cGU6JCxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOiR9LHt0YjohMH0pfSxIOmZ1bmN0aW9uKHMsYyl7Yz1vdChjPj4+MCk7dmFyIGc9Yz09PVwic3RkOjpzdHJpbmdcIjtxZShzPj4+MCx7bmFtZTpjLGZyb21XaXJlVHlwZTpmdW5jdGlvbigkKXt2YXIgST10ZVskPj4+Mj4+PjBdLEQ9JCs0O2lmKGcpZm9yKHZhciBIPUQsWD0wO1g8PUk7KytYKXt2YXIgcT1EK1g7aWYoWD09SXx8TltxPj4+MF09PTApe2lmKEg9RmUoSCxxLUgpLGo9PT12b2lkIDApdmFyIGo9SDtlbHNlIGorPVN0cmluZy5mcm9tQ2hhckNvZGUoMCksais9SDtIPXErMX19ZWxzZXtmb3Ioaj1BcnJheShJKSxYPTA7WDxJOysrWClqW1hdPVN0cmluZy5mcm9tQ2hhckNvZGUoTltEK1g+Pj4wXSk7aj1qLmpvaW4oXCJcIil9cmV0dXJuIGF0KCQpLGp9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oJCxJKXtJIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJihJPW5ldyBVaW50OEFycmF5KEkpKTt2YXIgRD10eXBlb2YgST09XCJzdHJpbmdcIjtpZighKER8fEkgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxJIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fEkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXRocm93IG5ldyBjdChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7dmFyIEg9ZyYmRD9FdChJKTpJLmxlbmd0aCxYPU10KDQrSCsxKSxxPVgrNDtpZih0ZVtYPj4+Mj4+PjBdPUgsZyYmRClidChJLE4scSxIKzEpO2Vsc2UgaWYoRClmb3IoRD0wO0Q8SDsrK0Qpe3ZhciBqPUkuY2hhckNvZGVBdChEKTtpZigyNTU8ail0aHJvdyBhdChxKSxuZXcgY3QoXCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHNcIik7TltxK0Q+Pj4wXT1qfWVsc2UgZm9yKEQ9MDtEPEg7KytEKU5bcStEPj4+MF09SVtEXTtyZXR1cm4gJCE9PW51bGwmJiQucHVzaChhdCxYKSxYfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOkhuLGViKCQpe2F0KCQpfX0pfSx6OmZ1bmN0aW9uKHMsYyxnKXtpZihjPj4+PTAsZz4+Pj0wLGc9b3QoZyksYz09PTIpdmFyICQ9R24sST1tZSxEPWVyLEg9KCk9PnNlLFg9MTtlbHNlIGM9PT00JiYoJD1GcixJPUxuLEQ9anIsSD0oKT0+dGUsWD0yKTtxZShzPj4+MCx7bmFtZTpnLGZyb21XaXJlVHlwZTpxPT57Zm9yKHZhciBqPXRlW3E+Pj4yPj4+MF0sbmU9SCgpLGZlLCRlPXErNCxrPTA7azw9ajsrK2spe3ZhciBhZT1xKzQraypjOyhrPT1qfHxuZVthZT4+PlhdPT0wKSYmKCRlPSQoJGUsYWUtJGUpLGZlPT09dm9pZCAwP2ZlPSRlOihmZSs9U3RyaW5nLmZyb21DaGFyQ29kZSgwKSxmZSs9JGUpLCRlPWFlK2MpfXJldHVybiBhdChxKSxmZX0sdG9XaXJlVHlwZToocSxqKT0+e2lmKHR5cGVvZiBqIT1cInN0cmluZ1wiKXRocm93IG5ldyBjdChgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtnfWApO3ZhciBuZT1EKGopLGZlPU10KDQrbmUrYyk7cmV0dXJuIHRlW2ZlPj4+Ml09bmU+PlgsSShqLGZlKzQsbmUrYykscSE9PW51bGwmJnEucHVzaChhdCxmZSksZmV9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6UXQsZWIocSl7YXQocSl9fSl9LGhhOmZ1bmN0aW9uKHMsYyl7Yz1vdChjPj4+MCkscWUocz4+PjAse3ViOiEwLG5hbWU6YyxhcmdQYWNrQWR2YW5jZTowLGZyb21XaXJlVHlwZTooKT0+e30sdG9XaXJlVHlwZTooKT0+e319KX0sZGE6KCk9PjEsczpmdW5jdGlvbihzLGMsZyl7cmV0dXJuIGM+Pj49MCxnPj4+PTAscz12ZShzPj4+MCksYz1fcihjLFwiZW12YWw6OmFzXCIpLFNyKGMsZyxzKX0sdzpmdW5jdGlvbihzKXtyZXR1cm4gcz4+Pj0wLElyKCgpPT4ocz12ZShzKSxzLnRoZW4oaXQpKSl9LG86ZnVuY3Rpb24ocyxjLGcsJCl7cmV0dXJuIGc+Pj49MCwkPj4+PTAscz1HdFtzPj4+MF0sYz12ZShjPj4+MCkscyhudWxsLGMsZywkKX0sazpmdW5jdGlvbihzLGMsZywkLEkpe3JldHVybiBnPj4+PTAsJD4+Pj0wLEk+Pj49MCxzPUd0W3M+Pj4wXSxjPXZlKGM+Pj4wKSxnPXJyKGcpLHMoYyxjW2ddLCQsSSl9LGI6d3IsQTpmdW5jdGlvbihzLGMpe3JldHVybiBjPj4+PTAscz12ZShzPj4+MCksYz12ZShjKSxzPT1jfSxtOmZ1bmN0aW9uKHMpe3JldHVybiBzPj4+PTAscz09PTA/aXQoVHIoKSk6KHM9cnIocyksaXQoVHIoKVtzXSkpfSxpOmZ1bmN0aW9uKHMsYyxnKXtjPUVyKHMsYz4+PjApO3ZhciAkPWMuc2hpZnQoKTtzLS07dmFyIEk9YHJldHVybiBmdW5jdGlvbiAob2JqLCBmdW5jLCBkZXN0cnVjdG9yc1JlZiwgYXJncykge1xcbmAsRD0wLEg9W107Zz09PTAmJkgucHVzaChcIm9ialwiKTtmb3IodmFyIFg9W1wicmV0VHlwZVwiXSxxPVskXSxqPTA7ajxzOysrailILnB1c2goXCJhcmdcIitqKSxYLnB1c2goXCJhcmdUeXBlXCIraikscS5wdXNoKGNbal0pLEkrPWAgIHZhciBhcmcke2p9ID0gYXJnVHlwZSR7an0ucmVhZFZhbHVlRnJvbVBvaW50ZXIoYXJncyR7RD9cIitcIitEOlwiXCJ9KTtcXG5gLEQrPWNbal0uYXJnUGFja0FkdmFuY2U7Zm9yKEkrPWAgIHZhciBydiA9ICR7Zz09PTE/XCJuZXcgZnVuY1wiOlwiZnVuYy5jYWxsXCJ9KCR7SC5qb2luKFwiLCBcIil9KTtcXG5gLGo9MDtqPHM7KytqKWNbal0uZGVsZXRlT2JqZWN0JiYoSSs9YCAgYXJnVHlwZSR7an0uZGVsZXRlT2JqZWN0KGFyZyR7an0pO1xcbmApO3JldHVybiAkLnVifHwoWC5wdXNoKFwiZW12YWxfcmV0dXJuVmFsdWVcIikscS5wdXNoKFNyKSxJKz1gICByZXR1cm4gZW12YWxfcmV0dXJuVmFsdWUocmV0VHlwZSwgZGVzdHJ1Y3RvcnNSZWYsIHJ2KTtcXG5gKSxYLnB1c2goSStgfTtcXG5gKSxzPUZuKFgpLmFwcGx5KG51bGwscSksZz1gbWV0aG9kQ2FsbGVyPCgke2MubWFwKG5lPT5uZS5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAkeyQubmFtZX0+YCxsdChucihnLHMpKX0scjpmdW5jdGlvbihzLGMpe3JldHVybiBjPj4+PTAscz12ZShzPj4+MCksYz12ZShjKSxpdChzW2NdKX0sZTpmdW5jdGlvbihzKXtzPj4+PTAsNDxzJiYoT2UuZ2V0KHMpLnBiKz0xKX0sdTpmdW5jdGlvbigpe3JldHVybiBpdChbXSl9LGw6ZnVuY3Rpb24ocyl7cz12ZShzPj4+MCk7Zm9yKHZhciBjPUFycmF5KHMubGVuZ3RoKSxnPTA7ZzxzLmxlbmd0aDtnKyspY1tnXT1zW2ddO3JldHVybiBpdChjKX0sZDpmdW5jdGlvbihzKXtyZXR1cm4gaXQocnIocz4+PjApKX0sajpmdW5jdGlvbigpe3JldHVybiBpdCh7fSl9LGg6ZnVuY3Rpb24ocyl7cz4+Pj0wO2Zvcih2YXIgYz12ZShzKTtjLmxlbmd0aDspe3ZhciBnPWMucG9wKCk7Yy5wb3AoKShnKX13cihzKX0sZzpmdW5jdGlvbihzLGMsZyl7Yz4+Pj0wLGc+Pj49MCxzPXZlKHM+Pj4wKSxjPXZlKGMpLGc9dmUoZyksc1tjXT1nfSxjOmZ1bmN0aW9uKHMsYyl7cmV0dXJuIGM+Pj49MCxzPV9yKHM+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIikscz1zLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGMpLGl0KHMpfSxUOmZ1bmN0aW9uKHMsYyl7cz0tOTAwNzE5OTI1NDc0MDk5Mj5zfHw5MDA3MTk5MjU0NzQwOTkyPHM/TmFOOk51bWJlcihzKSxjPj4+PTAscz1uZXcgRGF0ZSgxZTMqcyksQltjPj4+Mj4+PjBdPXMuZ2V0VVRDU2Vjb25kcygpLEJbYys0Pj4+Mj4+PjBdPXMuZ2V0VVRDTWludXRlcygpLEJbYys4Pj4+Mj4+PjBdPXMuZ2V0VVRDSG91cnMoKSxCW2MrMTI+Pj4yPj4+MF09cy5nZXRVVENEYXRlKCksQltjKzE2Pj4+Mj4+PjBdPXMuZ2V0VVRDTW9udGgoKSxCW2MrMjA+Pj4yPj4+MF09cy5nZXRVVENGdWxsWWVhcigpLTE5MDAsQltjKzI0Pj4+Mj4+PjBdPXMuZ2V0VVRDRGF5KCksQltjKzI4Pj4+Mj4+PjBdPShzLmdldFRpbWUoKS1EYXRlLlVUQyhzLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxVOmZ1bmN0aW9uKHMsYyl7cz0tOTAwNzE5OTI1NDc0MDk5Mj5zfHw5MDA3MTk5MjU0NzQwOTkyPHM/TmFOOk51bWJlcihzKSxjPj4+PTAscz1uZXcgRGF0ZSgxZTMqcyksQltjPj4+Mj4+PjBdPXMuZ2V0U2Vjb25kcygpLEJbYys0Pj4+Mj4+PjBdPXMuZ2V0TWludXRlcygpLEJbYys4Pj4+Mj4+PjBdPXMuZ2V0SG91cnMoKSxCW2MrMTI+Pj4yPj4+MF09cy5nZXREYXRlKCksQltjKzE2Pj4+Mj4+PjBdPXMuZ2V0TW9udGgoKSxCW2MrMjA+Pj4yPj4+MF09cy5nZXRGdWxsWWVhcigpLTE5MDAsQltjKzI0Pj4+Mj4+PjBdPXMuZ2V0RGF5KCksQltjKzI4Pj4+Mj4+PjBdPShRZShzLmdldEZ1bGxZZWFyKCkpP2VuOnB0KVtzLmdldE1vbnRoKCldK3MuZ2V0RGF0ZSgpLTF8MCxCW2MrMzY+Pj4yPj4+MF09LSg2MCpzLmdldFRpbWV6b25lT2Zmc2V0KCkpO3ZhciBnPW5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksJD1uZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO0JbYyszMj4+PjI+Pj4wXT0oZyE9JCYmcy5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbigkLGcpKXwwfSxWOmZ1bmN0aW9uKHMpe3M+Pj49MDt2YXIgYz1uZXcgRGF0ZShCW3MrMjA+Pj4yPj4+MF0rMTkwMCxCW3MrMTY+Pj4yPj4+MF0sQltzKzEyPj4+Mj4+PjBdLEJbcys4Pj4+Mj4+PjBdLEJbcys0Pj4+Mj4+PjBdLEJbcz4+PjI+Pj4wXSwwKSxnPUJbcyszMj4+PjI+Pj4wXSwkPWMuZ2V0VGltZXpvbmVPZmZzZXQoKSxJPW5ldyBEYXRlKGMuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksRD1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEg9TWF0aC5taW4oRCxJKTtyZXR1cm4gMD5nP0JbcyszMj4+PjI+Pj4wXT0rKEkhPUQmJkg9PSQpOjA8ZyE9KEg9PSQpJiYoST1NYXRoLm1heChELEkpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGc/SDpJKS0kKSkpLEJbcysyND4+PjI+Pj4wXT1jLmdldERheSgpLEJbcysyOD4+PjI+Pj4wXT0oUWUoYy5nZXRGdWxsWWVhcigpKT9lbjpwdClbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsQltzPj4+Mj4+PjBdPWMuZ2V0U2Vjb25kcygpLEJbcys0Pj4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLEJbcys4Pj4+Mj4+PjBdPWMuZ2V0SG91cnMoKSxCW3MrMTI+Pj4yPj4+MF09Yy5nZXREYXRlKCksQltzKzE2Pj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxCW3MrMjA+Pj4yPj4+MF09Yy5nZXRZZWFyKCkscz1jLmdldFRpbWUoKSxpc05hTihzKT8oQlt1bigpPj4+Mj4+PjBdPTYxLHM9LTEpOnMvPTFlMyxCaWdJbnQocyl9LFI6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LFM6ZnVuY3Rpb24oKXt9LEs6ZnVuY3Rpb24ocyxjLGcpe2Z1bmN0aW9uICQocSl7cmV0dXJuKHE9cS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFxcXCgoW0EtWmEteiBdKylcXFxcKSQvKSk/cVsxXTpcIkdNVFwifWc+Pj49MDt2YXIgST1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksRD1uZXcgRGF0ZShJLDAsMSksSD1uZXcgRGF0ZShJLDYsMSk7ST1ELmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIFg9SC5nZXRUaW1lem9uZU9mZnNldCgpO3RlW3M+Pj4wPj4+Mj4+PjBdPTYwKk1hdGgubWF4KEksWCksQltjPj4+MD4+PjI+Pj4wXT0rKEkhPVgpLHM9JChEKSxjPSQoSCkscz1QcihzKSxjPVByKGMpLFg8ST8odGVbZz4+PjI+Pj4wXT1zLHRlW2crND4+PjI+Pj4wXT1jKToodGVbZz4+PjI+Pj4wXT1jLHRlW2crND4+PjI+Pj4wXT1zKX0sdjooKT0+e0dlKFwiXCIpfSxmOmZ1bmN0aW9uKHMsYyxnKXtyZXR1cm4gcz4+Pj0wLGM9ZXQoYz4+PjAsZz4+PjApLFR0W3NdLmFwcGx5KG51bGwsYyl9LEk6ZnVuY3Rpb24ocyxjLGcpe3JldHVybiBzPj4+PTAsYz1ldChjPj4+MCxnPj4+MCksVHRbc10uYXBwbHkobnVsbCxjKX0sRTooKT0+RGF0ZS5ub3coKSxMOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LHE6KCk9PnBlcmZvcm1hbmNlLm5vdygpLEo6ZnVuY3Rpb24ocyl7cz4+Pj0wO3ZhciBjPU4ubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8cylyZXR1cm4hMTtmb3IodmFyIGc9MTs0Pj1nO2cqPTIpe3ZhciAkPWMqKDErLjIvZyk7JD1NYXRoLm1pbigkLHMrMTAwNjYzMjk2KTt2YXIgST1NYXRoOyQ9TWF0aC5tYXgocywkKTtlOntJPShJLm1pbi5jYWxsKEksNDI5NDkwMTc2MCwkKyg2NTUzNi0kJTY1NTM2KSU2NTUzNiktRS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e0UuZ3JvdyhJKSxNZSgpO3ZhciBEPTE7YnJlYWsgZX1jYXRjaHt9RD12b2lkIDB9aWYoRClyZXR1cm4hMH1yZXR1cm4hMX0sWTpmdW5jdGlvbihzLGMpe3M+Pj49MCxjPj4+PTA7dmFyIGc9MDtyZXR1cm4gS2UoKS5mb3JFYWNoKCgkLEkpPT57dmFyIEQ9YytnO2ZvcihJPXRlW3MrNCpJPj4+Mj4+PjBdPUQsRD0wO0Q8JC5sZW5ndGg7KytEKU1bSSsrPj4+MD4+PjBdPSQuY2hhckNvZGVBdChEKTtNW0k+Pj4wPj4+MF09MCxnKz0kLmxlbmd0aCsxfSksMH0sWjpmdW5jdGlvbihzLGMpe3M+Pj49MCxjPj4+PTA7dmFyIGc9S2UoKTt0ZVtzPj4+Mj4+PjBdPWcubGVuZ3RoO3ZhciAkPTA7cmV0dXJuIGcuZm9yRWFjaChJPT4kKz1JLmxlbmd0aCsxKSx0ZVtjPj4+Mj4+PjBdPSQsMH0seTooKT0+NTIsQzpmdW5jdGlvbigpe3JldHVybiA1Mn0sWDpmdW5jdGlvbigpe3JldHVybiA3MH0sQjpmdW5jdGlvbihzLGMsZywkKXtjPj4+PTAsZz4+Pj0wLCQ+Pj49MDtmb3IodmFyIEk9MCxEPTA7RDxnO0QrKyl7dmFyIEg9dGVbYz4+PjI+Pj4wXSxYPXRlW2MrND4+PjI+Pj4wXTtjKz04O2Zvcih2YXIgcT0wO3E8WDtxKyspe3ZhciBqPU5bSCtxPj4+MF0sbmU9dG5bc107aj09PTB8fGo9PT0xMD8oKHM9PT0xP0M6UykoQnQobmUsMCkpLG5lLmxlbmd0aD0wKTpuZS5wdXNoKGopfUkrPVh9cmV0dXJuIHRlWyQ+Pj4yPj4+MF09SSwwfSxlYTphbixwOmZ1bmN0aW9uKHMsYyxnLCQpe3JldHVybiBhbihzPj4+MCxjPj4+MCxnPj4+MCwkPj4+MCl9fSx1ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHMoZyl7cmV0dXJuIHVlPWcuZXhwb3J0cyx1ZT1xcigpLHVlPWRuKCksRT11ZS5qYSxNZSgpLHllLnVuc2hpZnQodWUua2EpLHdlLS0sd2U9PTAmJih6ZSE9PW51bGwmJihjbGVhckludGVydmFsKHplKSx6ZT1udWxsKSxSZSYmKGc9UmUsUmU9bnVsbCxnKCkpKSx1ZX12YXIgYz17YTpqbn07aWYod2UrKyxyLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHIuaW5zdGFudGlhdGVXYXNtKGMscyl9Y2F0Y2goZyl7UyhgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtnfWApLGkoZyl9cmV0dXJuIEl0KGMsZnVuY3Rpb24oZyl7cyhnLmluc3RhbmNlKX0pLmNhdGNoKGkpLHt9fSgpO3IuX09ydEluaXQ9KHMsYyk9PihyLl9PcnRJbml0PXVlLmxhKShzLGMpLHIuX09ydEdldExhc3RFcnJvcj0ocyxjKT0+KHIuX09ydEdldExhc3RFcnJvcj11ZS5tYSkocyxjKSxyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0ocyxjLGcsJCxJLEQsSCxYLHEsaik9PihyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz11ZS5uYSkocyxjLGcsJCxJLEQsSCxYLHEsaiksci5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KHMsYyk9PihyLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj11ZS5vYSkocyxjKSxyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KHMsYyxnKT0+KHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT11ZS5wYSkocyxjLGcpLHIuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0ocyxjLGcpPT4oci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PXVlLnFhKShzLGMsZyksci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXM9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9dWUucmEpKHMpLHIuX09ydENyZWF0ZVNlc3Npb249KHMsYyxnKT0+KHIuX09ydENyZWF0ZVNlc3Npb249dWUuc2EpKHMsYyxnKSxyLl9PcnRSZWxlYXNlU2Vzc2lvbj1zPT4oci5fT3J0UmVsZWFzZVNlc3Npb249dWUudGEpKHMpLHIuX09ydEdldElucHV0T3V0cHV0Q291bnQ9KHMsYyxnKT0+KHIuX09ydEdldElucHV0T3V0cHV0Q291bnQ9dWUudWEpKHMsYyxnKSxyLl9PcnRHZXRJbnB1dE5hbWU9KHMsYyk9PihyLl9PcnRHZXRJbnB1dE5hbWU9dWUudmEpKHMsYyksci5fT3J0R2V0T3V0cHV0TmFtZT0ocyxjKT0+KHIuX09ydEdldE91dHB1dE5hbWU9dWUud2EpKHMsYyksci5fT3J0RnJlZT1zPT4oci5fT3J0RnJlZT11ZS54YSkocyksci5fT3J0Q3JlYXRlVGVuc29yPShzLGMsZywkLEksRCk9PihyLl9PcnRDcmVhdGVUZW5zb3I9dWUueWEpKHMsYyxnLCQsSSxEKSxyLl9PcnRHZXRUZW5zb3JEYXRhPShzLGMsZywkLEkpPT4oci5fT3J0R2V0VGVuc29yRGF0YT11ZS56YSkocyxjLGcsJCxJKSxyLl9PcnRSZWxlYXNlVGVuc29yPXM9PihyLl9PcnRSZWxlYXNlVGVuc29yPXVlLkFhKShzKSxyLl9PcnRDcmVhdGVSdW5PcHRpb25zPShzLGMsZywkKT0+KHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9dWUuQmEpKHMsYyxnLCQpLHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShzLGMsZyk9PihyLl9PcnRBZGRSdW5Db25maWdFbnRyeT11ZS5DYSkocyxjLGcpLHIuX09ydFJlbGVhc2VSdW5PcHRpb25zPXM9PihyLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz11ZS5EYSkocyksci5fT3J0Q3JlYXRlQmluZGluZz1zPT4oci5fT3J0Q3JlYXRlQmluZGluZz11ZS5FYSkocyksci5fT3J0QmluZElucHV0PShzLGMsZyk9PihyLl9PcnRCaW5kSW5wdXQ9dWUuRmEpKHMsYyxnKSxyLl9PcnRCaW5kT3V0cHV0PShzLGMsZywkKT0+KHIuX09ydEJpbmRPdXRwdXQ9dWUuR2EpKHMsYyxnLCQpLHIuX09ydENsZWFyQm91bmRPdXRwdXRzPXM9PihyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz11ZS5IYSkocyksci5fT3J0UmVsZWFzZUJpbmRpbmc9cz0+KHIuX09ydFJlbGVhc2VCaW5kaW5nPXVlLklhKShzKSxyLl9PcnRSdW5XaXRoQmluZGluZz0ocyxjLGcsJCxJKT0+KHIuX09ydFJ1bldpdGhCaW5kaW5nPXVlLkphKShzLGMsZywkLEkpLHIuX09ydFJ1bj0ocyxjLGcsJCxJLEQsSCxYKT0+KHIuX09ydFJ1bj11ZS5LYSkocyxjLGcsJCxJLEQsSCxYKSxyLl9PcnRFbmRQcm9maWxpbmc9cz0+KHIuX09ydEVuZFByb2ZpbGluZz11ZS5MYSkocyksci5fSnNlcE91dHB1dD0ocyxjLGcpPT4oci5fSnNlcE91dHB1dD11ZS5NYSkocyxjLGcpLHIuX0pzZXBHZXROb2RlTmFtZT1zPT4oci5fSnNlcEdldE5vZGVOYW1lPXVlLk5hKShzKTt2YXIgdW49KCk9Pih1bj11ZS5PYSkoKSxNdD1yLl9tYWxsb2M9cz0+KE10PXIuX21hbGxvYz11ZS5QYSkocyksYXQ9ci5fZnJlZT1zPT4oYXQ9ci5fZnJlZT11ZS5RYSkocyksRnQ9cz0+KEZ0PXVlLlJhKShzKSxhcj0oKT0+KGFyPXVlLlRhKSgpLHNyPXM9Pihzcj11ZS5VYSkocyksT3I9cz0+KE9yPXVlLlZhKShzKSxqdD1zPT4oanQ9dWUuWGEpKHMpLGxuPSgpPT4obG49dWUuWWEpKCksZnQ9cz0+KGZ0PXVlLlphKShzKSxkdD0oKT0+KGR0PXVlLl9hKSgpO3IuX19fc3RhcnRfZW1fanM9OTU3MjkxLHIuX19fc3RvcF9lbV9qcz05NTc0NTI7ZnVuY3Rpb24gZG4oKXt2YXIgcz11ZTtzPU9iamVjdC5hc3NpZ24oe30scyk7dmFyIGM9JD0+KCk9PiQoKT4+PjAsZz0kPT5JPT4kKEkpPj4+MDtyZXR1cm4gcy5PYT1jKHMuT2EpLHMuUGE9ZyhzLlBhKSxzLlJhPWcocy5SYSkscy5UYT1jKHMuVGEpLHMuVmE9ZyhzLlZhKSxzfXIuc3RhY2tBbGxvYz1PcixyLnN0YWNrU2F2ZT1hcixyLnN0YWNrUmVzdG9yZT1zcixyLlVURjhUb1N0cmluZz1GZSxyLnN0cmluZ1RvVVRGOD0ocyxjLGcpPT5idChzLE4sYyxnKSxyLmxlbmd0aEJ5dGVzVVRGOD1FdDt2YXIgUHQ7UmU9ZnVuY3Rpb24gcygpe1B0fHxrcigpLFB0fHwoUmU9cyl9O2Z1bmN0aW9uIGtyKCl7aWYoISgwPHdlKSl7aWYoci5wcmVSdW4pZm9yKHR5cGVvZiByLnByZVJ1bj09XCJmdW5jdGlvblwiJiYoci5wcmVSdW49W3IucHJlUnVuXSk7ci5wcmVSdW4ubGVuZ3RoOyl7dmFyIHM9ci5wcmVSdW4uc2hpZnQoKTtwZS51bnNoaWZ0KHMpfWZvcig7MDxwZS5sZW5ndGg7KXBlLnNoaWZ0KCkocik7aWYoISgwPHdlfHxQdHx8KFB0PSEwLHIuY2FsbGVkUnVuPSEwLE8pKSl7Zm9yKDswPHllLmxlbmd0aDspeWUuc2hpZnQoKShyKTtmb3IobyhyKTswPGRlLmxlbmd0aDspZGUuc2hpZnQoKShyKX19fXJldHVybiBrcigpLHQucmVhZHl9fSkoKTt0eXBlb2Ygd2k9PVwib2JqZWN0XCImJnR5cGVvZiBpbz09XCJvYmplY3RcIj9pby5leHBvcnRzPWJpOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCYmZGVmaW5lKFtdLCgpPT5iaSl9KTt2YXIgJGk9QnIoKCk9Pnt9KTt2YXIgX2k9QnIoKCk9Pnt9KTt2YXIgU2k9e307aG4oU2kse2NwdXM6KCk9PlZsfSk7dmFyIFZsLHhpPVEoKCk9PntWbD12b2lkIDB9KTt2YXIgSWk9QnIoKEFpLGFvKT0+e1widXNlIHN0cmljdFwiO3ZhciBDaT0oKCk9Pnt2YXIgZT10eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZTxcInVcIiYmKGU9ZXx8X19maWxlbmFtZSksZnVuY3Rpb24odD17fSl7ZnVuY3Rpb24gcigpe3JldHVybiBiZS5idWZmZXIhPWRlLmJ1ZmZlciYma2UoKSxkZX1mdW5jdGlvbiBvKCl7cmV0dXJuIGJlLmJ1ZmZlciE9ZGUuYnVmZmVyJiZrZSgpLHdlfWZ1bmN0aW9uIGkoKXtyZXR1cm4gYmUuYnVmZmVyIT1kZS5idWZmZXImJmtlKCksemV9ZnVuY3Rpb24gdSgpe3JldHVybiBiZS5idWZmZXIhPWRlLmJ1ZmZlciYma2UoKSxSZX1mdW5jdGlvbiBhKCl7cmV0dXJuIGJlLmJ1ZmZlciE9ZGUuYnVmZmVyJiZrZSgpLEdlfWZ1bmN0aW9uIHAoKXtyZXR1cm4gYmUuYnVmZmVyIT1kZS5idWZmZXImJmtlKCksRn1mdW5jdGlvbiBtKCl7cmV0dXJuIGJlLmJ1ZmZlciE9ZGUuYnVmZmVyJiZrZSgpLGllfWZ1bmN0aW9uIGgoKXtyZXR1cm4gYmUuYnVmZmVyIT1kZS5idWZmZXImJmtlKCksbnR9dmFyIGQ9dCx5LHc7ZC5yZWFkeT1uZXcgUHJvbWlzZSgobixsKT0+e3k9bix3PWx9KSxkLm1vdW50RXh0ZXJuYWxEYXRhPShuLGwpPT57KGQuRmJ8fChkLkZiPW5ldyBNYXApKS5zZXQobixsKX0sZC51bm1vdW50RXh0ZXJuYWxEYXRhPSgpPT57ZGVsZXRlIGQuRmJ9LGQuanNlcEluaXQ9KG4sbCxmLGIsQSxQLHosTCk9PntkLnJjPW4sZC4kYj1sLGQuYmM9ZixkLk9iPWIsZC5hYz1BLGQuZWI9UCxkLmNjPXosZC5kYz1MLGw9KFosSyxvZSk9PiguLi5nZSk9PntsZXQgU2U9ZHQsUj1LPy4oKTtnZT1aKC4uLmdlKTtsZXQgbGU9Sz8uKCk7cmV0dXJuIFIhPT1sZSYmKFo9bGUsb2UoUiksSz1vZT1udWxsKSxkdCE9U2U/SSgpOmdlfSxmPVo9PmFzeW5jKC4uLkspPT57dHJ5e2lmKGQuRWIpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIGFscmVhZHkgc3RhcnRlZFwiKTtsZXQgb2U9ZC5FYj17ZmM6S1swXSxlcnJvcnM6W119LGdlPWF3YWl0IFooLi4uSyk7aWYoZC5FYiE9PW9lKXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTtuLmZsdXNoKCk7bGV0IFNlPW9lLmVycm9ycztpZigwPFNlLmxlbmd0aCl7bGV0IFI9YXdhaXQgUHJvbWlzZS5hbGwoU2UpO2lmKFI9Ui5maWx0ZXIobGU9PmxlKSwwPFIubGVuZ3RoKXRocm93IEVycm9yKFIuam9pbihgXFxuYCkpfXJldHVybiBnZX1maW5hbGx5e2QuRWI9bnVsbH19LGQuX09ydENyZWF0ZVNlc3Npb249bChkLl9PcnRDcmVhdGVTZXNzaW9uLCgpPT5kLl9PcnRDcmVhdGVTZXNzaW9uLFo9PmQuX09ydENyZWF0ZVNlc3Npb249WiksZC5fT3J0UnVuPWYobChkLl9PcnRSdW4sKCk9PmQuX09ydFJ1bixaPT5kLl9PcnRSdW49WikpLGQuX09ydFJ1bldpdGhCaW5kaW5nPWYobChkLl9PcnRSdW5XaXRoQmluZGluZywoKT0+ZC5fT3J0UnVuV2l0aEJpbmRpbmcsWj0+ZC5fT3J0UnVuV2l0aEJpbmRpbmc9WikpLGQuX09ydEJpbmRJbnB1dD1sKGQuX09ydEJpbmRJbnB1dCwoKT0+ZC5fT3J0QmluZElucHV0LFo9PmQuX09ydEJpbmRJbnB1dD1aKSxkLmpzZXBSZWdpc3RlckJ1ZmZlcj0oWixLLG9lLGdlKT0+bi5yZWdpc3RlckJ1ZmZlcihaLEssb2UsZ2UpLGQuanNlcFVucmVnaXN0ZXJCdWZmZXJzPVo9PntuLnVucmVnaXN0ZXJCdWZmZXJzKFopfSxkLmpzZXBHZXRCdWZmZXI9Wj0+bi5nZXRCdWZmZXIoWiksZC5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oWixLLG9lKT0+bi5jcmVhdGVEb3dubG9hZGVyKFosSyxvZSksZC5qc2VwT25SdW5TdGFydD0oKT0+bi5vblJ1blN0YXJ0KCl9O3ZhciBfPU9iamVjdC5hc3NpZ24oe30sZCksdj1cIi4vdGhpcy5wcm9ncmFtXCIseD0obixsKT0+e3Rocm93IGx9LFQ9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIixDPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsUz10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIsRT1kLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLE89XCJcIjtmdW5jdGlvbiBVKG4pe3JldHVybiBkLmxvY2F0ZUZpbGU/ZC5sb2NhdGVGaWxlKG4sTyk6TytufXZhciBNLE4sWTtpZihTKXt2YXIgc2U9KHJvKCksdXIodG8pKSxCPShvbygpLHVyKG5vKSk7Tz1DP0IuZGlybmFtZShPKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsTT0obCxmKT0+KGw9RXQobCk/bmV3IFVSTChsKTpCLm5vcm1hbGl6ZShsKSxzZS5yZWFkRmlsZVN5bmMobCxmP3ZvaWQgMDpcInV0ZjhcIikpLFk9bD0+KGw9TShsLCEwKSxsLmJ1ZmZlcnx8KGw9bmV3IFVpbnQ4QXJyYXkobCkpLGwpLE49KGwsZixiLEE9ITApPT57bD1FdChsKT9uZXcgVVJMKGwpOkIubm9ybWFsaXplKGwpLHNlLnJlYWRGaWxlKGwsQT92b2lkIDA6XCJ1dGY4XCIsKFAseik9PntQP2IoUCk6ZihBP3ouYnVmZmVyOnopfSl9LCFkLnRoaXNQcm9ncmFtJiYxPHByb2Nlc3MuYXJndi5sZW5ndGgmJih2PXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHg9KGwsZik9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWwsZn0sZC5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7bGV0IG47dHJ5e249JGkoKX1jYXRjaChsKXt0aHJvdyBjb25zb2xlLmVycm9yKFxcJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkP1xcJyksbH1nbG9iYWwuV29ya2VyPW4uV29ya2VyfWVsc2UoVHx8QykmJihDP089c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKE89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLHR5cGVvZiBlPFwidVwiJiZlJiYoTz1lKSxPLmluZGV4T2YoXCJibG9iOlwiKSE9PTA/Tz1PLnN1YnN0cigwLE8ucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6Tz1cIlwiLFN8fChNPW49Pnt2YXIgbD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGwub3BlbihcIkdFVFwiLG4sITEpLGwuc2VuZChudWxsKSxsLnJlc3BvbnNlVGV4dH0sQyYmKFk9bj0+e3ZhciBsPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gbC5vcGVuKFwiR0VUXCIsbiwhMSksbC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGwuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShsLnJlc3BvbnNlKX0pLE49KG4sbCxmKT0+e3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXCJHRVRcIixuLCEwKSxiLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsYi5vbmxvYWQ9KCk9PntiLnN0YXR1cz09MjAwfHxiLnN0YXR1cz09MCYmYi5yZXNwb25zZT9sKGIucmVzcG9uc2UpOmYoKX0sYi5vbmVycm9yPWYsYi5zZW5kKG51bGwpfSkpO1MmJnR5cGVvZiBwZXJmb3JtYW5jZT5cInVcIiYmKGdsb2JhbC5wZXJmb3JtYW5jZT1faSgpLnBlcmZvcm1hbmNlKTt2YXIgdGU9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxQZT1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7UyYmKHRlPSguLi5uKT0+c2Uud3JpdGVTeW5jKDEsbi5qb2luKFwiIFwiKStgXFxuYCksUGU9KC4uLm4pPT5zZS53cml0ZVN5bmMoMixuLmpvaW4oXCIgXCIpK2BcXG5gKSk7dmFyIEVlPXRlLGVlPVBlO09iamVjdC5hc3NpZ24oZCxfKSxfPW51bGwsdHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZCdChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIGJlLE1lLHBlPSExLHllLGRlLHdlLHplLFJlLEdlLEYsaWUsaGUsWGUsbnQ7ZnVuY3Rpb24ga2UoKXt2YXIgbj1iZS5idWZmZXI7ZC5IRUFQOD1kZT1uZXcgSW50OEFycmF5KG4pLGQuSEVBUDE2PXplPW5ldyBJbnQxNkFycmF5KG4pLGQuSEVBUFU4PXdlPW5ldyBVaW50OEFycmF5KG4pLGQuSEVBUFUxNj1SZT1uZXcgVWludDE2QXJyYXkobiksZC5IRUFQMzI9R2U9bmV3IEludDMyQXJyYXkobiksZC5IRUFQVTMyPUY9bmV3IFVpbnQzMkFycmF5KG4pLGQuSEVBUEYzMj1pZT1uZXcgRmxvYXQzMkFycmF5KG4pLGQuSEVBUEY2ND1udD1uZXcgRmxvYXQ2NEFycmF5KG4pLGQuSEVBUDY0PWhlPW5ldyBCaWdJbnQ2NEFycmF5KG4pLGQuSEVBUFU2ND1YZT1uZXcgQmlnVWludDY0QXJyYXkobil9dmFyIExlPTE2Nzc3MjE2O2lmKEUpYmU9ZC53YXNtTWVtb3J5O2Vsc2UgaWYoZC53YXNtTWVtb3J5KWJlPWQud2FzbU1lbW9yeTtlbHNlIGlmKGJlPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6TGUvNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSwhKGJlLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBlZShcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxTJiZlZShcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kL29yIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7a2UoKSxMZT1iZS5idWZmZXIuYnl0ZUxlbmd0aDt2YXIgSXQ9W10sVHQ9W10sVnQ9W10sUnQ9MCxKdD1udWxsLFd0PW51bGw7ZnVuY3Rpb24gbXIoKXtpZihSdC0tLFJ0PT0wJiYoSnQhPT1udWxsJiYoY2xlYXJJbnRlcnZhbChKdCksSnQ9bnVsbCksV3QpKXt2YXIgbj1XdDtXdD1udWxsLG4oKX19ZnVuY3Rpb24gQnQobil7dGhyb3cgbj1cIkFib3J0ZWQoXCIrbitcIilcIixlZShuKSxwZT0hMCx5ZT0xLG49bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihuK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSx3KG4pLG59dmFyIEZlPW49Pm4uc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIiksRXQ9bj0+bi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSxidDtidD1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiLEZlKGJ0KXx8KGJ0PVUoYnQpKTtmdW5jdGlvbiBmcihuKXtpZihZKXJldHVybiBZKG4pO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIEdyKG4pe2lmKFR8fEMpe2lmKHR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiYhRXQobikpcmV0dXJuIGZldGNoKG4se2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4obD0+e2lmKCFsLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK24rXCJcXCdcIjtyZXR1cm4gbC5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goKCk9PmZyKG4pKTtpZihOKXJldHVybiBuZXcgUHJvbWlzZSgobCxmKT0+e04obixiPT5sKG5ldyBVaW50OEFycmF5KGIpKSxmKX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5mcihuKSl9ZnVuY3Rpb24gb3QobixsLGYpe3JldHVybiBHcihuKS50aGVuKGI9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGIsbCkpLnRoZW4oYj0+YikudGhlbihmLGI9PntlZShgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtifWApLEJ0KGIpfSl9ZnVuY3Rpb24gaHIobixsKXt2YXIgZj1idDtyZXR1cm4gdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nIT1cImZ1bmN0aW9uXCJ8fEZlKGYpfHxFdChmKXx8U3x8dHlwZW9mIGZldGNoIT1cImZ1bmN0aW9uXCI/b3QoZixuLGwpOmZldGNoKGYse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oYj0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoYixuKS50aGVuKGwsZnVuY3Rpb24oQSl7cmV0dXJuIGVlKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtBfWApLGVlKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksb3QoZixuLGwpfSkpfXZhciBOdD17OTQ2NzQ4OihuLGwsZixiKT0+e2lmKHR5cGVvZiBkPlwidVwifHwhZC5GYilyZXR1cm4gMTtpZihuPU9lKG4+Pj4wKSxuLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKG49bi5zdWJzdHJpbmcoMikpLG49ZC5GYi5nZXQobiksIW4pcmV0dXJuIDI7aWYobD4+Pj0wLGY+Pj49MCxiPj4+PTAsbCtmPm4uYnl0ZUxlbmd0aClyZXR1cm4gMzt0cnl7cmV0dXJuIG8oKS5zZXQobi5zdWJhcnJheShsLGwrZiksYj4+PjApLDB9Y2F0Y2h7cmV0dXJuIDR9fSw5NDcyNDk6bj0+ZC4kYihuKSw5NDcyODI6bj0+ZC5iYyhuKSw5NDczMTQ6KG4sbCxmKT0+e2QuT2IobixsLGYsITApfSw5NDczNTM6KG4sbCxmKT0+e2QuT2IobixsLGYpfSw5NDczODY6bj0+e2QuZWIoXCJBYnNcIixuLHZvaWQgMCl9LDk0NzQzNzpuPT57ZC5lYihcIk5lZ1wiLG4sdm9pZCAwKX0sOTQ3NDg4Om49PntkLmViKFwiRmxvb3JcIixuLHZvaWQgMCl9LDk0NzU0MTpuPT57ZC5lYihcIkNlaWxcIixuLHZvaWQgMCl9LDk0NzU5MzpuPT57ZC5lYihcIlJlY2lwcm9jYWxcIixuLHZvaWQgMCl9LDk0NzY1MTpuPT57ZC5lYihcIlNxcnRcIixuLHZvaWQgMCl9LDk0NzcwMzpuPT57ZC5lYihcIkV4cFwiLG4sdm9pZCAwKX0sOTQ3NzU0Om49PntkLmViKFwiRXJmXCIsbix2b2lkIDApfSw5NDc4MDU6bj0+e2QuZWIoXCJTaWdtb2lkXCIsbix2b2lkIDApfSw5NDc4NjA6KG4sbCxmKT0+e2QuZWIoXCJIYXJkU2lnbW9pZFwiLG4se2FscGhhOmwsYmV0YTpmfSl9LDk0NzkzOTpuPT57ZC5lYihcIkxvZ1wiLG4sdm9pZCAwKX0sOTQ3OTkwOm49PntkLmViKFwiU2luXCIsbix2b2lkIDApfSw5NDgwNDE6bj0+e2QuZWIoXCJDb3NcIixuLHZvaWQgMCl9LDk0ODA5MjpuPT57ZC5lYihcIlRhblwiLG4sdm9pZCAwKX0sOTQ4MTQzOm49PntkLmViKFwiQXNpblwiLG4sdm9pZCAwKX0sOTQ4MTk1Om49PntkLmViKFwiQWNvc1wiLG4sdm9pZCAwKX0sOTQ4MjQ3Om49PntkLmViKFwiQXRhblwiLG4sdm9pZCAwKX0sOTQ4Mjk5Om49PntkLmViKFwiU2luaFwiLG4sdm9pZCAwKX0sOTQ4MzUxOm49PntkLmViKFwiQ29zaFwiLG4sdm9pZCAwKX0sOTQ4NDAzOm49PntkLmViKFwiQXNpbmhcIixuLHZvaWQgMCl9LDk0ODQ1NjpuPT57ZC5lYihcIkFjb3NoXCIsbix2b2lkIDApfSw5NDg1MDk6bj0+e2QuZWIoXCJBdGFuaFwiLG4sdm9pZCAwKX0sOTQ4NTYyOm49PntkLmViKFwiVGFuaFwiLG4sdm9pZCAwKX0sOTQ4NjE0Om49PntkLmViKFwiTm90XCIsbix2b2lkIDApfSw5NDg2NjU6KG4sbCxmKT0+e2QuZWIoXCJDbGlwXCIsbix7bWluOmwsbWF4OmZ9KX0sOTQ4NzM0Om49PntkLmViKFwiQ2xpcFwiLG4sdm9pZCAwKX0sOTQ4Nzg2OihuLGwpPT57ZC5lYihcIkVsdVwiLG4se2FscGhhOmx9KX0sOTQ4ODQ0Om49PntkLmViKFwiUmVsdVwiLG4sdm9pZCAwKX0sOTQ4ODk2OihuLGwpPT57ZC5lYihcIkxlYWt5UmVsdVwiLG4se2FscGhhOmx9KX0sOTQ4OTYwOihuLGwpPT57ZC5lYihcIlRocmVzaG9sZGVkUmVsdVwiLG4se2FscGhhOmx9KX0sOTQ5MDMwOihuLGwpPT57ZC5lYihcIkNhc3RcIixuLHt0bzpsfSl9LDk0OTA4ODpuPT57ZC5lYihcIkFkZFwiLG4sdm9pZCAwKX0sOTQ5MTM5Om49PntkLmViKFwiU3ViXCIsbix2b2lkIDApfSw5NDkxOTA6bj0+e2QuZWIoXCJNdWxcIixuLHZvaWQgMCl9LDk0OTI0MTpuPT57ZC5lYihcIkRpdlwiLG4sdm9pZCAwKX0sOTQ5MjkyOm49PntkLmViKFwiUG93XCIsbix2b2lkIDApfSw5NDkzNDM6bj0+e2QuZWIoXCJFcXVhbFwiLG4sdm9pZCAwKX0sOTQ5Mzk2Om49PntkLmViKFwiR3JlYXRlclwiLG4sdm9pZCAwKX0sOTQ5NDUxOm49PntkLmViKFwiR3JlYXRlck9yRXF1YWxcIixuLHZvaWQgMCl9LDk0OTUxMzpuPT57ZC5lYihcIkxlc3NcIixuLHZvaWQgMCl9LDk0OTU2NTpuPT57ZC5lYihcIkxlc3NPckVxdWFsXCIsbix2b2lkIDApfSw5NDk2MjQ6KG4sbCxmLGIsQSk9PntkLmViKFwiUmVkdWNlTWVhblwiLG4se2tlZXBEaW1zOiEhbCxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KGI+Pj4wLEE+Pj4wKSk6W119KX0sOTQ5NzgzOihuLGwsZixiLEEpPT57ZC5lYihcIlJlZHVjZU1heFwiLG4se2tlZXBEaW1zOiEhbCxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KGI+Pj4wLEE+Pj4wKSk6W119KX0sOTQ5OTQxOihuLGwsZixiLEEpPT57ZC5lYihcIlJlZHVjZU1pblwiLG4se2tlZXBEaW1zOiEhbCxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KGI+Pj4wLEE+Pj4wKSk6W119KX0sOTUwMDk5OihuLGwsZixiLEEpPT57ZC5lYihcIlJlZHVjZVByb2RcIixuLHtrZWVwRGltczohIWwsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGEoKS5zdWJhcnJheShiPj4+MCxBPj4+MCkpOltdfSl9LDk1MDI1ODoobixsLGYsYixBKT0+e2QuZWIoXCJSZWR1Y2VTdW1cIixuLHtrZWVwRGltczohIWwsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGEoKS5zdWJhcnJheShiPj4+MCxBPj4+MCkpOltdfSl9LDk1MDQxNjoobixsLGYsYixBKT0+e2QuZWIoXCJSZWR1Y2VMMVwiLG4se2tlZXBEaW1zOiEhbCxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KGI+Pj4wLEE+Pj4wKSk6W119KX0sOTUwNTczOihuLGwsZixiLEEpPT57ZC5lYihcIlJlZHVjZUwyXCIsbix7a2VlcERpbXM6ISFsLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoYj4+PjAsQT4+PjApKTpbXX0pfSw5NTA3MzA6KG4sbCxmLGIsQSk9PntkLmViKFwiUmVkdWNlTG9nU3VtXCIsbix7a2VlcERpbXM6ISFsLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoYj4+PjAsQT4+PjApKTpbXX0pfSw5NTA4OTE6KG4sbCxmLGIsQSk9PntkLmViKFwiUmVkdWNlU3VtU3F1YXJlXCIsbix7a2VlcERpbXM6ISFsLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoYj4+PjAsQT4+PjApKTpbXX0pfSw5NTEwNTU6KG4sbCxmLGIsQSk9PntkLmViKFwiUmVkdWNlTG9nU3VtRXhwXCIsbix7a2VlcERpbXM6ISFsLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoYj4+PjAsQT4+PjApKTpbXX0pfSw5NTEyMTk6bj0+e2QuZWIoXCJXaGVyZVwiLG4sdm9pZCAwKX0sOTUxMjcyOihuLGwsZik9PntkLmViKFwiVHJhbnNwb3NlXCIsbix7cGVybTpsP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KGw+Pj4wLGY+Pj4wKSk6W119KX0sOTUxMzgwOihuLGwsZixiLEEsUCx6LEwsWixLLG9lLGdlLFNlLFIsbGUpPT57ZC5lYihcIkNvbnZUcmFuc3Bvc2VcIixuLHtmb3JtYXQ6Wj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmwsZGlsYXRpb25zOltmXSxncm91cDpiLGtlcm5lbF9zaGFwZTpbQV0scGFkczpbUCx6XSxzdHJpZGVzOltMXSx3SXNDb25zdDooKT0+ISFyKClbSz4+PjBdLG91dHB1dFBhZGRpbmc6b2U/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkob2U+Pj4wLGdlPj4+MCkpOltdLG91dHB1dFNoYXBlOlNlP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KFNlPj4+MCxSPj4+MCkpOltdLGFjdGl2YXRpb246T2UobGUpfSl9LDk1MTc4MjoobixsLGYsYixBLFAseixMLFosSyxvZSxnZSxTZSxSKT0+e2QuZWIoXCJDb252VHJhbnNwb3NlXCIsbix7Zm9ybWF0Okw/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpsLGRpbGF0aW9uczpBcnJheS5mcm9tKGEoKS5zdWJhcnJheShmPj4+MCwoZj4+PjApKzI+Pj4wKSksZ3JvdXA6YixrZXJuZWxTaGFwZTpBcnJheS5mcm9tKGEoKS5zdWJhcnJheShBPj4+MCwoQT4+PjApKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKGEoKS5zdWJhcnJheShQPj4+MCwoUD4+PjApKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKGEoKS5zdWJhcnJheSh6Pj4+MCwoej4+PjApKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcigpW1o+Pj4wXSxvdXRwdXRQYWRkaW5nOks/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoSz4+PjAsb2U+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Z2U/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoZ2U+Pj4wLFNlPj4+MCkpOltdLGFjdGl2YXRpb246T2UoUil9KX0sOTUyMzQ3OihuLGwsZixiLEEsUCx6LEwsWixLLG9lLGdlLFNlLFIsbGUpPT57ZC5lYihcIkNvbnZUcmFuc3Bvc2VcIixuLHtmb3JtYXQ6Wj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmwsZGlsYXRpb25zOltmXSxncm91cDpiLGtlcm5lbF9zaGFwZTpbQV0scGFkczpbUCx6XSxzdHJpZGVzOltMXSx3SXNDb25zdDooKT0+ISFyKClbSz4+PjBdLG91dHB1dFBhZGRpbmc6b2U/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkob2U+Pj4wLGdlPj4+MCkpOltdLG91dHB1dFNoYXBlOlNlP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KFNlPj4+MCxSPj4+MCkpOltdLGFjdGl2YXRpb246T2UobGUpfSl9LDk1Mjc0OToobixsLGYsYixBLFAseixMLFosSyxvZSxnZSxTZSxSKT0+e2QuZWIoXCJDb252VHJhbnNwb3NlXCIsbix7Zm9ybWF0Okw/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpsLGRpbGF0aW9uczpBcnJheS5mcm9tKGEoKS5zdWJhcnJheShmPj4+MCwoZj4+PjApKzI+Pj4wKSksZ3JvdXA6YixrZXJuZWxTaGFwZTpBcnJheS5mcm9tKGEoKS5zdWJhcnJheShBPj4+MCwoQT4+PjApKzI+Pj4wKSkscGFkczpBcnJheS5mcm9tKGEoKS5zdWJhcnJheShQPj4+MCwoUD4+PjApKzQ+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKGEoKS5zdWJhcnJheSh6Pj4+MCwoej4+PjApKzI+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhcigpW1o+Pj4wXSxvdXRwdXRQYWRkaW5nOks/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoSz4+PjAsb2U+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Z2U/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoZ2U+Pj4wLFNlPj4+MCkpOltdLGFjdGl2YXRpb246T2UoUil9KX0sOTUzMzE0OihuLGwpPT57ZC5lYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsbix7Zm9ybWF0Omw/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTUzNDA1OihuLGwsZixiLEEsUCx6LEwsWixLLG9lLGdlLFNlLFIsbGUsSWUpPT57ZC5lYihcIkF2ZXJhZ2VQb29sXCIsbix7Zm9ybWF0OkllP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmwsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOkEsZGlsYXRpb25zOltQLHpdLGtlcm5lbF9zaGFwZTpbTCxaXSxwYWRzOltLLG9lLGdlLFNlXSxzdHJpZGVzOltSLGxlXX0pfSw5NTM2ODk6KG4sbCk9PntkLmViKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixuLHtmb3JtYXQ6bD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTM3ODA6KG4sbCxmLGIsQSxQLHosTCxaLEssb2UsZ2UsU2UsUixsZSxJZSk9PntkLmViKFwiQXZlcmFnZVBvb2xcIixuLHtmb3JtYXQ6SWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6bCxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6QSxkaWxhdGlvbnM6W1Asel0sa2VybmVsX3NoYXBlOltMLFpdLHBhZHM6W0ssb2UsZ2UsU2VdLHN0cmlkZXM6W1IsbGVdfSl9LDk1NDA2NDoobixsKT0+e2QuZWIoXCJHbG9iYWxNYXhQb29sXCIsbix7Zm9ybWF0Omw/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTU0MTUxOihuLGwsZixiLEEsUCx6LEwsWixLLG9lLGdlLFNlLFIsbGUsSWUpPT57ZC5lYihcIk1heFBvb2xcIixuLHtmb3JtYXQ6SWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6bCxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6QSxkaWxhdGlvbnM6W1Asel0sa2VybmVsX3NoYXBlOltMLFpdLHBhZHM6W0ssb2UsZ2UsU2VdLHN0cmlkZXM6W1IsbGVdfSl9LDk1NDQzMToobixsKT0+e2QuZWIoXCJHbG9iYWxNYXhQb29sXCIsbix7Zm9ybWF0Omw/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTU0NTE4OihuLGwsZixiLEEsUCx6LEwsWixLLG9lLGdlLFNlLFIsbGUsSWUpPT57ZC5lYihcIk1heFBvb2xcIixuLHtmb3JtYXQ6SWU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6bCxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6QSxkaWxhdGlvbnM6W1Asel0sa2VybmVsX3NoYXBlOltMLFpdLHBhZHM6W0ssb2UsZ2UsU2VdLHN0cmlkZXM6W1IsbGVdfSl9LDk1NDc5ODoobixsLGYsYixBKT0+e2QuZWIoXCJHZW1tXCIsbix7YWxwaGE6bCxiZXRhOmYsdHJhbnNBOmIsdHJhbnNCOkF9KX0sOTU0OTAyOm49PntkLmViKFwiTWF0TXVsXCIsbix2b2lkIDApfSw5NTQ5NTY6KG4sbCxmLGIpPT57ZC5lYihcIkFyZ01heFwiLG4se2tlZXBEaW1zOiEhbCxzZWxlY3RMYXN0SW5kZXg6ISFmLGF4aXM6Yn0pfSw5NTUwNjQ6KG4sbCxmLGIpPT57ZC5lYihcIkFyZ01pblwiLG4se2tlZXBEaW1zOiEhbCxzZWxlY3RMYXN0SW5kZXg6ISFmLGF4aXM6Yn0pfSw5NTUxNzI6KG4sbCk9PntkLmViKFwiU29mdG1heFwiLG4se2F4aXM6bH0pfSw5NTUyMzU6KG4sbCk9PntkLmViKFwiQ29uY2F0XCIsbix7YXhpczpsfSl9LDk1NTI5NToobixsLGYsYixBKT0+e2QuZWIoXCJTcGxpdFwiLG4se2F4aXM6bCxudW1PdXRwdXRzOmYsc3BsaXRTaXplczpiP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KGI+Pj4wLEE+Pj4wKSk6W119KX0sOTU1NDM1Om49PntkLmViKFwiRXhwYW5kXCIsbix2b2lkIDApfSw5NTU0ODk6KG4sbCk9PntkLmViKFwiR2F0aGVyXCIsbix7YXhpczpOdW1iZXIobCl9KX0sOTU1NTYwOihuLGwpPT57ZC5lYihcIkdhdGhlckVsZW1lbnRzXCIsbix7YXhpczpOdW1iZXIobCl9KX0sOTU1NjM5OihuLGwsZixiLEEsUCx6LEwsWixLLG9lKT0+e2QuZWIoXCJSZXNpemVcIixuLHthbnRpYWxpYXM6bCxheGVzOmY/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoZj4+PjAsYj4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpPZShBKSxjdWJpY0NvZWZmQTpQLGV4Y2x1ZGVPdXRzaWRlOnosZXh0cmFwb2xhdGlvblZhbHVlOkwsa2VlcEFzcGVjdFJhdGlvUG9saWN5Ok9lKFopLG1vZGU6T2UoSyksbmVhcmVzdE1vZGU6T2Uob2UpfSl9LDk1NTk4NToobixsLGYsYixBLFAseik9PntkLmViKFwiU2xpY2VcIixuLHtzdGFydHM6bD9BcnJheS5mcm9tKGEoKS5zdWJhcnJheShsPj4+MCxmPj4+MCkpOltdLGVuZHM6Yj9BcnJheS5mcm9tKGEoKS5zdWJhcnJheShiPj4+MCxBPj4+MCkpOltdLGF4ZXM6UD9BcnJheS5mcm9tKGEoKS5zdWJhcnJheShQPj4+MCx6Pj4+MCkpOltdfSl9LDk1NjIwMTpuPT57ZC5lYihcIlRpbGVcIixuLHZvaWQgMCl9LDk1NjI1MzoobixsLGYpPT57ZC5lYihcIkxheWVyTm9ybWFsaXphdGlvblwiLG4se2F4aXM6TnVtYmVyKGwpLGVwc2lsb246TnVtYmVyKGYpfSl9LDk1NjM2MDoobixsLGYpPT57ZC5lYihcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLG4se2Vwc2lsb246bCxmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTY0NzQ6KG4sbCxmKT0+e2QuZWIoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixuLHtlcHNpbG9uOmwsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTU2NTg4Om49PntkLmViKFwiUmFuZ2VcIixuLHZvaWQgMCl9LDk1NjY0MToobixsKT0+e2QuZWIoXCJFaW5zdW1cIixuLHtlcXVhdGlvbjpPZShsKX0pfSw5NTY3MjI6KG4sbCxmLGIsQSk9PntkLmViKFwiUGFkXCIsbix7bW9kZTpsLHZhbHVlOmYscGFkczpiP0FycmF5LmZyb20oYSgpLnN1YmFycmF5KGI+Pj4wLEE+Pj4wKSk6W119KX0sOTU2ODQ5OihuLGwsZixiLEEsUCk9PntkLmViKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsbix7ZXBzaWxvbjpsLG1vbWVudHVtOmYsc3BhdGlhbDohIUEsdHJhaW5pbmdNb2RlOiEhYixmb3JtYXQ6UD9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5NTcwMTg6KG4sbCxmLGIsQSxQKT0+e2QuZWIoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixuLHtlcHNpbG9uOmwsbW9tZW50dW06ZixzcGF0aWFsOiEhQSx0cmFpbmluZ01vZGU6ISFiLGZvcm1hdDpQP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDk1NzE4NzoobixsLGYpPT57ZC5lYihcIkN1bVN1bVwiLG4se2V4Y2x1c2l2ZTpOdW1iZXIobCkscmV2ZXJzZTpOdW1iZXIoZil9KX0sOTU3Mjg0OihuLGwsZixiLEEsUCx6LEwsWik9PntkLmViKFwiQXR0ZW50aW9uXCIsbix7bnVtSGVhZHM6bCxpc1VuaWRpcmVjdGlvbmFsOmYsbWFza0ZpbHRlclZhbHVlOmIsc2NhbGU6QSxkb1JvdGFyeTpQLHFrdkhpZGRlblNpemVzOno/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIoTCkrej4+PjApKTpbXSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiEhWn0pfSw5NTc1NTY6bj0+e2QuZWIoXCJHZWx1XCIsbix2b2lkIDApfSw5NTc2MDg6KG4sbCxmLGIsQSxQKT0+e2QuZWIoXCJNdWx0aUhlYWRBdHRlbnRpb25cIixuLHtudW1IZWFkczpsLGlzVW5pZGlyZWN0aW9uYWw6ZixtYXNrRmlsdGVyVmFsdWU6YixzY2FsZTpBLGRvUm90YXJ5OlB9KX0sOTU3NzY3Om49PntkLmViKFwiQmlhc0FkZFwiLG4sdm9pZCAwKX0sOTU3ODIyOm49PntkLmViKFwiQmlhc1NwbGl0R2VsdVwiLG4sdm9pZCAwKX0sOTU3ODgzOihuLGwpPT57ZC5lYihcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixuLHtlcHNpbG9uOmx9KX0sOTU3OTY0OihuLGwsZixiLEEsUCx6LEwsWixLLG9lLGdlLFNlKT0+e2QuZWIoXCJDb252XCIsbix7Zm9ybWF0Olo/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6bCxkaWxhdGlvbnM6W2ZdLGdyb3VwOmIsa2VybmVsX3NoYXBlOltBXSxwYWRzOlA/QXJyYXkuZnJvbShhKCkuc3ViYXJyYXkoUD4+PjAsej4+PjApKTpbXSxzdHJpZGVzOltMXSx3X2lzX2NvbnN0OigpPT4hIXIoKVtLPj4+MF0sYWN0aXZhdGlvbjpPZShvZSksYWN0aXZhdGlvbl9wYXJhbXM6Z2U/QXJyYXkuZnJvbShtKCkuc3ViYXJyYXkoZ2U+Pj4wLFNlPj4+MCkpOltdfSl9LDk1ODMzNDoobixsLGYsYixBLFAseixMLFosSyxvZSxnZSxTZSxSLGxlLEllKT0+e2QuZWIoXCJDb252XCIsbix7Zm9ybWF0OmdlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmwsZGlsYXRpb25zOltmLGJdLGdyb3VwOkEsa2VybmVsX3NoYXBlOltQLHpdLHBhZHM6TD9BcnJheS5mcm9tKGEoKS5zdWJhcnJheShMPj4+MCxaPj4+MCkpOltdLHN0cmlkZXM6W0ssb2VdLHdfaXNfY29uc3Q6KCk9PiEhcigpW1NlPj4+MF0sYWN0aXZhdGlvbjpPZShSKSxhY3RpdmF0aW9uX3BhcmFtczpsZT9BcnJheS5mcm9tKG0oKS5zdWJhcnJheShsZT4+PjAsSWU+Pj4wKSk6W119KX0sOTU4NzI1Om49PntkLmNjKG4pfSw5NTg3NTk6KG4sbCk9PmQuZGMobixsLGQuRWIuZmMsZC5FYi5lcnJvcnMpfTtmdW5jdGlvbiBncihuKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7bn0pYCx0aGlzLnN0YXR1cz1ufXZhciBjdD1uPT57bi50ZXJtaW5hdGUoKSxuLm9ubWVzc2FnZT0oKT0+e319LExyPW49PnttZS55Yi5sZW5ndGg9PTAmJigkcigpLG1lLlBiKG1lLnliWzBdKSk7dmFyIGw9bWUueWIucG9wKCk7aWYoIWwpcmV0dXJuIDY7bWUuemIucHVzaChsKSxtZS5wYltuLnhiXT1sLGwueGI9bi54Yjt2YXIgZj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTpuLmhjLGFyZzpuLlZiLHB0aHJlYWRfcHRyOm4ueGJ9O3JldHVybiBTJiZsLnVucmVmKCksbC5wb3N0TWVzc2FnZShmLG4ubmMpLDB9LHFlPTAseXI9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLGJyPShuLGwsZik9PntsPj4+PTA7dmFyIGI9bCtmO2ZvcihmPWw7bltmXSYmIShmPj1iKTspKytmO2lmKDE2PGYtbCYmbi5idWZmZXImJnlyKXJldHVybiB5ci5kZWNvZGUobi5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj9uLnNsaWNlKGwsZik6bi5zdWJhcnJheShsLGYpKTtmb3IoYj1cIlwiO2w8Zjspe3ZhciBBPW5bbCsrXTtpZihBJjEyOCl7dmFyIFA9bltsKytdJjYzO2lmKChBJjIyNCk9PTE5MiliKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChBJjMxKTw8NnxQKTtlbHNle3ZhciB6PW5bbCsrXSY2MztBPShBJjI0MCk9PTIyND8oQSYxNSk8PDEyfFA8PDZ8ejooQSY3KTw8MTh8UDw8MTJ8ejw8NnxuW2wrK10mNjMsNjU1MzY+QT9iKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEEpOihBLT02NTUzNixiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fEE+PjEwLDU2MzIwfEEmMTAyMykpfX1lbHNlIGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoQSl9cmV0dXJuIGJ9LE9lPShuLGwpPT4obj4+Pj0wKT9icihvKCksbixsKTpcIlwiLHdyPW49Pnt2YXIgbD1KbigpO3JldHVybiBuPW4oKSxtbihsKSxufTtmdW5jdGlvbiB2ZShuLGwpe3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMixiPWFyZ3VtZW50cztyZXR1cm4gd3IoKCk9Pntmb3IodmFyIEE9MipmLFA9UW4oOCpBKSx6PVA+Pj4zLEw9MDtMPGY7TCsrKXt2YXIgWj1iWzIrTF07dHlwZW9mIFo9PVwiYmlnaW50XCI/KGhlW3orMipMXT0xbixoZVt6KzIqTCsxXT1aKTooaGVbeisyKkxdPTBuLGgoKVt6KzIqTCsxPj4+MF09Wil9cmV0dXJuIHNpKG4sQSxQLGwpfSl9ZnVuY3Rpb24gaXQobil7aWYoRSlyZXR1cm4gdmUoMCwxLG4pO3llPW4sMDxxZXx8KG1lLmljKCksZC5vbkV4aXQ/LihuKSxwZT0hMCkseChuLG5ldyBncihuKSl9dmFyIFF0PW49PntpZih5ZT1uLEUpdGhyb3cgRnIobiksXCJ1bndpbmRcIjtpdChuKX0sdnI9bj0+e24gaW5zdGFuY2VvZiBncnx8bj09XCJ1bndpbmRcInx8eCgxLG4pfTtmdW5jdGlvbiBIbigpe2Zvcih2YXIgbj1kLm51bVRocmVhZHM7bi0tOykkcigpO0l0LnVuc2hpZnQoKCk9PntSdCsrLEduKCgpPT5tcigpKX0pfWZ1bmN0aW9uICRyKCl7dmFyIG49VShcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud29ya2VyLmpzXCIpO249bmV3IFdvcmtlcihuKSxtZS55Yi5wdXNoKG4pfWZ1bmN0aW9uIEduKG4pe0U/bigpOlByb21pc2UuYWxsKG1lLnliLm1hcChtZS5QYikpLnRoZW4obil9dmFyIG1lPXt5YjpbXSx6YjpbXSxVYjpbXSxwYjp7fSxJYigpe0U/KG1lLnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1tZS5lYyxtZS50aHJlYWRJbml0VExTPW1lLlRiLG1lLnNldEV4aXRTdGF0dXM9bWUuU2IpOkhuKCl9LFNiOm49PnllPW4sc2M6W1wiJHRlcm1pbmF0ZVdvcmtlclwiXSxpYzooKT0+e2Zvcih2YXIgbiBvZiBtZS56YiljdChuKTtmb3IobiBvZiBtZS55YiljdChuKTttZS55Yj1bXSxtZS56Yj1bXSxtZS5wYj1bXX0sUmI6bj0+e3ZhciBsPW4ueGI7ZGVsZXRlIG1lLnBiW2xdLG1lLnliLnB1c2gobiksbWUuemIuc3BsaWNlKG1lLnpiLmluZGV4T2YobiksMSksbi54Yj0wLFpuKGwpfSxlYygpe30sVGIoKXttZS5VYi5mb3JFYWNoKG49Pm4oKSl9LFBiOm49Pm5ldyBQcm9taXNlKGw9PntuLm9ubWVzc2FnZT1QPT57UD1QLmRhdGE7dmFyIHo9UC5jbWQ7aWYoUC50YXJnZXRUaHJlYWQmJlAudGFyZ2V0VGhyZWFkIT1wbigpKXt2YXIgTD1tZS5wYltQLnRhcmdldFRocmVhZF07TD9MLnBvc3RNZXNzYWdlKFAsUC50cmFuc2Zlckxpc3QpOmVlKGBJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJHt6fVwiIHRvIHRhcmdldCBwdGhyZWFkICR7UC50YXJnZXRUaHJlYWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIHo9PT1cImNoZWNrTWFpbGJveFwiP0Z0KCk6ej09PVwic3Bhd25UaHJlYWRcIj9McihQKTp6PT09XCJjbGVhbnVwVGhyZWFkXCI/bWUuUmIobWUucGJbUC50aHJlYWRdKTp6PT09XCJraWxsVGhyZWFkXCI/KFA9UC50aHJlYWQsej1tZS5wYltQXSxkZWxldGUgbWUucGJbUF0sY3QoeiksWm4oUCksbWUuemIuc3BsaWNlKG1lLnpiLmluZGV4T2YoeiksMSksei54Yj0wKTp6PT09XCJjYW5jZWxUaHJlYWRcIj9tZS5wYltQLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6ej09PVwibG9hZGVkXCI/KG4ubG9hZGVkPSEwLFMmJiFuLnhiJiZuLnVucmVmKCksbChuKSk6ej09PVwiYWxlcnRcIj9hbGVydChgVGhyZWFkICR7UC50aHJlYWRJZH06ICR7UC50ZXh0fWApOlAudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIj9uLnBvc3RNZXNzYWdlKFApOno9PT1cImNhbGxIYW5kbGVyXCI/ZFtQLmhhbmRsZXJdKC4uLlAuYXJncyk6eiYmZWUoYHdvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCAke3p9YCl9LG4ub25lcnJvcj1QPT57dGhyb3cgZWUoYHdvcmtlciBzZW50IGFuIGVycm9yISAke1AuZmlsZW5hbWV9OiR7UC5saW5lbm99OiAke1AubWVzc2FnZX1gKSxQfSxTJiYobi5vbihcIm1lc3NhZ2VcIixQPT5uLm9ubWVzc2FnZSh7ZGF0YTpQfSkpLG4ub24oXCJlcnJvclwiLFA9Pm4ub25lcnJvcihQKSkpO3ZhciBmPVtdLGI9W1wib25FeGl0XCJdLEE7Zm9yKEEgb2YgYilkLmhhc093blByb3BlcnR5KEEpJiZmLnB1c2goQSk7bi5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmYsdXJsT3JCbG9iOmQubWFpblNjcmlwdFVybE9yQmxvYnx8ZSx3YXNtTWVtb3J5OmJlLHdhc21Nb2R1bGU6TWV9KX0pfTtkLlBUaHJlYWQ9bWU7dmFyIGVyPW49Pntmb3IoOzA8bi5sZW5ndGg7KW4uc2hpZnQoKShkKX07ZC5lc3RhYmxpc2hTdGFja1NwYWNlPSgpPT57dmFyIG49cG4oKSxsPXAoKVtuKzUyPj4+Mj4+PjBdO249cCgpW24rNTY+Pj4yPj4+MF0sbGkobCxsLW4pLG1uKGwpfTtmdW5jdGlvbiBGcihuKXtpZihFKXJldHVybiB2ZSgxLDAsbik7UXQobil9ZC5pbnZva2VFbnRyeVBvaW50PShuLGwpPT57bj1kaS5hcHBseShudWxsLFtuLGxdKSwwPHFlP21lLlNiKG4pOlhuKG4pfTtmdW5jdGlvbiBMbihuKXt0aGlzLkRiPW4tMjQsdGhpcy5wYz1mdW5jdGlvbihsKXtwKClbdGhpcy5EYis0Pj4+Mj4+PjBdPWx9LHRoaXMuTWI9ZnVuY3Rpb24obCl7cCgpW3RoaXMuRGIrOD4+PjI+Pj4wXT1sfSx0aGlzLkliPWZ1bmN0aW9uKGwsZil7dGhpcy5LYigpLHRoaXMucGMobCksdGhpcy5NYihmKX0sdGhpcy5LYj1mdW5jdGlvbigpe3AoKVt0aGlzLkRiKzE2Pj4+Mj4+PjBdPTB9fXZhciBqcj0wLF9yPTA7ZnVuY3Rpb24gU3IobixsLGYsYil7cmV0dXJuIEU/dmUoMiwxLG4sbCxmLGIpOkh0KG4sbCxmLGIpfWZ1bmN0aW9uIEh0KG4sbCxmLGIpe2lmKG4+Pj49MCxsPj4+PTAsZj4+Pj0wLGI+Pj49MCx0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuIGVlKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgQT1bXTtyZXR1cm4gRSYmQS5sZW5ndGg9PT0wP1NyKG4sbCxmLGIpOihuPXtoYzpmLHhiOm4sVmI6YixuYzpBfSxFPyhuLnFjPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShuLEEpLDApOkxyKG4pKX1mdW5jdGlvbiBxcihuLGwsZil7cmV0dXJuIEU/dmUoMywxLG4sbCxmKTowfWZ1bmN0aW9uIG10KG4sbCl7aWYoRSlyZXR1cm4gdmUoNCwxLG4sbCl9dmFyIEplPW49Pntmb3IodmFyIGw9MCxmPTA7ZjxuLmxlbmd0aDsrK2Ype3ZhciBiPW4uY2hhckNvZGVBdChmKTsxMjc+PWI/bCsrOjIwNDc+PWI/bCs9Mjo1NTI5Njw9YiYmNTczNDM+PWI/KGwrPTQsKytmKTpsKz0zfXJldHVybiBsfSx4cj0obixsLGYsYik9PntpZihmPj4+PTAsISgwPGIpKXJldHVybiAwO3ZhciBBPWY7Yj1mK2ItMTtmb3IodmFyIFA9MDtQPG4ubGVuZ3RoOysrUCl7dmFyIHo9bi5jaGFyQ29kZUF0KFApO2lmKDU1Mjk2PD16JiY1NzM0Mz49eil7dmFyIEw9bi5jaGFyQ29kZUF0KCsrUCk7ej02NTUzNisoKHomMTAyMyk8PDEwKXxMJjEwMjN9aWYoMTI3Pj16KXtpZihmPj1iKWJyZWFrO2xbZisrPj4+MF09en1lbHNle2lmKDIwNDc+PXope2lmKGYrMT49YilicmVhaztsW2YrKz4+PjBdPTE5Mnx6Pj42fWVsc2V7aWYoNjU1MzU+PXope2lmKGYrMj49YilicmVhaztsW2YrKz4+PjBdPTIyNHx6Pj4xMn1lbHNle2lmKGYrMz49YilicmVhaztsW2YrKz4+PjBdPTI0MHx6Pj4xOCxsW2YrKz4+PjBdPTEyOHx6Pj4xMiY2M31sW2YrKz4+PjBdPTEyOHx6Pj42JjYzfWxbZisrPj4+MF09MTI4fHomNjN9fXJldHVybiBsW2Y+Pj4wXT0wLGYtQX0sRHQ9KG4sbCxmKT0+eHIobixvKCksbCxmKTtmdW5jdGlvbiBDcihuLGwpe2lmKEUpcmV0dXJuIHZlKDUsMSxuLGwpfWZ1bmN0aW9uIEFyKG4sbCxmKXtpZihFKXJldHVybiB2ZSg2LDEsbixsLGYpfWZ1bmN0aW9uIEtyKG4sbCxmKXtyZXR1cm4gRT92ZSg3LDEsbixsLGYpOjB9ZnVuY3Rpb24gdHIobixsKXtpZihFKXJldHVybiB2ZSg4LDEsbixsKX1mdW5jdGlvbiBZcihuLGwsZil7aWYoRSlyZXR1cm4gdmUoOSwxLG4sbCxmKX1mdW5jdGlvbiBacihuLGwsZixiKXtpZihFKXJldHVybiB2ZSgxMCwxLG4sbCxmLGIpfWZ1bmN0aW9uIFhyKG4sbCxmLGIpe2lmKEUpcmV0dXJuIHZlKDExLDEsbixsLGYsYil9ZnVuY3Rpb24gSnIobixsLGYsYil7aWYoRSlyZXR1cm4gdmUoMTIsMSxuLGwsZixiKX1mdW5jdGlvbiBJcihuKXtpZihFKXJldHVybiB2ZSgxMywxLG4pfWZ1bmN0aW9uIEd0KG4sbCl7aWYoRSlyZXR1cm4gdmUoMTQsMSxuLGwpfWZ1bmN0aW9uIFFyKG4sbCxmKXtpZihFKXJldHVybiB2ZSgxNSwxLG4sbCxmKX12YXIgcnI9bj0+e2lmKG49PT1udWxsKXJldHVyblwibnVsbFwiO3ZhciBsPXR5cGVvZiBuO3JldHVybiBsPT09XCJvYmplY3RcInx8bD09PVwiYXJyYXlcInx8bD09PVwiZnVuY3Rpb25cIj9uLnRvU3RyaW5nKCk6XCJcIitufSxUcixsdD1uPT57Zm9yKHZhciBsPVwiXCI7bygpW24+Pj4wXTspbCs9VHJbbygpW24rKz4+PjBdXTtyZXR1cm4gbH0sRXI9e30sbnI9e30sRm49e30sUWU7ZnVuY3Rpb24gZW4obixsLGY9e30pe3ZhciBiPWwubmFtZTtpZighbil0aHJvdyBuZXcgUWUoYHR5cGUgXCIke2J9XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKG5yLmhhc093blByb3BlcnR5KG4pKXtpZihmLlliKXJldHVybjt0aHJvdyBuZXcgUWUoYENhbm5vdCByZWdpc3RlciB0eXBlIFxcJyR7Yn1cXCcgdHdpY2VgKX1ucltuXT1sLGRlbGV0ZSBGbltuXSxFci5oYXNPd25Qcm9wZXJ0eShuKSYmKGw9RXJbbl0sZGVsZXRlIEVyW25dLGwuZm9yRWFjaChBPT5BKCkpKX1mdW5jdGlvbiBwdChuLGwsZj17fSl7aWYoIShcImFyZ1BhY2tBZHZhbmNlXCJpbiBsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtlbihuLGwsZil9dmFyIFByPShuLGwsZik9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmP2I9PnIoKVtiPj4+MD4+PjBdOmI9Pm8oKVtiPj4+MD4+PjBdO2Nhc2UgMjpyZXR1cm4gZj9iPT5pKClbYj4+PjE+Pj4wXTpiPT51KClbYj4+PjE+Pj4wXTtjYXNlIDQ6cmV0dXJuIGY/Yj0+YSgpW2I+Pj4yPj4+MF06Yj0+cCgpW2I+Pj4yPj4+MF07Y2FzZSA4OnJldHVybiBmP2I9PmhlW2I+Pj4zXTpiPT5YZVtiPj4+M107ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7bH0pOiAke259YCl9fTtmdW5jdGlvbiBvcigpe3RoaXMud2I9W3ZvaWQgMF0sdGhpcy5OYj1bXX12YXIgZXQ9bmV3IG9yO2Z1bmN0aW9uIEx0KG4pe24+Pj49MCxuPj1ldC5EYiYmLS1ldC5nZXQobikuUWI9PT0wJiZldC5NYihuKX12YXIgS2U9bj0+e2lmKCFuKXRocm93IG5ldyBRZShcIkNhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9IFwiK24pO3JldHVybiBldC5nZXQobikudmFsdWV9LHR0PW49Pntzd2l0Y2gobil7Y2FzZSB2b2lkIDA6cmV0dXJuIDE7Y2FzZSBudWxsOnJldHVybiAyO2Nhc2UhMDpyZXR1cm4gMztjYXNlITE6cmV0dXJuIDQ7ZGVmYXVsdDpyZXR1cm4gZXQuS2Ioe1FiOjEsdmFsdWU6bn0pfX07ZnVuY3Rpb24gdG4obil7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGEoKVtuPj4+Mj4+PjBdKX12YXIgcm49KG4sbCk9Pntzd2l0Y2gobCl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUobSgpW2Y+Pj4yPj4+MF0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShoKClbZj4+PjM+Pj4wXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtsfSk6ICR7bn1gKX19O2Z1bmN0aW9uIG5uKG4pe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShwKClbbj4+PjI+Pj4wXSl9dmFyIG9uPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGYtMTZsZVwiKTp2b2lkIDAsYW49KG4sbCk9Pntmb3IodmFyIGY9bj4+MSxiPWYrbC8yOyEoZj49YikmJnUoKVtmPj4+MF07KSsrZjtpZihmPDw9MSwzMjxmLW4mJm9uKXJldHVybiBvbi5kZWNvZGUobygpLnNsaWNlKG4sZikpO2ZvcihmPVwiXCIsYj0wOyEoYj49bC8yKTsrK2Ipe3ZhciBBPWkoKVtuKzIqYj4+PjE+Pj4wXTtpZihBPT0wKWJyZWFrO2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoQSl9cmV0dXJuIGZ9LHNuPShuLGwsZik9PntpZihmPz89MjE0NzQ4MzY0NywyPmYpcmV0dXJuIDA7Zi09Mjt2YXIgYj1sO2Y9ZjwyKm4ubGVuZ3RoP2YvMjpuLmxlbmd0aDtmb3IodmFyIEE9MDtBPGY7KytBKXt2YXIgUD1uLmNoYXJDb2RlQXQoQSk7aSgpW2w+Pj4xPj4+MF09UCxsKz0yfXJldHVybiBpKClbbD4+PjE+Pj4wXT0wLGwtYn0saXI9bj0+MipuLmxlbmd0aCxqbj0obixsKT0+e2Zvcih2YXIgZj0wLGI9XCJcIjshKGY+PWwvNCk7KXt2YXIgQT1hKClbbis0KmY+Pj4yPj4+MF07aWYoQT09MClicmVhazsrK2YsNjU1MzY8PUE/KEEtPTY1NTM2LGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8QT4+MTAsNTYzMjB8QSYxMDIzKSk6Yis9U3RyaW5nLmZyb21DaGFyQ29kZShBKX1yZXR1cm4gYn0sdWU9KG4sbCxmKT0+e2lmKGw+Pj49MCxmPz89MjE0NzQ4MzY0Nyw0PmYpcmV0dXJuIDA7dmFyIGI9bDtmPWIrZi00O2Zvcih2YXIgQT0wO0E8bi5sZW5ndGg7KytBKXt2YXIgUD1uLmNoYXJDb2RlQXQoQSk7aWYoNTUyOTY8PVAmJjU3MzQzPj1QKXt2YXIgej1uLmNoYXJDb2RlQXQoKytBKTtQPTY1NTM2KygoUCYxMDIzKTw8MTApfHomMTAyM31pZihhKClbbD4+PjI+Pj4wXT1QLGwrPTQsbCs0PmYpYnJlYWt9cmV0dXJuIGEoKVtsPj4+Mj4+PjBdPTAsbC1ifSx1bj1uPT57Zm9yKHZhciBsPTAsZj0wO2Y8bi5sZW5ndGg7KytmKXt2YXIgYj1uLmNoYXJDb2RlQXQoZik7NTUyOTY8PWImJjU3MzQzPj1iJiYrK2YsbCs9NH1yZXR1cm4gbH0sTXQ9KCk9PntpZighKDA8cWUpKXRyeXtFP1huKHllKTpRdCh5ZSl9Y2F0Y2gobil7dnIobil9fTtmdW5jdGlvbiBhdChuKXtuPj4+PTAsdHlwZW9mIEF0b21pY3Mub2M9PVwiZnVuY3Rpb25cIiYmKEF0b21pY3Mub2MoYSgpLG4+Pj4yLG4pLnZhbHVlLnRoZW4oRnQpLG4rPTEyOCxBdG9taWNzLnN0b3JlKGEoKSxuPj4+MiwxKSl9ZC5fX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQ9YXQ7dmFyIEZ0PSgpPT57dmFyIG49cG4oKTtpZihuJiYoYXQobiksIXBlKSl0cnl7dWkoKSxNdCgpfWNhdGNoKGwpe3ZyKGwpfX07ZC5jaGVja01haWxib3g9RnQ7dmFyIGFyPVtdLHNyPShuLGwpPT57dmFyIGY9bnJbbl07aWYoZj09PXZvaWQgMCl0aHJvdyBuPWlpKG4pLGY9bHQobiksd3QobiksbmV3IFFlKGwrXCIgaGFzIHVua25vd24gdHlwZSBcIitmKTtyZXR1cm4gZn0sT3I9KG4sbCxmKT0+e3ZhciBiPVtdO3JldHVybiBuPW4udG9XaXJlVHlwZShiLGYpLGIubGVuZ3RoJiYocCgpW2w+Pj4yPj4+MF09dHQoYikpLG59LGp0PW49Pnt0cnl7bigpfWNhdGNoKGwpe0J0KGwpfX07ZnVuY3Rpb24gbG4oKXt2YXIgbj1yZSxsPXt9O2ZvcihsZXRbZixiXW9mIE9iamVjdC5lbnRyaWVzKG4pKWxbZl09dHlwZW9mIGI9PVwiZnVuY3Rpb25cIj9mdW5jdGlvbigpe1B0LnB1c2goZik7dHJ5e3JldHVybiBiLmFwcGx5KG51bGwsYXJndW1lbnRzKX1maW5hbGx5e3BlfHwoUHQucG9wKCksZHQmJmZ0PT09MSYmUHQubGVuZ3RoPT09MCYmKGZ0PTAscWUrPTEsanQocGkpLHR5cGVvZiBGaWJlcnM8XCJ1XCImJkZpYmVycy51YygpKSl9fTpiO3JldHVybiBsfXZhciBmdD0wLGR0PW51bGwsZG49MCxQdD1bXSxrcj17fSxzPXt9LGM9MCxnPW51bGwsJD1bXTtmdW5jdGlvbiBJKCl7cmV0dXJuIG5ldyBQcm9taXNlKChuLGwpPT57Zz17cmVzb2x2ZTpuLHJlamVjdDpsfX0pfWZ1bmN0aW9uIEQoKXt2YXIgbj1Scig2NTU0OCksbD1uKzEyO3AoKVtuPj4+Mj4+PjBdPWwscCgpW24rND4+PjI+Pj4wXT1sKzY1NTM2LGw9UHRbMF07dmFyIGY9a3JbbF07cmV0dXJuIGY9PT12b2lkIDAmJihmPWMrKyxrcltsXT1mLHNbZl09bCksbD1mLGEoKVtuKzg+Pj4yPj4+MF09bCxufWZ1bmN0aW9uIEgoKXt2YXIgbj1hKClbZHQrOD4+PjI+Pj4wXTtyZXR1cm4gbj1yZVtzW25dXSwtLXFlLG4oKX1mdW5jdGlvbiBYKG4pe2lmKCFwZSl7aWYoZnQ9PT0wKXt2YXIgbD0hMSxmPSExO24oKGI9MCk9PntpZighcGUmJihkbj1iLGw9ITAsZikpe2Z0PTIsanQoKCk9Pm1pKGR0KSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuSmIuWGImJkJyb3dzZXIuSmIucmVzdW1lKCksYj0hMTt0cnl7dmFyIEE9SCgpfWNhdGNoKEwpe0E9TCxiPSEwfXZhciBQPSExO2lmKCFkdCl7dmFyIHo9Zzt6JiYoZz1udWxsLChiP3oucmVqZWN0OnoucmVzb2x2ZSkoQSksUD0hMCl9aWYoYiYmIVApdGhyb3cgQX19KSxmPSEwLGx8fChmdD0xLGR0PUQoKSx0eXBlb2YgQnJvd3NlcjxcInVcIiYmQnJvd3Nlci5KYi5YYiYmQnJvd3Nlci5KYi5wYXVzZSgpLGp0KCgpPT5jaShkdCkpKX1lbHNlIGZ0PT09Mj8oZnQ9MCxqdChmaSksd3QoZHQpLGR0PW51bGwsJC5mb3JFYWNoKGI9PntpZighcGUpdHJ5e2IoKSxNdCgpfWNhdGNoKEEpe3ZyKEEpfX0pKTpCdChgaW52YWxpZCBzdGF0ZTogJHtmdH1gKTtyZXR1cm4gZG59fWZ1bmN0aW9uIHEobil7cmV0dXJuIFgobD0+e24oKS50aGVuKGwpfSl9dmFyIGo9W10sbmU9e30sZmU9bj0+e3ZhciBsPW5lW25dO3JldHVybiBsPT09dm9pZCAwP2x0KG4pOmx9LCRlPSgpPT50eXBlb2YgZ2xvYmFsVGhpcz09XCJvYmplY3RcIj9nbG9iYWxUaGlzOkZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSxrPW49Pnt2YXIgbD1qLmxlbmd0aDtyZXR1cm4gai5wdXNoKG4pLGx9LGFlPShuLGwpPT57Zm9yKHZhciBmPUFycmF5KG4pLGI9MDtiPG47KytiKWZbYl09c3IocCgpW2wrNCpiPj4+Mj4+PjBdLFwicGFyYW1ldGVyIFwiK2IpO3JldHVybiBmfSxBZT0obixsKT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KGwsXCJuYW1lXCIse3ZhbHVlOm59KTtmdW5jdGlvbiBPdChuKXt2YXIgbD1GdW5jdGlvbjtpZighKGwgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIGx9IHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uYCk7dmFyIGY9QWUobC5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIixmdW5jdGlvbigpe30pO3JldHVybiBmLnByb3RvdHlwZT1sLnByb3RvdHlwZSxmPW5ldyBmLG49bC5hcHBseShmLG4pLG4gaW5zdGFuY2VvZiBPYmplY3Q/bjpmfXZhciBrdD1uPT5uJTQ9PT0wJiYobiUxMDAhPT0wfHxuJTQwMD09PTApLE5vPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLEhvPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO2Z1bmN0aW9uIEdvKG4sbCxmLGIsQSxQLHope3JldHVybiBFP3ZlKDE2LDEsbixsLGYsYixBLFAseik6LTUyfWZ1bmN0aW9uIExvKG4sbCxmLGIsQSxQKXtpZihFKXJldHVybiB2ZSgxNywxLG4sbCxmLGIsQSxQKX12YXIgRm89bj0+e3ZhciBsPUplKG4pKzEsZj1ScihsKTtyZXR1cm4gZiYmRHQobixmLGwpLGZ9LHFuPVtdLGpvPShuLGwpPT57cW4ubGVuZ3RoPTA7Zm9yKHZhciBmO2Y9bygpW24rKz4+PjBdOyl7dmFyIGI9ZiE9MTA1O2ImPWYhPTExMixsKz1iJiZsJTg/NDowLHFuLnB1c2goZj09MTEyP3AoKVtsPj4+Mj4+PjBdOmY9PTEwNj9oZVtsPj4+M106Zj09MTA1P2EoKVtsPj4+Mj4+PjBdOmgoKVtsPj4+Mz4+PjBdKSxsKz1iPzg6NH1yZXR1cm4gcW59LEtuPXt9LHFvPSgpPT57aWYoIVluKXt2YXIgbj17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzp2fHxcIi4vdGhpcy5wcm9ncmFtXCJ9LGw7Zm9yKGwgaW4gS24pS25bbF09PT12b2lkIDA/ZGVsZXRlIG5bbF06bltsXT1LbltsXTt2YXIgZj1bXTtmb3IobCBpbiBuKWYucHVzaChgJHtsfT0ke25bbF19YCk7WW49Zn1yZXR1cm4gWW59LFluO2Z1bmN0aW9uIEtvKG4sbCl7aWYoRSlyZXR1cm4gdmUoMTgsMSxuLGwpO24+Pj49MCxsPj4+PTA7dmFyIGY9MDtyZXR1cm4gcW8oKS5mb3JFYWNoKChiLEEpPT57dmFyIFA9bCtmO2ZvcihBPXAoKVtuKzQqQT4+PjI+Pj4wXT1QLFA9MDtQPGIubGVuZ3RoOysrUClyKClbQSsrPj4+MD4+PjBdPWIuY2hhckNvZGVBdChQKTtyKClbQT4+PjA+Pj4wXT0wLGYrPWIubGVuZ3RoKzF9KSwwfWZ1bmN0aW9uIFlvKG4sbCl7aWYoRSlyZXR1cm4gdmUoMTksMSxuLGwpO24+Pj49MCxsPj4+PTA7dmFyIGY9cW8oKTtwKClbbj4+PjI+Pj4wXT1mLmxlbmd0aDt2YXIgYj0wO3JldHVybiBmLmZvckVhY2goQT0+Yis9QS5sZW5ndGgrMSkscCgpW2w+Pj4yPj4+MF09YiwwfWZ1bmN0aW9uIFpvKG4pe3JldHVybiBFP3ZlKDIwLDEsbik6NTJ9ZnVuY3Rpb24gWG8obixsLGYsYil7cmV0dXJuIEU/dmUoMjEsMSxuLGwsZixiKTo1Mn1mdW5jdGlvbiBKbyhuLGwsZixiKXtyZXR1cm4gRT92ZSgyMiwxLG4sbCxmLGIpOjcwfXZhciBBbD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gUW8obixsLGYsYil7aWYoRSlyZXR1cm4gdmUoMjMsMSxuLGwsZixiKTtsPj4+PTAsZj4+Pj0wLGI+Pj49MDtmb3IodmFyIEE9MCxQPTA7UDxmO1ArKyl7dmFyIHo9cCgpW2w+Pj4yPj4+MF0sTD1wKClbbCs0Pj4+Mj4+PjBdO2wrPTg7Zm9yKHZhciBaPTA7WjxMO1orKyl7dmFyIEs9bygpW3orWj4+PjBdLG9lPUFsW25dO0s9PT0wfHxLPT09MTA/KChuPT09MT9FZTplZSkoYnIob2UsMCkpLG9lLmxlbmd0aD0wKTpvZS5wdXNoKEspfUErPUx9cmV0dXJuIHAoKVtiPj4+Mj4+PjBdPUEsMH12YXIgZWk9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSx0aT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIElsKG4pe3ZhciBsPUFycmF5KEplKG4pKzEpO3JldHVybiB4cihuLGwsMCxsLmxlbmd0aCksbH12YXIgVGw9KG4sbCk9PntyKCkuc2V0KG4sbD4+PjApfTtmdW5jdGlvbiByaShuLGwsZixiKXtmdW5jdGlvbiBBKFIsbGUsSWUpe2ZvcihSPXR5cGVvZiBSPT1cIm51bWJlclwiP1IudG9TdHJpbmcoKTpSfHxcIlwiO1IubGVuZ3RoPGxlOylSPUllWzBdK1I7cmV0dXJuIFJ9ZnVuY3Rpb24gUChSLGxlKXtyZXR1cm4gQShSLGxlLFwiMFwiKX1mdW5jdGlvbiB6KFIsbGUpe2Z1bmN0aW9uIEllKGdpKXtyZXR1cm4gMD5naT8tMTowPGdpPzE6MH12YXIgcXQ7cmV0dXJuKHF0PUllKFIuZ2V0RnVsbFllYXIoKS1sZS5nZXRGdWxsWWVhcigpKSk9PT0wJiYocXQ9SWUoUi5nZXRNb250aCgpLWxlLmdldE1vbnRoKCkpKT09PTAmJihxdD1JZShSLmdldERhdGUoKS1sZS5nZXREYXRlKCkpKSxxdH1mdW5jdGlvbiBMKFIpe3N3aXRjaChSLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKFIuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIFI7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShSLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKFIuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoUi5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShSLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShSLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIFooUil7dmFyIGxlPVIuQWI7Zm9yKFI9bmV3IERhdGUobmV3IERhdGUoUi5CYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPGxlOyl7dmFyIEllPVIuZ2V0TW9udGgoKSxxdD0oa3QoUi5nZXRGdWxsWWVhcigpKT9laTp0aSlbSWVdO2lmKGxlPnF0LVIuZ2V0RGF0ZSgpKWxlLT1xdC1SLmdldERhdGUoKSsxLFIuc2V0RGF0ZSgxKSwxMT5JZT9SLnNldE1vbnRoKEllKzEpOihSLnNldE1vbnRoKDApLFIuc2V0RnVsbFllYXIoUi5nZXRGdWxsWWVhcigpKzEpKTtlbHNle1Iuc2V0RGF0ZShSLmdldERhdGUoKStsZSk7YnJlYWt9fXJldHVybiBJZT1uZXcgRGF0ZShSLmdldEZ1bGxZZWFyKCkrMSwwLDQpLGxlPUwobmV3IERhdGUoUi5nZXRGdWxsWWVhcigpLDAsNCkpLEllPUwoSWUpLDA+PXoobGUsUik/MD49eihJZSxSKT9SLmdldEZ1bGxZZWFyKCkrMTpSLmdldEZ1bGxZZWFyKCk6Ui5nZXRGdWxsWWVhcigpLTF9bj4+Pj0wLGw+Pj49MCxmPj4+PTAsYj4+Pj0wO3ZhciBLPXAoKVtiKzQwPj4+Mj4+PjBdO2I9e2xjOmEoKVtiPj4+Mj4+PjBdLGtjOmEoKVtiKzQ+Pj4yPj4+MF0sR2I6YSgpW2IrOD4+PjI+Pj4wXSxMYjphKClbYisxMj4+PjI+Pj4wXSxIYjphKClbYisxNj4+PjI+Pj4wXSxCYjphKClbYisyMD4+PjI+Pj4wXSx2YjphKClbYisyND4+PjI+Pj4wXSxBYjphKClbYisyOD4+PjI+Pj4wXSx0YzphKClbYiszMj4+PjI+Pj4wXSxqYzphKClbYiszNj4+PjI+Pj4wXSxtYzpLP09lKEspOlwiXCJ9LGY9T2UoZiksSz17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgb2UgaW4gSylmPWYucmVwbGFjZShuZXcgUmVnRXhwKG9lLFwiZ1wiKSxLW29lXSk7dmFyIGdlPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksU2U9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO0s9e1wiJWFcIjpSPT5nZVtSLnZiXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6Uj0+Z2VbUi52Yl0sXCIlYlwiOlI9PlNlW1IuSGJdLnN1YnN0cmluZygwLDMpLFwiJUJcIjpSPT5TZVtSLkhiXSxcIiVDXCI6Uj0+UCgoUi5CYisxOTAwKS8xMDB8MCwyKSxcIiVkXCI6Uj0+UChSLkxiLDIpLFwiJWVcIjpSPT5BKFIuTGIsMixcIiBcIiksXCIlZ1wiOlI9PlooUikudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOlI9PlooUiksXCIlSFwiOlI9PlAoUi5HYiwyKSxcIiVJXCI6Uj0+KFI9Ui5HYixSPT0wP1I9MTI6MTI8UiYmKFItPTEyKSxQKFIsMikpLFwiJWpcIjpSPT57Zm9yKHZhciBsZT0wLEllPTA7SWU8PVIuSGItMTtsZSs9KGt0KFIuQmIrMTkwMCk/ZWk6dGkpW0llKytdKTtyZXR1cm4gUChSLkxiK2xlLDMpfSxcIiVtXCI6Uj0+UChSLkhiKzEsMiksXCIlTVwiOlI9PlAoUi5rYywyKSxcIiVuXCI6KCk9PmBcXG5gLFwiJXBcIjpSPT4wPD1SLkdiJiYxMj5SLkdiP1wiQU1cIjpcIlBNXCIsXCIlU1wiOlI9PlAoUi5sYywyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6Uj0+Ui52Ynx8NyxcIiVVXCI6Uj0+UChNYXRoLmZsb29yKChSLkFiKzctUi52YikvNyksMiksXCIlVlwiOlI9Pnt2YXIgbGU9TWF0aC5mbG9vcigoUi5BYis3LShSLnZiKzYpJTcpLzcpO2lmKDI+PShSLnZiKzM3MS1SLkFiLTIpJTcmJmxlKyssbGUpbGU9PTUzJiYoSWU9KFIudmIrMzcxLVIuQWIpJTcsSWU9PTR8fEllPT0zJiZrdChSLkJiKXx8KGxlPTEpKTtlbHNle2xlPTUyO3ZhciBJZT0oUi52Yis3LVIuQWItMSklNzsoSWU9PTR8fEllPT01JiZrdChSLkJiJTQwMC0xKSkmJmxlKyt9cmV0dXJuIFAobGUsMil9LFwiJXdcIjpSPT5SLnZiLFwiJVdcIjpSPT5QKE1hdGguZmxvb3IoKFIuQWIrNy0oUi52Yis2KSU3KS83KSwyKSxcIiV5XCI6Uj0+KFIuQmIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOlI9PlIuQmIrMTkwMCxcIiV6XCI6Uj0+e1I9Ui5qYzt2YXIgbGU9MDw9UjtyZXR1cm4gUj1NYXRoLmFicyhSKS82MCwobGU/XCIrXCI6XCItXCIpKyhcIjAwMDBcIisoUi82MCoxMDArUiU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOlI9PlIubWMsXCIlJVwiOigpPT5cIiVcIn0sZj1mLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpO2ZvcihvZSBpbiBLKWYuaW5jbHVkZXMob2UpJiYoZj1mLnJlcGxhY2UobmV3IFJlZ0V4cChvZSxcImdcIiksS1tvZV0oYikpKTtyZXR1cm4gZj1mLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIiksb2U9SWwoZiksb2UubGVuZ3RoPmw/MDooVGwob2Usbiksb2UubGVuZ3RoLTEpfW1lLkliKCk7Zm9yKHZhciBuaT1BcnJheSgyNTYpLGNuPTA7MjU2PmNuOysrY24pbmlbY25dPVN0cmluZy5mcm9tQ2hhckNvZGUoY24pO1RyPW5pLFFlPWQuQmluZGluZ0Vycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iobil7c3VwZXIobiksdGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fSxkLkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihuKXtzdXBlcihuKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSxPYmplY3QuYXNzaWduKG9yLnByb3RvdHlwZSx7Z2V0KG4pe3JldHVybiB0aGlzLndiW25dfSxoYXMobil7cmV0dXJuIHRoaXMud2Jbbl0hPT12b2lkIDB9LEtiKG4pe3ZhciBsPXRoaXMuTmIucG9wKCl8fHRoaXMud2IubGVuZ3RoO3JldHVybiB0aGlzLndiW2xdPW4sbH0sTWIobil7dGhpcy53YltuXT12b2lkIDAsdGhpcy5OYi5wdXNoKG4pfX0pLGV0LndiLnB1c2goe3ZhbHVlOnZvaWQgMH0se3ZhbHVlOm51bGx9LHt2YWx1ZTohMH0se3ZhbHVlOiExfSksZXQuRGI9ZXQud2IubGVuZ3RoLGQuY291bnRfZW12YWxfaGFuZGxlcz0oKT0+e2Zvcih2YXIgbj0wLGw9ZXQuRGI7bDxldC53Yi5sZW5ndGg7KytsKWV0LndiW2xdIT09dm9pZCAwJiYrK247cmV0dXJuIG59O3ZhciBFbD1baXQsRnIsU3IscXIsbXQsQ3IsQXIsS3IsdHIsWXIsWnIsWHIsSnIsSXIsR3QsUXIsR28sTG8sS28sWW8sWm8sWG8sSm8sUW9dLFBsPXt1YTpmdW5jdGlvbihuLGwsZil7cmV0dXJuIHEoYXN5bmMoKT0+e2F3YWl0IGQuYWMobixsLGYpfSl9LGI6ZnVuY3Rpb24obixsLGYpe3Rocm93IG4+Pj49MCxuZXcgTG4obikuSWIobD4+PjAsZj4+PjApLGpyPW4sX3IrKyxqcn0sZmE6ZnVuY3Rpb24obil7YWkobj4+PjAsIUMsMSwhVCwxMzEwNzIsITEpLG1lLlRiKCl9LEQ6ZnVuY3Rpb24obil7bj4+Pj0wLEU/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6bn0pOm1lLlJiKG1lLnBiW25dKX0sWDpIdCx6OnFyLGxhOm10LFQ6Q3IsVjpBcixtYTpLcixqYTp0cixjYTpZcixpYTpacixIOlhyLFU6SnIsUjpJcixrYTpHdCxTOlFyLEs6ZnVuY3Rpb24obixsLGYsYixBKXtuPj4+PTAsbD4+Pj0wLGY+Pj49MCxsPWx0KGwpO3ZhciBQPWwuaW5kZXhPZihcInVcIikhPS0xO1AmJihBPSgxbjw8NjRuKS0xbikscHQobix7bmFtZTpsLGZyb21XaXJlVHlwZTp6PT56LHRvV2lyZVR5cGU6ZnVuY3Rpb24oeixMKXtpZih0eXBlb2YgTCE9XCJiaWdpbnRcIiYmdHlwZW9mIEwhPVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke3JyKEwpfVwiIHRvICR7dGhpcy5uYW1lfWApO2lmKEw8Ynx8TD5BKXRocm93IG5ldyBUeXBlRXJyb3IoYFBhc3NpbmcgYSBudW1iZXIgXCIke3JyKEwpfVwiIGZyb20gSlMgc2lkZSB0byBDL0MrKyBzaWRlIHRvIGFuIGFyZ3VtZW50IG9mIHR5cGUgXCIke2x9XCIsIHdoaWNoIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIFske2J9LCAke0F9XSFgKTtyZXR1cm4gTH0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpQcihsLGYsIVApLENiOm51bGx9KX0sc2E6ZnVuY3Rpb24obixsLGYsYil7bj4+Pj0wLGw9bHQobD4+PjApLHB0KG4se25hbWU6bCxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oQSl7cmV0dXJuISFBfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKEEsUCl7cmV0dXJuIFA/ZjpifSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKEEpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShvKClbQT4+PjBdKX0sQ2I6bnVsbH0pfSxyYTpmdW5jdGlvbihuLGwpe24+Pj49MCxsPWx0KGw+Pj4wKSxwdChuLHtuYW1lOmwsZnJvbVdpcmVUeXBlOmY9Pnt2YXIgYj1LZShmKTtyZXR1cm4gTHQoZiksYn0sdG9XaXJlVHlwZTooZixiKT0+dHQoYiksYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjp0bixDYjpudWxsfSl9LEo6ZnVuY3Rpb24obixsLGYpe24+Pj49MCxmPj4+PTAsbD1sdChsPj4+MCkscHQobix7bmFtZTpsLGZyb21XaXJlVHlwZTpiPT5iLHRvV2lyZVR5cGU6KGIsQSk9PkEsYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpybihsLGYpLENiOm51bGx9KX0sdjpmdW5jdGlvbihuLGwsZixiLEEpe2lmKG4+Pj49MCxmPj4+PTAsbD1sdChsPj4+MCksQT09PS0xJiYoQT00Mjk0OTY3Mjk1KSxBPUw9PkwsYj09PTApe3ZhciBQPTMyLTgqZjtBPUw9Pkw8PFA+Pj5QfXZhciB6PWwuaW5jbHVkZXMoXCJ1bnNpZ25lZFwiKT9mdW5jdGlvbihMLFope3JldHVybiBaPj4+MH06ZnVuY3Rpb24oTCxaKXtyZXR1cm4gWn07cHQobix7bmFtZTpsLGZyb21XaXJlVHlwZTpBLHRvV2lyZVR5cGU6eixhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOlByKGwsZixiIT09MCksQ2I6bnVsbH0pfSxvOmZ1bmN0aW9uKG4sbCxmKXtmdW5jdGlvbiBiKFApe3ZhciB6PXAoKVtQPj4+Mj4+PjBdO3JldHVybiBQPXAoKVtQKzQ+Pj4yPj4+MF0sbmV3IEEocigpLmJ1ZmZlcixQLHopfW4+Pj49MDt2YXIgQT1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXksQmlnSW50NjRBcnJheSxCaWdVaW50NjRBcnJheV1bbF07Zj1sdChmPj4+MCkscHQobix7bmFtZTpmLGZyb21XaXJlVHlwZTpiLGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6Yn0se1liOiEwfSl9LEw6ZnVuY3Rpb24obixsKXtuPj4+PTAsbD1sdChsPj4+MCk7dmFyIGY9bD09PVwic3RkOjpzdHJpbmdcIjtwdChuLHtuYW1lOmwsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGIpe3ZhciBBPXAoKVtiPj4+Mj4+PjBdLFA9Yis0O2lmKGYpZm9yKHZhciB6PVAsTD0wO0w8PUE7KytMKXt2YXIgWj1QK0w7aWYoTD09QXx8bygpW1o+Pj4wXT09MCl7aWYoej1PZSh6LFoteiksSz09PXZvaWQgMCl2YXIgSz16O2Vsc2UgSys9U3RyaW5nLmZyb21DaGFyQ29kZSgwKSxLKz16O3o9WisxfX1lbHNle2ZvcihLPUFycmF5KEEpLEw9MDtMPEE7KytMKUtbTF09U3RyaW5nLmZyb21DaGFyQ29kZShvKClbUCtMPj4+MF0pO0s9Sy5qb2luKFwiXCIpfXJldHVybiB3dChiKSxLfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGIsQSl7QSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYoQT1uZXcgVWludDhBcnJheShBKSk7dmFyIFA9dHlwZW9mIEE9PVwic3RyaW5nXCI7aWYoIShQfHxBIGluc3RhbmNlb2YgVWludDhBcnJheXx8QSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHxBIGluc3RhbmNlb2YgSW50OEFycmF5KSl0aHJvdyBuZXcgUWUoXCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nXCIpO3ZhciB6PWYmJlA/SmUoQSk6QS5sZW5ndGgsTD1Scig0K3orMSksWj1MKzQ7aWYocCgpW0w+Pj4yPj4+MF09eixmJiZQKUR0KEEsWix6KzEpO2Vsc2UgaWYoUClmb3IoUD0wO1A8ejsrK1Ape3ZhciBLPUEuY2hhckNvZGVBdChQKTtpZigyNTU8Syl0aHJvdyB3dChaKSxuZXcgUWUoXCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHNcIik7bygpW1orUD4+PjBdPUt9ZWxzZSBmb3IoUD0wO1A8ejsrK1ApbygpW1orUD4+PjBdPUFbUF07cmV0dXJuIGIhPT1udWxsJiZiLnB1c2god3QsTCksTH0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpubixDYihiKXt3dChiKX19KX0sQjpmdW5jdGlvbihuLGwsZil7aWYobj4+Pj0wLGw+Pj49MCxmPj4+PTAsZj1sdChmKSxsPT09Mil2YXIgYj1hbixBPXNuLFA9aXIsej0oKT0+dSgpLEw9MTtlbHNlIGw9PT00JiYoYj1qbixBPXVlLFA9dW4sej0oKT0+cCgpLEw9Mik7cHQobix7bmFtZTpmLGZyb21XaXJlVHlwZTpaPT57Zm9yKHZhciBLPXAoKVtaPj4+Mj4+PjBdLG9lPXooKSxnZSxTZT1aKzQsUj0wO1I8PUs7KytSKXt2YXIgbGU9Wis0K1IqbDsoUj09S3x8b2VbbGU+Pj5MXT09MCkmJihTZT1iKFNlLGxlLVNlKSxnZT09PXZvaWQgMD9nZT1TZTooZ2UrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCksZ2UrPVNlKSxTZT1sZStsKX1yZXR1cm4gd3QoWiksZ2V9LHRvV2lyZVR5cGU6KFosSyk9PntpZih0eXBlb2YgSyE9XCJzdHJpbmdcIil0aHJvdyBuZXcgUWUoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7Zn1gKTt2YXIgb2U9UChLKSxnZT1Scig0K29lK2wpO3JldHVybiBwKClbZ2U+Pj4yXT1vZT4+TCxBKEssZ2UrNCxvZStsKSxaIT09bnVsbCYmWi5wdXNoKHd0LGdlKSxnZX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjp0bixDYihaKXt3dChaKX19KX0sdGE6ZnVuY3Rpb24obixsKXtuPj4+PTAsbD1sdChsPj4+MCkscHQobix7WmI6ITAsbmFtZTpsLGFyZ1BhY2tBZHZhbmNlOjAsZnJvbVdpcmVUeXBlOigpPT57fSx0b1dpcmVUeXBlOigpPT57fX0pfSxxYTooKT0+MSxQOmZ1bmN0aW9uKG4sbCl7bj4+Pj0wLG49PWw+Pj4wP3NldFRpbWVvdXQoKCk9PkZ0KCkpOkU/cG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDpuLGNtZDpcImNoZWNrTWFpbGJveFwifSk6KG49bWUucGJbbl0pJiZuLnBvc3RNZXNzYWdlKHtjbWQ6XCJjaGVja01haWxib3hcIn0pfSxZOmZ1bmN0aW9uKG4sbCxmLGIpe2w+Pj49MCxmLz0yLGFyLmxlbmd0aD1mLGI9Yj4+PjA+Pj4zO2Zvcih2YXIgQT0wO0E8ZjtBKyspYXJbQV09aGVbYisyKkFdP2hlW2IrMipBKzFdOmgoKVtiKzIqQSsxPj4+MF07cmV0dXJuIG49MD5uP050Wy1uLTFdOkVsW25dLG1lLldiPWwsbD1uLmFwcGx5KG51bGwsYXIpLG1lLldiPTAsbH0sZWE6YXQscGE6ZnVuY3Rpb24obil7UyYmbWUucGJbbj4+PjBdLnJlZigpfSx0OmZ1bmN0aW9uKG4sbCxmKXtyZXR1cm4gbD4+Pj0wLGY+Pj49MCxuPUtlKG4+Pj4wKSxsPXNyKGwsXCJlbXZhbDo6YXNcIiksT3IobCxmLG4pfSx5OmZ1bmN0aW9uKG4pe3JldHVybiBuPj4+PTAscSgoKT0+KG49S2Uobiksbi50aGVuKHR0KSkpfSxwOmZ1bmN0aW9uKG4sbCxmLGIpe3JldHVybiBmPj4+PTAsYj4+Pj0wLG49altuPj4+MF0sbD1LZShsPj4+MCksbihudWxsLGwsZixiKX0sazpmdW5jdGlvbihuLGwsZixiLEEpe3JldHVybiBmPj4+PTAsYj4+Pj0wLEE+Pj49MCxuPWpbbj4+PjBdLGw9S2UobD4+PjApLGY9ZmUoZiksbihsLGxbZl0sYixBKX0sYzpMdCxDOmZ1bmN0aW9uKG4sbCl7cmV0dXJuIGw+Pj49MCxuPUtlKG4+Pj4wKSxsPUtlKGwpLG49PWx9LG46ZnVuY3Rpb24obil7cmV0dXJuIG4+Pj49MCxuPT09MD90dCgkZSgpKToobj1mZShuKSx0dCgkZSgpW25dKSl9LGo6ZnVuY3Rpb24obixsLGYpe2w9YWUobixsPj4+MCk7dmFyIGI9bC5zaGlmdCgpO24tLTt2YXIgQT1gcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZ1bmMsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XFxuYCxQPTAsej1bXTtmPT09MCYmei5wdXNoKFwib2JqXCIpO2Zvcih2YXIgTD1bXCJyZXRUeXBlXCJdLFo9W2JdLEs9MDtLPG47KytLKXoucHVzaChcImFyZ1wiK0spLEwucHVzaChcImFyZ1R5cGVcIitLKSxaLnB1c2gobFtLXSksQSs9YCAgdmFyIGFyZyR7S30gPSBhcmdUeXBlJHtLfS5yZWFkVmFsdWVGcm9tUG9pbnRlcihhcmdzJHtQP1wiK1wiK1A6XCJcIn0pO1xcbmAsUCs9bFtLXS5hcmdQYWNrQWR2YW5jZTtmb3IoQSs9YCAgdmFyIHJ2ID0gJHtmPT09MT9cIm5ldyBmdW5jXCI6XCJmdW5jLmNhbGxcIn0oJHt6LmpvaW4oXCIsIFwiKX0pO1xcbmAsSz0wO0s8bjsrK0spbFtLXS5kZWxldGVPYmplY3QmJihBKz1gICBhcmdUeXBlJHtLfS5kZWxldGVPYmplY3QoYXJnJHtLfSk7XFxuYCk7cmV0dXJuIGIuWmJ8fChMLnB1c2goXCJlbXZhbF9yZXR1cm5WYWx1ZVwiKSxaLnB1c2goT3IpLEErPWAgIHJldHVybiBlbXZhbF9yZXR1cm5WYWx1ZShyZXRUeXBlLCBkZXN0cnVjdG9yc1JlZiwgcnYpO1xcbmApLEwucHVzaChBK2B9O1xcbmApLG49T3QoTCkuYXBwbHkobnVsbCxaKSxmPWBtZXRob2RDYWxsZXI8KCR7bC5tYXAob2U9Pm9lLm5hbWUpLmpvaW4oXCIsIFwiKX0pID0+ICR7Yi5uYW1lfT5gLGsoQWUoZixuKSl9LHM6ZnVuY3Rpb24obixsKXtyZXR1cm4gbD4+Pj0wLG49S2Uobj4+PjApLGw9S2UobCksdHQobltsXSl9LGU6ZnVuY3Rpb24obil7bj4+Pj0wLDQ8biYmKGV0LmdldChuKS5RYis9MSl9LHc6ZnVuY3Rpb24oKXtyZXR1cm4gdHQoW10pfSxtOmZ1bmN0aW9uKG4pe249S2Uobj4+PjApO2Zvcih2YXIgbD1BcnJheShuLmxlbmd0aCksZj0wO2Y8bi5sZW5ndGg7ZisrKWxbZl09bltmXTtyZXR1cm4gdHQobCl9LGY6ZnVuY3Rpb24obil7cmV0dXJuIHR0KGZlKG4+Pj4wKSl9LGw6ZnVuY3Rpb24oKXtyZXR1cm4gdHQoe30pfSxpOmZ1bmN0aW9uKG4pe24+Pj49MDtmb3IodmFyIGw9S2Uobik7bC5sZW5ndGg7KXt2YXIgZj1sLnBvcCgpO2wucG9wKCkoZil9THQobil9LGg6ZnVuY3Rpb24obixsLGYpe2w+Pj49MCxmPj4+PTAsbj1LZShuPj4+MCksbD1LZShsKSxmPUtlKGYpLG5bbF09Zn0sZDpmdW5jdGlvbihuLGwpe3JldHVybiBsPj4+PTAsbj1zcihuPj4+MCxcIl9lbXZhbF90YWtlX3ZhbHVlXCIpLG49bi5yZWFkVmFsdWVGcm9tUG9pbnRlcihsKSx0dChuKX0sJDpmdW5jdGlvbihuLGwpe249LTkwMDcxOTkyNTQ3NDA5OTI+bnx8OTAwNzE5OTI1NDc0MDk5MjxuP05hTjpOdW1iZXIobiksbD4+Pj0wLG49bmV3IERhdGUoMWUzKm4pLGEoKVtsPj4+Mj4+PjBdPW4uZ2V0VVRDU2Vjb25kcygpLGEoKVtsKzQ+Pj4yPj4+MF09bi5nZXRVVENNaW51dGVzKCksYSgpW2wrOD4+PjI+Pj4wXT1uLmdldFVUQ0hvdXJzKCksYSgpW2wrMTI+Pj4yPj4+MF09bi5nZXRVVENEYXRlKCksYSgpW2wrMTY+Pj4yPj4+MF09bi5nZXRVVENNb250aCgpLGEoKVtsKzIwPj4+Mj4+PjBdPW4uZ2V0VVRDRnVsbFllYXIoKS0xOTAwLGEoKVtsKzI0Pj4+Mj4+PjBdPW4uZ2V0VVRDRGF5KCksbj0obi5nZXRUaW1lKCktRGF0ZS5VVEMobi5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MCxhKClbbCsyOD4+PjI+Pj4wXT1ufSxhYTpmdW5jdGlvbihuLGwpe249LTkwMDcxOTkyNTQ3NDA5OTI+bnx8OTAwNzE5OTI1NDc0MDk5MjxuP05hTjpOdW1iZXIobiksbD4+Pj0wLG49bmV3IERhdGUoMWUzKm4pLGEoKVtsPj4+Mj4+PjBdPW4uZ2V0U2Vjb25kcygpLGEoKVtsKzQ+Pj4yPj4+MF09bi5nZXRNaW51dGVzKCksYSgpW2wrOD4+PjI+Pj4wXT1uLmdldEhvdXJzKCksYSgpW2wrMTI+Pj4yPj4+MF09bi5nZXREYXRlKCksYSgpW2wrMTY+Pj4yPj4+MF09bi5nZXRNb250aCgpLGEoKVtsKzIwPj4+Mj4+PjBdPW4uZ2V0RnVsbFllYXIoKS0xOTAwLGEoKVtsKzI0Pj4+Mj4+PjBdPW4uZ2V0RGF5KCk7dmFyIGY9KGt0KG4uZ2V0RnVsbFllYXIoKSk/Tm86SG8pW24uZ2V0TW9udGgoKV0rbi5nZXREYXRlKCktMXwwO2EoKVtsKzI4Pj4+Mj4+PjBdPWYsYSgpW2wrMzY+Pj4yPj4+MF09LSg2MCpuLmdldFRpbWV6b25lT2Zmc2V0KCkpLGY9bmV3IERhdGUobi5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgYj1uZXcgRGF0ZShuLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO249KGYhPWImJm4uZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4oYixmKSl8MCxhKClbbCszMj4+PjI+Pj4wXT1ufSxiYTpmdW5jdGlvbihuKXtuPj4+PTA7dmFyIGw9bmV3IERhdGUoYSgpW24rMjA+Pj4yPj4+MF0rMTkwMCxhKClbbisxNj4+PjI+Pj4wXSxhKClbbisxMj4+PjI+Pj4wXSxhKClbbis4Pj4+Mj4+PjBdLGEoKVtuKzQ+Pj4yPj4+MF0sYSgpW24+Pj4yPj4+MF0sMCksZj1hKClbbiszMj4+PjI+Pj4wXSxiPWwuZ2V0VGltZXpvbmVPZmZzZXQoKSxBPW5ldyBEYXRlKGwuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksUD1uZXcgRGF0ZShsLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHo9TWF0aC5taW4oUCxBKTtyZXR1cm4gMD5mP2EoKVtuKzMyPj4+Mj4+PjBdPSsoQSE9UCYmej09Yik6MDxmIT0oej09YikmJihBPU1hdGgubWF4KFAsQSksbC5zZXRUaW1lKGwuZ2V0VGltZSgpKzZlNCooKDA8Zj96OkEpLWIpKSksYSgpW24rMjQ+Pj4yPj4+MF09bC5nZXREYXkoKSxmPShrdChsLmdldEZ1bGxZZWFyKCkpP05vOkhvKVtsLmdldE1vbnRoKCldK2wuZ2V0RGF0ZSgpLTF8MCxhKClbbisyOD4+PjI+Pj4wXT1mLGEoKVtuPj4+Mj4+PjBdPWwuZ2V0U2Vjb25kcygpLGEoKVtuKzQ+Pj4yPj4+MF09bC5nZXRNaW51dGVzKCksYSgpW24rOD4+PjI+Pj4wXT1sLmdldEhvdXJzKCksYSgpW24rMTI+Pj4yPj4+MF09bC5nZXREYXRlKCksYSgpW24rMTY+Pj4yPj4+MF09bC5nZXRNb250aCgpLGEoKVtuKzIwPj4+Mj4+PjBdPWwuZ2V0WWVhcigpLG49bC5nZXRUaW1lKCksaXNOYU4obik/KGEoKVtvaSgpPj4+Mj4+PjBdPTYxLG49LTEpOm4vPTFlMyxCaWdJbnQobil9LFo6R28sXzpMbyxPOmZ1bmN0aW9uKG4sbCxmKXtmdW5jdGlvbiBiKEspe3JldHVybihLPUsudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP0tbMV06XCJHTVRcIn1uPj4+PTAsbD4+Pj0wLGY+Pj49MDt2YXIgQT1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksUD1uZXcgRGF0ZShBLDAsMSksej1uZXcgRGF0ZShBLDYsMSk7QT1QLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEw9ei5nZXRUaW1lem9uZU9mZnNldCgpLFo9TWF0aC5tYXgoQSxMKTtwKClbbj4+PjI+Pj4wXT02MCpaLGEoKVtsPj4+Mj4+PjBdPSsoQSE9TCksbj1iKFApLGw9Yih6KSxuPUZvKG4pLGw9Rm8obCksTDxBPyhwKClbZj4+PjI+Pj4wXT1uLHAoKVtmKzQ+Pj4yPj4+MF09bCk6KHAoKVtmPj4+Mj4+PjBdPWwscCgpW2YrND4+PjI+Pj4wXT1uKX0scTooKT0+e0J0KFwiXCIpfSxnOmZ1bmN0aW9uKG4sbCxmKXtyZXR1cm4gbj4+Pj0wLGw9am8obD4+PjAsZj4+PjApLE50W25dLmFwcGx5KG51bGwsbCl9LE06ZnVuY3Rpb24obixsLGYpe3JldHVybiBuPj4+PTAsbD1qbyhsPj4+MCxmPj4+MCksTnRbbl0uYXBwbHkobnVsbCxsKX0sRTooKT0+e30sSTooKT0+RGF0ZS5ub3coKSxvYTooKT0+e3Rocm93IHFlKz0xLFwidW53aW5kXCJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sdTooKT0+cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKSx4OigpPT5TPyh4aSgpLHVyKFNpKSkuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSxOOmZ1bmN0aW9uKG4pe24+Pj49MDt2YXIgbD1vKCkubGVuZ3RoO2lmKG48PWx8fDQyOTQ5MDE3NjA8bilyZXR1cm4hMTtmb3IodmFyIGY9MTs0Pj1mO2YqPTIpe3ZhciBiPWwqKDErLjIvZik7Yj1NYXRoLm1pbihiLG4rMTAwNjYzMjk2KTt2YXIgQT1NYXRoO2I9TWF0aC5tYXgobixiKTtlOntBPShBLm1pbi5jYWxsKEEsNDI5NDkwMTc2MCxiKyg2NTUzNi1iJTY1NTM2KSU2NTUzNiktYmUuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXtiZS5ncm93KEEpLGtlKCk7dmFyIFA9MTticmVhayBlfWNhdGNoe31QPXZvaWQgMH1pZihQKXJldHVybiEwfXJldHVybiExfSxnYTpLbyxoYTpZbyxXOlF0LEE6Wm8sRzpYbyxkYTpKbyxGOlFvLGE6YmV8fGQud2FzbU1lbW9yeSxuYTpyaSxyOmZ1bmN0aW9uKG4sbCxmLGIpe3JldHVybiByaShuPj4+MCxsPj4+MCxmPj4+MCxiPj4+MCl9fSxyZT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oZixiKXtyZXR1cm4gcmU9Zi5leHBvcnRzLHJlPWxuKCkscmU9T2woKSxtZS5VYi5wdXNoKHJlLmJiKSxUdC51bnNoaWZ0KHJlLnZhKSxNZT1iLG1yKCkscmV9dmFyIGw9e2E6UGx9O2lmKFJ0KyssZC5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBkLmluc3RhbnRpYXRlV2FzbShsLG4pfWNhdGNoKGYpe2VlKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2Z9YCksdyhmKX1yZXR1cm4gaHIobCxmdW5jdGlvbihmKXtuKGYuaW5zdGFuY2UsZi5tb2R1bGUpfSkuY2F0Y2godykse319KCk7ZC5fT3J0SW5pdD0obixsKT0+KGQuX09ydEluaXQ9cmUud2EpKG4sbCksZC5fT3J0R2V0TGFzdEVycm9yPShuLGwpPT4oZC5fT3J0R2V0TGFzdEVycm9yPXJlLnhhKShuLGwpLGQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShuLGwsZixiLEEsUCx6LEwsWixLKT0+KGQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXJlLnlhKShuLGwsZixiLEEsUCx6LEwsWixLKSxkLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0obixsKT0+KGQuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXJlLnphKShuLGwpLGQuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT0obixsLGYpPT4oZC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPXJlLkFhKShuLGwsZiksZC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShuLGwsZik9PihkLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cmUuQmEpKG4sbCxmKSxkLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9bj0+KGQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1yZS5DYSkobiksZC5fT3J0Q3JlYXRlU2Vzc2lvbj0obixsLGYpPT4oZC5fT3J0Q3JlYXRlU2Vzc2lvbj1yZS5EYSkobixsLGYpLGQuX09ydFJlbGVhc2VTZXNzaW9uPW49PihkLl9PcnRSZWxlYXNlU2Vzc2lvbj1yZS5FYSkobiksZC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0obixsLGYpPT4oZC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1yZS5GYSkobixsLGYpLGQuX09ydEdldElucHV0TmFtZT0obixsKT0+KGQuX09ydEdldElucHV0TmFtZT1yZS5HYSkobixsKSxkLl9PcnRHZXRPdXRwdXROYW1lPShuLGwpPT4oZC5fT3J0R2V0T3V0cHV0TmFtZT1yZS5IYSkobixsKSxkLl9PcnRGcmVlPW49PihkLl9PcnRGcmVlPXJlLklhKShuKSxkLl9PcnRDcmVhdGVUZW5zb3I9KG4sbCxmLGIsQSxQKT0+KGQuX09ydENyZWF0ZVRlbnNvcj1yZS5KYSkobixsLGYsYixBLFApLGQuX09ydEdldFRlbnNvckRhdGE9KG4sbCxmLGIsQSk9PihkLl9PcnRHZXRUZW5zb3JEYXRhPXJlLkthKShuLGwsZixiLEEpLGQuX09ydFJlbGVhc2VUZW5zb3I9bj0+KGQuX09ydFJlbGVhc2VUZW5zb3I9cmUuTGEpKG4pLGQuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KG4sbCxmLGIpPT4oZC5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1yZS5NYSkobixsLGYsYiksZC5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KG4sbCxmKT0+KGQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXJlLk5hKShuLGwsZiksZC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9bj0+KGQuX09ydFJlbGVhc2VSdW5PcHRpb25zPXJlLk9hKShuKSxkLl9PcnRDcmVhdGVCaW5kaW5nPW49PihkLl9PcnRDcmVhdGVCaW5kaW5nPXJlLlBhKShuKSxkLl9PcnRCaW5kSW5wdXQ9KG4sbCxmKT0+KGQuX09ydEJpbmRJbnB1dD1yZS5RYSkobixsLGYpLGQuX09ydEJpbmRPdXRwdXQ9KG4sbCxmLGIpPT4oZC5fT3J0QmluZE91dHB1dD1yZS5SYSkobixsLGYsYiksZC5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9bj0+KGQuX09ydENsZWFyQm91bmRPdXRwdXRzPXJlLlNhKShuKSxkLl9PcnRSZWxlYXNlQmluZGluZz1uPT4oZC5fT3J0UmVsZWFzZUJpbmRpbmc9cmUuVGEpKG4pLGQuX09ydFJ1bldpdGhCaW5kaW5nPShuLGwsZixiLEEpPT4oZC5fT3J0UnVuV2l0aEJpbmRpbmc9cmUuVWEpKG4sbCxmLGIsQSksZC5fT3J0UnVuPShuLGwsZixiLEEsUCx6LEwpPT4oZC5fT3J0UnVuPXJlLlZhKShuLGwsZixiLEEsUCx6LEwpLGQuX09ydEVuZFByb2ZpbGluZz1uPT4oZC5fT3J0RW5kUHJvZmlsaW5nPXJlLldhKShuKSxkLl9Kc2VwT3V0cHV0PShuLGwsZik9PihkLl9Kc2VwT3V0cHV0PXJlLlhhKShuLGwsZiksZC5fSnNlcEdldE5vZGVOYW1lPW49PihkLl9Kc2VwR2V0Tm9kZU5hbWU9cmUuWWEpKG4pO3ZhciBvaT0oKT0+KG9pPXJlLlphKSgpLHBuPWQuX3B0aHJlYWRfc2VsZj0oKT0+KHBuPWQuX3B0aHJlYWRfc2VsZj1yZS5fYSkoKSxScj1kLl9tYWxsb2M9bj0+KFJyPWQuX21hbGxvYz1yZS4kYSkobiksd3Q9ZC5fZnJlZT1uPT4od3Q9ZC5fZnJlZT1yZS5hYikobik7ZC5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9KCk9PihkLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1yZS5iYikoKTt2YXIgaWk9bj0+KGlpPXJlLmNiKShuKTtkLl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3M9KCk9PihkLl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3M9cmUuZGIpKCk7dmFyIGFpPWQuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PShuLGwsZixiLEEsUCk9PihhaT1kLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1yZS5mYikobixsLGYsYixBLFApO2QuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPSgpPT4oZC5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9cmUuZ2IpKCk7dmFyIHNpPShuLGwsZixiKT0+KHNpPXJlLmhiKShuLGwsZixiKSxabj1uPT4oWm49cmUuaWIpKG4pLFhuPWQuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PW49PihYbj1kLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1yZS5qYikobiksdWk9KCk9Pih1aT1yZS5rYikoKSxsaT0obixsKT0+KGxpPXJlLmxiKShuLGwpLEpuPSgpPT4oSm49cmUubWIpKCksbW49bj0+KG1uPXJlLm5iKShuKSxRbj1uPT4oUW49cmUub2IpKG4pLGRpPWQuZHluQ2FsbF9paT0obixsKT0+KGRpPWQuZHluQ2FsbF9paT1yZS5xYikobixsKSxjaT1uPT4oY2k9cmUucmIpKG4pLHBpPSgpPT4ocGk9cmUuc2IpKCksbWk9bj0+KG1pPXJlLnRiKShuKSxmaT0oKT0+KGZpPXJlLnViKSgpO2QuX19fc3RhcnRfZW1fanM9OTU4ODcxLGQuX19fc3RvcF9lbV9qcz05NTkwMzI7ZnVuY3Rpb24gT2woKXt2YXIgbj1yZTtuPU9iamVjdC5hc3NpZ24oe30sbik7dmFyIGw9Yj0+KCk9PmIoKT4+PjAsZj1iPT5BPT5iKEEpPj4+MDtyZXR1cm4gbi5aYT1sKG4uWmEpLG4uX2E9bChuLl9hKSxuLiRhPWYobi4kYSksbi5jYj1mKG4uY2IpLG4uZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkPWwobi5lbXNjcmlwdGVuX21haW5fcnVudGltZV90aHJlYWRfaWQpLG4ubWI9bChuLm1iKSxuLm9iPWYobi5vYiksbn1kLndhc21NZW1vcnk9YmUsZC5zdGFja0FsbG9jPVFuLGQuc3RhY2tTYXZlPUpuLGQuc3RhY2tSZXN0b3JlPW1uLGQua2VlcFJ1bnRpbWVBbGl2ZT0oKT0+MDxxZSxkLlVURjhUb1N0cmluZz1PZSxkLnN0cmluZ1RvVVRGOD1EdCxkLmxlbmd0aEJ5dGVzVVRGOD1KZSxkLkV4aXRTdGF0dXM9Z3IsZC5QVGhyZWFkPW1lO3ZhciBmbjtXdD1mdW5jdGlvbiBuKCl7Zm58fGhpKCksZm58fChXdD1uKX07ZnVuY3Rpb24gaGkoKXtpZighKDA8UnQpKWlmKEUpeShkKSxFfHxlcihUdCksc3RhcnRXb3JrZXIoZCk7ZWxzZXtpZihkLnByZVJ1bilmb3IodHlwZW9mIGQucHJlUnVuPT1cImZ1bmN0aW9uXCImJihkLnByZVJ1bj1bZC5wcmVSdW5dKTtkLnByZVJ1bi5sZW5ndGg7KUl0LnVuc2hpZnQoZC5wcmVSdW4uc2hpZnQoKSk7ZXIoSXQpLDA8UnR8fGZufHwoZm49ITAsZC5jYWxsZWRSdW49ITAscGV8fChFfHxlcihUdCkseShkKSxFfHxlcihWdCkpKX19cmV0dXJuIGhpKCksdC5yZWFkeX19KSgpO3R5cGVvZiBBaT09XCJvYmplY3RcIiYmdHlwZW9mIGFvPT1cIm9iamVjdFwiP2FvLmV4cG9ydHM9Q2k6dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sKCk9PkNpKX0pO3ZhciBUaT1CcigoVnAsV2wpPT57V2wuZXhwb3J0cz1cXCdcInVzZSBzdHJpY3RcIjt2YXIgTW9kdWxlPXt9LEVOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBub2RlV29ya2VyVGhyZWFkcz1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIikscGFyZW50UG9ydD1ub2RlV29ya2VyVGhyZWFkcy5wYXJlbnRQb3J0O3BhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsZT0+b25tZXNzYWdlKHtkYXRhOmV9KSk7dmFyIGZzPXJlcXVpcmUoXCJmc1wiKSx2bT1yZXF1aXJlKFwidm1cIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmUsTW9kdWxlLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpub2RlV29ya2VyVGhyZWFkcy5Xb3JrZXIsaW1wb3J0U2NyaXB0czplPT52bS5ydW5JblRoaXNDb250ZXh0KGZzLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKSx7ZmlsZW5hbWU6ZX0pLHBvc3RNZXNzYWdlOmU9PnBhcmVudFBvcnQucG9zdE1lc3NhZ2UoZSkscGVyZm9ybWFuY2U6Z2xvYmFsLnBlcmZvcm1hbmNlfHx7bm93OkRhdGUubm93fX0pfXZhciBpbml0aWFsaXplZEpTPSExO2Z1bmN0aW9uIHRocmVhZFByaW50RXJyKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtmcy53cml0ZVN5bmMoMixlK2BcXFxcbmApO3JldHVybn1jb25zb2xlLmVycm9yKGUpfWZ1bmN0aW9uIHRocmVhZEFsZXJ0KCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OmUsdGhyZWFkSWQ6TW9kdWxlLl9wdGhyZWFkX3NlbGYoKX0pfXZhciBlcnI9dGhyZWFkUHJpbnRFcnI7c2VsZi5hbGVydD10aHJlYWRBbGVydCxNb2R1bGUuaW5zdGFudGlhdGVXYXNtPShlLHQpPT57dmFyIGE9TW9kdWxlLndhc21Nb2R1bGU7TW9kdWxlLndhc21Nb2R1bGU9bnVsbDt2YXIgcj1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoYSxlKTtyZXR1cm4gdChyKX0sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb258fGV9O2Z1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZSl7dHJ5e2lmKGUuZGF0YS5jbWQ9PT1cImxvYWRcIil7bGV0IGE9W107c2VsZi5vbm1lc3NhZ2U9cj0+YS5wdXNoKHIpLHNlbGYuc3RhcnRXb3JrZXI9cj0+e01vZHVsZT1yLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2ZvcihsZXQgcyBvZiBhKWhhbmRsZU1lc3NhZ2Uocyk7c2VsZi5vbm1lc3NhZ2U9aGFuZGxlTWVzc2FnZX0sTW9kdWxlLndhc21Nb2R1bGU9ZS5kYXRhLndhc21Nb2R1bGU7Zm9yKGNvbnN0IHIgb2YgZS5kYXRhLmhhbmRsZXJzKU1vZHVsZVtyXT0oLi4ucyk9Pntwb3N0TWVzc2FnZSh7Y21kOlwiY2FsbEhhbmRsZXJcIixoYW5kbGVyOnIsYXJnczpzfSl9O2lmKE1vZHVsZS53YXNtTWVtb3J5PWUuZGF0YS53YXNtTWVtb3J5LE1vZHVsZS5idWZmZXI9TW9kdWxlLndhc21NZW1vcnkuYnVmZmVyLE1vZHVsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLHR5cGVvZiBlLmRhdGEudXJsT3JCbG9iPT1cInN0cmluZ1wiKWltcG9ydFNjcmlwdHMoZS5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgdD1VUkwuY3JlYXRlT2JqZWN0VVJMKGUuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHModCksVVJMLnJldm9rZU9iamVjdFVSTCh0KX1vcnRXYXNtVGhyZWFkZWQoTW9kdWxlKX1lbHNlIGlmKGUuZGF0YS5jbWQ9PT1cInJ1blwiKXtNb2R1bGUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0KGUuZGF0YS5wdGhyZWFkX3B0ciwwLDAsMSksTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdChlLmRhdGEucHRocmVhZF9wdHIpLE1vZHVsZS5lc3RhYmxpc2hTdGFja1NwYWNlKCksTW9kdWxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKGUuZGF0YSksTW9kdWxlLlBUaHJlYWQudGhyZWFkSW5pdFRMUygpLGluaXRpYWxpemVkSlN8fChpbml0aWFsaXplZEpTPSEwKTt0cnl7TW9kdWxlLmludm9rZUVudHJ5UG9pbnQoZS5kYXRhLnN0YXJ0X3JvdXRpbmUsZS5kYXRhLmFyZyl9Y2F0Y2goYSl7aWYoYSE9XCJ1bndpbmRcIil0aHJvdyBhfX1lbHNlIGUuZGF0YS5jbWQ9PT1cImNhbmNlbFwiP01vZHVsZS5fcHRocmVhZF9zZWxmKCkmJk1vZHVsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOmUuZGF0YS50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwifHwoZS5kYXRhLmNtZD09PVwiY2hlY2tNYWlsYm94XCI/aW5pdGlhbGl6ZWRKUyYmTW9kdWxlLmNoZWNrTWFpbGJveCgpOmUuZGF0YS5jbWQmJihlcnIoYHdvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgJHtlLmRhdGEuY21kfWApLGVycihlLmRhdGEpKSl9Y2F0Y2goYSl7dGhyb3cgTW9kdWxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD8uKCksYX19c2VsZi5vbm1lc3NhZ2U9aGFuZGxlTWVzc2FnZTtcXFxcblxcJ30pO3ZhciBsbyxzdCxNcix5bix6cixCaSxjbyxWZT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bG89ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHN0PWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxNcj1lPT5bdm9pZCAwLDQsMSwxLDIsMiw0LDgsdm9pZCAwLDEsMiw4LDQsOCx2b2lkIDAsdm9pZCAwLHZvaWQgMF1bZV0seW49ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSx6cj1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sQmk9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJib29sXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwidWludDMyXCIsY289ZT0+e3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7ZX1gKX19fSk7dmFyIGJuPVEoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBNaT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Ym4oKX0pO3ZhciB6aSxVaT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7emk9XCIxLjE3LjAtZGV2LjIwMjQwMTE2LTgwZjI3NGNhNmZcIn0pO3ZhciBWaSxLdCxwbz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VWkoKTtWaT1cIndhcm5pbmdcIixLdD17d2FzbTp7fSx3ZWJnbDp7fSx3ZWJncHU6e30sdmVyc2lvbnM6e2NvbW1vbjp6aX0sc2V0IGxvZ0xldmVsKGUpe2lmKGUhPT12b2lkIDApe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wifHxbXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihlKT09PS0xKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApO1ZpPWV9fSxnZXQgbG9nTGV2ZWwoKXtyZXR1cm4gVml9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoS3QsXCJsb2dMZXZlbFwiLHtlbnVtZXJhYmxlOiEwfSl9KTt2YXIgbHIsV2k9USgoKT0+e1widXNlIHN0cmljdFwiO3BvKCk7bHI9S3R9KTt2YXIgTmk9USgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEhpPVEoKCk9PntcInVzZSBzdHJpY3RcIjt3bigpfSk7dmFyIExpPVEoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBGaT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d24oKX0pO3ZhciB3bj1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TmkoKTtIaSgpO0xpKCk7RmkoKX0pO3ZhciB2bj1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d24oKX0pO3ZhciBtbyxqaSxZdCxadCxmbz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cG8oKTttbz0oZSx0KT0+e0t0Lndhc20udHJhY2UmJmNvbnNvbGUudGltZVN0YW1wKGAke2V9OjpPUlQ6OiR7dH1gKX0samk9KGUsdCk9PntsZXQgcj1uZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcXFxyXFxcXG58XFxcXHJ8XFxcXG4vZyl8fFtdLG89ITE7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDtpKyspe2lmKG8mJiFyW2ldLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IHU9YEZVTkNfJHtlfTo6JHtyW2ldLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYodSs9YDo6JHt0fWApLG1vKFwiQ1BVXCIsdSk7cmV0dXJufXJbaV0uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYobz0hMCl9fSxZdD1lPT57S3Qud2FzbS50cmFjZSYmamkoXCJCRUdJTlwiLGUpfSxadD1lPT57S3Qud2FzbS50cmFjZSYmamkoXCJFTkRcIixlKX19KTt2YXIgcWk9USgoKT0+e1widXNlIHN0cmljdFwiO2JuKCk7dm4oKTtmbygpfSk7dmFyIEtpPVEoKCk9PntcInVzZSBzdHJpY3RcIjtxaSgpfSk7dmFyIFlpPVEoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBaaT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Ym4oKTt2bigpfSk7dmFyIFhpPVEoKCk9PntcInVzZSBzdHJpY3RcIjtaaSgpfSk7dmFyIGRyPVEoKCk9PntcInVzZSBzdHJpY3RcIjtNaSgpO1dpKCk7S2koKTt2bigpO2ZvKCk7WWkoKTtYaSgpfSk7dmFyIFhsLEpsLEppLFFpLGVhLFFsLERlLHp0PVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO1hsPVtcIlZcIixcIklcIixcIldcIixcIkVcIixcIkZcIl0sSmw9KGUsdCk9Pntjb25zb2xlLmxvZyhgWyR7WGxbZV19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke3R9YCl9LGVhPShlLHQpPT57Smk9ZSxRaT10fSxRbD0oZSx0KT0+e2xldCByPXpyKGUpLG89enIoSmkpO3I+PW8mJkpsKHIsdHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj90KCk6dCl9LERlPSguLi5lKT0+e1FpJiZRbCguLi5lKX19KTt2YXIgdGEscmE9USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7dGE9KGUsdCk9Pm5ldyh5bih0KSkoZSl9KTt2YXIgJG49USgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIF9uLGVkLG5hLGdvLGhvLGlhLGFhPVEoKCk9PntcInVzZSBzdHJpY3RcIjt6dCgpOyRuKCk7X249ZT0+TWF0aC5jZWlsKGUvMTYpKjE2LGVkPTEsbmE9KCk9PmVkKyssZ289YXN5bmMoZSx0LHIsbyk9PntsZXQgaT1fbihyKSx1PWUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTppLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7dHJ5e2xldCBhPWUuZ2V0Q29tbWFuZEVuY29kZXIoKTtlLmVuZENvbXB1dGVQYXNzKCksYS5jb3B5QnVmZmVyVG9CdWZmZXIodCwwLHUsMCxpKSxlLmZsdXNoKCksYXdhaXQgdS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2xldCBwPXUuZ2V0TWFwcGVkUmFuZ2UoKTtpZihvKXtsZXQgbT1vKCk7cmV0dXJuIG0uc2V0KG5ldyBVaW50OEFycmF5KHAsMCxyKSksbX1lbHNlIHJldHVybiBuZXcgVWludDhBcnJheShwLnNsaWNlKDAscikpfWZpbmFsbHl7dS5kZXN0cm95KCl9fSxobz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc9W10sdGhpcy5idWZmZXJzUGVuZGluZz1bXSx0aGlzLmV4dGVybmFsQnVmZmVycz1uZXcgTWFwfXVwbG9hZCh0LHIpe2xldCBvPXIuYnVmZmVyLGk9ci5ieXRlT2Zmc2V0LHU9ci5ieXRlTGVuZ3RoLGE9X24odSkscD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIXApdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihwLm9yaWdpbmFsU2l6ZSE9PXUpdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7cC5vcmlnaW5hbFNpemV9LCBkYXRhIHNpemU9JHt1fWApO2xldCBtPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHttYXBwZWRBdENyZWF0aW9uOiEwLHNpemU6YSx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEV8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KSxoPW0uZ2V0TWFwcGVkUmFuZ2UoKTtuZXcgVWludDhBcnJheShoKS5zZXQobmV3IFVpbnQ4QXJyYXkobyxpLHUpKSxtLnVubWFwKCk7bGV0IGQ9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksZC5jb3B5QnVmZmVyVG9CdWZmZXIobSwwLHAuZ3B1RGF0YS5idWZmZXIsMCxhKSxEZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke3R9KWApLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcucHVzaChtKX1tZW1jcHkodCxyKXtsZXQgbz10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7bGV0IGk9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHIpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYoby5vcmlnaW5hbFNpemUhPT1pLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2xldCB1PV9uKG8ub3JpZ2luYWxTaXplKSxhPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLGEuY29weUJ1ZmZlclRvQnVmZmVyKG8uZ3B1RGF0YS5idWZmZXIsMCxpLmdwdURhdGEuYnVmZmVyLDAsdSl9cmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0LHIsbyl7bGV0IGk7aWYobyl7aWYoaT10aGlzLmV4dGVybmFsQnVmZmVycy5nZXQobyksaT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBidWZmZXIgaXMgbm90IHJlZ2lzdGVyZWRcIik7aWYodD09PW8pcmV0dXJuIERlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7aX0sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKSxpO3RoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZShvKX1lbHNlIGk9bmEoKTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGkse2dwdURhdGE6e2lkOmksdHlwZTowLGJ1ZmZlcjp0fSxvcmlnaW5hbFNpemU6cn0pLHRoaXMuZXh0ZXJuYWxCdWZmZXJzLnNldCh0LGkpLERlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7cn0pID0+IGlkPSR7aX0sIHJlZ2lzdGVyZWQuYCksaX11bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCl7bGV0IHI9dGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KHQpO3IhPT12b2lkIDAmJih0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUociksdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKHQpLERlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHtyfWApKX1jcmVhdGUodCxyPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1Qpe2xldCBvPV9uKHQpLGksdT0ociZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UsYT0ociZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07aWYodXx8YSl7bGV0IG09dT90aGlzLmZyZWVCdWZmZXJzOnRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLGg9bS5nZXQobyk7aHx8KGg9W10sbS5zZXQobyxoKSksaC5sZW5ndGg+MD9pPWgucG9wKCk6aT10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpvLHVzYWdlOnJ9KX1lbHNlIGk9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpyfSk7bGV0IHA9e2lkOm5hKCksdHlwZTowLGJ1ZmZlcjppfTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KHAuaWQse2dwdURhdGE6cCxvcmlnaW5hbFNpemU6dH0pLERlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHt0fSkgPT4gaWQ9JHtwLmlkfWApLHB9Z2V0KHQpe3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk/LmdwdURhdGF9cmVsZWFzZSh0KXtsZXQgcj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwicmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3RcIik7cmV0dXJuIERlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke3R9KSwgZ3B1RGF0YUlkPSR7ci5ncHVEYXRhLmlkfWApLHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZSh0KSx0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goci5ncHVEYXRhLmJ1ZmZlciksci5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQodCxyKXtsZXQgbz10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCBnbyh0aGlzLmJhY2tlbmQsby5ncHVEYXRhLmJ1ZmZlcixvLm9yaWdpbmFsU2l6ZSxyKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyl0LmRlc3Ryb3koKTt0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nPVtdO2ZvcihsZXQgdCBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRT90aGlzLmZyZWVCdWZmZXJzLmdldCh0LnNpemUpLnB1c2godCk6KHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNP3RoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldCh0LnNpemUpLnB1c2godCk6dC5kZXN0cm95KCk7dGhpcy5idWZmZXJzUGVuZGluZz1bXX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXB9fSxpYT0oLi4uZSk9Pm5ldyBobyguLi5lKX0pO3ZhciB5byx4ZSxZZT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eW89Y2xhc3N7Y29uc3RydWN0b3IodCl7T2JqZWN0LmFzc2lnbih0aGlzLHQpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLmtleXx8KHRoaXMua2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAodD0+YCR7dGhpc1t0XX1gKS5qb2luKFwiO1wiKSksdGhpcy5rZXl9fSx4ZT1lPT5uZXcgeW8oZSl9KTt2YXIgYm8sdnQsVyxYdCxTbix4bixDbixDZT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Ym89Y2xhc3N7c3RhdGljIGNhbGNNYXRNdWxTaGFwZSh0LHIpe3JldHVybiB0WzFdIT09clswXT92b2lkIDA6W3RbMF0sclsxXV19fSx2dD1jbGFzc3tzdGF0aWMgY2FsY1NoYXBlKHQscixvPSExKXtsZXQgaT10Lmxlbmd0aCx1PXIubGVuZ3RoO2lmKGk9PT0wKXJldHVybiByO2lmKHU9PT0wKXJldHVybiB0O2xldCBhPU1hdGgubWF4KHQubGVuZ3RoLHIubGVuZ3RoKSxwPW5ldyBBcnJheShhKTtpZihvKXtpZihpPDJ8fHU8MilyZXR1cm47bGV0IG09Ym8uY2FsY01hdE11bFNoYXBlKFt0W2ktMl0sdFtpLTFdXSxbclt1LTJdLHJbdS0xXV0pO2lmKG09PT12b2lkIDApcmV0dXJuO1twW2EtMl0scFthLTFdXT1tfWZvcihsZXQgbT1vPzM6MTttPD1hO20rKyl7bGV0IGg9aS1tPDA/MTp0W2ktbV0sZD11LW08MD8xOnJbdS1tXTtpZihoIT09ZCYmaD4xJiZkPjEpcmV0dXJuO3BbYS1tXT1NYXRoLm1heChoLGQpfXJldHVybiBwfXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHQscil7bGV0IG89dC5sZW5ndGgsaT1yLmxlbmd0aDtpZihvPmkpcmV0dXJuITE7Zm9yKGxldCB1PTE7dTw9bzt1KyspaWYodFtvLXVdIT09MSYmdFtvLXVdIT09cltpLXVdKXJldHVybiExO3JldHVybiEwfX0sVz1jbGFzcyBle3N0YXRpYyBzaXplKHQpe3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHQubGVuZ3RoKX1zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHIpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscixvKXtsZXQgaT0xO2ZvcihsZXQgdT1yO3U8bzt1Kyspe2lmKHRbdV08MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO2kqPXRbdV19cmV0dXJuIGl9c3RhdGljIGNvbXB1dGVTdHJpZGVzKHQpe2xldCByPXQubGVuZ3RoO2lmKHI9PT0wKXJldHVybltdO2lmKHI9PT0xKXJldHVyblsxXTtsZXQgbz1uZXcgQXJyYXkocik7b1tyLTFdPTEsb1tyLTJdPXRbci0xXTtmb3IobGV0IGk9ci0zO2k+PTA7LS1pKW9baV09b1tpKzFdKnRbaSsxXTtyZXR1cm4gb31zdGF0aWMgbm9ybWFsaXplQXhpcyh0LHIpe2lmKHQ8LXImJnQ+PXIpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiB0PDA/dCtyOnR9c3RhdGljIG5vcm1hbGl6ZUF4ZXModCxyKXtyZXR1cm4gdC5tYXAobz0+dGhpcy5ub3JtYWxpemVBeGlzKG8scj8/dC5sZW5ndGgpKX1zdGF0aWMgc29ydEJhc2VkT25QZXJtKHQscil7cmV0dXJuIHI/ci5tYXAobz0+dFtvXSk6dC5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUodCxyKXtsZXQgbz10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKGksdSk9Pmkrclt1XStyW3Urb10pfXN0YXRpYyBhcmVFcXVhbCh0LHIpe3JldHVybiB0Lmxlbmd0aCE9PXIubGVuZ3RoPyExOnQuZXZlcnkoKG8saSk9Pm89PT1yW2ldKX19LFh0PWNsYXNzIGV7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQscixvLGksdSxhKXtpZighdCYmby5sZW5ndGghPT1yLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IHA9MDtwPHIubGVuZ3RoLTI7cCsrKXA+PW8ubGVuZ3RoP28ucHVzaChyW3ArMl0pOm9bcF09cltwKzJdO2ZvcihsZXQgcD0wO3A8by5sZW5ndGg7cCsrKWlmKHA8aS5sZW5ndGgpe2lmKGlbcF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IHA9MDtwPG8ubGVuZ3RoO3ArKylpZihwPHUubGVuZ3RoKXtpZih1W3BdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHUucHVzaCgxKTtmb3IobGV0IHA9MDtwPG8ubGVuZ3RoKjI7cCsrKWlmKHA8YS5sZW5ndGgpe2lmKGFbcF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgYS5wdXNoKDApO2ZvcihsZXQgcD0wO3A8by5sZW5ndGg7cCsrKXtpZihvW3BdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihhW3BdPj1vW3BdfHxhW3Arby5sZW5ndGhdPj1vW3BdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxyLG8saSx1LGEscCl7aWYocCl7aWYodS5sZW5ndGghPT0yKih0Lmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihpLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgbT0wO208dC5sZW5ndGgtMjttKyspZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W20rKGE/MToyKV0sclttXSxvW21dLGlbbV0sdSxtLG0rdC5sZW5ndGgtMixwKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUodCxyLG8saSx1LGEscCl7aWYoci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2xldCBtPVtyWzBdLHJbMV1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcih0LHIsbSxvLGksdSxhLHApLG19c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxyLG8saSx1LGEscCl7aWYodC5sZW5ndGg8PTB8fHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7bGV0IG09W3RbMF0sclswXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKCExLHQsbSxvLGksdSxhLHApLG19c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcih0LHIsbyxpLHUsYSxwLG0pe2lmKHQpZm9yKGxldCBoPTA7aDxyLmxlbmd0aC0yO2grKylvLnB1c2goMSk7ZWxzZSBmb3IobGV0IGg9MDtoPHIubGVuZ3RoLTI7aCsrKW8ucHVzaChlLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHJbaCsyXSxpW2hdLHVbaF0sYVtoXSxwLGgsaCtyLmxlbmd0aC0yLG0pKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodCxyLG8saSx1LGEscCxtKXtsZXQgaD1vKihpLTEpKzE7aWYobSYmbSE9PVwiTk9UU0VUXCIpc3dpdGNoKG0pe2Nhc2VcIlZBTElEXCI6cmV0dXJuIHVbYV09MCx1W3BdPTAsTWF0aC5mbG9vcigodC1oKS9yKzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYobyE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tsZXQgeT0oKHQrci0xKS9yLTEpKnIraS10O3JldHVybiB1W2FdPU1hdGguZmxvb3IobT09PVwiU0FNRV9MT1dFUlwiPyh5KzEpLzI6eS8yKSx1W3BdPXktdVthXSxNYXRoLmZsb29yKCh0K3ktaSkvcisxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX1lbHNlIHJldHVybiBNYXRoLmZsb29yKCh0K3VbYV0rdVtwXS1oKS9yKzEpfX0sU249Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQscixvLGksdSl7aWYodC5sZW5ndGghPT0yfHxvLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IGEscCxtO3I/KGE9dFsxXSxwPXRbMF0pOihhPXRbMF0scD10WzFdKTtsZXQgaD0tMTtpZihpPyhtPW9bMF0saD0xKToobT1vWzFdLGg9MCksb1toXSE9PXApdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKGE8PTB8fG08PTB8fHA8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYodSYmIXZ0LmlzVmFsaWRCcm9hZGNhc3QodSxbYSxtXSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW2EsbSxwXX19LHhuPS0zNDAyODIzNDY2Mzg1Mjg4NmUyMixDbj0zNDAyODIzNDY2Mzg1Mjg4NmUyMn0pO3ZhciB0ZCx2byxOZSxodCxHLEhlLFplLGd0LHV0LGNlLCRvLFYsSixBbix3byxzYSxjcixfZT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VmUoKTtDZSgpO3RkPTY0LHZvPShlLHQpPT57aWYodD09PTMpdGhyb3cgbmV3IEVycm9yKFwidmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZFwiKTtzd2l0Y2goZSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHtlfWApfX0sTmU9KGUsdD0xKT0+e2xldCByPXZvKGUsdCk7cmV0dXJuIHR5cGVvZiByPT1cInN0cmluZ1wiP3I6clswXX0saHQ9KGUsdD0xKT0+e2xldCByPXZvKGUsdCk7cmV0dXJuIHR5cGVvZiByPT1cInN0cmluZ1wiP3I6clsxXX0sRz1lPT5lLmxlbmd0aD09PTA/W106W3t0eXBlOlwidWludDMyXCIsZGF0YTplfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6Vy5jb21wdXRlU3RyaWRlcyhlKX1dLEhlPWU9PmUlND09PTA/NDplJTI9PT0wPzI6MSxaZT0oZT1cImYzMlwiLHQscj1cIjBcIik9PiF0fHx0PT09MT9gJHtlfSgke3J9KWA6YHZlYyR7dH08JHtlfT4oJHtyfSlgLGd0PShlLHQscik9PmU9PT1cImYzMlwiP3I6dD09PTE/YGYzMigke3J9KWA6YHZlYyR7dH1mKCR7cn0pYCx1dD0oZSx0KT0+dD09PTQ/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnogKyAke2V9LncpYDp0PT09Mj9gKCR7ZX0ueCArICR7ZX0ueSlgOnQ9PT0zP2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56KWA6ZSxjZT0oZSx0LHIsbyk9PmUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmcj40P3R5cGVvZiB0PT1cInN0cmluZ1wiP289PT1cImYxNlwiP2Ake2V9Wygke3R9KSAvIDhdWygke3R9KSAlIDggLyA0XVsoJHt0fSkgJSA4ICUgNF1gOmAke2V9Wygke3R9KSAvIDRdWygke3R9KSAlIDRdYDpvPT09XCJmMTZcIj9gJHtlfVske01hdGguZmxvb3IodC84KX1dWyR7TWF0aC5mbG9vcih0JTgvNCl9XVske3QlOCU0fV1gOmAke2V9WyR7TWF0aC5mbG9vcih0LzQpfV1bJHt0JTR9XWA6cj4xP2Ake2V9WyR7dH1dYDplLCRvPShlLHQscixvLGkpPT57bGV0IHU9dHlwZW9mIHI9PVwibnVtYmVyXCIsYT11P3I6ci5sZW5ndGgscD1bLi4ubmV3IEFycmF5KGEpLmtleXMoKV0sbT1hPDI/XCJ1MzJcIjphPD00P2B2ZWMke2F9PHUzMj5gOmBhcnJheTx1MzIsICR7YX0+YCxoPXZvKHQsaSksZD10eXBlb2YgaD09XCJzdHJpbmdcIj9oOmhbMV0seT10eXBlb2YgaD09XCJzdHJpbmdcIj9oOmhbMF0sdz17aW5kaWNlczptLHZhbHVlOmQsc3RvcmFnZTp5LHRlbnNvcjp0fSxfPUY9PnR5cGVvZiBGPT1cInN0cmluZ1wiP0Y6YCR7Rn11YCx2PXtvZmZzZXRUb0luZGljZXM6ITEsaW5kaWNlc1RvT2Zmc2V0OiExLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiExLHNldDohMSxzZXRCeUluZGljZXM6ITEsZ2V0OiExLGdldEJ5SW5kaWNlczohMX0seD11P1widW5pZm9ybXMuXCI6XCJcIixUPWAke3h9JHtlfV9zaGFwZWAsQz1gJHt4fSR7ZX1fc3RyaWRlc2AsUz1cIlwiO2ZvcihsZXQgRj0wO0Y8YS0xO0YrKylTKz1gXFxuICAgIGxldCBkaW0ke0Z9ID0gY3VycmVudCAvICR7Y2UoQyxGLGEpfTtcXG4gICAgbGV0IHJlc3Qke0Z9ID0gY3VycmVudCAlICR7Y2UoQyxGLGEpfTtcXG4gICAgaW5kaWNlc1ske0Z9XSA9IGRpbSR7Rn07XFxuICAgIGN1cnJlbnQgPSByZXN0JHtGfTtcXG4gICAgYDtTKz1gaW5kaWNlc1ske2EtMX1dID0gY3VycmVudDtgO2xldCBFPWE8Mj9cIlwiOmBcXG4gIGZuIG8yaV8ke2V9KG9mZnNldDogdTMyKSAtPiAke3cuaW5kaWNlc30ge1xcbiAgICB2YXIgaW5kaWNlczogJHt3LmluZGljZXN9O1xcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcXG4gICAgJHtTfVxcbiAgICByZXR1cm4gaW5kaWNlcztcXG4gIH1gLE89Rj0+KHYub2Zmc2V0VG9JbmRpY2VzPSEwLGE8Mj9GOmBvMmlfJHtlfSgke0Z9KWApLFU9W107aWYoYT49Milmb3IobGV0IEY9YS0xO0Y+PTA7Ri0tKVUucHVzaChgJHtjZShDLEYsYSl9ICogKGluZGljZXNbJHtGfV0pYCk7bGV0IE09YTwyP1wiXCI6YFxcbiAgZm4gaTJvXyR7ZX0oaW5kaWNlczogJHt3LmluZGljZXN9KSAtPiB1MzIge1xcbiAgICByZXR1cm4gJHtVLmpvaW4oXCIrXCIpfTtcXG4gIH1gLE49Rj0+KHYuaW5kaWNlc1RvT2Zmc2V0PSEwLGE8Mj9GOmBpMm9fJHtlfSgke0Z9KWApLFk9KC4uLkYpPT5hPT09MD9cIjB1XCI6YCR7dy5pbmRpY2VzfSgke0YubWFwKF8pLmpvaW4oXCIsXCIpfSlgLHNlPShGLGllKT0+YTwyP2Ake0Z9YDpgJHtjZShGLGllLGEpfWAsQj0oRixpZSxoZSk9PmE8Mj9gJHtGfT0ke2hlfTtgOmAke2NlKEYsaWUsYSl9PSR7aGV9O2AsdGU9e30sUGU9KEYsaWUpPT57di5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgaGU9YCR7aWUubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKGhlIGluIHRlKXJldHVybmAke2hlfSgke0Z9KWA7bGV0IFhlPVtdO2ZvcihsZXQgbnQ9YS0xO250Pj0wO250LS0pe2xldCBrZT1pZS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLG50K2llLnJhbmstYSk7WGUucHVzaChgJHtzZShDLG50KX0gKiAoJHtrZX0gJSAke3NlKFQsbnQpfSlgKX1yZXR1cm4gdGVbaGVdPWBmbiAke2hlfShvdXRwdXRJbmRpY2VzOiAke2llLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XFxuICAgICAgICAgICAgIHJldHVybiAke1hlLmxlbmd0aD4wP1hlLmpvaW4oXCIrXCIpOlwiMHVcIn07XFxuICAgICAgICAgICB9YCxgJHtoZX0oJHtGfSlgfSxFZT0oRixpZSk9PigoKT0+e2lmKHcuc3RvcmFnZT09PXcudmFsdWUpcmV0dXJuYCR7ZX1bJHtGfV09JHtpZX07YDtpZih3LnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZ3LnZhbHVlPT09XCJpMzJcIilyZXR1cm5gJHtlfVske0Z9XT12ZWMyPHUzMj4odTMyKCR7aWV9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHtpZX0gPCAwKSk7YDtpZih3LnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZ3LnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gJHtlfVske0Z9XT12ZWMyPHUzMj4odTMyKCR7aWV9KSwgMHUpO2A7aWYody5zdG9yYWdlPT09XCJ1MzJcIiYmdy52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmAke2V9WyR7Rn1dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7aWV9KSk7YDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7dy5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3cudmFsdWV9IHlldGApfSkoKSxlZT1GPT4oKCk9PntpZih3LnN0b3JhZ2U9PT13LnZhbHVlKXJldHVybmAke2V9WyR7Rn1dYDtpZih3LnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZ3LnZhbHVlPT09XCJpMzJcIilyZXR1cm5gaTMyKCR7ZX1bJHtGfV0ueClgO2lmKHcuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJncudmFsdWU9PT1cInUzMlwiKXJldHVybmB1MzIoJHtlfVske0Z9XS54KWA7aWYody5zdG9yYWdlPT09XCJ1MzJcIiYmdy52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmB2ZWM0PGJvb2w+KGJvb2woJHtlfVske0Z9XSAmIDB4RkZ1KSwgYm9vbCgke2V9WyR7Rn1dICYgMHhGRjAwdSksIGJvb2woJHtlfVske0Z9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtlfVske0Z9XSAmIDB4RkYwMDAwMDB1KSlgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt3LnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7dy52YWx1ZX0geWV0YCl9KSgpLGJlPWE8Mj9cIlwiOmBcXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7dy5pbmRpY2VzfSkgLT4gJHtkfSB7XFxuICAgIHJldHVybiAke2VlKGBpMm9fJHtlfShpbmRpY2VzKWApfTtcXG4gIH1gLE1lPWE8Mj9cIlwiOigoKT0+e2xldCBGPXAubWFwKGhlPT5gZCR7aGV9OiB1MzJgKS5qb2luKFwiLCBcIiksaWU9cC5tYXAoaGU9PmBkJHtoZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxcbiAgZm4gZ2V0XyR7ZX0oJHtGfSkgLT4gJHtkfSB7XFxuICAgIHJldHVybiBnZXRfJHtlfUJ5SW5kaWNlcygke1koaWUpfSk7XFxuICB9YH0pKCkscGU9KC4uLkYpPT57aWYoRi5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke2F9YCk7bGV0IGllPUYubWFwKF8pLmpvaW4oXCIsXCIpO3JldHVybiBhPT09MD9lZShcIjB1XCIpOmE9PT0xP2VlKGllWzBdKToodi5nZXQ9ITAsdi5nZXRCeUluZGljZXM9ITAsdi5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9KCR7aWV9KWApfSx5ZT1GPT5hPDI/ZWUoRik6KHYuZ2V0QnlJbmRpY2VzPSEwLHYuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfUJ5SW5kaWNlcygke0Z9KWApLGRlPWE8Mj9cIlwiOmBcXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7dy5pbmRpY2VzfSwgdmFsdWU6ICR7ZH0pIHtcXG4gICAgJHtFZShgaTJvXyR7ZX0oaW5kaWNlcylgLFwidmFsdWVcIil9XFxuICB9YCx3ZT1hPDI/XCJcIjooKCk9PntsZXQgRj1wLm1hcChoZT0+YGQke2hlfTogdTMyYCkuam9pbihcIiwgXCIpLGllPXAubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcXG4gIGZuIHNldF8ke2V9KCR7Rn0sIHZhbHVlOiAke2R9KSB7XFxuICAgIHNldF8ke2V9QnlJbmRpY2VzKCR7WShpZSl9LCB2YWx1ZSk7XFxuICB9YH0pKCk7cmV0dXJue2ltcGw6KCk9PntsZXQgRj1bXSxpZT0hMTtyZXR1cm4gdi5vZmZzZXRUb0luZGljZXMmJihGLnB1c2goRSksaWU9ITApLHYuaW5kaWNlc1RvT2Zmc2V0JiYoRi5wdXNoKE0pLGllPSEwKSx2LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0JiYoT2JqZWN0LnZhbHVlcyh0ZSkuZm9yRWFjaChoZT0+Ri5wdXNoKGhlKSksaWU9ITApLHYuc2V0JiYoRi5wdXNoKHdlKSxpZT0hMCksdi5zZXRCeUluZGljZXMmJihGLnB1c2goZGUpLGllPSEwKSx2LmdldCYmKEYucHVzaChNZSksaWU9ITApLHYuZ2V0QnlJbmRpY2VzJiYoRi5wdXNoKGJlKSxpZT0hMCksIXUmJmllJiZGLnVuc2hpZnQoYGNvbnN0ICR7VH0gPSAke3cuaW5kaWNlc30oJHtyLmpvaW4oXCIsXCIpfSk7YCxgY29uc3QgJHtDfSA9ICR7dy5pbmRpY2VzfSgke1cuY29tcHV0ZVN0cmlkZXMocikuam9pbihcIixcIil9KTtgKSxGLmpvaW4oYFxcbmApfSx0eXBlOncsb2Zmc2V0VG9JbmRpY2VzOk8saW5kaWNlc1RvT2Zmc2V0Ok4sYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6UGUsaW5kaWNlczpZLGluZGljZXNHZXQ6c2UsaW5kaWNlc1NldDpCLHNldDooLi4uRik9PntpZihGLmxlbmd0aCE9PWErMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHthfWApO2xldCBpZT1GW2FdO2lmKHR5cGVvZiBpZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgaGU9Ri5zbGljZSgwLGEpLm1hcChfKS5qb2luKFwiLFwiKTtyZXR1cm4gYT09PTA/RWUoXCIwdVwiLGllKTphPT09MT9FZShoZVswXSxpZSk6KHYuc2V0PSEwLHYuc2V0QnlJbmRpY2VzPSEwLHYuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke2hlfSwgJHtpZX0pYCl9LHNldEJ5T2Zmc2V0OkVlLHNldEJ5SW5kaWNlczooRixpZSk9PmE8Mj9FZShGLGllKToodi5zZXRCeUluZGljZXM9ITAsdi5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7Rn0sICR7aWV9KTtgKSxnZXQ6cGUsZ2V0QnlPZmZzZXQ6ZWUsZ2V0QnlJbmRpY2VzOnllLHVzYWdlOm8sbmFtZTplLHN0cmlkZXM6QyxzaGFwZTpULHJhbms6YX19LFY9KGUsdCxyLG89MSk9PiRvKGUsdCxyLFwiaW5wdXRcIixvKSxKPShlLHQscixvPTEpPT4kbyhlLHQscixcIm91dHB1dFwiLG8pLEFuPShlLHQscixvPTEpPT4kbyhlLHQscixcImludGVybmFsXCIsbyksd289Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cD10O3RoaXMuaW50ZXJuYWxWYXJpYWJsZXM9W107dGhpcy52YXJpYWJsZXM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD10ZCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLGk9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdLHU9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLGE9dT9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YDpgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmAscD11P1wibGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDsgbGV0IGxvY2FsX2lkeCA9IGxvY2FsX2lkLng7XCI6YGxldCBnbG9iYWxfaWR4ID0gKHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXFxuICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueCkgKiAke3IqbyppfXUgKyBsb2NhbF9pZHg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7cn0sICR7b30sICR7aX0pXFxuICBmbiBtYWluKCR7YX0pIHtcXG4gICAgJHtwfVxcbiAgYH1hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpe3QucmFuayE9PTAmJih0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pKX1kZWNsYXJlVmFyaWFibGUodCxyKXtpZih0LnVzYWdlPT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLnZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KTtsZXQgbz10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLGk9dC50eXBlLnN0b3JhZ2U7cmV0dXJuYEBncm91cCgwKSBAYmluZGluZygke3J9KSB2YXI8c3RvcmFnZSwgJHtvfT4gJHt0Lm5hbWV9OiBhcnJheTwke2l9PjtgfWRlY2xhcmVWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQubWFwKHI9PnRoaXMuZGVjbGFyZVZhcmlhYmxlKHIsdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKGBcXG5gKX1yZWdpc3RlckludGVybmFsVmFyaWFibGUodCl7aWYodC51c2FnZSE9PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuXCIpO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5mb3JFYWNoKHI9PnRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHIpKSx0aGlzfXJlZ2lzdGVyVW5pZm9ybSh0LHIsbz0xKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQsdHlwZTpyLGxlbmd0aDpvfSksdGhpc31yZWdpc3RlclVuaWZvcm1zKHQpe3JldHVybiB0aGlzLnVuaWZvcm1zPXRoaXMudW5pZm9ybXMuY29uY2F0KHQpLHRoaXN9dW5pZm9ybURlY2xhcmF0aW9uKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IHQ9W107Zm9yKGxldHtuYW1lOnIsdHlwZTpvLGxlbmd0aDppfW9mIHRoaXMudW5pZm9ybXMpaWYoaSYmaT40KW89PT1cImYxNlwiP3QucHVzaChgQGFsaWduKDE2KSAke3J9OmFycmF5PG1hdDJ4NDwke299PiwgJHtNYXRoLmNlaWwoaS84KX0+YCk6dC5wdXNoKGAke3J9OmFycmF5PHZlYzQ8JHtvfT4sICR7TWF0aC5jZWlsKGkvNCl9PmApO2Vsc2V7bGV0IHU9aT09bnVsbHx8aT09PTE/bzpgdmVjJHtpfTwke299PmA7dC5wdXNoKGAke3J9OiR7dX1gKX1yZXR1cm5gXFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2B9Z2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKXtyZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSt0aGlzLnZhcmlhYmxlcy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxcbmApK3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcXG5gKX19LHNhPWU9Pm5ldyB3byhlKSxjcj0oZSx0KT0+e2xldCByPWUubGVuZ3RoLG89W107Zm9yKGxldCBpPTA7aTxyO2krKyl7bGV0IHU9ci0xLWksYT1lW3VdfHwxOyh0W3QubGVuZ3RoLTEtaV18fDEpPjEmJmE9PT0xJiZvLnVuc2hpZnQodSl9cmV0dXJuIG99fSk7dmFyIHJkLHVhLG5kLG9kLHl0LGxhLGRhLHByPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1llKCk7X2UoKTtyZD1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIil9LHVhPShlLHQpPT50JiZ0Lmxlbmd0aCE9PWU/Wy4uLm5ldyBBcnJheShlKS5rZXlzKCldLnJldmVyc2UoKTp0LG5kPShlLHQpPT5XLnNvcnRCYXNlZE9uUGVybShlLHVhKGUubGVuZ3RoLHQpKSxvZD0oZSx0LHIsbyk9PntsZXQgaT1bXTtpLnB1c2goYGZuIHBlcm0oaTogJHtvLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcXG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2ApO2ZvcihsZXQgdT0wO3U8dDsrK3UpaS5wdXNoKHIuaW5kaWNlc1NldChcImFcIixlW3VdLGBpWyR7dX1dYCkpO3JldHVybiBpLnB1c2goXCJyZXR1cm4gYTt9XCIpLGkuam9pbihgXFxuYCl9LHl0PShlLHQpPT57bGV0IHI9ZS5kYXRhVHlwZSxvPWUuZGltcy5sZW5ndGgsaT11YShvLHQpLHU9bmQoZS5kaW1zLGkpLGE9SihcIm91dHB1dFwiLHIsdS5sZW5ndGgpLHA9VihcImFcIixyLG8pLG09aD0+YFxcbiAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhwLGEpfVxcblxcbiAgJHtvZChpLG8scCxhKX1cXG5cXG4gICR7aC5tYWluU3RhcnQoKX1cXG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cXG5cXG4gICAgbGV0IGluZGljZXMgPSAke2Eub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XFxuXFxuICAgICR7YS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixwLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cXG4gIH1gO3JldHVybntuYW1lOlwiVHJhbnNwb3NlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6aD0+e2xldCBkPVcuc2l6ZSh1KTtyZXR1cm57b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTpoWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOmR9LC4uLkcoaFswXS5kaW1zKSwuLi5HKHUpXX19LGdldFNoYWRlclNvdXJjZTptfX0sbGE9KGUsdCk9PntyZChlLmlucHV0cyksZS5jb21wdXRlKHl0KGUuaW5wdXRzWzBdLHQucGVybSkpfSxkYT1lPT54ZSh7cGVybTplLnBlcm19KX0pO3ZhciBpZCxhZCxzZCx1ZCxsZCxkZCxjZCxwZCxtZCxmZCwkdCxjYSxwYSxtYSxmYSxoYSxnYSx5YSxiYSx3YSx2YSwkYT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtfZSgpO0luKCk7cHIoKTtpZD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxhZD17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LHNkPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LHVkPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0sbGQ9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG89dC1lO288dDsrK28pci5wdXNoKG8pO3JldHVybiByfSxkZD0oZSx0KT0+e2xldCByPVtdLG89ZS5sZW5ndGg7Zm9yKGxldCB1PTA7dTxvO3UrKyl0LmluZGV4T2YodSk9PT0tMSYmci5wdXNoKGVbdV0pO2xldCBpPXQubWFwKHU9PmVbdV0pO3JldHVybltyLGldfSxjZD0oZSx0KT0+e2xldCByPWUubGVuZ3RoK3QubGVuZ3RoLG89W10saT0wO2ZvcihsZXQgdT0wO3U8cjt1KyspdC5pbmRleE9mKHUpPT09LTE/by5wdXNoKGVbaSsrXSk6by5wdXNoKDEpO3JldHVybiBvfSxwZD0oZSx0KT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKGVbZS5sZW5ndGgtci0xXSE9PXQtMS1yKXJldHVybiExO3JldHVybiEwfSxtZD0oZSx0KT0+e2xldCByPVtdO2lmKCFwZChlLHQpKXtmb3IobGV0IG89MDtvPHQ7KytvKWUuaW5kZXhPZihvKT09PS0xJiZyLnB1c2gobyk7ZS5mb3JFYWNoKG89PnIucHVzaChvKSl9cmV0dXJuIHJ9LGZkPShlLHQscixvLGksdSxhKT0+e2xldCBwPXJbMF0uZGltcyxtPVcuc2l6ZSh1KSxoPVcuc2l6ZShhKSxkPVYoXCJfQVwiLHJbMF0uZGF0YVR5cGUscCkseT1KKFwib3V0cHV0XCIsaSx1KSx3PTMyLF89YFxcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PCR7eS50eXBlLnN0b3JhZ2V9LCAke3d9PjtcXG4gICAgICAgYDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOng9PmBcXG4gICAgICAgICR7eC5yZWdpc3RlclVuaWZvcm0oXCJyZWR1Y2VTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhkLHkpfVxcbiAgICAgICAgJHtffVxcbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcXG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XFxuICAgICAgICAgfVxcbiAgICAgICAgICR7eC5tYWluU3RhcnQodyl9XFxuXFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke3d9O1xcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xcblxcbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gJHt5LnR5cGUuc3RvcmFnZX0oJHtzZFtvXX0pO1xcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcXG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke3d9KSB7XFxuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gJHt5LnR5cGUuc3RvcmFnZX0oJHtkLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtpZFtvXX07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHt3fXUpO1xcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XFxuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XFxuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XFxuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcXG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7YWRbb119O1xcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XFxuICAgICAgICAgICB9XFxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XFxuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgICAgICAgfVxcblxcbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcXG4gICAgICAgICAgJHt5LnNldEJ5T2Zmc2V0KFwib3V0cHV0SW5kZXhcIixgJHtvPT09XCJtZWFuXCI/YGJlc3RWYWx1ZSAvICR7eS50eXBlLnN0b3JhZ2V9KHVuaWZvcm1zLnJlZHVjZVNpemUpYDpgJHt1ZFtvXX1gfWApfTtcXG4gICAgICAgICB9XFxuICAgICAgICB9YCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6aX1dLGRpc3BhdGNoR3JvdXA6e3g6bX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6aH1dfSl9fSwkdD0oZSx0LHIsbyk9PntsZXQgaT1lLmlucHV0cy5sZW5ndGg9PT0xP3I6X28oZS5pbnB1dHMsciksdT1pLmF4ZXM7dS5sZW5ndGg9PT0wJiYhaS5ub29wV2l0aEVtcHR5QXhlcyYmKHU9ZS5pbnB1dHNbMF0uZGltcy5tYXAoKF8sdik9PnYpKTtsZXQgYT1XLm5vcm1hbGl6ZUF4ZXModSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCkscD1hLG09ZS5pbnB1dHNbMF0saD1tZChwLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtoLmxlbmd0aD4wJiYobT1lLmNvbXB1dGUoeXQoZS5pbnB1dHNbMF0saCkse2lucHV0czpbMF0sb3V0cHV0czpbLTFdfSlbMF0scD1sZChwLmxlbmd0aCxtLmRpbXMubGVuZ3RoKSk7bGV0W2QseV09ZGQobS5kaW1zLHApLHc9ZDtpLmtlZXBEaW1zJiYodz1jZChkLGEpKSxlLmNvbXB1dGUoZmQodCx7aGludDppLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LFttXSxvLGUuaW5wdXRzWzBdLmRhdGFUeXBlLHcseSkse2lucHV0czpbbV19KX0sY2E9KGUsdCk9PnskdChlLFwiUmVkdWNlTWVhblNoYXJlZFwiLHQsXCJtZWFuXCIpfSxwYT0oZSx0KT0+eyR0KGUsXCJSZWR1Y2VMMVNoYXJlZFwiLHQsXCJsMVwiKX0sbWE9KGUsdCk9PnskdChlLFwiUmVkdWNlTDJTaGFyZWRcIix0LFwibDJcIil9LGZhPShlLHQpPT57JHQoZSxcIlJlZHVjZUxvZ1N1bUV4cFNoYXJlZFwiLHQsXCJsb2dTdW1FeHBcIil9LGhhPShlLHQpPT57JHQoZSxcIlJlZHVjZU1heFNoYXJlZFwiLHQsXCJtYXhcIil9LGdhPShlLHQpPT57JHQoZSxcIlJlZHVjZU1pblNoYXJlZFwiLHQsXCJtaW5cIil9LHlhPShlLHQpPT57JHQoZSxcIlJlZHVjZVByb2RTaGFyZWRcIix0LFwicHJvZFwiKX0sYmE9KGUsdCk9PnskdChlLFwiUmVkdWNlU3VtU2hhcmVkXCIsdCxcInN1bVwiKX0sd2E9KGUsdCk9PnskdChlLFwiUmVkdWNlU3VtU3F1YXJlU2hhcmVkXCIsdCxcInN1bVNxdWFyZVwiKX0sdmE9KGUsdCk9PnskdChlLFwiUmVkdWNlTG9nU3VtU2hhcmVkXCIsdCxcImxvZ1N1bVwiKX19KTt2YXIgX3QsaGQsVG4sX28sU3QsZ2QseWQsYmQsd2QsdmQsJGQsX2QsU2QseGQsQ2QseHQsX2EsU2EseGEsQ2EsQWEsSWEsVGEsRWEsUGEsT2EsSW49USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7WWUoKTtfZSgpOyRhKCk7X3Q9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MiYmZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGVzIGlucHV0IGRpbXMuXCIpfSxoZD1lPT5bXCJcIixcIlwiLGB2YXIgdmFsdWUgPSAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSxUbj0oZSx0LHIsbyxpLHUsYT0hMSxwPSExKT0+e2xldCBtPVtdLGg9clswXS5kaW1zLGQ9aC5sZW5ndGgseT1XLm5vcm1hbGl6ZUF4ZXMoaSxkKSx3PSFwJiZ5Lmxlbmd0aD09PTA7aC5mb3JFYWNoKChULEMpPT57d3x8eS5pbmRleE9mKEMpPj0wP2EmJm0ucHVzaCgxKTptLnB1c2goVCl9KTtsZXQgXz1tLmxlbmd0aCx2PVcuc2l6ZShtKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOlQ9PntsZXQgQz1bXSxTPVYoXCJfQVwiLHJbMF0uZGF0YVR5cGUsZCksRT1KKFwib3V0cHV0XCIsdSxfKSxPPW8oUyxFLHkpLFU9T1syXTtmb3IobGV0IE09MCxOPTA7TTxkO00rKyl3fHx5LmluZGV4T2YoTSk+PTA/KGEmJk4rKyxVPWBmb3IodmFyIGoke019OiB1MzIgPSAwOyBqJHtNfSA8ICR7aFtNXX07IGoke019KyspIHtcXG4gICAgICAgICAgICAgICAgICAke09bMl0uaW5jbHVkZXMoXCJsYXN0X2luZGV4XCIpP2BsZXQgbGFzdF9pbmRleCA9IGoke019O2A6XCJcIn1cXG4gICAgICAgICAgICAgICAgICAke1MuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixNLGBqJHtNfWApfVxcbiAgICAgICAgICAgICAgICAgICR7VX1cXG4gICAgICAgICAgICAgICAgfWApOihDLnB1c2goYCR7Uy5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLE0sRS5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixOKSl9O2ApLE4rKyk7cmV0dXJuYFxcblxcbiAgICAgICAgJHtULnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhTLEUpfVxcblxcbiAgICAgICAgJHtULm1haW5TdGFydCgpfVxcbiAgICAgICAgICAke1QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtTLnR5cGUuaW5kaWNlc307XFxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7RS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgICAgICAgJHtDLmpvaW4oYFxcbmApfVxcbiAgICAgICAgICAke09bMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxcbiAgICAgICAgICAke09bMV19XFxuICAgICAgICAgICR7VX1cXG4gICAgICAgICAgJHtPWzNdfVxcbiAgICAgICAgICAke08ubGVuZ3RoPT09ND9FLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6Ty5zbGljZSg0KS5qb2luKGBcXG5gKX1cXG4gICAgICAgIH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6dX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHYvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOlwidWludDMyXCIsZGF0YTp2fSwuLi5HKGgpLC4uLkcobSldfSl9fSxfbz0oZSx0KT0+e2xldCByPVtdO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChvPT5yLnB1c2goTnVtYmVyKG8pKSkseGUoe2F4ZXM6cixrZWVwRGltczp0LmtlZXBEaW1zLG5vb3BXaXRoRW1wdHlBeGVzOnQubm9vcFdpdGhFbXB0eUF4ZXN9KX0sU3Q9KGUsdCxyLG8pPT57bGV0IGk9ZS5pbnB1dHMsdT1pLmxlbmd0aD09PTE/cjpfbyhpLHIpO2UuY29tcHV0ZShUbih0LHtoaW50OnUuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2lbMF1dLHUubm9vcFdpdGhFbXB0eUF4ZXMmJnUuYXhlcy5sZW5ndGg9PT0wP2hkOm8sdS5heGVzLGlbMF0uZGF0YVR5cGUsdS5rZWVwRGltcyx1Lm5vb3BXaXRoRW1wdHlBeGVzKSx7aW5wdXRzOlswXX0pfSxnZD0oZSx0KT0+e190KGUuaW5wdXRzKSxTdChlLFwiUmVkdWNlTG9nU3VtXCIsdCwobyxpKT0+W2B2YXIgdmFsdWUgPSAke2kudHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7by5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LHlkPShlLHQpPT57X3QoZS5pbnB1dHMpLFN0KGUsXCJSZWR1Y2VMMVwiLHQsKG8saSk9PltgdmFyIHZhbHVlID0gJHtpLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBhYnMoJHtvLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdKX0sYmQ9KGUsdCk9PntfdChlLmlucHV0cyksU3QoZSxcIlJlZHVjZUwyXCIsdCwobyxpKT0+W2B2YXIgdCA9ICR7aS50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtpLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7by5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFwidmFsdWUgPSBzcXJ0KHZhbHVlKTtcIl0pfSx3ZD0oZSx0KT0+e190KGUuaW5wdXRzKSxTdChlLFwiUmVkdWNlTG9nU3VtRXhwXCIsdCwobyxpKT0+W2B2YXIgdmFsdWUgPSAke2kudHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGV4cCgke28uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sdmQ9KGUsdCk9PntfdChlLmlucHV0cyksU3QoZSxcIlJlZHVjZU1heFwiLHQsKG8saSx1KT0+e2xldCBhPVtdO2ZvcihsZXQgcD0wO3A8by5yYW5rO3ArKykodS5pbmRleE9mKHApPj0wfHx1Lmxlbmd0aD09PTApJiZhLnB1c2goby5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHAsMCkpO3JldHVybltgJHthLmpvaW4oYFxcbmApfWAsYHZhciB2YWx1ZSA9ICR7by5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtvLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdfSl9LCRkPShlLHQpPT57X3QoZS5pbnB1dHMpLFN0KGUsXCJSZWR1Y2VNZWFuXCIsdCwobyxpLHUpPT57bGV0IGE9MTtmb3IobGV0IHA9MDtwPG8ucmFuaztwKyspKHUuaW5kZXhPZihwKT49MHx8dS5sZW5ndGg9PT0wKSYmKGEqPWUuaW5wdXRzWzBdLmRpbXNbcF0pO3JldHVybltcInZhciBzdW0gPSBmMzIoMCk7XCIsXCJcIixgc3VtICs9IGYzMigke28uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsYGxldCB2YWx1ZSA9ICR7aS50eXBlLnZhbHVlfShzdW0gLyAke2F9KTtgXX0pfSxfZD0oZSx0KT0+e190KGUuaW5wdXRzKSxTdChlLFwiUmVkdWNlTWluXCIsdCwobyxpLHUpPT57bGV0IGE9W107Zm9yKGxldCBwPTA7cDxvLnJhbms7cCsrKSh1LmluZGV4T2YocCk+PTB8fHUubGVuZ3RoPT09MCkmJmEucHVzaChgaW5wdXRfaW5kaWNlc1ske3B9XSA9IDA7YCk7cmV0dXJuW2Ake2Euam9pbihgXFxuYCl9YCxgdmFyIHZhbHVlID0gJHtvLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke28uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sU2Q9KGUsdCk9PntfdChlLmlucHV0cyksU3QoZSxcIlJlZHVjZVByb2RcIix0LChvLGkpPT5bYHZhciB2YWx1ZSA9ICR7aS50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtvLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSx4ZD0oZSx0KT0+e190KGUuaW5wdXRzKSxTdChlLFwiUmVkdWNlU3VtXCIsdCwobyxpKT0+W2B2YXIgdmFsdWUgPSAke2kudHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7by5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sQ2Q9KGUsdCk9PntfdChlLmlucHV0cyksU3QoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKG8saSk9PltgdmFyIHQgPSAke2kudHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7aS50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke28uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSx4dD0oZSx0LHIpPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiByO2xldCBvPTEsaT0xO2ZvcihsZXQgdT0wO3U8dC5sZW5ndGg7dSsrKXQuaW5kZXhPZih1KT09PS0xP28qPWVbdV06aSo9ZVt1XTtyZXR1cm4gaTwzMiYmbz4xMDI0fSxfYT0oZSx0KT0+e3h0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpPyRkKGUsdCk6Y2EoZSx0KX0sU2E9KGUsdCk9Pnt4dChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT95ZChlLHQpOnBhKGUsdCl9LHhhPShlLHQpPT57eHQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/YmQoZSx0KTptYShlLHQpfSxDYT0oZSx0KT0+e3h0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3dkKGUsdCk6ZmEoZSx0KX0sQWE9KGUsdCk9Pnt4dChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT92ZChlLHQpOmhhKGUsdCl9LElhPShlLHQpPT57eHQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/X2QoZSx0KTpnYShlLHQpfSxUYT0oZSx0KT0+e3h0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1NkKGUsdCk6eWEoZSx0KX0sRWE9KGUsdCk9Pnt4dChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT94ZChlLHQpOmJhKGUsdCl9LFBhPShlLHQpPT57eHQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q2QoZSx0KTp3YShlLHQpfSxPYT0oZSx0KT0+e3h0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2dkKGUsdCk6dmEoZSx0KX19KTt2YXIga2EsUmEsQmEsU28sRGE9USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7WWUoKTtJbigpO2thPWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkFyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LFJhPShlLHQpPT57a2EoZS5pbnB1dHMpO2xldCByPShvLGksdSk9PntsZXQgYT1bXTtmb3IobGV0IHA9MDtwPG8ucmFuaztwKyspKHUuaW5kZXhPZihwKT49MHx8dS5sZW5ndGg9PT0wKSYmYS5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7cH1dID0gMDtgKTtyZXR1cm5bYCR7YS5qb2luKGBcXG5gKX1gLGB2YXIgdmFsdWUgPSAke28uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XFxudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke28uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPD1cIjpcIjxcIn0gdmFsdWUpIHtcXG4gICAgICAgICB2YWx1ZSA9ICR7by5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcXG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xcbiAgICAgICB9YCxcIlwiLGkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKFRuKFwiQXJnTWluXCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLHIsW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxCYT0oZSx0KT0+e2thKGUuaW5wdXRzKTtsZXQgcj0obyxpLHUpPT57bGV0IGE9W107Zm9yKGxldCBwPTA7cDxvLnJhbms7cCsrKSh1LmluZGV4T2YocCk+PTB8fHUubGVuZ3RoPT09MCkmJmEucHVzaChgaW5wdXRfaW5kaWNlc1ske3B9XSA9IDA7YCk7cmV0dXJuW2Ake2Euam9pbihgXFxuYCl9YCxgdmFyIHZhbHVlID0gJHtvLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtvLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIj49XCI6XCI+XCJ9IHZhbHVlKSB7XFxuICAgICAgICAgdmFsdWUgPSAke28uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XFxuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcXG4gICAgICAgfWAsXCJcIixpLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShUbihcImFyZ01heFwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxyLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sU289ZT0+eGUoZSl9KTt2YXIgQWQsSWQsVGQsRWQsRW4sUGQsTWEseG89USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7JG4oKTtfZSgpO0FkPShlLHQpPT57bGV0IHI9ZVswXSxvPWVbMV0saT1lWzJdLHU9ZVszXSxhPWVbNF0scD1lWzVdO2lmKGEmJnApdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgcmVsYXRpdmVfcG9zaXRpb25fYmlhc1wiKTtpZihyLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnNcXCcpO2xldCBtPXIuZGltc1swXSxoPXIuZGltc1sxXSxkPXIuZGltc1syXTtpZihpLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcXCcpO2lmKG8uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcXCdJbnB1dCBcIndlaWdodHNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9uc1xcJyk7aWYoby5kaW1zWzBdIT09ZCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCAxIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAyIG9mIGlucHV0IDBcIik7aWYoaS5kaW1zWzBdIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihcXCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIlxcJyk7bGV0IHk9aS5kaW1zWzBdLzMsdz15LF89dztpZih0LnFrdkhpZGRlblNpemVzLmxlbmd0aD4wKXtpZih0LnFrdkhpZGRlblNpemVzLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBhdHRyaWJ1dGUgc2hvdWxkIGhhdmUgMyBlbGVtZW50c1wiKTtmb3IobGV0IEUgb2YgdC5xa3ZIaWRkZW5TaXplcylpZihFJXQubnVtSGVhZHMhPT0wKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSBudW1faGVhZHNcIik7eT10LnFrdkhpZGRlblNpemVzWzBdLHc9dC5xa3ZIaWRkZW5TaXplc1sxXSxfPXQucWt2SGlkZGVuU2l6ZXNbMl19bGV0IHY9aDtpZih5IT09dyl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIGZpcnN0IGVsZW1lbnQgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIHNlY29uZFwiKTtpZihpLmRpbXNbMF0hPT15K3crXyl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgc3VtIG9mIFEvSy9WIGhpZGRlbiBzaXplc1xcJyk7bGV0IHg9MDtpZihhKXtpZih3IT09Xyl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJwYXN0XCIgZXhwZWN0IGtfaGlkZGVuX3NpemUgPT0gdl9oaWRkZW5fc2l6ZVxcJyk7aWYoYS5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnNcXCcpO2lmKGEuZGltc1swXSE9PTIpdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDJcXCcpO2lmKGEuZGltc1sxXSE9PW0pdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwicGFzdFwiIHNlY29uZCBkaW1lbnNpb24gbXVzdCBiZSBiYXRjaF9zaXplXFwnKTtpZihhLmRpbXNbMl0hPT10Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcihcXCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHNcXCcpO2lmKGEuZGltc1s0XSE9PXcvdC5udW1IZWFkcyl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJwYXN0XCIgZmlmdGggZGltZW5zaW9uIG11c3QgYmUga19oaWRkZW5fc2l6ZSAvIG51bV9oZWFkc1xcJyk7dC5wYXN0UHJlc2VudFNoYXJlQnVmZmVyfHwoeD1hLmRpbXNbM10pfWxldCBUPXYreCxDPS0xLFM9MDtpZih1KXRocm93IG5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKTtpZihhKXRocm93IG5ldyBFcnJvcihcInBhc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihwKXRocm93IG5ldyBFcnJvcihcInJlbGF0aXZlUG9zaXRpb25CaWFzIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJue2JhdGNoU2l6ZTptLHNlcXVlbmNlTGVuZ3RoOmgscGFzdFNlcXVlbmNlTGVuZ3RoOngsa3ZTZXF1ZW5jZUxlbmd0aDp2LHRvdGFsU2VxdWVuY2VMZW5ndGg6VCxtYXhTZXF1ZW5jZUxlbmd0aDpDLGlucHV0SGlkZGVuU2l6ZTpkLGhpZGRlblNpemU6eSx2SGlkZGVuU2l6ZTpfLGhlYWRTaXplOk1hdGguZmxvb3IoeS90Lm51bUhlYWRzKSx2SGVhZFNpemU6TWF0aC5mbG9vcihfL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpTLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6ITEscWt2Rm9ybWF0OjF9fSxJZD0oZSx0LHIsbyk9PntsZXQgaT1IZShvKSx1PTY0LGE9by9pO2E8dT91PTE6YS84PDY0JiYodT1NYXRoLmNlaWwoYS84KSk7bGV0IHA9TWF0aC5jZWlsKG8vaS91KSxoPVt7dHlwZTpzdCh0LmRhdGFUeXBlKSxkYXRhOjEvb30se3R5cGU6XCJ1aW50MzJcIixkYXRhOmF9LHt0eXBlOlwidWludDMyXCIsZGF0YTpwfV0sZD1OZSh0LmRhdGFUeXBlLGkpLHk9dz0+e2xldCBfPUooXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMsaSksdj1cInRocmVhZF9tYXhfdmVjdG9yXCI7aT09PTI/dj1cIm1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KVwiOmk9PT00JiYodj1cIm1heChtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSksIG1heCh0aHJlYWRfbWF4X3ZlY3Rvci56LCB0aHJlYWRfbWF4X3ZlY3Rvci53KSlcIik7bGV0IHg9aHQodC5kYXRhVHlwZSksVD1be25hbWU6XCJkX2ludlwiLHR5cGU6eH0se25hbWU6XCJkX2NvbXBcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZWxlbWVudHNfcGVyX3dnXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxcbiAgdmFyPHdvcmtncm91cD4gd2dNYXg6IGFycmF5PGYzMiwgJHt1fT47XFxuICB2YXI8d29ya2dyb3VwPiB3Z1N1bTogYXJyYXk8ZjMyLCAke3V9PjtcXG4gICR7dy5yZWdpc3RlclVuaWZvcm1zKFQpLmRlY2xhcmVWYXJpYWJsZXMoXyl9XFxuICAke3cubWFpblN0YXJ0KFt1LDEsMV0pfVxcbiAgICBsZXQgbG9jYWxPZmZzZXQgPSBsb2NhbF9pZHggKiB1bmlmb3Jtcy5lbGVtZW50c19wZXJfd2c7XFxuICAgIGxldCBvZmZzZXQ6IHUzMiA9IHdvcmtncm91cF9pZC54ICogdW5pZm9ybXMuZF9jb21wICsgbG9jYWxPZmZzZXQ7XFxuXFxuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7WmUoXCJmMzJcIixpLFwiLTMuNDAyODIzZSszOGZcIil9O1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3dnICYmIGkgKyBsb2NhbE9mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XFxuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHtndCh4LGksXCJ4W29mZnNldCArIGldXCIpfSwgdGhyZWFkX21heF92ZWN0b3IpO1xcbiAgICB9XFxuICAgIHdnTWF4W2xvY2FsX2lkeF0gPSAke3Z9O1xcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgIHZhciBtYXhWYWx1ZSA9IC0zLjQwMjgyM2UrMzhmO1xcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3V9OyBpKyspIHtcXG4gICAgICBtYXhWYWx1ZSA9IG1heCh3Z01heFtpXSwgbWF4VmFsdWUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBzdW1WZWN0b3IgPSAke1plKFwiZjMyXCIsaSxcIjBcIil9O1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3dnICYmIGkgKyBsb2NhbE9mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XFxuICAgICAgc3VtVmVjdG9yICs9IGV4cCgke2d0KHgsaSxcInhbb2Zmc2V0ICsgaV1cIil9IC0gbWF4VmFsdWUpO1xcbiAgICB9XFxuICAgIHdnU3VtW2xvY2FsX2lkeF0gPSAke3V0KFwic3VtVmVjdG9yXCIsaSl9O1xcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgIHZhciBzdW06IGYzMiA9IDA7XFxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7dX07IGkrKykge1xcbiAgICAgIHN1bSArPSB3Z1N1bVtpXTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3VtID09IDApIHtcXG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3dnICYmIGkgKyBsb2NhbE9mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XFxuICAgICAgICB4W29mZnNldCArIGldID0gJHtaZSh4LGksXCJ1bmlmb3Jtcy5kX2ludlwiKX07XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfd2cgJiYgaSArIGxvY2FsT2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcXG4gICAgICAgIGxldCBmMzJpbnB1dCA9ICR7Z3QoeCxpLFwieFtvZmZzZXQgKyBpXVwiKX07XFxuICAgICAgICB4W29mZnNldCArIGldID0gJHtfLnR5cGUudmFsdWV9KGV4cChmMzJpbnB1dCAtIG1heFZhbHVlKSAvIHN1bSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiQXR0ZW50aW9uUHJvYnNTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dX07JHtkfTske2l9YH0sZ2V0U2hhZGVyU291cmNlOnksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltdLGRpc3BhdGNoR3JvdXA6e3g6cn0scHJvZ3JhbVVuaWZvcm1zOmh9KX0se2lucHV0czpbdF0sb3V0cHV0czpbXX0pfSxUZD0oZSx0LHIsbyxpLHUpPT57bGV0IGE9W2kuYmF0Y2hTaXplLGkubnVtSGVhZHMsaS5zZXF1ZW5jZUxlbmd0aCxpLmt2U2VxdWVuY2VMZW5ndGgraS5wYXN0U2VxdWVuY2VMZW5ndGhdLHA9dS5zY2FsZT09PTA/MS9NYXRoLnNxcnQoaS5oZWFkU2l6ZSk6dS5zY2FsZSxtPUhlKGkuaGVhZFNpemUpLGg9aS5oZWFkU2l6ZS9tLGQ9MTIseT17eDpNYXRoLmNlaWwoaS50b3RhbFNlcXVlbmNlTGVuZ3RoL2QpLHk6TWF0aC5jZWlsKGkuc2VxdWVuY2VMZW5ndGgvZCksejppLmJhdGNoU2l6ZSppLm51bUhlYWRzfSx3PXN0KHQuZGF0YVR5cGUpLF89W3t0eXBlOlwidWludDMyXCIsZGF0YTppLnNlcXVlbmNlTGVuZ3RofSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6aH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOmkudG90YWxTZXF1ZW5jZUxlbmd0aH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOmkua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6dyxkYXRhOnB9XSx2PVt0LHJdLHg9Qz0+e2xldCBTPVYoXCJxXCIsdC5kYXRhVHlwZSx0LmRpbXMsbSksRT1WKFwia2V5XCIsci5kYXRhVHlwZSxyLmRpbXMsbSksTz1KKFwib3V0cHV0XCIsdC5kYXRhVHlwZSxhKSxVPU5lKHQuZGF0YVR5cGUpLE09W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia3Zfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpVfV07cmV0dXJuYFxcbiAgY29uc3QgYmV0YTogJHtVfSA9IDEuMDtcXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7ZH11O1xcblxcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7Uy50eXBlLnN0b3JhZ2V9LCAke2QqZH0+O1xcbiAgdmFyPHdvcmtncm91cD4gdGlsZUs6IGFycmF5PCR7Uy50eXBlLnN0b3JhZ2V9LCAke2QqZH0+O1xcbiAgJHtDLnJlZ2lzdGVyVW5pZm9ybXMoTSkuZGVjbGFyZVZhcmlhYmxlcyhTLEUsTyl9XFxuICAke0MubWFpblN0YXJ0KFtkLGQsMV0pfVxcbiAgICAvLyB4IGhvbGRzIHRoZSBOIGFuZCB5IGhvbGRzIHRoZSBNXFxuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLno7XFxuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XFxuICAgIGxldCBuID0gd29ya2dyb3VwX2lkLnggKiBUSUxFX1NJWkU7XFxuICAgIGxldCBsbSA9IG0gKyBsb2NhbF9pZC55O1xcbiAgICBsZXQgbG4gPSBuICsgbG9jYWxfaWQueDtcXG5cXG4gICAgbGV0IHFPZmZzZXQgPSB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyAqIGhlYWRJZHggKyBtICogdW5pZm9ybXMuSztcXG4gICAgbGV0IGtPZmZzZXQgPSB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LICogaGVhZElkeCArIG4gKiB1bmlmb3Jtcy5LO1xcblxcbiAgICB2YXIgdmFsdWUgPSAke1plKFUsbSl9O1xcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XFxuICAgICAgaWYgKG0gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcXG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xcbiAgICAgIH1cXG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xcbiAgICAgICAgdGlsZUtbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0ga2V5W2tPZmZzZXQgKyBsb2NhbF9pZC55ICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcXG4gICAgICB9XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcXG4gICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXTtcXG4gICAgICB9XFxuXFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICB9XFxuXFxuICAgIGxldCBoZWFkT2Zmc2V0ID0gaGVhZElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xcbiAgICBpZiAobG0gPCB1bmlmb3Jtcy5NICYmIGxuIDwgdW5pZm9ybXMuTikge1xcbiAgICAgIGxldCBvdXRwdXRJZHggPSBoZWFkT2Zmc2V0ICsgbG0gKiB1bmlmb3Jtcy5OICsgbG47XFxuICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke3V0KFwidmFsdWVcIixtKX0gKiB1bmlmb3Jtcy5hbHBoYTtcXG4gICAgfVxcbiAgfWB9LFQ9ZS5jb21wdXRlKHtuYW1lOlwiQXR0ZW50aW9uUHJvYnNcIixzaGFkZXJDYWNoZTp7aGludDpgJHttfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6eSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp4fSx7aW5wdXRzOnYsb3V0cHV0czpbLTFdfSlbMF07cmV0dXJuIElkKGUsVCxpLmJhdGNoU2l6ZSppLm51bUhlYWRzKmkuc2VxdWVuY2VMZW5ndGgsaS50b3RhbFNlcXVlbmNlTGVuZ3RoKSxUfSxFZD0oZSx0LHIsbyk9PntsZXQgaT1bby5iYXRjaFNpemUsby5zZXF1ZW5jZUxlbmd0aCxvLnZIaWRkZW5TaXplXSx1PTEyLGE9e3g6TWF0aC5jZWlsKG8udkhlYWRTaXplL3UpLHk6TWF0aC5jZWlsKG8uc2VxdWVuY2VMZW5ndGgvdSksejpvLmJhdGNoU2l6ZSpvLm51bUhlYWRzfSxwPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6by5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOm8udG90YWxTZXF1ZW5jZUxlbmd0aH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOm8udkhlYWRTaXplfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6by5udW1IZWFkc30se3R5cGU6XCJ1aW50MzJcIixkYXRhOm8udkhpZGRlblNpemV9XSxtPWg9PntsZXQgZD1WKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcykseT1WKFwidlwiLHIuZGF0YVR5cGUsci5kaW1zKSx3PUooXCJvdXRwdXRcIix0LmRhdGFUeXBlLGkpLF89W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInZfaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3V9dTtcXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke2QudHlwZS52YWx1ZX0sICR7dSp1fT47XFxuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtkLnR5cGUudmFsdWV9LCAke3UqdX0+O1xcbiAgJHtoLnJlZ2lzdGVyVW5pZm9ybXMoXykuZGVjbGFyZVZhcmlhYmxlcyhkLHksdyl9XFxuICAke2gubWFpblN0YXJ0KFt1LHUsMV0pfVxcbiAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLno7XFxuICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRSArIGxvY2FsX2lkLnk7XFxuICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRSArIGxvY2FsX2lkLng7XFxuXFxuICAgbGV0IG9mZnNldEEgPSBoZWFkSWR4ICogKHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LKSArIG0gKiB1bmlmb3Jtcy5LO1xcbiAgIGxldCBvZmZzZXRCID0gaGVhZElkeCAqICh1bmlmb3Jtcy5OICogdW5pZm9ybXMuSykgKyBuO1xcblxcbiAgIHZhciB2YWx1ZSA9ICR7ZC50eXBlLnN0b3JhZ2V9KDApO1xcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcXG4gICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcXG4gICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcXG4gICAgIH1cXG4gICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcXG4gICAgICAgdGlsZUtbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gdltvZmZzZXRCICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xcbiAgICAgfVxcbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8VElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xcbiAgICAgICB2YWx1ZSArPSB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueF07XFxuICAgICB9XFxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgfVxcblxcbiAgIC8vIHdlIG5lZWQgdG8gdHJhbnNwb3NlIG91dHB1dCBmcm9tIEJOU0hfdiB0byBCU05EX3ZcXG4gICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcXG4gICBsZXQgY3VycmVudEJhdGNoSGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xcbiAgIGxldCBoZWFkT2Zmc2V0ID0gKGJhdGNoSWR4ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLm51bV9oZWFkcyArIGN1cnJlbnRCYXRjaEhlYWROdW1iZXIpICogdW5pZm9ybXMuTjtcXG4gICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcXG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKnVuaWZvcm1zLnZfaGlkZGVuX3NpemUgKyBtICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZVxcbiAgICAgICArIGN1cnJlbnRCYXRjaEhlYWROdW1iZXIgKiB1bmlmb3Jtcy5OICsgbjtcXG4gICAgIG91dHB1dFtvdXRwdXRJZHhdID0gdmFsdWU7XFxuICAgfVxcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJBdHRlbnRpb25TY29yZVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDphLHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOm19LHtpbnB1dHM6W3Qscl0sb3V0cHV0czpbMF19KVswXX0sRW49KGUsdCxyLG8saSx1LGEscCxtLGgsZCk9PntsZXQgeT1UZChlLHQscixtLGgsZCk7RWQoZSx5LG8saCl9LFBkPShlLHQpPT57bGV0IHI9W3QuYmF0Y2hTaXplLHQubnVtSGVhZHMsdC5zZXF1ZW5jZUxlbmd0aCx0LmhlYWRTaXplXSxvPXQuc2VxdWVuY2VMZW5ndGgsaT10LmlucHV0SGlkZGVuU2l6ZSx1PXQuaGVhZFNpemUsYT0xMixwPXt4Ok1hdGguY2VpbCh0LmhlYWRTaXplL2EpLHk6TWF0aC5jZWlsKHQuc2VxdWVuY2VMZW5ndGgvYSksejp0LmJhdGNoU2l6ZSp0Lm51bUhlYWRzfSxtPVtlLmlucHV0c1swXSxlLmlucHV0c1sxXSxlLmlucHV0c1syXV0saD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOm99LHt0eXBlOlwidWludDMyXCIsZGF0YTppfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnQubnVtSGVhZHN9LHt0eXBlOlwidWludDMyXCIsZGF0YTp0LmhlYWRTaXplfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5oaWRkZW5TaXplfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5oaWRkZW5TaXplK3QuaGlkZGVuU2l6ZSt0LnZIaWRkZW5TaXplfV0sZD15PT57bGV0IHc9SihcIm91dHB1dF9xXCIsbVswXS5kYXRhVHlwZSxyKSxfPUooXCJvdXRwdXRfa1wiLG1bMF0uZGF0YVR5cGUsciksdj1KKFwib3V0cHV0X3ZcIixtWzBdLmRhdGFUeXBlLHIpLHg9VihcImlucHV0XCIsbVswXS5kYXRhVHlwZSxtWzBdLmRpbXMpLFQ9VihcIndlaWdodFwiLG1bMV0uZGF0YVR5cGUsbVsxXS5kaW1zKSxDPVYoXCJiaWFzXCIsbVsyXS5kYXRhVHlwZSxtWzJdLmRpbXMpLFM9eC50eXBlLnN0b3JhZ2UsRT1be25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGVhZF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImxkYlwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7YX11O1xcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke1N9LCAke2EqYX0+O1xcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFE6IGFycmF5PCR7U30sICR7YSphfT47XFxuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0SzogYXJyYXk8JHtTfSwgJHthKmF9PjtcXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke1N9LCAke2EqYX0+O1xcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybXMoRSkuZGVjbGFyZVZhcmlhYmxlcyh4LFQsQyx3LF8sdil9XFxuICAke3kubWFpblN0YXJ0KFthLGEsMV0pfVxcbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xcbiAgICBsZXQgaGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xcbiAgICBsZXQgbSA9IHdvcmtncm91cF9pZC55ICogVElMRV9TSVpFICsgbG9jYWxfaWQueTtcXG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRSArIGxvY2FsX2lkLng7XFxuXFxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJhdGNoSW5kZXggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XFxuICAgIGxldCBiaWFzT2Zmc2V0USA9IGhlYWROdW1iZXIgKiB1bmlmb3Jtcy5oZWFkX3NpemU7XFxuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XFxuICAgIGxldCBiaWFzT2Zmc2V0ViA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldEs7XFxuXFxuICAgIHZhciB2YWx1ZVEgPSAke1N9KDApO1xcbiAgICB2YXIgdmFsdWVLID0gJHtTfSgwKTtcXG4gICAgdmFyIHZhbHVlViA9ICR7U30oMCk7XFxuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcXG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XFxuICAgICAgICB0aWxlSW5wdXRbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gaW5wdXRbaW5wdXRPZmZzZXQgKyB3ICsgbG9jYWxfaWQueF07XFxuICAgICAgfVxcbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcXG4gICAgICAgIGxldCBvZmZzZXQgPSBuICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLmxkYjtcXG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XFxuICAgICAgICB0aWxlV2VpZ2h0S1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldEsgKyBvZmZzZXRdO1xcbiAgICAgICAgdGlsZVdlaWdodFZbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRWICsgb2Zmc2V0XTtcXG4gICAgICB9XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcXG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcXG4gICAgICAgIGxldCB3ZWlnaHRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogayArIGxvY2FsX2lkLng7XFxuICAgICAgICB2YWx1ZVEgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0UVt3ZWlnaHRUaWxlT2Zmc2V0XTtcXG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xcbiAgICAgICAgdmFsdWVWICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFZbd2VpZ2h0VGlsZU9mZnNldF07XFxuICAgICAgfVxcblxcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgfVxcblxcbiAgICBsZXQgaGVhZE9mZnNldCA9IChtICogdW5pZm9ybXMuTiArIG4pICUgdW5pZm9ybXMuaGVhZF9zaXplO1xcbiAgICB2YWx1ZVEgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFFdO1xcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xcbiAgICB2YWx1ZVYgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFZdO1xcblxcbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcXG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XFxuICAgICAgbGV0IG91dHB1dElkeCA9IG9mZnNldCArIG0gKiB1bmlmb3Jtcy5OICsgbjtcXG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xcbiAgICAgIG91dHB1dF9rW291dHB1dElkeF0gPSB2YWx1ZUs7XFxuICAgICAgb3V0cHV0X3Zbb3V0cHV0SWR4XSA9IHZhbHVlVjtcXG4gICAgfVxcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJBdHRlbnRpb25QcmVwYXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSx7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6cCxwcm9ncmFtVW5pZm9ybXM6aH0pLGdldFNoYWRlclNvdXJjZTpkfSx7aW5wdXRzOm0sb3V0cHV0czpbLTEsLTEsLTFdfSl9LE1hPShlLHQpPT57bGV0IHI9QWQoZS5pbnB1dHMsdCksW28saSx1XT1QZChlLHIpO3JldHVybiBFbihlLG8saSx1LGUuaW5wdXRzWzRdLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGUuaW5wdXRzWzVdLHIsdCl9fSk7dmFyIE9kLGtkLFJkLHphLFVhPVEoKCk9PntcInVzZSBzdHJpY3RcIjtkcigpO0NlKCk7WWUoKTtfZSgpO09kPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHNcIik7bGV0IHI9KG8saSx1KT0+e2xldCBhPWkubGVuZ3RoO2lmKGEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYCR7dX06IG51bSBkaW1lbnNpb25zICE9ICR7YX1gKTtpLmZvckVhY2goKHAsbSk9PntpZihwIT09b1ttXSl0aHJvdyBuZXcgRXJyb3IoYCR7dX06IGRpbVske219XSBkbyBub3QgbWF0Y2hgKX0pfTtpZihlWzBdLmRpbXMubGVuZ3RoPjEpe2xldCBvPXQuZm9ybWF0PT09XCJOSFdDXCI/dC5zcGF0aWFsP2VbMF0uZGltcy5zbGljZSgtMSk6ZVswXS5kaW1zLnNsaWNlKC0xKS5jb25jYXQoZVswXS5kaW1zLnNsaWNlKDEsZVswXS5kaW1zLmxlbmd0aC0xKSk6ZVswXS5kaW1zLnNsaWNlKDEsdC5zcGF0aWFsPzI6dm9pZCAwKTtyKGVbMV0uZGltcyxvLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxyKGVbMl0uZGltcyxvLFwiSW52YWxpZCBpbnB1dCBCXCIpLHIoZVszXS5kaW1zLG8sXCJJbnZhbGlkIGlucHV0IG1lYW5cIikscihlWzRdLmRpbXMsbyxcIkludmFsaWQgaW5wdXQgdmFyXCIpfWVsc2UgcihlWzFdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxyKGVbMl0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IEJcIikscihlWzNdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLHIoZVs0XS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgdmFyXCIpfSxrZD0oZSx0KT0+e2xldHtlcHNpbG9uOnIsc3BhdGlhbDpvLGZvcm1hdDppfT10LHU9ZVswXS5kaW1zLGE9bz9IZSh1W3UubGVuZ3RoLTFdKToxLHA9aT09PVwiTkhXQ1wiJiZ1Lmxlbmd0aD4xP2E6MSxtPVcuc2l6ZSh1KS9hLGg9byxkPWg/dS5sZW5ndGg6dSx5PVYoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsYSksdz1WKFwic2NhbGVcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyxwKSxfPVYoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMscCksdj1WKFwiaW5wdXRNZWFuXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMscCkseD1WKFwiaW5wdXRWYXJcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcyxwKSxUPUooXCJ5XCIsZVswXS5kYXRhVHlwZSxkLGEpLEM9KCk9PntsZXQgRT1cIlwiO2lmKG8pRT1gbGV0IGNPZmZzZXQgPSAke3UubGVuZ3RoPT09MT9cIjB1XCI6aT09PVwiTkhXQ1wiP2BvdXRwdXRJbmRpY2VzWyR7dS5sZW5ndGgtMX1dIC8gJHthfWA6XCJvdXRwdXRJbmRpY2VzWzFdXCJ9O2A7ZWxzZSBpZihpPT09XCJOQ0hXXCIpRT1gXFxuICAgICAgICAgICAgJHtULmluZGljZXNTZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCIwXCIsXCIwXCIpfVxcbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHtULmluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIil9O2A7ZWxzZXtFPWB2YXIgY0luZGljZXMgPSAke3cudHlwZS5pbmRpY2VzfSgwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgIGNJbmRpY2VzWzBdID0gb3V0cHV0SW5kaWNlc1ske3UubGVuZ3RoLTF9XTtgO2ZvcihsZXQgTz0xO088dy5yYW5rO08rKylFKz1gY0luZGljZXNbJHtPfV0gPSBvdXRwdXRJbmRpY2VzWyR7T31dO2A7RSs9YGxldCBjT2Zmc2V0ID0gJHt3LmluZGljZXNUb09mZnNldChcImNJbmRpY2VzXCIpfTtgfXJldHVybiBFfSxTPUU9PmBcXG4gIGNvbnN0IGVwc2lsb24gPSAke3J9O1xcbiAgJHtFLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHksdyxfLHYseCxUKX1cXG4gICR7RS5tYWluU3RhcnQoKX1cXG4gICR7RS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cXG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke1Qub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHthfWApfTtcXG4gICAgJHtDKCl9XFxuICAgIGxldCBzY2FsZSA9ICR7dy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xcbiAgICBsZXQgYmlhcyA9ICR7Xy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xcbiAgICBsZXQgaW5wdXRNZWFuID0gJHt2LmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XFxuICAgIGxldCBpbnB1dFZhciA9ICR7eC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xcbiAgICBsZXQgeCA9ICR7eS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xcbiAgICBsZXQgdmFsdWUgPSAoeCAtIGlucHV0TWVhbikgKiBpbnZlcnNlU3FydChpbnB1dFZhciArIGVwc2lsb24pICogc2NhbGUgKyBiaWFzO1xcbiAgICAke1Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cXG4gIH1gO3JldHVybntuYW1lOlwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5lcHNpbG9ufV8ke3QuZm9ybWF0fV8ke299XyR7YX1gLGlucHV0RGVwZW5kZW5jaWVzOmg/W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXTp2b2lkIDB9LGdldFNoYWRlclNvdXJjZTpTLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmg/W3t0eXBlOlwidWludDMyXCIsZGF0YTptfSwuLi5HKHUpXTpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOm19XX0pfX0sUmQ9ZT0+eGUoZSksemE9KGUsdCk9PntsZXR7aW5wdXRzOnIsb3V0cHV0Q291bnQ6b309ZSxpPVJkKHsuLi50LG91dHB1dENvdW50Om99KTtpZihsci53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJk9kKHIsaSksdC50cmFpbmluZ01vZGUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHRyYWluaW5nTW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7ZS5jb21wdXRlKGtkKHIsaSkpfX0pO3ZhciBCZCxEZCxWYSxXYT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtfZSgpO0JkPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVszMjAsNjQwLDEyODBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIG9mIGNoYW5uZWxzIHNob3VsZCBiZSAzMjAsIDY0MCBvciAxMjgwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LERkPWU9PntsZXQgdD1lWzBdLmRpbXMscj1lWzBdLmRpbXNbMl0sbz1XLnNpemUodCkvNCxpPWVbMF0uZGF0YVR5cGUsdT1WKFwiaW5wdXRcIixpLHQsNCksYT1WKFwiYmlhc1wiLGksW3JdLDQpLHA9VihcInJlc2lkdWFsXCIsaSx0LDQpLG09SihcIm91dHB1dFwiLGksdCw0KTtyZXR1cm57bmFtZTpcIkJpYXNBZGRcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfX0pLGdldFNoYWRlclNvdXJjZTpkPT5gXFxuICBjb25zdCBjaGFubmVscyA9ICR7cn11IC8gNDtcXG4gICR7ZC5kZWNsYXJlVmFyaWFibGVzKHUsYSxwLG0pfVxcblxcbiAgJHtkLm1haW5TdGFydCgpfVxcbiAgICAke2QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvKX1cXG4gICAgbGV0IHZhbHVlID0gJHt1LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX1cXG4gICAgICArICR7YS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSBjaGFubmVsc1wiKX0gKyAke3AuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgJHttLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XFxuICB9YH19LFZhPWU9PntCZChlLmlucHV0cyksZS5jb21wdXRlKERkKGUuaW5wdXRzKSl9fSk7dmFyIE1kLFRlLE5hLEhhLEdhLExhLEZhLGphLHFhLEthLFlhLHpkLFphLFhhLEphLFFhLFBuLGVzLE9uLHRzLHJzLG5zLG9zLGlzLGFzLHNzLHVzLGxzLGRzLGNzLHBzLG1zLGZzLGhzLGdzLHlzLGJzLHdzLENvPVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7WWUoKTtfZSgpO01kPShlLHQscixvLGksdSk9PntsZXQgYT1NYXRoLmNlaWwodC80KSxwPVwiXCI7dHlwZW9mIGk9PVwic3RyaW5nXCI/cD1gJHtpfShhKWA6cD1pKFwiYVwiKTtsZXQgbT1WKFwiaW5wdXREYXRhXCIscixbYV0sNCksaD1KKFwib3V0cHV0RGF0YVwiLG8sW2FdLDQpO3JldHVybmBcXG4gICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0saCl9XFxuXFxuICAke3U/P1wiXCJ9XFxuXFxuICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XFxuXFxuICAgIGxldCBhID0gJHttLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICR7aC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixwKX1cXG4gIH1gfSxUZT0oZSx0LHIsbyxpLHU9ZS5kYXRhVHlwZSk9Pih7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50OmksaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOmE9Pk1kKGEsVy5zaXplKGUuZGltcyksZS5kYXRhVHlwZSx1LHIsbyksZ2V0UnVuRGF0YTphPT4oe291dHB1dHM6W3tkaW1zOmUuZGltcyxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoVy5zaXplKGFbMF0uZGltcykvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOk1hdGguY2VpbChXLnNpemUoZS5kaW1zKS80KX1dfSl9KSxOYT1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiQWJzXCIsXCJhYnNcIikpfSxIYT1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiQWNvc1wiLFwiYWNvc1wiKSl9LEdhPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJBY29zaFwiLFwiYWNvc2hcIikpfSxMYT1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiQXNpblwiLFwiYXNpblwiKSl9LEZhPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJBc2luaFwiLFwiYXNpbmhcIikpfSxqYT1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiQXRhblwiLFwiYXRhblwiKSl9LHFhPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJBdGFuaFwiLFwiYXRhbmhcIikpfSxLYT1lPT54ZShlKSxZYT0oZSx0KT0+e2xldCByO3N3aXRjaCh0LnRvKXtjYXNlIDEwOnI9XCJ2ZWM0PGYxNj5cIjticmVhaztjYXNlIDE6cj1cInZlYzQ8ZjMyPlwiO2JyZWFrO2Nhc2UgMTI6cj1cInZlYzQ8dTMyPlwiO2JyZWFrO2Nhc2UgNjpyPVwidmVjNDxpMzI+XCI7YnJlYWs7Y2FzZSA5OnI9XCJ2ZWM0PGJvb2w+XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlIFxcJ3RvXFwnIGZyb20gXFwnQ2FzdFxcJyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJDYXN0XCIscix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LHpkPWU9PntsZXQgdD1lLmxlbmd0aD49MiYmZVsxXS5kYXRhIT09MD9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOnhuLHI9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YSE9PTA/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTpDbjtyZXR1cm4geGUoe21pbjp0LG1heDpyfSl9LFphPShlLHQpPT57bGV0IHI9ZS5pbnB1dHMubGVuZ3RoPT09MT90OnpkKGUuaW5wdXRzKSxvPWh0KGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsaT0+YGNsYW1wKCR7aX0sIGNsaXBfbWluXywgY2xpcF9tYXhfKWAsYFxcbiAgICBjb25zdCBjbGlwX21pbl86IHZlYzQ8JHtvfT4gPSB2ZWM0KCR7b30oJHtyLm1pbn0pKTtcXG4gICAgY29uc3QgY2xpcF9tYXhfOiB2ZWM0PCR7b30+ID0gdmVjNCgke299KCR7ci5tYXh9KSk7XFxuYCxyLmNhY2hlS2V5KSx7aW5wdXRzOlswXX0pfSxYYT1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LEphPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LFFhPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sUG49ZT0+eGUoZSksZXM9KGUsdCk9PntsZXQgcj1odChlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiRWx1XCIsbz0+YGVsdV92ZjMyKCR7b30pYCxgXFxuICBjb25zdCBlbHVfYWxwaGFfID0gJHtyfSgke3QuYWxwaGF9KTtcXG5cXG4gIGZuIGVsdV9mMzIoYTogJHtyfSkgLT4gJHtyfSB7XFxuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xcbiAgfVxcblxcbiAgZm4gZWx1X3ZmMzIodjogdmVjNDwke3J9PikgLT4gdmVjNDwke3J9PiB7XFxuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xcbiAgfWAsdC5jYWNoZUtleSkpfSxPbj0oZSx0PVwiZjMyXCIpPT5gXFxuY29uc3QgcjA6ICR7dH0gPSAwLjMyNzU5MTE7XFxuY29uc3QgcjE6ICR7dH0gPSAwLjI1NDgyOTU5MjtcXG5jb25zdCByMjogJHt0fSA9IC0wLjI4NDQ5NjczNjtcXG5jb25zdCByMzogJHt0fSA9IDEuNDIxNDEzNzQxO1xcbmNvbnN0IHI0OiAke3R9ID0gLTEuNDUzMTUyMDI3O1xcbmNvbnN0IHI1OiAke3R9ID0gMS4wNjE0MDU0Mjk7XFxuXFxuZm4gZXJmX3ZmMzIodjogJHtlfSkgLT4gJHtlfSB7XFxuICBsZXQgYWJzdiA9IGFicyh2KTtcXG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XFxuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcXG59YCx0cz1lPT57bGV0IHQ9aHQoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShUZShlLmlucHV0c1swXSxcIkVyZlwiLHI9PmBlcmZfdmYzMigke3J9KWAsT24oYHZlYzQ8JHt0fT5gLHQpKSl9LHJzPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LG5zPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxvcz1lPT57bGV0IHQ9aHQoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShUZShlLmlucHV0c1swXSxcIkdlbHVcIixyPT5gMC41ICogJHtyfSAqICgxLjAgKyBlcmZfdmYzMigke3J9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLE9uKGB2ZWM0PCR7dH0+YCx0KSkpfSxpcz0oZSx0KT0+e2xldCByPWh0KGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJMZWFreVJlbHVcIixvPT5gc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHtvfSwgJHtvfSwgJHtvfSA+PSB2ZWM0PCR7cn0+KDAuMCkpYCxgY29uc3QgbGVha3lfcmVsdV9hbHBoYV8gPSAke3J9KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpfSxhcz1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiTm90XCIsdD0+YCEke3R9YCkpfSxzcz1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiTmVnXCIsdD0+YC0ke3R9YCkpfSx1cz1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiUmVjaXByb2NhbFwiLHQ9PmAxLjAvJHt0fWApKX0sbHM9ZT0+e2xldCB0PWh0KGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJSZWx1XCIscj0+YHNlbGVjdCh2ZWM0PCR7dH0+KDAuMCksICR7cn0sICR7cn0gPiB2ZWM0PCR7dH0+KDAuMCkpYCkpfSxkcz1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiU2lnbW9pZFwiLHQ9PmAoMS4wIC8gKDEuMCArIGV4cCgtJHt0fSkpKWApKX0sY3M9ZT0+eGUoZSkscHM9KGUsdCk9PntsZXQgcj1odChlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiSGFyZFNpZ21vaWRcIixvPT5gbWF4KHZlYzQ8JHtyfT4oMC4wKSwgbWluKHZlYzQ8JHtyfT4oMS4wKSwgJHt0LmFscGhhfSAqICR7b30gKyB2ZWM0PCR7cn0+KCR7dC5iZXRhfSkpKWAsdm9pZCAwLHQuY2FjaGVLZXkpKX0sbXM9ZT0+e2UuY29tcHV0ZShUZShlLmlucHV0c1swXSxcIlNpblwiLFwic2luXCIpKX0sZnM9ZT0+e2UuY29tcHV0ZShUZShlLmlucHV0c1swXSxcIlNpbmhcIixcInNpbmhcIikpfSxocz1lPT57ZS5jb21wdXRlKFRlKGUuaW5wdXRzWzBdLFwiU3FydFwiLFwic3FydFwiKSl9LGdzPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJUYW5cIixcInRhblwiKSl9LHlzPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJUYW5oXCIsdD0+YHNpZ24oJHt0fSkgKiAoMSAtIGV4cCgtMiAqIGFicygke3R9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHt0fSkpKWApKX0sYnM9KGUsdCk9PntsZXQgcj1odChlLmlucHV0c1swXS5kYXRhVHlwZSk7cmV0dXJuIGUuY29tcHV0ZShUZShlLmlucHV0c1swXSxcIlRocmVzaG9sZGVkUmVsdVwiLG89PmBzZWxlY3QodmVjNDwke3J9PigwLjApLCAke299LCAke299ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8gPSB2ZWM0PCR7cn0+KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpLDB9LHdzPWU9PntlLmNvbXB1dGUoVGUoZS5pbnB1dHNbMF0sXCJMb2dcIixcImxvZ1wiKSl9fSk7dmFyIFZkLFdkLHZzLCRzPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO19lKCk7Q28oKTtWZD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxXZD1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IHI9VihcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCksbz1WKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksaT1KKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLHU9Vy5zaXplKHQpLzQsYT1OZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfX0pLGdldFNoYWRlclNvdXJjZTptPT5gXFxuICBjb25zdCBNX1NRUlQyID0gc3FydCgyLjApO1xcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtlWzBdLmRpbXNbMl0vNC8yfXU7XFxuXFxuICAke20uZGVjbGFyZVZhcmlhYmxlcyhyLG8saSl9XFxuXFxuICAke09uKGB2ZWM0PCR7YX0+YCxhKX1cXG5cXG4gICR7bS5tYWluU3RhcnQoKX1cXG4gICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModSl9XFxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcXG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XFxuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XFxuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xcblxcbiAgICAke2kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XFxuICB9YH19LHZzPWU9PntWZChlLmlucHV0cyksZS5jb21wdXRlKFdkKGUuaW5wdXRzKSl9fSk7dmFyIE5kLEhkLEN0LF9zLFNzLHhzLENzLEFzLElzLFRzLEVzLFBzLE9zLGtzPVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7X2UoKTtOZD0oZSx0LHIsbyxpLHUsYSxwLG0saCxkLHkpPT57bGV0IHcsXzt0eXBlb2YgcD09XCJzdHJpbmdcIj93PV89KFMsRSk9PmAke3B9KCgke1N9KSwoJHtFfSkpYDp0eXBlb2YgcD09XCJmdW5jdGlvblwiP3c9Xz1wOih3PXAuc2NhbGFyLF89cC52ZWN0b3IpO2xldCB2PUooXCJvdXRwdXREYXRhXCIsZCxvLmxlbmd0aCw0KSx4PVYoXCJhRGF0YVwiLG0sdC5sZW5ndGgsNCksVD1WKFwiYkRhdGFcIixoLHIubGVuZ3RoLDQpLEM7aWYoaSlpZih1KXtsZXQgUz1XLnNpemUodCk9PT0xLEU9Vy5zaXplKHIpPT09MSxPPXQubGVuZ3RoPjAmJnRbdC5sZW5ndGgtMV0lND09PTAsVT1yLmxlbmd0aD4wJiZyW3IubGVuZ3RoLTFdJTQ9PT0wO1N8fEU/Qz12LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLF8oUz9gJHt4LnR5cGUudmFsdWV9KCR7eC5nZXRCeU9mZnNldChcIjBcIil9LngpYDp4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxFP2Ake1QudHlwZS52YWx1ZX0oJHtULmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOlQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk6Qz1gXFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeCAqIDR1XCIpfTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix2KX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke1QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsdil9O1xcbiAgICAgICAgICAgICR7di5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKGF8fE8/eC5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKTpgJHt4LnR5cGUudmFsdWV9KCR7eC5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKX1bb2Zmc2V0QSAlIDR1XSlgLGF8fFU/VC5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKTpgJHtULnR5cGUudmFsdWV9KCR7VC5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKX1bb2Zmc2V0QiAlIDR1XSlgKSl9XFxuICAgICAgICAgIGB9ZWxzZSBDPXYuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyh4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxULmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIXUpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCBTPShFLE8sVT1cIlwiKT0+e2xldCBNPWBhRGF0YVtpbmRleEEke099XVtjb21wb25lbnRBJHtPfV1gLE49YGJEYXRhW2luZGV4QiR7T31dW2NvbXBvbmVudEIke099XWA7cmV0dXJuYFxcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHtPfSA9ICR7di5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7T311YCl9O1xcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHtPfSA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7T31gLHYpfTtcXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7T30gPSAke1QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke099YCx2KX07XFxuICAgICAgICAgICAgbGV0IGluZGV4QSR7T30gPSBvZmZzZXRBJHtPfSAvIDR1O1xcbiAgICAgICAgICAgIGxldCBpbmRleEIke099ID0gb2Zmc2V0QiR7T30gLyA0dTtcXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7T30gPSBvZmZzZXRBJHtPfSAlIDR1O1xcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHtPfSA9IG9mZnNldEIke099ICUgNHU7XFxuICAgICAgICAgICAgJHtFfVske099XSA9ICR7VX0oJHt3KE0sTil9KTtcXG4gICAgICAgICAgYH07ZD09PTk/Qz1gXFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XFxuICAgICAgICAgICAgJHtTKFwiZGF0YVwiLDAsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHtTKFwiZGF0YVwiLDEsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHtTKFwiZGF0YVwiLDIsXCJ1MzJcIil9XFxuICAgICAgICAgICAgJHtTKFwiZGF0YVwiLDMsXCJ1MzJcIil9XFxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOkM9YFxcbiAgICAgICAgICAgICR7UyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cXG4gICAgICAgICAgICAke1MoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XFxuICAgICAgICAgICAgJHtTKFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxcbiAgICAgICAgICAgICR7UyhcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cXG4gICAgICAgICAgYH1yZXR1cm5gXFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHgsVCx2KX1cXG5cXG4gICAgICAgICR7eT8/XCJcIn1cXG5cXG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XFxuICAgICAgICAke0N9XFxuICAgICAgfWB9LEhkPShlLHQscixvLGksdSxhPXIuZGF0YVR5cGUpPT57bGV0IHA9IVcuYXJlRXF1YWwoci5kaW1zLG8uZGltcyksbT1yLmRpbXMsaD1XLnNpemUoci5kaW1zKSxkPSExLHk9ITEsdz1bcF07aWYocCl7bGV0IF89dnQuY2FsY1NoYXBlKHIuZGltcyxvLmRpbXMsITEpO2lmKCFfKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bT1fLGg9Vy5zaXplKG0pO2xldCB2PVcuc2l6ZShyLmRpbXMpPT09MSx4PVcuc2l6ZShvLmRpbXMpPT09MSxUPXIuZGltcy5sZW5ndGg+MCYmci5kaW1zW3IuZGltcy5sZW5ndGgtMV0lND09PTAsQz1vLmRpbXMubGVuZ3RoPjAmJm8uZGltc1tvLmRpbXMubGVuZ3RoLTFdJTQ9PT0wO3cucHVzaCh2KSx3LnB1c2goeCksdy5wdXNoKFQpLHcucHVzaChDKTtsZXQgUz0xO2ZvcihsZXQgRT0xO0U8bS5sZW5ndGg7RSsrKXtsZXQgTz1yLmRpbXNbci5kaW1zLmxlbmd0aC1FXT8/MSxVPW8uZGltc1tvLmRpbXMubGVuZ3RoLUVdPz8xO2lmKE89PT1VKVMqPU87ZWxzZSBicmVha31TJTQ9PT0wPyh5PSEwLGQ9ITApOih2fHx4fHxUfHxDKSYmKGQ9ITApfWVsc2UgZD0hMDtyZXR1cm4gdy5wdXNoKGQpLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6dCt3Lm1hcChfPT5fLnRvU3RyaW5nKCkpLmpvaW4oXCJfXCIpLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpfPT5OZChfLHIuZGltcyxvLmRpbXMsbSxkLHAseSxpLHIuZGF0YVR5cGUsby5kYXRhVHlwZSxhLHUpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6TWF0aC5jZWlsKFcuc2l6ZShtKS80KX0sLi4uRyhyLmRpbXMpLC4uLkcoby5kaW1zKSwuLi5HKG0pXX0pfX0sQ3Q9KGUsdCxyLG8saSx1KT0+e2UuY29tcHV0ZShIZCh0LGk/P1wiXCIsZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0scixvLHUpKX0sX3M9ZT0+e0N0KGUsXCJBZGRcIiwodCxyKT0+YCR7dH0rJHtyfWApfSxTcz1lPT57Q3QoZSxcIkRpdlwiLCh0LHIpPT5gJHt0fS8ke3J9YCl9LHhzPWU9PntDdChlLFwiRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH09PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT09JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxDcz1lPT57Q3QoZSxcIk11bFwiLCh0LHIpPT5gJHt0fSoke3J9YCl9LEFzPWU9PntsZXQgdD1WKFwiaW5wdXRcIixlLmlucHV0c1swXS5kYXRhVHlwZSxlLmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO0N0KGUsXCJQb3dcIix7c2NhbGFyOihvLGkpPT5gcG93X2N1c3RvbSgke299LCR7aX0pYCx2ZWN0b3I6KG8saSk9PmBwb3dfdmVjdG9yX2N1c3RvbSgke299LCR7aX0pYH0sYFxcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XFxuICAgICAgaWYgKGIgPT0gJHt0fSgwLjApKSB7XFxuICAgICAgICByZXR1cm4gJHt0fSgxLjApO1xcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xcbiAgICAgICAgcmV0dXJuICR7dH0ocG93KGYzMihhKSwgZjMyKGIpKSk7IC8vIE5hTlxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xcbiAgICB9XFxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dH0+LCBiIDogdmVjNDwke3R9PikgLT4gdmVjNDwke3R9PiB7XFxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XFxuICAgICAgcmV0dXJuIHZlYzQ8JHt0fT4ocG93X2N1c3RvbShhLngsIGIueCksIHBvd19jdXN0b20oYS55LCBiLnkpLCBwb3dfY3VzdG9tKGEueiwgYi56KSwgcG93X2N1c3RvbShhLncsIGIudykpO1xcbiAgICB9XFxuICAgICAgYCl9LElzPWU9PntDdChlLFwiU3ViXCIsKHQscik9PmAke3R9LSR7cn1gKX0sVHM9ZT0+e0N0KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PiR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT4ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LEVzPWU9PntDdChlLFwiTGVzc1wiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTwke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxQcz1lPT57Q3QoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9Pj0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sT3M9ZT0+e0N0KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTw9JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PD0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIExkLEZkLGpkLHFkLFJzLEJzLERzPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1llKCk7X2UoKTtMZD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IHQ9ZVswXS5kYXRhVHlwZSxyPWVbMF0uZGltcy5sZW5ndGg7Zm9yKGxldCBvIG9mIGUpe2lmKG8uZGF0YVR5cGUhPT10KXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlXCIpO2lmKG8uZGltcy5sZW5ndGghPT1yKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9fSxGZD0oZSx0KT0+YFxcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtlfXU+KCR7dH0pO1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX07IGkgKz0gMXUgKSB7XFxuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xcbiAgICAgICAgcmV0dXJuIGk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiAke2V9dTtcXG4gIH1gLGpkPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgsbz1bXTtmb3IobGV0IGk9MDtpPHI7KytpKXtsZXQgdT10LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGVbaV0uZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKSk7cj09PTE/by5wdXNoKHUpOmk9PT0wP28ucHVzaChgaWYgKGlucHV0SW5kZXggPT0gJHtpfXUpIHsgJHt1fSB9YCk6aT09PXItMT9vLnB1c2goYGVsc2UgeyAke3V9IH1gKTpvLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtpfSkgeyAke3V9IH1gKX1yZXR1cm4gby5qb2luKGBcXG5gKX0scWQ9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKTtpZih0Pj1yLmxlbmd0aHx8dDwtMSpyLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtsZXQgbz10PDA/ci5sZW5ndGgrdDp0LGk9ci5zbGljZSgwKTtmb3IobGV0IEM9MTtDPGUubGVuZ3RoO0MrKyl7bGV0IFM9ZVtDXS5kaW1zLnNsaWNlKCk7Zm9yKGxldCBFPTA7RTxyLmxlbmd0aDtFKyspaWYoRT09PW8paVtvXSs9U1tFXTtlbHNlIGlmKHJbRV0hPT1TW0VdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWxldCB1PVcuc2l6ZShpKSxhPW5ldyBBcnJheShlLmxlbmd0aCkscD1uZXcgQXJyYXkoZS5sZW5ndGgpLG09ZVswXS5kYXRhVHlwZSxoPTAsZD1bXSx5PVtdLHc9W3t0eXBlOlwidWludDMyXCIsZGF0YTp1fV07Zm9yKGxldCBDPTA7QzxlLmxlbmd0aDsrK0MpaCs9ZVtDXS5kaW1zW29dLGFbQ109aCx5LnB1c2goZVtDXS5kaW1zLmxlbmd0aCkscFtDXT1WKGBpbnB1dCR7Q31gLG0seVtDXSksZC5wdXNoKFwicmFua1wiKSx3LnB1c2goe3R5cGU6XCJ1aW50MzJcIixkYXRhOmFbQ119KTtmb3IobGV0IEM9MDtDPGUubGVuZ3RoOysrQyl3LnB1c2goLi4uRyhlW0NdLmRpbXMpKTt3LnB1c2goLi4uRyhpKSk7bGV0IF89SihcIm91dHB1dFwiLG0saS5sZW5ndGgpLHY9Xy5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pLHg9QXJyYXkuZnJvbShBcnJheShhLmxlbmd0aCkua2V5cygpKS5tYXAoQz0+YHVuaWZvcm1zLnNpemVJbkNvbmNhdEF4aXMke0N9YCkuam9pbihcIixcIiksVD1DPT5gXFxuXFxuICAkeygoKT0+e0MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpO2ZvcihsZXQgUz0wO1M8ZS5sZW5ndGg7UysrKUMucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtTfWAsXCJ1MzJcIik7cmV0dXJuIEMuZGVjbGFyZVZhcmlhYmxlcyguLi5wLF8pfSkoKX1cXG5cXG4gICR7RmQoYS5sZW5ndGgseCl9XFxuXFxuICAke0MubWFpblN0YXJ0KCl9XFxuICAgICR7Qy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cXG5cXG4gICAgdmFyIGluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke3Z9KTtcXG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcXG4gICAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHthLmxlbmd0aH11Pigke3h9KTtcXG4gICAgICAke3Z9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcXG4gICAgfVxcblxcbiAgICAke2pkKHAsXyl9XFxuICB9YDtyZXR1cm57bmFtZTpcIkNvbmNhdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpkfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQpfSxwcm9ncmFtVW5pZm9ybXM6d30pLGdldFNoYWRlclNvdXJjZTpUfX0sUnM9KGUsdCk9PntMZChlLmlucHV0cyksZS5jb21wdXRlKHFkKGUuaW5wdXRzLHQuYXhpcykpfSxCcz1lPT54ZSh7YXhpczplLmF4aXN9KX0pO3ZhciBBdCxrbixVdD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtBdD0oZSx0KT0+e3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjpyZXR1cm5gdmFsdWUgPSBtYXgodmFsdWUsICR7dH0oMC4wKSk7YDtjYXNlXCJTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gKCR7dH0oMS4wKSAvICgke3R9KDEuMCkgKyBleHAoLXZhbHVlKSkpO2A7Y2FzZVwiQ2xpcFwiOnJldHVybmB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAke3R9KHVuaWZvcm1zLmNsaXBfbWluKSwgJHt0fSh1bmlmb3Jtcy5jbGlwX21heCkpO2A7ZGVmYXVsdDpyZXR1cm5cIlwifX0sa249ZT0+e2xldCB0PWU/LmFjdGl2YXRpb258fFwiXCI7aWYodD09PVwiQ2xpcFwiKXtsZXRbcixvXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8W3huLENuXTtyZXR1cm57YWN0aXZhdGlvbjp0LGNsaXBNYXg6byxjbGlwTWluOnJ9fXJldHVybnthY3RpdmF0aW9uOnR9fX0pO3ZhciBqZSxSbixCbj1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7amU9KGUsdCk9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm5gdmVjMjwke3R9PmA7Y2FzZSAzOnJldHVybmB2ZWMzPCR7dH0+YDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt0fT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2V9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0sUm49ZT0+YFxcbiAgICAgICR7ZT9cInZhbHVlID0gdmFsdWUgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKTtcIjpcIlwifVxcbiAgICAgIGB9KTt2YXIgRG4sQW89USgoKT0+e1widXNlIHN0cmljdFwiO0RuPWU9PmBcXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XFxufVxcbmZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XFxuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxcbiAgICBpMzIoJHtlfS54KSwgaTMyKCR7ZX0ueSksIGkzMigke2V9LnopLCAxKSk7XFxufVxcbmB9KTt2YXIgS2QsWWQsVXIsTXMsWmQsVnIsWGQsTW4sV3I9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7X2UoKTtVdCgpO0JuKCk7S2Q9KGUsdCk9PmU/YFxcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgYDpgXFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgYCxZZD0oZSx0KT0+ZT9gXFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XFxuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcXG4gICAgICAgICR7dD09PTM/XCJcIjpcImxldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107XCJ9XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XFxuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07XCJ9XFxuICAgICAgICB9YDpgXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XFxuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XFxuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldO1wifVxcbiAgICAgICAgfWAsVXI9KGUsdCxyPVwiZjMyXCIsbyxpPSExLHU9MzIsYT0hMSxwPTMyKT0+e2xldCBtPXRbMV0qZVsxXSxoPXRbMF0qZVswXSxkPWk/bTp1LHk9aT91Om0sdz1kL3RbMF0sXz11L3RbMV07aWYoISgoaSYmdz09PTQmJmVbMV09PT00fHwhaSYmKHc9PT0zfHx3PT09NCkpJiZkJXRbMF09PT0wJiZ1JXRbMV09PT0wJiZlWzBdPT09NCkpdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7aX0gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke3d9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxcbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke3d9IG11c3QgYmUgMyBvciA0LlxcbiAgdGlsZUFXaWR0aCAke2R9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHt1fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHt3fTwke3J9PiwgJHtkL3d9PiwgJHt5fT47XFxudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke3J9PiwgJHtoL2VbMF19PiwgJHt1fT47XFxuXFxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcXG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke3d9O1xcbmNvbnN0IHRpbGVJbm5lciA9ICR7dX07XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXFxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XFxuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcXG5cXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcXG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XFxuICBsZXQgYmF0Y2ggPSAke2E/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XFxuICAke28/YGxldCBiYXRjaEluZGljZXMgPSAke28ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxcbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHttfTtcXG5cXG4gIGxldCBudW1fdGlsZXMgPSAke2E/YCR7TWF0aC5jZWlsKHAvdSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XFxuICB2YXIga1N0YXJ0ID0gJHthP2BpMzIoZ2xvYmFsSWQueikgKiAke3B9YDpcIjBcIn07XFxuXFxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7cn0+LCByb3dQZXJUaHJlYWQ+O1xcblxcbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXFxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7X307XFxuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcXG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcXG4gICAgICAgICAgJHtLZChpLG8pfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7X307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XFxuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XFxuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHtvP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgfVxcbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XFxuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xcbiAgICAgICAgICAke3c9PT0zP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XFxuXFxuICAgICAgICAgICR7WWQoaSx3KX1cXG4gICAgICB9XFxuXFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XFxuICB9XFxufWB9LE1zPShlLHQpPT5lP2BcXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICAgICAgICAgIGA6YFxcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XFxuICAgICAgICAgICAgYCxaZD1lPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIixWcj0oZSx0LHI9XCJmMzJcIixvLGk9ITEsdT0zMixhPSExLHA9MzIsbT0hMSk9PntsZXQgaD1lWzFdKnRbMV0sZD1lWzBdKnRbMF0seT1pP2g6dSx3PWk/dTpoO2lmKCEodyV0WzFdPT09MCYmeSV0WzBdPT09MCYmdSV0WzFdPT09MCkpdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7d30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHt5fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7dX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtsZXQgXz13L3RbMV0sdj15L3RbMF0seD11L3RbMV0sVD1tP2BcXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XFxuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke2h9O1xcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke2R9O1xcblxcbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7d307IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XFxuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7eX07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XFxuICAgICAgICAgICR7TXMoaSxvKX1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt1fTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7ZH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XFxuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke28/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcXG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3RbMF19XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtpP2BtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XTtgOmBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XVtrXTtgfVxcbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICB9XFxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19O1xcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7dFswXX07XFxuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBgOmBcXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XFxuXFxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcXG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7aH07XFxuXFxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke199O1xcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHt2fTtcXG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7eH07XFxuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXFxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7X307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke3Z9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XFxuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcXG4gICAgICAke01zKGksbyl9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3h9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XFxuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7bz9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xcbiAgICB9XFxuICB9XFxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XFxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcXG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcXG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICR7WmQoaSl9XFxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxufVxcblxcbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xcbiAgfVxcbn1cXG5gO3JldHVybmBcXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke3l9PiwgJHt3fT47XFxuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHtyfSwgJHtkfT4sICR7dX0+O1xcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcXG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XFxuICBjb25zdCB0aWxlSW5uZXIgPSAke3V9O1xcblxcbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcXG4gICAgbGV0IGJhdGNoID0gJHthP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xcbiAgICAke28/YGxldCBiYXRjaEluZGljZXMgPSAke28ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxcbiAgICBsZXQgbnVtX3RpbGVzID0gJHthP2Ake01hdGguY2VpbChwL3UpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xcbiAgICB2YXIga1N0YXJ0ID0gJHthP2BpMzIoZ2xvYmFsSWQueikgKiAke3B9YDpcIjBcIn07XFxuXFxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xcblxcbiAgICAvLyBXaXRob3V0IHRoaXMgaW5pdGlhbGl6YXRpb24gc3RyYW5nZSB2YWx1ZXMgc2hvdyB1cCBpbiBhY2MuXFxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gMC4wO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAke1R9XFxuICB9XFxuYH0sWGQ9KGUsdCxyLG8saSx1PSExKT0+e2xldFthLHAsbV09aSxbaCxkLHksd109byxfPWNyKGEsbSksdj1jcihwLG0pLHg9TmUob1swXS50eXBlLnRlbnNvciksVD0oKT0+e2xldCBFPWQucmFuayxPPWgucmFuayxVPWB2YXIgYUluZGljZXM6ICR7ZC50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBNPUUtMi0xLE49Ty0xO00+PTA7TS0tLE4tLSlVKz1gXFxuYUluZGljZXNbJHtNfV0gPSAke08+MT9gYmF0Y2hJbmRpY2VzWyR7Tn1dYDpcImJhdGNoSW5kaWNlc1wifTtgO3JldHVybiBfLmZvckVhY2goTT0+e1UrPWBcXG5hSW5kaWNlc1ske019XSA9IDA7YH0pLFUrPWBcXG5hSW5kaWNlc1ske0UtMn1dID0gdTMyKHJvdyk7XFxuICAgICAgICAgICAgICAgICAgIGFJbmRpY2VzWyR7RS0xfV0gPSB1MzIoY29sSW4pO2AsVX0sQz0oKT0+e2xldCBFPXkucmFuayxPPWgucmFuayxVPWB2YXIgYkluZGljZXM6ICR7eS50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBNPUUtMi0xLE49Ty0xO00+PTA7TS0tLE4tLSlVKz1gXFxuYkluZGljZXNbJHtNfV0gPSAke08+MT9gYmF0Y2hJbmRpY2VzWyR7Tn1dYDpcImJhdGNoSW5kaWNlc1wifTtgO3JldHVybiB2LmZvckVhY2goTT0+e1UrPWBcXG5iSW5kaWNlc1ske019XSA9IDA7YH0pLFUrPWBcXG5iSW5kaWNlc1ske0UtMn1dID0gdTMyKHJvdyk7XFxuICAgICAgICAgICAgICAgICAgIGJJbmRpY2VzWyR7RS0xfV0gPSB1MzIoY29sSW4pO2AsVX07cmV0dXJuYFxcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2gudHlwZS5pbmRpY2VzfSkgLT4gJHtqZShlLHgpfSB7XFxuICAgICAgdmFyIHZhbHVlID0gJHtqZShlLHgpfSgwLjApO1xcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XFxuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxcbiAgICAgIHtcXG4gICAgICAgICR7VCgpfVxcbiAgICAgICAgdmFsdWUgPSAke2QuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtoLnR5cGUuaW5kaWNlc30pIC0+ICR7amUoZSx4KX0ge1xcbiAgICAgIHZhciB2YWx1ZSA9ICR7amUoZSx4KX0oMC4wKTtcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcXG4gICAgICB7XFxuICAgICAgICAke0MoKX1cXG4gICAgICAgIHZhbHVlID0gJHt5LmdldEJ5SW5kaWNlcyhcImJJbmRpY2VzXCIpfTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke2plKGUseCl9KSB7XFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcXG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XFxuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcXG4gICAgICAgICR7dD9gdmFsdWUgPSB2YWx1ZSArICR7dT9cImJpYXNbY29sSW5dXCI6YCR7amUoZSx4KX0oYmlhc1tyb3ddKWB9O2A6XCJcIn1cXG4gICAgICAgICR7cn1cXG4gICAgICAgICR7dy5zZXRCeUluZGljZXMoXCJ2ZWMzPHUzMj4oY29vcmRzKVwiLFwidmFsdWVcIil9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGB9LE1uPShlLHQscixvLGk9ITEpPT57bGV0IHU9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHA9dS5zbGljZSgwLC0yKSxtPWEuc2xpY2UoMCwtMiksaD1vP28uc2xpY2UoMCwtMik6ci5zbGljZSgwLC0yKSxkPVcuc2l6ZShoKSx5PXVbdS5sZW5ndGgtMl0sdz11W3UubGVuZ3RoLTFdLF89YVthLmxlbmd0aC0xXSx2PXclND09PTAmJl8lND09PTAseD15PD04P1s0LDEsMV06WzQsNCwxXSxUPVs4LDgsMV0sQz1bTWF0aC5jZWlsKF8vVFswXS94WzBdKSxNYXRoLmNlaWwoeS9UWzFdL3hbMV0pLE1hdGguY2VpbChkL1RbMl0veFsyXSldLFM9dj80OjEsRT1bLi4ucCx5LHcvU10sTz1FLmxlbmd0aCxVPVsuLi5tLHcsXy9TXSxNPVUubGVuZ3RoLE49W2QseSxfL1NdLFk9W3t0eXBlOlwiaW50MzJcIixkYXRhOnl9LHt0eXBlOlwiaW50MzJcIixkYXRhOl99LHt0eXBlOlwiaW50MzJcIixkYXRhOnd9XTt0LmFjdGl2YXRpb249PT1cIkNsaXBcIiYmWS5wdXNoKHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5jbGlwTWF4fSx7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuY2xpcE1pbn0pLFkucHVzaCguLi5HKGgpLC4uLkcoRSksLi4uRyhVKSk7bGV0IHNlPVtcInJhbmtcIixcInJhbmtcIl0sQj1lLmxlbmd0aD4yO0ImJihZLnB1c2goLi4uRyhlWzJdLmRpbXMpKSxzZS5wdXNoKFwicmFua1wiKSksWS5wdXNoKC4uLkcoTikpO2xldCB0ZT1QZT0+e2xldCBFZT1oLmxlbmd0aCxlZT1BbihcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUsRWUsMSksYmU9TmUoZVswXS5kYXRhVHlwZSksTWU9VihcImFcIixlWzBdLmRhdGFUeXBlLE8sUykscGU9VihcImJcIixlWzFdLmRhdGFUeXBlLE0sUykseWU9SihcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsTi5sZW5ndGgsUyksZGU9W01lLHBlXTtpZihCKXtsZXQgR2U9aT9TOjE7ZGUucHVzaChWKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxHZSkpfWxldCB3ZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9XTt0LmFjdGl2YXRpb249PT1cIkNsaXBcIiYmd2UucHVzaCh7bmFtZTpcImNsaXBfbWF4XCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImNsaXBfbWluXCIsdHlwZTpcImYzMlwifSk7bGV0IHplPUF0KHQseWUudHlwZS52YWx1ZSksUmU9WGQoUyxCLHplLFtlZSxNZSxwZSx5ZV0sW3AsbSxoXSxpKTtyZXR1cm5gXFxuICAke1BlLnJlZ2lzdGVyVW5pZm9ybXMod2UpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoZWUpLmRlY2xhcmVWYXJpYWJsZXMoLi4uZGUseWUpfVxcbiAgJHtSZX1cXG4gICR7dj9Vcih4LFQsYmUsZWUpOlZyKHgsVCxiZSxlZSl9XFxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHt0LmFjdGl2YXRpb259OyR7dn07JHtpfWAsaW5wdXREZXBlbmRlbmNpZXM6c2V9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpDWzBdLHk6Q1sxXSx6OkNbMl19LHByb2dyYW1Vbmlmb3JtczpZfSksZ2V0U2hhZGVyU291cmNlOnRlfX19KTt2YXIgSmQsenMsVXM9USgoKT0+e1widXNlIHN0cmljdFwiO3p0KCk7X2UoKTtVdCgpO0JuKCk7QW8oKTtXcigpO0pkPShlLHQscixvLGk9ITEsdSxhPTQscD00LG09NCxoPVwiZjMyXCIpPT57bGV0IGQ9Qj0+e3N3aXRjaChCKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHtofT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7Qn0gaXMgbm90IHN1cHBvcnRlZC5gKX19LHk9Qj0+e3N3aXRjaChCKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0J9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx3PWU/YFxcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XFxuICAgIGA6YFxcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XFxuICAgIGAsXz1lP2BcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3cgLyBvdXRXaWR0aCxcXG4gICAgICByb3cgJSBvdXRXaWR0aCxcXG4gICAgICBjb2wpO1xcbiAgICBgOmBcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3csXFxuICAgICAgY29sIC8gb3V0V2lkdGgsXFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xcbiAgICBgLHY9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIseD1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIixUPWU/XCJyb3dcIjpcImNvbFwiLEM9ZT9cImNvbFwiOlwicm93XCIsUz1gXFxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XFxuICAgIGxldCBvdXRSb3cgPSAke1R9IC8gb3V0V2lkdGg7XFxuICAgIGxldCBvdXRDb2wgPSAke1R9ICUgb3V0V2lkdGg7XFxuXFxuICAgIGxldCBXUm93ID0gJHtDfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcXG4gICAgbGV0IFdDb2wgPSAke0N9IC8gaW5DaGFubmVscyAlIGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKTtcXG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiB1bmlmb3Jtcy5zdHJpZGVbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvblswXSAqIFdSb3cgLSB1bmlmb3Jtcy5wYWRbMF07XFxuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xcbiAgICBsZXQgeENoID0gJHtDfSAlIGluQ2hhbm5lbHM7XFxuICAgIHZhciByZXNEYXRhID0gJHtqZShhLGgpfSgwLjApO1xcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxcbiAgICAvLyB0aGUgXFwnc2FtZVxcJyBwYWRkaW5nIHR5cGUuXFxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7dn0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke3h9KSB7XFxuICAgICAgJHt3fVxcbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcXG4gICAgICAke2QoYSl9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc0RhdGE7YCxFPWU/dCYmbz9gXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XFxuICAgICR7U31gOmBcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcXG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xcbiAgICAgICR7U31cXG4gICAgfVxcbiAgICByZXR1cm4gJHtqZShhLGgpfSgwLjApO2A6byYmcj9gXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XFxuICAgICR7U31gOmBcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcXG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xcbiAgICAgICR7U31cXG4gICAgfVxcbiAgICByZXR1cm4gJHtqZShhLGgpfSgwLjApO2AsTz1gJHt5KHApfWAsVT1qZShtLGgpLE09ZT9qZShhLGgpOmplKHAsaCksTj1lP2plKHAsaCk6amUoYSxoKSxZPUF0KHUsVSk7cmV0dXJuYFxcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke019IHtcXG4gICAgICAke2U/RTpPfVxcbiAgICB9XFxuXFxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7Tn0ge1xcbiAgICAgICR7ZT9POkV9XFxuICAgIH1cXG5cXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7VX0pIHtcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke219O1xcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcXG4gICAgICB7XFxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcXG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XFxuICAgICAgJHtffVxcbiAgICAgICR7Um4oaSl9XFxuICAgICAgJHtZfVxcbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfWB9LHpzPShlLHQscixvLGksdSxhLHApPT57bGV0IG09dC5mb3JtYXQ9PT1cIk5IV0NcIixoPW0/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxkPXJbMF0seT1tP3JbMl06clszXSx3PW0/clsxXTpyWzJdLF89bT9yWzNdOnJbMV0sdj1tJiYoaCU0PT09MHx8aCUzPT09MCkmJl8lND09PTAseD1tP186eSp3LFQ9bT95Knc6XyxDPVs4LDgsMV0sUz1vPD04P1s0LDEsMV06WzQsNCwxXSxFPVtNYXRoLmNlaWwoeC9DWzBdL1NbMF0pLE1hdGguY2VpbChUL0NbMV0vU1sxXSksTWF0aC5jZWlsKGQvQ1syXS9TWzJdKV07RGUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke0V9YCk7bGV0IE89dj9tJiZoJTQhPT0wPzM6NDoxLFU9Q1sxXSpTWzFdLE09Q1swXSpTWzBdLE49TWF0aC5tYXgoQ1swXSpPLENbMV0pLFk9byVVPT09MCxzZT1pJU09PT0wLEI9dSVOPT09MCx0ZT12P1tPLDQsNF06WzEsMSwxXSxQZT1be3R5cGU6XCJpbnQzMlwiLGRhdGE6b30se3R5cGU6XCJpbnQzMlwiLGRhdGE6aX0se3R5cGU6XCJpbnQzMlwiLGRhdGE6dX0se3R5cGU6XCJpbnQzMlwiLGRhdGE6W3QucGFkc1swXSx0LnBhZHNbMV1dfSx7dHlwZTpcImludDMyXCIsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOlwiaW50MzJcIixkYXRhOnQuZGlsYXRpb25zfV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJlBlLnB1c2goe3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNYXh9LHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5jbGlwTWlufSksUGUucHVzaCguLi5HKGVbMF0uZGltcyksLi4uRyhlWzFdLmRpbXMpKTtsZXQgRWU9W1wicmFua1wiLFwicmFua1wiXTthJiYoUGUucHVzaCguLi5HKGVbMl0uZGltcykpLEVlLnB1c2goXCJyYW5rXCIpKSxQZS5wdXNoKC4uLkcocikpO2xldCBlZT1iZT0+e2xldCBNZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwicGFkXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInN0cmlkZVwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJkaWxhdGlvblwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn1dO3QuYWN0aXZhdGlvbj09PVwiQ2xpcFwiJiZNZS5wdXNoKHtuYW1lOlwiY2xpcF9tYXhcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiY2xpcF9taW5cIix0eXBlOlwiZjMyXCJ9KTtsZXQgcGU9dj80OjEseWU9TmUoZVswXS5kYXRhVHlwZSksZGU9YFxcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7dj9gdmVjNDwke3llfT5gOnllfSkge1xcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3Y/YHZlYzQ8JHt5ZX0+YDp5ZX0odmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke3Y/YHZlYzQ8JHt5ZX0+YDp5ZX0pIHtcXG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XFxuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke3Y/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xcbiAgICAgIH1gLHdlPVYoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLE89PT0zPzE6TyksemU9VihcIndcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgscGUpLFJlPVt3ZSx6ZV0sR2U9SihcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgscGUpO2lmKGEpe2xldCBGPVYoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLHBlKTtSZS5wdXNoKEYpLGRlKz1gXFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke3Y/YHZlYzQ8JHt5ZX0+YDp5ZX0ge1xcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHttP1wid1wiOlwieVwifSR7dj9cIi8gNFwiOlwiXCJ9XTtcXG4gICAgICAgIH1gfXJldHVybmBcXG4gICAgICAgICR7RG4oXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cXG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XFxuICAgICAgICAke2JlLnJlZ2lzdGVyVW5pZm9ybXMoTWUpLmRlY2xhcmVWYXJpYWJsZXMoLi4uUmUsR2UpfVxcbiAgICAgICAgJHtkZX1cXG4gICAgICAgICR7SmQobSxZLHNlLEIsYSx0LHRlWzBdLHRlWzFdLHRlWzJdLHllKX1cXG4gICAgICAgICR7dj9VcihTLEMseWUsdm9pZCAwLCFtLE4pOlZyKFMsQyx5ZSx2b2lkIDAsIW0sTiwhMSx2b2lkIDAscCl9YH07cmV0dXJue25hbWU6XCJDb252MkRNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske099OyR7dn07JHtZfTske3NlfTske0J9OyR7VX07JHtNfTske059YCxpbnB1dERlcGVuZGVuY2llczpFZX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OkVbMF0seTpFWzFdLHo6RVsyXX0scHJvZ3JhbVVuaWZvcm1zOlBlfSksZ2V0U2hhZGVyU291cmNlOmVlfX19KTt2YXIgSW8sVnM9USgoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7X2UoKTtFbygpO1V0KCk7SW89KGUsdCxyKT0+e2xldCBvPWUubGVuZ3RoPjIsaT1vP1widmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07XCI6XCJcIix1PWVbMF0uZGltcyxhPWVbMV0uZGltcyxwPWFbMF0vdC5ncm91cCxtPXQuZm9ybWF0PT09XCJOSFdDXCIsaD1Ubyh1LGEsdC5kaWxhdGlvbnMsdC5wYWRzLHQuc3RyaWRlcyxtKSxkPVcuc2l6ZShoKSx5PVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6ZH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnQuZGlsYXRpb25zfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6W3QucGFkc1swXSx0LnBhZHNbMV1dfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH1dO3QuYWN0aXZhdGlvbj09PVwiQ2xpcFwiJiZ5LnB1c2goe3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNYXh9LHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5jbGlwTWlufSkseS5wdXNoKC4uLkcodSksLi4uRyhhKSwuLi5HKGgpKTtsZXQgdz1bXCJyYW5rXCIsXCJyYW5rXCJdO28mJih5LnB1c2goLi4uRyhlWzJdLmRpbXMpKSx3LnB1c2goXCJyYW5rXCIpKSx5LnB1c2goLi4uRyhoKSk7bGV0IF89dj0+e2xldCB4PUooXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGgubGVuZ3RoKSxUPUF0KHQseC50eXBlLnZhbHVlKSxDPVYoXCJ4XCIsZVswXS5kYXRhVHlwZSx1Lmxlbmd0aCksUz1WKFwid1wiLGVbMV0uZGF0YVR5cGUsYS5sZW5ndGgpLEU9W0MsU107byYmRS5wdXNoKFYoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMpKTtsZXQgTz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwib3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybiB0LmFjdGl2YXRpb249PT1cIkNsaXBcIiYmTy5wdXNoKHtuYW1lOlwiY2xpcF9tYXhcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiY2xpcF9taW5cIix0eXBlOlwiZjMyXCJ9KSxgXFxuICAke3YucmVnaXN0ZXJVbmlmb3JtcyhPKS5kZWNsYXJlVmFyaWFibGVzKC4uLkUseCl9XFxuXFxuICAke3YubWFpblN0YXJ0KCl9XFxuICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XFxuXFxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt4Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XFxuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske20/MzoxfV07XFxuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7bT8xOjJ9XSwgb3V0cHV0SW5kaWNlc1ske20/MjozfV0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XFxuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xcblxcbiAgICB2YXIgdmFsdWU6ICR7eC50eXBlLnZhbHVlfSA9ICR7eC50eXBlLnZhbHVlfSgwKTtcXG4gICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3SW5DaGFubmVsKyspIHtcXG4gICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogdW5pZm9ybXMud19zaGFwZVsxXSArIHdJbkNoYW5uZWw7XFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcXG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xcblxcbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbJHttPzE6Mn1dKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVszXTsgd1dpZHRoKyspIHtcXG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbJHttPzI6M31dKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGV0IHhWYWwgPSAke20/Qy5nZXQoXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCIpOkMuZ2V0KFwiYmF0Y2hcIixcImlucHV0X2NoYW5uZWxcIixcInhIZWlnaHRcIixcInhXaWR0aFwiKX07XFxuICAgICAgICAgIGxldCB3VmFsID0gJHtTLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7aX1cXG4gICAgJHtUfVxcbiAgICAke3guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cXG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczp3fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnI/cihoKTpoLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6X319fSk7dmFyIFBvLFFkLFdzLE9vPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1dyKCk7X2UoKTtVdCgpO1BvPShlLHQscixvLGk9ITEpPT57bGV0IHU9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHA9dVt1Lmxlbmd0aC0yXSxtPWFbYS5sZW5ndGgtMV0saD11W3UubGVuZ3RoLTFdLGQ9SGUobSkseT1IZShoKSx3PUhlKHApLF89Vy5zaXplKHIpL2Qvdyx2PWUubGVuZ3RoPjIseD1vP28uc2xpY2UoMCwtMik6ci5zbGljZSgwLC0yKSxDPVtXLnNpemUoeCkscCxtXSxTPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6X30se3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9LHt0eXBlOlwidWludDMyXCIsZGF0YTptfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6aH1dO3QuYWN0aXZhdGlvbj09PVwiQ2xpcFwiJiZTLnB1c2goe3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNYXh9LHt0eXBlOlwiZmxvYXQzMlwiLGRhdGE6dC5jbGlwTWlufSksUy5wdXNoKC4uLkcoeCksLi4uRyh1KSwuLi5HKGEpKSx2JiZTLnB1c2goLi4uRyhlWzJdLmRpbXMpKSxTLnB1c2goLi4uRyhDKSk7bGV0IEU9Tz0+e2xldCBVPUFuKFwiYmF0Y2hfZGltc1wiLGVbMF0uZGF0YVR5cGUseC5sZW5ndGgpLE09VihcImFcIixlWzBdLmRhdGFUeXBlLHUubGVuZ3RoLHkpLE49VihcImJcIixlWzFdLmRhdGFUeXBlLGEubGVuZ3RoLGQpLFk9SihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsQy5sZW5ndGgsZCksc2U9QXQodCxZLnR5cGUudmFsdWUpLEI9W00sTl0sdGU9XCJcIjtpZih2KXtsZXQgZGU9aT9kOjE7Qi5wdXNoKFYoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGRlKSksdGU9YCR7aT9gdmFsdWUgKz0gYmlhc1tjb2wgLyAke2RlfV07YDpgdmFsdWUgKz0gJHtZLnR5cGUudmFsdWV9KGJpYXNbcm93ICsgaV0pO2B9YH1sZXQgUGU9dS5zbGljZSgwLC0yKSxFZT1hLnNsaWNlKDAsLTIpLGVlPWNyKFBlLHgpLGJlPWNyKEVlLHgpLE1lPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJk1lLnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pO2xldCBwZT0oZGUsd2UpPT57bGV0IHplPWRlLnJhbmssUmU9ZGUubmFtZTtpZih6ZT09PTIpcmV0dXJuYHZhciAke1JlfV9pbmRpY2VzID0gJHtkZS50eXBlLmluZGljZXN9KDB1LCAwdSk7YDtsZXQgR2U9VS5yYW5rLEY9YHZhciAke1JlfV9pbmRpY2VzOiAke2RlLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IGllPXplLTItMSxoZT1HZS0xO2llPj0wO2llLS0saGUtLSlGKz1gXFxuJHtSZX1faW5kaWNlc1ske2llfV0gPSAke0dlPjE/YGJhdGNoX2luZGljZXNbJHtoZX1dYDpcImJhdGNoX2luZGljZXNcIn07YDtyZXR1cm4gd2UuZm9yRWFjaChpZT0+e0YrPWBcXG4ke1JlfV9pbmRpY2VzWyR7aWV9XSA9IDA7YH0pLEYrPWAke1JlfV9pbmRpY2VzWyR7emUtMn1dID0gMHU7XFxuICAgICAgICAgICAgICAgICAgICAgJHtSZX1faW5kaWNlc1ske3plLTF9XSA9IDB1O2AsRn0seWU9KCk9PntsZXQgZGU9YHZhciBhX2RhdGE6ICR7TS50eXBlLnZhbHVlfTtgO2ZvcihsZXQgd2U9MDt3ZTx5O3dlKyspZGUrPWBcXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke3dlfSA9IGJbKGJfb2Zmc2V0ICsgKGsgKyAke3dlfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7ZH1dO2A7Zm9yKGxldCB3ZT0wO3dlPHc7d2UrKyl7ZGUrPWBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke3dlfSkgKiB1bmlmb3Jtcy5LICsgaykgLyAke3l9XTtgO2ZvcihsZXQgemU9MDt6ZTx5O3plKyspZGUrPWBcXG4gICAgICAgICAgICB2YWx1ZXNbJHt3ZX1dID0gZm1hKCR7Ti50eXBlLnZhbHVlfShhX2RhdGEke3k9PT0xP1wiXCI6YFske3plfV1gfSksIGJfZGF0YSR7emV9LCB2YWx1ZXNbJHt3ZX1dKTtcXG5gfXJldHVybiBkZX07cmV0dXJuYFxcbiAgJHtPLnJlZ2lzdGVyVW5pZm9ybXMoTWUpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoVSkuZGVjbGFyZVZhcmlhYmxlcyguLi5CLFkpfVxcbiAgJHtPLm1haW5TdGFydCgpfVxcbiAgICAke08uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxcbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7ZH0pKSAqICR7ZH07XFxuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLk4gLyAke2R9KTtcXG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHt3fTtcXG4gICAgbGV0IHJvdyA9IChpbmRleDEgJSBzdHJpZGUxKSAqICR7d307XFxuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XFxuXFxuICAgICR7ci5sZW5ndGg9PT0yP1wiXCI6YGxldCBiYXRjaF9pbmRpY2VzID0gJHtVLm9mZnNldFRvSW5kaWNlcyhcImJhdGNoXCIpfTtgfVxcbiAgICAke3BlKE0sZWUpfVxcbiAgICBsZXQgYV9vZmZzZXQgPSAke00uaW5kaWNlc1RvT2Zmc2V0KFwiYV9pbmRpY2VzXCIpfTtcXG4gICAgJHtwZShOLGJlKX1cXG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtOLmluZGljZXNUb09mZnNldChcImJfaW5kaWNlc1wiKX07XFxuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7WS50eXBlLnZhbHVlfSwgJHt3fT47XFxuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke3l9KSB7XFxuICAgICAgJHt5ZSgpfVxcbiAgICB9XFxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7d311OyBpKyspIHtcXG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XFxuICAgICAgJHt0ZX1cXG4gICAgICAke3NlfVxcbiAgICAgIGxldCBjdXJfaW5kaWNlcyA9ICR7WS50eXBlLmluZGljZXN9KGJhdGNoLCByb3cgKyBpLCBjb2wpO1xcbiAgICAgIGxldCBvZmZzZXQgPSAke1kuaW5kaWNlc1RvT2Zmc2V0KFwiY3VyX2luZGljZXNcIil9O1xcbiAgICAgICR7WS5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHtkfWAsXCJ2YWx1ZVwiKX07XFxuICAgIH1cXG4gIH1cXG4gIGB9O3JldHVybntuYW1lOlwiTWF0TXVsTmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmFjdGl2YXRpb259OyR7ZH07JHt5fTske3d9OyR7aX1gLGlucHV0RGVwZW5kZW5jaWVzOnY/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKF8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpFfX0sUWQ9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpfSxXcz1lPT57UWQoZS5pbnB1dHMpO2xldCB0PXZ0LmNhbGNTaGFwZShlLmlucHV0c1swXS5kaW1zLGUuaW5wdXRzWzFdLmRpbXMsITApO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgcj10W3QubGVuZ3RoLTFdLG89ZS5pbnB1dHNbMF0uZGltc1tlLmlucHV0c1swXS5kaW1zLmxlbmd0aC0xXTtyPDgmJm88OD9lLmNvbXB1dGUoUG8oZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpOmUuY29tcHV0ZShNbihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSl9fSk7dmFyIFRvLE5zLGVjLEhzLGtvLHRjLHJjLFJvLEVvPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1VzKCk7V3IoKTtWcygpO1V0KCk7T28oKTtwcigpO1RvPShlLHQscixvLGksdSk9PntsZXQgYT1lWzBdLHA9ZS5zbGljZSh1PzE6Mix1PzM6NCksbT1wLmxlbmd0aCxoPXRbMF0seT10LnNsaWNlKDIpLm1hcCgodix4KT0+disodi0xKSooclt4XS0xKSksXz1wLm1hcCgodix4KT0+ditvW3hdK29beCttXSkubWFwKCh2LHgpPT5NYXRoLmZsb29yKCh2LXlbeF0raVt4XSkvaVt4XSkpO3JldHVybiBfLnNwbGljZSgwLDAsYSksXy5zcGxpY2UodT8zOjEsMCxoKSxffSxOcz1bMiwzLDEsMF0sZWM9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IGNvbnYgMUQgYW5kIDJEXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCByPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxvPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKHIhPT1vKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMV0uZGltc1swXSE9PWVbMl0uZGltc1swXSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBpPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke2l9RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtpfURgKTtpZih0LnBhZHMubGVuZ3RoIT09aSoyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtpKjJ9RGApO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIil9LEhzPShlLHQpPT57bGV0IHI9ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2ZvcihsZXQgdT0yO3U8dFsxXS5kaW1zLmxlbmd0aDsrK3Upclt1LTJdPT09MCYmKHJbdS0yXT10WzFdLmRpbXNbdV0pO2xldCBvPWUucGFkcy5zbGljZSgpO1h0LmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLHIsbyxlLmZvcm1hdD09PVwiTkhXQ1wiLGUuYXV0b1BhZCk7bGV0IGk9T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihpLHtrZXJuZWxTaGFwZTpyLHBhZHM6b30pLGl9LGtvPWU9PntsZXQgdD1rbihlKSxyPWUuZm9ybWF0LG89W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxpPWUuZGlsYXRpb25zLHU9ZS5ncm91cCxhPWUua2VybmVsX3NoYXBlLHA9ZS5wYWRzLG09ZS5zdHJpZGVzLGg9ZS53X2lzX2NvbnN0KCk7cmV0dXJue2F1dG9QYWQ6byxmb3JtYXQ6cixkaWxhdGlvbnM6aSxncm91cDp1LGtlcm5lbFNoYXBlOmEscGFkczpwLHN0cmlkZXM6bSx3SXNDb25zdDpoLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sdGM9KGUsdCxyKT0+e2xldCBvPUhzKHIsdCksaT1yLmZvcm1hdD09PVwiTkhXQ1wiO2lmKHIuZ3JvdXAhPT0xKXtlLmNvbXB1dGUoSW8odCxvKSk7cmV0dXJufWxldCB1PXQubGVuZ3RoPT09MyxhPXRbMF0uZGltc1tpPzE6Ml0scD10WzBdLmRpbXNbaT8yOjNdLG09dFswXS5kaW1zW2k/MzoxXSxoPXRbMV0uZGltc1syXSxkPXRbMV0uZGltc1szXSx5PVRvKHRbMF0uZGltcyx0WzFdLmRpbXMsci5kaWxhdGlvbnMsby5wYWRzLHIuc3RyaWRlcyxpKSx3PXlbaT8xOjJdLF89eVtpPzI6M10sdj15W2k/MzoxXSx4PWkmJmg9PT1hJiZkPT09cCYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MDtpZih4fHxoPT09MSYmZD09PTEmJnIuZGlsYXRpb25zWzBdPT09MSYmci5kaWxhdGlvbnNbMV09PT0xJiZyLnN0cmlkZXNbMF09PT0xJiZyLnN0cmlkZXNbMV09PT0xJiZyLnBhZHNbMF09PT0wJiZyLnBhZHNbMV09PT0wKXtsZXQgTT15WzBdLE4sWSxzZSxCPVtdO2lmKGkpe2xldCBFZT1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZSh5dCh0WzFdLE5zKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO2lmKHIud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9RWUpLHgpe2xldCBlZT1hKnAqbTtOPXRbMF0ucmVzaGFwZShbMSxNLGVlXSksWT1FZS5yZXNoYXBlKFsxLGVlLHZdKSxzZT1bMSxNLHZdfWVsc2UgTj10WzBdLnJlc2hhcGUoW00sYSpwLG1dKSxZPUVlLnJlc2hhcGUoWzEsbSx2XSksc2U9W00sdypfLHZdO0IucHVzaChOKSxCLnB1c2goWSl9ZWxzZSBOPXRbMF0ucmVzaGFwZShbTSxtLGEqcF0pLFk9dFsxXS5yZXNoYXBlKFsxLHYsbV0pLHNlPVtNLHYsdypfXSxCLnB1c2goWSksQi5wdXNoKE4pO3UmJkIucHVzaCh0WzJdKTtsZXQgdGU9c2VbMl0sUGU9QlswXS5kaW1zW0JbMF0uZGltcy5sZW5ndGgtMV07dGU8OCYmUGU8OD9lLmNvbXB1dGUoUG8oQixvLHksc2UsaSkse2lucHV0czpCfSk6ZS5jb21wdXRlKE1uKEIsbyx5LHNlLGkpLHtpbnB1dHM6Qn0pO3JldHVybn1sZXQgVD0hMCxDPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKHl0KHRbMV0sTnMpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1DKTtsZXQgUz1bdFswXSxDXTt1JiZTLnB1c2godFsyXSk7bGV0IEU9aT93Kl86dixPPWk/djp3Kl8sVT1oKmQqbTtlLmNvbXB1dGUoenMoUyxvLHksRSxPLFUsdSxUKSx7aW5wdXRzOlN9KX0scmM9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG89W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm8ucHVzaChlLmlucHV0c1syXSk7bGV0IGk9WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSx1PVsxXS5jb25jYXQodC5zdHJpZGVzKSxhPVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLHA9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSxtPUhzKHsuLi50LHBhZHM6aSxzdHJpZGVzOnUsZGlsYXRpb25zOmEsa2VybmVsU2hhcGU6cH0sbyk7ZS5jb21wdXRlKElvKG8sbSxoPT5yP1toWzBdLGhbMl0saFszXV06W10pKX0sUm89KGUsdCk9PntlYyhlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTM/cmMoZSx0KTp0YyhlLGUuaW5wdXRzLHQpfX0pO3ZhciBuYyxHcyxMcz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7enQoKTtfZSgpO1V0KCk7Qm4oKTtBbygpO1dyKCk7bmM9KGUsdD0hMSxyLG89NCk9PntsZXQgaT1qZShvLFwiZjMyXCIpLHU9Qz0+e3N3aXRjaChDKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XCI7Y2FzZSA0OnJldHVybmBcXG4gICAgICAgICAgICBsZXQgY29vcmQxID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAxLCByb3dJbm5lcik7XFxuICAgICAgICAgICAgbGV0IGNvb3JkMiA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMiwgcm93SW5uZXIpO1xcbiAgICAgICAgICAgIGxldCBjb29yZDMgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDMsIHJvd0lubmVyKTtcXG4gICAgICAgICAgICBsZXQgdjAgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcXG4gICAgICAgICAgICBsZXQgdjEgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMSwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XFxuICAgICAgICAgICAgbGV0IHYyID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDIsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xcbiAgICAgICAgICAgIGxldCB2MyA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQzLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcXG4gICAgICAgICAgICByZXR1cm4gdmVjNDxmMzI+KHYwLCB2MSwgdjIsIHYzKTtcXG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7Q30gaXMgbm90IHN1cHBvcnRlZC5gKX19LGE9ZT9gXFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCBpWFIsIGlYQywgeENoKTtcXG4gICAgICBgOmBcXG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgaVhSLCBpWEMpO1xcbiAgICAgIGAscD1lP2BcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3cgLyBvdXRXaWR0aCxcXG4gICAgICByb3cgJSBvdXRXaWR0aCxcXG4gICAgICBjb2wpO1xcbiAgICBgOmBcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3csXFxuICAgICAgY29sIC8gb3V0V2lkdGgsXFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xcbiAgICBgLG09ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIsaD1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIixkPWU/XCJyb3dcIjpcImNvbFwiLHk9ZT9cImNvbFwiOlwicm93XCIsdz1gXFxuICAgICAgbGV0IGluQ2hhbm5lbHMgPSAke2U/XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwifTtcXG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XFxuICAgICAgbGV0IG91dFJvdyA9ICR7ZH0gLyBvdXRXaWR0aDtcXG4gICAgICBsZXQgb3V0Q29sID0gJHtkfSAlIG91dFdpZHRoO1xcblxcbiAgICAgIGxldCBXUm93ID0gJHt5fSAvICh1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXSAqIGluQ2hhbm5lbHMpO1xcbiAgICAgIGxldCBXQ29sID0gJHt5fSAvIGluQ2hhbm5lbHMgJSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTtcXG4gICAgICBsZXQgeFIgPSBmMzIob3V0Um93IC0gdW5pZm9ybXMucGFkc1swXSArIHVuaWZvcm1zLmRpbGF0aW9uc1swXSAqIFdSb3cpIC8gZjMyKHVuaWZvcm1zLnN0cmlkZXNbMF0pO1xcbiAgICAgIGxldCB4QyA9IGYzMihvdXRDb2wgLSB1bmlmb3Jtcy5wYWRzWzFdICsgdW5pZm9ybXMuZGlsYXRpb25zWzFdICogV0NvbCkgLyBmMzIodW5pZm9ybXMuc3RyaWRlc1sxXSk7XFxuICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49IGYzMigke219KSB8fCBmcmFjdCh4UikgPiAwLjApIHtcXG4gICAgICAgIHJldHVybiAke2l9KDAuMCk7XFxuICAgICAgfVxcbiAgICAgIGlmICh4QyA8IDAuMCB8fCB4QyA+PSBmMzIoJHtofSkgfHwgZnJhY3QoeEMpID4gMC4wKSB7XFxuICAgICAgICByZXR1cm4gJHtpfSgwLjApO1xcbiAgICAgIH1cXG4gICAgICBsZXQgaVhSID0gaTMyKHhSKTtcXG4gICAgICBsZXQgaVhDID0gaTMyKHhDKTtcXG4gICAgICBsZXQgeENoID0gJHt5fSAlIGluQ2hhbm5lbHM7XFxuICAgICAgJHthfVxcbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpLyR7b31dO2AsXz1lP2BcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke299O1xcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpIHtcXG4gICAgICAgICR7d31cXG4gICAgICB9XFxuICAgICAgcmV0dXJuICR7aX0oMC4wKTtgOmBcXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke299O1xcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcXG4gICAgICAgICR7d31cXG4gICAgICB9XFxuICAgICAgcmV0dXJuICR7aX0oMC4wKTtgLHY9YFxcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7b307XFxuICAgICAgbGV0IGluQ2hhbm5lbHMgPSAke2U/XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwifTtcXG4gICAgICBsZXQgY29vcmRYID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF0gLSAxIC0gcm93IC8gKHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdICogaW5DaGFubmVscyk7XFxuICAgICAgbGV0IGNvb3JkWSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdIC0gMSAtIChyb3cgLyBpbkNoYW5uZWxzKSAlIHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdO1xcbiAgICAgIGlmICgke2U/XCJyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXJcIjpcInJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlclwifSAgJiYgY29vcmRYID49IDAgJiYgY29vcmRZID49IDApIHtcXG4gICAgICAgIGxldCByb3dJbm5lciA9IHJvdyAlIGluQ2hhbm5lbHM7XFxuICAgICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCwgcm93SW5uZXIpO1xcbiAgICAgICAgJHt1KG8pfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJHtpfSgwLjApO1xcbiAgICAgIGAseD1BdChyLGkpO3JldHVybmBcXG4gIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7aX0ge1xcbiAgICAke2U/Xzp2fVxcbiAgfVxcblxcbiAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtpfSB7XFxuICAgICR7ZT92Ol99XFxuICB9XFxuXFxuICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUlucHV0IDogJHtpfSkge1xcbiAgICBsZXQgY29sID0gY29sSW4gKiAke299O1xcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcXG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0O1xcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKVwifTtcXG4gICAgICAke3B9XFxuICAgICAgJHtSbih0KX1cXG4gICAgICAke3h9XFxuICAgICAgcmVzdWx0W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcywgdmVjNDxpMzI+KHVuaWZvcm1zLnJlc3VsdF9zaGFwZSkpLyR7b31dID0gdmFsdWU7XFxuICAgIH1cXG4gIH1gfSxHcz0oZSx0LHIsbyxpLHUsYSxwKT0+e2xldCBtPXQuZm9ybWF0PT09XCJOSFdDXCIsaD1tP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sZD1yWzBdLHk9bT9yWzJdOnJbM10sdz1tP3JbMV06clsyXSxfPW0/clszXTpyWzFdLHY9bT9oJTQ9PT0wJiZfJTQ9PT0wOnklND09PTAmJl8lND09PTAseD1tP186eSp3LFQ9bT95Knc6XyxDPXY/WzgsOCwxXTpbeDw9NHx8VDw9ND80OjE2LHg+NCYmVDw9ND80OjE2LDFdLFM9dj9bNCw0LDFdOlt4PD00PzE6NCx4PjQmJlQ8PTQ/MTo0LDFdLEU9W01hdGguY2VpbCh4L0NbMF0vU1swXSksTWF0aC5jZWlsKFQvQ1sxXS9TWzFdKSxNYXRoLmNlaWwoZC9DWzJdL1NbMl0pXTtEZShcInZlcmJvc2VcIiwoKT0+YFtjb252X2JhY2twcm9wX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke0V9YCk7bGV0IE89dj80OjEsVT1NYXRoLm1heChDWzBdKk8sQ1sxXSksTT12PzQ6MSxOPVt0Lmtlcm5lbFNoYXBlW20/MToyXSx0Lmtlcm5lbFNoYXBlW20/MjozXV0sWT1bTlswXSsodC5kaWxhdGlvbnNbMF08PTE/MDooTlswXS0xKSoodC5kaWxhdGlvbnNbMF0tMSkpLE5bMV0rKHQuZGlsYXRpb25zWzFdPD0xPzA6KE5bMV0tMSkqKHQuZGlsYXRpb25zWzFdLTEpKV0sc2U9W1lbMF0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMF0rdC5wYWRzWzJdKS8yKSxZWzFdLTEtTWF0aC5mbG9vcigodC5wYWRzWzFdK3QucGFkc1szXSkvMildLEI9W3t0eXBlOlwiaW50MzJcIixkYXRhOm99LHt0eXBlOlwiaW50MzJcIixkYXRhOml9LHt0eXBlOlwiaW50MzJcIixkYXRhOnV9LHt0eXBlOlwiaW50MzJcIixkYXRhOnQuc3RyaWRlc30se3R5cGU6XCJpbnQzMlwiLGRhdGE6dC5kaWxhdGlvbnN9LHt0eXBlOlwiaW50MzJcIixkYXRhOk59LHt0eXBlOlwiaW50MzJcIixkYXRhOnNlfV07dC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJkIucHVzaCh7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuY2xpcE1heH0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmNsaXBNaW59KSxCLnB1c2goLi4uRyhlWzBdLmRpbXMpLC4uLkcoZVsxXS5kaW1zKSk7bGV0IHRlPVtcInJhbmtcIixcInJhbmtcIl07YSYmKEIucHVzaCguLi5HKGVbMl0uZGltcykpLHRlLnB1c2goXCJyYW5rXCIpKSxCLnB1c2goLi4uRyhyKSk7bGV0IFBlPUVlPT57bGV0IGVlPVYoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLE0pLGJlPVYoXCJ3XCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLDEpLE1lPUooXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLE0pLHBlPVtlZSxiZV0seWU9XCJcIjtpZihhKXtsZXQgd2U9VihcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsTSk7cGUucHVzaCh3ZSkseWUrPWBcXG4gICAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0ge1xcbiAgICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke20/XCJ3XCI6XCJ5XCJ9JHt2P1wiLyA0XCI6XCJcIn1dO1xcbiAgICAgICAgICB9YH1sZXQgZGU9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpOLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpzZS5sZW5ndGh9XTtyZXR1cm4gdC5hY3RpdmF0aW9uPT09XCJDbGlwXCImJmRlLnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pLGBcXG4gICAgICAgICR7RG4oXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cXG4gICAgICAgICR7RWUucmVnaXN0ZXJVbmlmb3JtcyhkZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5wZSxNZSl9O1xcbiAgICAgICAgJHt5ZX1cXG4gICAgICAgICR7bmMobSxhLHQsTyl9XFxuICAgICAgICAke3Y/VXIoUyxDLFwiZjMyXCIsdm9pZCAwLCFtLFUpOlZyKFMsQyxcImYzMlwiLHZvaWQgMCwhbSxVLCExLHZvaWQgMCxwKX1gfTtyZXR1cm57bmFtZTpcIkNvbnYyRFRyYW5zcG9zZU1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7U307JHtDfTske3Z9YCxpbnB1dERlcGVuZGVuY2llczp0ZX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OkVbMF0seTpFWzFdLHo6RVsyXX0scHJvZ3JhbVVuaWZvcm1zOkJ9KSxnZXRTaGFkZXJTb3VyY2U6UGV9fX0pO3ZhciBvYyxCbyxGcz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7enQoKTtDZSgpO19lKCk7b2M9KGUsdCxyLG8saSx1PSExLGEscCxtPSExKT0+e2xldCBoPW0/MToyLGQ9bT8yOjMseT1tPzM6MSx3PXU/MjoxLF89YFxcbiAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiB1MzIsIHZhbHVlIDogJHt1P2B2ZWM0PCR7YX0+YDphfSkge1xcbiAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7dT9gdmVjNDwke2F9PmA6YX0odmFsdWUpO1xcbiAgfWA7byYmKF8rPWBcXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHt1P2B2ZWM0PCR7YX0+YDphfSB7XFxuICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7bT9cIndcIjpcInlcIn0ke3U/XCIvIDRcIjpcIlwifV07XFxuICAgIH1gKTtsZXQgdj11PzQ6MSx4PVYoXCJXXCIsdFsxXS5kYXRhVHlwZSx0WzFdLmRpbXMubGVuZ3RoLHYpLFQ9VihcIkR5XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMubGVuZ3RoLHYpLEM9W1QseF07byYmQy5wdXNoKFYoXCJiaWFzXCIsdFsyXS5kYXRhVHlwZSxbclt5XV0ubGVuZ3RoLHYpKTtsZXQgUz1KKFwicmVzdWx0XCIsdFswXS5kYXRhVHlwZSxyLmxlbmd0aCx2KSxFPWB7XFxuICAgICAgICBsZXQgYmF0Y2g6IHUzMiA9ICR7aT9cImdsb2JhbF9pZC56XCI6XCJ3b3JrZ3JvdXBfaWQuelwifSAvIHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsxXTtcXG4gICAgICAgIGxldCByID0gJHtpP1wiZ2xvYmFsX2lkLnpcIjpcIndvcmtncm91cF9pZC56XCJ9ICUgdW5pZm9ybXMucmVzdWx0X3NoYXBlWzFdO1xcbiAgICAgICAgbGV0IGMgPSAke2k/XCJnbG9iYWxfaWQueVwiOlwid29ya2dyb3VwX2lkLnlcIn0gKiAke3d9O1xcbiAgICAgICAgbGV0IGQxOiB1MzIgPSAke2k/XCJnbG9iYWxfaWQueFwiOlwid29ya2dyb3VwX2lkLnhcIn0gKiA0O1xcblxcbiAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHZlYzI8aTMyPih1bmlmb3Jtcy5wYWRzKTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICB2YXIgZG90UHJvZDogYXJyYXk8dmVjNDwke2F9PiwgJHt3fT47XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7d307IGkrKykge1xcbiAgICAgICAgICBkb3RQcm9kW2ldID0gdmVjNDwke2F9PigwLjApO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdSID0gd1IgKyAxKSB7XFxuICAgICAgICAgIHZhciBkeVIgPSAoJHthfShkeUNvcm5lci54KSArICR7YX0od1IpKSAvICR7YX0odW5pZm9ybXMuc3RyaWRlcy54KTtcXG4gICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdIC0gMSAtIHdSO1xcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2F9KHVuaWZvcm1zLkR5X3NoYXBlWzFdKSB8fFxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCB8fCB3UlBlcm0gPCAwKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd0MgPSB3QyArIDEpIHtcXG4gICAgICAgICAgICBsZXQgZHlDID0gKCR7YX0oZHlDb3JuZXIueSkgKyAke2F9KHdDKSkgLyAke2F9KHVuaWZvcm1zLnN0cmlkZXMueSk7XFxuICAgICAgICAgICAgbGV0IGR5QzIgPSAoJHthfShkeUNvcm5lci55KSArIDEuMCArICR7YX0od0MpKSAvICR7YX0odW5pZm9ybXMuc3RyaWRlcy55KTtcXG4gICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gLSAxIC0gd0M7XFxuICAgICAgICAgICAgaWYgKHdDUGVybSA8IDApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbCA9IHRydWU7XFxuICAgICAgICAgICAgdmFyIGJEeUNWYWwyID0gdHJ1ZTtcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2F9KHVuaWZvcm1zLkR5X3NoYXBlWzJdKSB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBiRHlDVmFsID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChkeUMyIDwgMC4wIHx8IGR5QzIgPj0gJHthfSh1bmlmb3Jtcy5EeV9zaGFwZVsyXSkgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDMikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGJEeUNWYWwyID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcXG4gICAgICAgICAgICBsZXQgaWR5QzI6IHUzMiA9IHUzMihkeUMyKTtcXG4gICAgICAgICAgICBpZiAoYkR5Q1ZhbCAmJiBiRHlDVmFsMikge1xcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gdW5pZm9ybXMuRHlfc2hhcGVbM107XFxuICAgICAgICAgICAgICBmb3IgKHZhciBkMiA6dTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3guZ2V0KFwidTMyKHdSUGVybSlcIixcInUzMih3Q1Blcm0pXCIsXCJkMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMVwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgMlwiLFwiZDJcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxICsgM1wiLFwiZDJcIil9O1xcblxcbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtULmdldChcImJhdGNoXCIsXCJpZHlSXCIsXCJpZHlDXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7YX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XFxuXFxuICAgICAgICAgICAgICAgIHhWYWx1ZSA9ICAke1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XFxuXFxuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdmVjNDwke2F9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsKSB7XFxuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVske3l9XTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XFxuXFxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImQyXCIpfTtcXG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHthfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJEeUNWYWwyKSB7XFxuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7eC5nZXQoXCJ1MzIod1JQZXJtKVwiLFwidTMyKHdDUGVybSlcIixcImQxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAxXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAyXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHt4LmdldChcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiLFwiZDEgKyAzXCIsXCJkMlwiKX07XFxuXFxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUMyXCIsXCJkMlwiKX07XFxuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7YX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZFsxXSA9IGRvdFByb2RbMV0gKyB0bXB2YWw7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHt3fTsgaSA9IGkgKyAxKSB7XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2RbaV0gKyAke28/XCJiaWFzW2MraV1cIjpgdmVjNDwke2F9PigwLjApYH07XFxuICAgICAgICAgICR7Uy5zZXQoXCJiYXRjaFwiLFwiclwiLFwiYyArIGlcIixcImQxXCIsXCJ2YWx1ZVwiKX07XFxuICAgICAgICB9XFxuICAgICAgfWAsTz1gXFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xcbiAgICAgICAgICBsZXQgYmF0Y2ggPSAke1MuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XFxuICAgICAgICAgIGxldCBkMSA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHkpfTtcXG4gICAgICAgICAgbGV0IHIgPSAke1MuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixoKX07XFxuICAgICAgICAgIGxldCBjID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsZCl9O1xcbiAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdW5pZm9ybXMucGFkcztcXG4gICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcXG4gICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcXG4gICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgICB2YXIgZG90UHJvZCA9ICR7YX0oMC4wKTtcXG4gICAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLng7IHdSID0gd1IgKyAxKSB7XFxuICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBkeVIgPSAoJHthfShkeVJDb3JuZXIpICsgJHthfSh3UikpIC8gJHthfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcXG4gICAgICAgICAgICBsZXQgd1JQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueCAtIDEgLSB3UiAvIHVuaWZvcm1zLmRpbGF0aW9ucy54O1xcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7YX0odW5pZm9ybXMuRHlfc2hhcGVbJHtofV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcXG4gICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcXG5cXG4gICAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueTsgd0MgPSB3QyArIDEpIHtcXG4gICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7YX0oZHlDQ29ybmVyKSArICR7YX0od0MpKSAvICR7YX0odW5pZm9ybXMuc3RyaWRlcy55KTtcXG4gICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2F9KHVuaWZvcm1zLkR5X3NoYXBlWyR7ZH1dKSB8fFxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcXG4gICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwOyBkMiA9IGQyICsgMSkge1xcbiAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHttP1QuZ2V0KFwiYmF0Y2hcIixcImlkeVJcIixcImlkeUNcIixcImlucHV0Q2hhbm5lbFwiKTpULmdldChcImJhdGNoXCIsXCJpbnB1dENoYW5uZWxcIixcImlkeVJcIixcImlkeUNcIil9O1xcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlID0gJHt4LmdldChcImlucHV0Q2hhbm5lbFwiLFwid091dENoYW5uZWxcIixcInUzMih3UlBlcm0pXCIsXCJ1MzIod0NQZXJtKVwiKX07XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAxO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kICsgJHtvP1wiYmlhc1tkMV1cIjpgJHthfSgwLjApYH07XFxuICAgICAgICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMocCkuZGVjbGFyZVZhcmlhYmxlcyguLi5DLFMpfVxcbiAgJHtffVxcblxcbiAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9O1xcbiAgJHt1P0U6T319YH0sQm89KGUsdCxyKT0+e2xldCBvPWUubGVuZ3RoPjIsaT10Lm91dHB1dFNoYXBlLHU9Vy5zaXplKGkpLGE9W01hdGguY2VpbCh1LzY0KSwxLDFdO0RlKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHthfWApO2xldCBwPXQuZm9ybWF0PT09XCJOSFdDXCIsbT1bXCJyYW5rXCIsXCJyYW5rXCJdLGg9W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dLGQ9W3Qua2VybmVsU2hhcGVbcD8xOjJdLHQua2VybmVsU2hhcGVbcD8yOjNdXSx5PVt0LmRpbGF0aW9uc1swXSx0LmRpbGF0aW9uc1sxXV0sdz1bZFswXSsodC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVtwPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpKSxkWzFdKyh0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW3A/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSkpXSxfPVt3WzBdLTEtTWF0aC5mbG9vcigodC5wYWRzWzBdK3QucGFkc1syXSkvMiksd1sxXS0xLU1hdGguZmxvb3IodC5wYWRzWzFdK3QucGFkc1szXSkvMl0sdj0hMSx4PXQuZ3JvdXAsVD1lWzFdLmRpbXMsQz1UWzBdL3gsUz1UWzFdLEU9W3t0eXBlOlwiaW50MzJcIixkYXRhOnV9LHt0eXBlOlwidWludDMyXCIsZGF0YTpofSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6ZH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnl9LHt0eXBlOlwidWludDMyXCIsZGF0YTp3fSx7dHlwZTpcImludDMyXCIsZGF0YTpffSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6Q30se3R5cGU6XCJ1aW50MzJcIixkYXRhOlN9LC4uLkcoZVswXS5kaW1zKSwuLi5HKGVbMV0uZGltcyldO28mJihFLnB1c2goLi4uRyhlWzJdLmRpbXMpKSxtLnB1c2goXCJyYW5rXCIpKSxFLnB1c2goLi4uRyhpKSk7bGV0IE89YVsxXT09PTEmJmFbMl09PT0xLFU9TT0+e2xldCBOPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmgubGVuZ3RofSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpkLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmQubGVuZ3RofSx7bmFtZTpcImVmZmVjdGl2ZV9maWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dy5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Xy5sZW5ndGh9LHtuYW1lOlwiaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XSxZPU5lKGVbMF0uZGF0YVR5cGUpO3JldHVybmAke29jKE0sZSxpLG8sTyx2LFksTixwKX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9O2AsaW5wdXREZXBlbmRlbmNpZXM6bX0sZ2V0UnVuRGF0YTooKT0+KHtkaXNwYXRjaEdyb3VwOnt4OmFbMF0seTphWzFdLHo6YVsyXX0sb3V0cHV0czpbe2RpbXM6cj9yKGkpOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLHByb2dyYW1Vbmlmb3JtczpFfSksZ2V0U2hhZGVyU291cmNlOlV9fX0pO3ZhciBpYyxhYyxzYyxqcyxxcyx1YyxsYyxkYyxjYyxLcyxZcz1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7THMoKTtGcygpO1V0KCk7cHIoKTtpYz0oZSx0LHIsbyxpLHUpPT4oZS0xKSp0K3IrKG8tMSkqaSsxLXUsYWM9KGUsdCxyLG8saSk9PntsZXQgdT1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW29dPXUscltpXT1lLXUpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbb109ZS11LHJbaV09dSl9LHNjPShlLHQscixvLGksdSxhLHAsbSxoKT0+e2xldCBkPWUubGVuZ3RoLTIseT1oLmxlbmd0aD09PTA7aWYobS5sZW5ndGg9PT0wKWZvcihsZXQgdj0wO3Y8ZDsrK3YpbS5wdXNoKDApO2xldCB3PWVbMF0sXz10W3A/MzoxXSppO2ZvcihsZXQgdj0wLHg9ZS5sZW5ndGgtZC0ocD8xOjApO3Y8ZDsrK3YsKyt4KXtsZXQgVD1lW3hdLEM9eT9UKmFbdl06aFt2XSxTPWljKFQsYVt2XSx1W3ZdLHRbeF0sclt2XSxDKTthYyhTLG8sdSx2LHYrZCkseSYmaC5wdXNoKGFbdl0qKFQtMSkrbVt2XSsodFt4XS0xKSpyW3ZdKzEtdVt2XS11W3YrZF0pfWguc3BsaWNlKDAsMCx3KSxoLnNwbGljZShwPzM6MSwwLF8pfSxqcz0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKCh5LHcpPT55KncsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgeT0yO3k8dFsxXS5kaW1zLmxlbmd0aDsrK3kpci5wdXNoKHRbMV0uZGltc1t5XSl9bGV0IG89ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShvPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IGk9ZS5wYWRzLnNsaWNlKCksdT1lLm91dHB1dFNoYXBlLnNsaWNlKCksYT1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxwPXRbMF0uZGltcyxtPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYobS5yZWR1Y2UoKHksdyk9PnkrdywwKT09PTApe2xldCB5PXRbMF0uZGltcy5sZW5ndGgtMjttPW5ldyBBcnJheSh5KS5maWxsKDEpfWxldCBoPWUuc3RyaWRlcy5zbGljZSgpO2lmKGgucmVkdWNlKCh5LHcpPT55K3csMCk9PT0wKXtsZXQgeT10WzBdLmRpbXMubGVuZ3RoLTI7aD1uZXcgQXJyYXkoeSkuZmlsbCgxKX1zYyhwLHIsbSxlLmF1dG9QYWQsZS5ncm91cCxpLGgsbyxhLHUpO2xldCBkPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZCx7a2VybmVsU2hhcGU6cixwYWRzOmksb3V0cHV0UGFkZGluZzphLG91dHB1dFNoYXBlOnUsZGlsYXRpb25zOm0sc3RyaWRlczpofSksZH0scXM9ZT0+e2xldCB0PWtuKGUpLHI9ZS5mb3JtYXQsbz1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLGk9ZS5kaWxhdGlvbnMsdT1lLmdyb3VwLGE9ZS5rZXJuZWxTaGFwZSxwPWUucGFkcyxtPWUuc3RyaWRlcyxoPWUud0lzQ29uc3QoKSxkPWUub3V0cHV0UGFkZGluZyx5PWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6byxmb3JtYXQ6cixkaWxhdGlvbnM6aSxncm91cDp1LGtlcm5lbFNoYXBlOmEsb3V0cHV0UGFkZGluZzpkLG91dHB1dFNoYXBlOnkscGFkczpwLHN0cmlkZXM6bSx3SXNDb25zdDpoLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sdWM9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbz1lWzFdLmRpbXNbMF07aWYociE9PW8pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgaT1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09aSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCB1PWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKGQseSk9PmQreSwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT11KXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3V9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKGQseSk9PmQreSwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09dSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7dX1EYCk7aWYodC5wYWRzLnJlZHVjZSgoZCx5KT0+ZCt5LDApPjAmJnQucGFkcy5sZW5ndGghPT11KjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3UqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXUmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7dX1EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKGQseSk9PmQreSwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LGxjPVsyLDMsMSwwXSxkYz0oZSx0LHIpPT57bGV0IG89anMocix0KSxpPXIuZm9ybWF0PT09XCJOSFdDXCIsdT1vLm91dHB1dFNoYXBlLGE9dVtpPzM6MV0scD10WzBdLmRpbXNbaT8zOjFdO2lmKG8uZ3JvdXAhPT0xfHxhPT09MSYmcD09PTEpe2UuY29tcHV0ZShCbyh0LG8pKTtyZXR1cm59bGV0IG09dVtpPzE6Ml0saD11W2k/MjozXSxkPXRbMV0uZGltc1syXSx5PXRbMV0uZGltc1szXSx3PWk/bSpoOmEsXz1pP2E6bSpoLHY9ZCp5KnAseD0hMCxUPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKHl0KHRbMV0sbGMpLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1UKTtsZXQgQz1bdFswXSxUXSxTPXQubGVuZ3RoPT09MztTJiYoIWkmJnRbMl0uZGltcy5sZW5ndGg9PT0xP0MucHVzaCh0WzJdLnJlc2hhcGUoW3RbMl0uZGltc1swXSwxLDFdKSk6Qy5wdXNoKHRbMl0pKSxlLmNvbXB1dGUoR3MoQyxvLHUsdyxfLHYsUyx4KSx7aW5wdXRzOkN9KX0sY2M9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG89W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO28ubGVuZ3RoPT09MyYmby5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgaT10Lmtlcm5lbFNoYXBlOyhpLmxlbmd0aD09PTB8fGlbMF09PT0wKSYmKGk9W2UuaW5wdXRzWzFdLmRpbXNbMl1dKTtsZXQgdT10LmRpbGF0aW9uczsodS5sZW5ndGg9PT0wfHx1WzBdPT09MCkmJih1PVsxXSk7bGV0IGE9dC5zdHJpZGVzOyhhLmxlbmd0aD09PTB8fGFbMF09PT0wKSYmKGE9WzFdKTtsZXQgcD10LnBhZHM7cC5sZW5ndGg9PT0wJiYocD1bMCwwXSkscD1bMCxwWzBdLDAscFsxXV0sYT1bMV0uY29uY2F0KGEpLHU9WzFdLmNvbmNhdCh1KSxpPVsxXS5jb25jYXQoaSk7bGV0IG09anMoey4uLnQscGFkczpwLHN0cmlkZXM6YSxkaWxhdGlvbnM6dSxrZXJuZWxTaGFwZTppfSxvKTtlLmNvbXB1dGUoQm8obyxtLGg9PnI/W2hbMF0saFsyXSxoWzNdXTpbaFswXSxoWzFdLGhbM11dKSl9LEtzPShlLHQpPT57dWMoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zP2NjKGUsdCk6ZGMoZSxlLmlucHV0cyx0KX19KTt2YXIgcGMsWnMsWHMsSnM9USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7Q2UoKTtZZSgpO19lKCk7cGM9KGUsdCxyLG8pPT57bGV0IGk9Vy5zaXplKHQpLHU9dC5sZW5ndGgsYT1WKFwiaW5wdXRcIixlLHUpLHA9SihcIm91dHB1dFwiLGUsdSksbT1yLmRhdGFUeXBlPT09Nj9yLmdldEludDMyQXJyYXkoKVswXTpOdW1iZXIoci5nZXRCaWdJbnQ2NEFycmF5KClbMF0pLGg9Vy5ub3JtYWxpemVBeGlzKG0sdSksZD15PT57bGV0IHc9YCBpMzIoJHthLmluZGljZXNHZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9KSBgLF89Y2UoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLHUpLHY9by5yZXZlcnNlP3crKG8uZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLHg9by5yZXZlcnNlP186dysoby5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxcbiAgICAgICAgICAgICAgICAke3kucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGEscCl9XFxuICAgICAgICAgICAgICAgICR7eS5tYWluU3RhcnQoKX1cXG4gICAgICAgICAgICAgICAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XFxuICAgICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7cC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtwLnR5cGUudmFsdWV9KDApO1xcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7dn07XFxuICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgOiBpMzIgPSAke3h9O1xcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgJHthLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XFxuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAke2EuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpfTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcXG4gICAgICAgICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQ3VtU3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6by5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOlwidWludDMyXCIsZGF0YTppfSx7dHlwZTpcImludDMyXCIsZGF0YTpofSwuLi5HKHQpLC4uLkcodCldfSksZ2V0U2hhZGVyU291cmNlOmR9fSxacz0oZSx0KT0+e2xldCByPWUuaW5wdXRzWzBdLmRpbXMsbz1lLmlucHV0c1swXS5kYXRhVHlwZSxpPWUuaW5wdXRzWzFdO2UuY29tcHV0ZShwYyhvLHIsaSx0KSx7aW5wdXRzOlswXX0pfSxYcz1lPT57bGV0IHQ9ZS5leGNsdXNpdmU9PT0xLHI9ZS5yZXZlcnNlPT09MTtyZXR1cm4geGUoe2V4Y2x1c2l2ZTp0LHJldmVyc2U6cn0pfX0pO3ZhciBEbyx6bixRcyxtYyxmYyxNbyx6byxldSxoYyx0dSxydSxudT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtZZSgpO19lKCk7RG89XCJbYS16QS1aXXxcXFxcXFxcXC5cXFxcXFxcXC5cXFxcXFxcXC5cIix6bj1cIihcIitEbytcIikrXCIsUXM9XCJeXCIrem4rXCIkXCIsbWM9XCIoXCIrem4rXCIsKSpcIit6bixmYz1cIl5cIittYytcIiRcIixNbz1jbGFzc3tjb25zdHJ1Y3Rvcih0PS0xKXt0aGlzLnN5bWJvbFRvSW5kaWNlcz1uZXcgTWFwLHRoaXMuaW5wdXRJbmRleD10fWFkZFN5bWJvbCh0LHIpe2xldCBvPXRoaXMuc3ltYm9sVG9JbmRpY2VzLmdldCh0KTtvPT09dm9pZCAwP289W3JdOm8ucHVzaChyKSx0aGlzLnN5bWJvbFRvSW5kaWNlcy5zZXQodCxvKX19LHpvPWNsYXNze2NvbnN0cnVjdG9yKHQscil7dGhpcy5lcXVhdGlvbj1yO3RoaXMuaGFzRWxsaXBzaXM9ITEsdGhpcy5zeW1ib2xUb0luZm89bmV3IE1hcCx0aGlzLmxocz1uZXcgQXJyYXksdGhpcy5vdXRwdXREaW1zPVtdO2xldFtvLGldPXIuaW5jbHVkZXMoXCItPlwiKT9yLnNwbGl0KFwiLT5cIiwyKTpbcixcIlwiXTtpZighby5tYXRjaChSZWdFeHAoZmMpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2lmKG8uc3BsaXQoXCIsXCIpLmZvckVhY2goKHAsbSk9PntsZXQgaD10W21dLmRpbXMuc2xpY2UoKTtpZighcC5tYXRjaChSZWdFeHAoUXMpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBkPXRoaXMucHJvY2Vzc1Rlcm0ocCwhMCxoLG0pO3RoaXMubGhzLnB1c2goZCl9KSxpPT09XCJcIilpKz1bLi4udGhpcy5zeW1ib2xUb0luZm8uZW50cmllcygpXS5maWx0ZXIoKFtwLG1dKT0+bS5jb3VudD09PTF8fHA9PT1cIi4uLlwiKS5tYXAoKFtwXSk9PnApLmpvaW4oXCJcIik7ZWxzZSBpZighaS5tYXRjaChSZWdFeHAoem4pKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIU1wiKTtpLm1hdGNoKFJlZ0V4cChEbyxcImdcIikpPy5mb3JFYWNoKHA9PntpZihwPT09XCIuLi5cIil0aGlzLm91dHB1dERpbXM9dGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7ZWxzZXtsZXQgbT10aGlzLnN5bWJvbFRvSW5mby5nZXQocCk7aWYobT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIUyBzeW1ib2xcIik7dGhpcy5vdXRwdXREaW1zLnB1c2gobS5kaW1WYWx1ZSl9fSksdGhpcy5yaHM9dGhpcy5wcm9jZXNzVGVybShpLCExLHRoaXMub3V0cHV0RGltcyl9YWRkU3ltYm9sKHQscixvKXtsZXQgaT10aGlzLnN5bWJvbFRvSW5mby5nZXQodCk7aWYoaSE9PXZvaWQgMCl7aWYoaS5kaW1WYWx1ZSE9PXImJmkuY291bnQhPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpLmNvdW50KyssaS5pbnB1dEluZGljZXMucHVzaChvKX1lbHNlIGk9e2NvdW50OjEsZGltVmFsdWU6cixpbnB1dEluZGljZXM6W29dfTt0aGlzLnN5bWJvbFRvSW5mby5zZXQodCxpKX1wcm9jZXNzVGVybSh0LHIsbyxpPS0xKXtsZXQgdT1vLmxlbmd0aCxhPSExLHA9W10sbT0wO2lmKCF0Lm1hdGNoKFJlZ0V4cChRcykpJiYhciYmdCE9PVwiXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgaD10Lm1hdGNoKFJlZ0V4cChEbyxcImdcIikpLGQ9bmV3IE1vKGkpO3JldHVybiBoPy5mb3JFYWNoKCh5LHcpPT57aWYoeT09PVwiLi4uXCIpe2lmKGEpdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybVwiKTthPSEwO2xldCBfPXUtaC5sZW5ndGgrMTtpZihfPDApdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihwPW8uc2xpY2UobSxtK18pLHRoaXMuaGFzRWxsaXBzaXMpe2lmKHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCE9PXAubGVuZ3RofHx0aGlzLmVsbGlwc2lzRGltcy50b1N0cmluZygpIT09cC50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIGRpbWVuc2lvbnMgbWlzbWF0Y2hcIil9ZWxzZSBpZihyKXRoaXMuaGFzRWxsaXBzaXM9ITAsdGhpcy5lbGxpcHNpc0RpbXM9cDtlbHNlIHRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFNcIik7Zm9yKGxldCB2PTA7djxwLmxlbmd0aDt2Kyspe2xldCB4PVN0cmluZy5mcm9tQ2hhckNvZGUoXCIwXCIuY2hhckNvZGVBdCgwKSt2KTtkLmFkZFN5bWJvbCh4LHcrdiksdGhpcy5hZGRTeW1ib2woeCxvW20rK10saSl9fWVsc2UgZC5hZGRTeW1ib2woeSx3Kyh0aGlzLmhhc0VsbGlwc2lzP3RoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aC0xOjApKSx0aGlzLmFkZFN5bWJvbCh5LG9bbSsrXSxpKX0pLGR9fSxldT1lPT5lK1wiX21heFwiLGhjPShlLHQscixvKT0+e2xldCB1PWUubWFwKGQ9PmQubGVuZ3RoKS5tYXAoKGQseSk9PlYoYGlucHV0JHt5fWAsdCxkKSksYT1XLnNpemUobykscD1KKFwib3V0cHV0XCIsdCxvLmxlbmd0aCksbT1bLi4uci5zeW1ib2xUb0luZm8ua2V5cygpXS5maWx0ZXIoZD0+IXIucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoZCkpLGg9ZD0+e2xldCB5PVtdLHc9XCJ2YXIgcHJvZCA9IDEuMDtcIixfPVwidmFyIHN1bSA9IDAuMDtcIix2PVwic3VtICs9IHByb2Q7XCIseD1bXSxUPVtdLEM9W10sUz1bXSxFPXIuc3ltYm9sVG9JbmZvLnNpemU9PT1yLnJocy5zeW1ib2xUb0luZGljZXMuc2l6ZTtyLnN5bWJvbFRvSW5mby5mb3JFYWNoKChVLE0pPT57aWYoci5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhNKSl7bGV0IE49ci5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldChNKT8uWzBdO04hPT12b2lkIDAmJnIubGhzLmZvckVhY2goKFksc2UpPT57aWYoVS5pbnB1dEluZGljZXMuaW5jbHVkZXMoc2UpKXtsZXQgQj1ZLnN5bWJvbFRvSW5kaWNlcy5nZXQoTSk7aWYoQj09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtCLmZvckVhY2godGU9Pnt5LnB1c2goYCR7dVtzZV0uaW5kaWNlc1NldChgaW5wdXQke3NlfUluZGljZXNgLHRlLHAuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixOKSl9YCl9KX19KX1lbHNlIHIubGhzLmZvckVhY2goKE4sWSk9PntpZihVLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhZKSl7bGV0IHNlPU4uc3ltYm9sVG9JbmRpY2VzLmdldChNKTtpZihzZT09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN5bWJvbCBlcnJvclwiKTtzZS5mb3JFYWNoKEI9Pnt4LnB1c2goYCR7dVtZXS5pbmRpY2VzU2V0KGBpbnB1dCR7WX1JbmRpY2VzYCxCLGAke019YCl9YCl9KSxTLnB1c2goYHByb2QgKj0gJHt1W1ldLmdldEJ5SW5kaWNlcyhgaW5wdXQke1l9SW5kaWNlc2ApfTtgKX19KSxULnB1c2goYGZvcih2YXIgJHtNfTogdTMyID0gMDsgJHtNfSA8IHVuaWZvcm1zLiR7ZXUoTSl9OyAke019KyspIHtgKSxDLnB1c2goXCJ9XCIpfSk7bGV0IE89RT9bLi4ueSxgbGV0IHN1bSA9ICR7dS5tYXAoKFUsTSk9PlUuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7TX1JbmRpY2VzYCkpLmpvaW4oXCIgKiBcIil9O2BdOlsuLi55LF8sLi4uVCwuLi54LHcsLi4uUyx2LC4uLkNdO3JldHVybmBcXG4gICAgICAgICAgICAke2QucmVnaXN0ZXJVbmlmb3JtcyhtLm1hcChVPT4oe25hbWU6YCR7ZXUoVSl9YCx0eXBlOlwidTMyXCJ9KSkpLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLnUscCl9XFxuXFxuICAgICAgICAgICAgJHtkLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICR7ZC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cXG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7cC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgICAke3UubWFwKChVLE0pPT5gdmFyIGlucHV0JHtNfUluZGljZXM6ICR7dVtNXS50eXBlLmluZGljZXN9O2ApLmpvaW4oYFxcbmApfVxcbiAgICAgICAgICAgICR7Ty5qb2luKGBcXG5gKX07XFxuICAgICAgICAgICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcXG4gICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiRWluc3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6ci5lcXVhdGlvbixpbnB1dERlcGVuZGVuY2llczplLm1hcCgoKT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT57bGV0IGQ9bS5maWx0ZXIodz0+ci5zeW1ib2xUb0luZm8uaGFzKHcpKS5tYXAodz0+KHt0eXBlOlwidWludDMyXCIsZGF0YTpyLnN5bWJvbFRvSW5mby5nZXQodyk/LmRpbVZhbHVlfHwwfSkpO2QucHVzaCh7dHlwZTpcInVpbnQzMlwiLGRhdGE6YX0pO2xldCB5PWUubWFwKCh3LF8pPT5bLi4uRyh3KV0pLnJlZHVjZSgodyxfKT0+dy5jb25jYXQoXyksZCk7cmV0dXJuIHkucHVzaCguLi5HKG8pKSx7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3Jtczp5fX0sZ2V0U2hhZGVyU291cmNlOmh9fSx0dT0oZSx0KT0+e2xldCByPW5ldyB6byhlLmlucHV0cyx0LmVxdWF0aW9uKSxvPXIub3V0cHV0RGltcyxpPWUuaW5wdXRzLm1hcCgodSxhKT0+dS5kaW1zKTtlLmNvbXB1dGUoaGMoaSxlLmlucHV0c1swXS5kYXRhVHlwZSxyLG8pKX0scnU9ZT0+e2xldCB0PWUuZXF1YXRpb24ucmVwbGFjZSgvXFxcXHMrL2csXCJcIik7cmV0dXJuIHhlKHtlcXVhdGlvbjp0fSl9fSk7dmFyIGdjLG91LHljLGJjLGl1LGF1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7X2UoKTtnYz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgMiBpbnB1dC5cIik7bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG89ci5sZW5ndGg8dC5sZW5ndGg/MDpyLmxlbmd0aC10Lmxlbmd0aCxpPXQubGVuZ3RoPHIubGVuZ3RoPzA6dC5sZW5ndGgtci5sZW5ndGg7Zm9yKDtvPHIubGVuZ3RoJiZpPHQubGVuZ3RoOysrbywrK2kpaWYocltvXSE9PXRbaV0mJnJbb10hPT0xJiZ0W2ldIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dFwiKX0sb3U9KGUsdCk9PntsZXQgcj1lLmxlbmd0aC10Lmxlbmd0aCxvPVtdO2ZvcihsZXQgaT0wO2k8cjsrK2kpby5wdXNoKGVbaV0pO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7KytpKW8ucHVzaCh0W2ldPT09MT9lW2krcl06dFtpXSk7cmV0dXJuIG99LHljPShlLHQpPT5lLmxlbmd0aD50Lmxlbmd0aD9vdShlLHQpOm91KHQsZSksYmM9ZT0+e2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxvPXljKHQsciksaT1lWzBdLmRhdGFUeXBlLHU9aT09PTk/NDoxLGE9TWF0aC5jZWlsKFcuc2l6ZShvKS91KSxwPWg9PntsZXQgZD1WKFwiaW5wdXRcIixpLHQubGVuZ3RoLHUpLHk9SihcIm91dHB1dFwiLGksby5sZW5ndGgsdSksdztpZihpPT09OSl7bGV0IF89KHYseCxUPVwiXCIpPT5gXFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7eS5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt4fSA9ICR7ZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLHkpfTtcXG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcXG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7eH0gPSBvZmZzZXQke3h9ICUgNHU7XFxuICAgICAgICAgICR7dn1bJHt4fV0gPSAke1R9KCR7ZC5nZXRCeU9mZnNldChgaW5kZXgke3h9YCl9W2NvbXBvbmVudCR7eH1dKTtcXG4gICAgICAgIGA7dz1gXFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7dX07XFxuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcXG4gICAgICAgICR7XyhcImRhdGFcIiwwLFwidTMyXCIpfVxcbiAgICAgICAgJHtfKFwiZGF0YVwiLDEsXCJ1MzJcIil9XFxuICAgICAgICAke18oXCJkYXRhXCIsMixcInUzMlwiKX1cXG4gICAgICAgICR7XyhcImRhdGFcIiwzLFwidTMyXCIpfVxcbiAgICAgICAgJHt5LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGF0YVwiKX1cXG4gICAgICB9YH1lbHNlIHc9YFxcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICBsZXQgaW5wdXRPZmZzZXQgPSAke2QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIseSl9O1xcbiAgICAgICAgJHt5LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGQuZ2V0QnlPZmZzZXQoXCJpbnB1dE9mZnNldFwiKSl9XFxuICAgICAgfWA7cmV0dXJuYFxcbiAgICAke2gucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGQseSl9XFxuICAgICR7aC5tYWluU3RhcnQoKX1cXG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cXG4gICAgJHt3fWB9LG09W3t0eXBlOlwidWludDMyXCIsZGF0YTphfSwuLi5HKHQpLC4uLkcobyldO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7by5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6cCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pfX0saXU9ZT0+e2djKGUuaW5wdXRzKSxlLmNvbXB1dGUoYmMoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHdjLHZjLHN1LHV1LGx1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7WWUoKTtfZSgpO3djPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LHZjPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG89ZVsxXS5kaW1zLGk9ci5sZW5ndGgsdT1XLm5vcm1hbGl6ZUF4aXModC5heGlzLGkpLGE9ci5zbGljZSgwKTthLnNwbGljZSh1LDEsLi4ubyk7bGV0IHA9clt1XSxtPWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxoPU1hdGguY2VpbChXLnNpemUoYSkvbSksZD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOmh9LHt0eXBlOlwiaW50MzJcIixkYXRhOnB9LHt0eXBlOlwidWludDMyXCIsZGF0YTp1fSwuLi5HKGVbMF0uZGltcyksLi4uRyhlWzFdLmRpbXMpLC4uLkcoYSldLHk9dz0+e2xldCBfPVYoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLG0pLHY9VihcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCkseD1KKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCxtKSxUPVM9PntsZXQgRT1vLmxlbmd0aCxPPWB2YXIgaW5kaWNlc0luZGljZXMke1N9ICA9ICR7di50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBVPTA7VTxFO1UrKylPKz1gJHtFPjE/YGluZGljZXNJbmRpY2VzJHtTfVske1V9XWA6YGluZGljZXNJbmRpY2VzJHtTfWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHtTfVt1bmlmb3Jtcy5heGlzICsgJHtVfV1gOmBvdXRwdXRJbmRpY2VzJHtTfWB9O2A7Tys9YFxcbiAgICAgICAgICB2YXIgaWR4JHtTfSA9ICR7di5nZXRCeUluZGljZXMoYGluZGljZXNJbmRpY2VzJHtTfWApfTtcXG4gICAgICAgICAgaWYgKGlkeCR7U30gPCAwKSB7XFxuICAgICAgICAgICAgaWR4JHtTfSA9IGlkeCR7U30gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzJHtTfSA9ICR7Xy50eXBlLmluZGljZXN9KDApO1xcbiAgICAgICAgYDtmb3IobGV0IFU9MCxNPTA7VTxpO1UrKylVPT09dT8oTys9YCR7aT4xP2BkYXRhSW5kaWNlcyR7U31bJHtVfV1gOmBkYXRhSW5kaWNlcyR7U31gfSA9IHUzMihpZHgke1N9KTtgLE0rPUUpOihPKz1gJHtpPjE/YGRhdGFJbmRpY2VzJHtTfVske1V9XWA6YGRhdGFJbmRpY2VzJHtTfWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHtTfVske019XWA6YG91dHB1dEluZGljZXMke1N9YH07YCxNKyspO3JldHVybiBPfSxDO2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgUz0oRSxPLFU9XCJcIik9PmBcXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke099ID0gJHt4Lm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHtPfXVgKX07XFxuICAgICAgICAgICR7VChPKX07XFxuICAgICAgICAgIGxldCBvZmZzZXQke099ID0gJHtfLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke099YCl9O1xcbiAgICAgICAgICBsZXQgaW5kZXgke099ID0gb2Zmc2V0JHtPfSAvIDR1O1xcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHtPfSA9IG9mZnNldCR7T30gJSA0dTtcXG4gICAgICAgICAgJHtFfVske099XSA9ICR7VX0oJHtfLmdldEJ5T2Zmc2V0KGBpbmRleCR7T31gKX1bY29tcG9uZW50JHtPfV0pO1xcbiAgICAgICAgYDtDPWBcXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHttfTtcXG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcXG4gICAgICAgICR7UyhcInZhbHVlXCIsMCxcInUzMlwiKX1cXG4gICAgICAgICR7UyhcInZhbHVlXCIsMSxcInUzMlwiKX1cXG4gICAgICAgICR7UyhcInZhbHVlXCIsMixcInUzMlwiKX1cXG4gICAgICAgICR7UyhcInZhbHVlXCIsMyxcInUzMlwiKX1cXG4gICAgICAgICR7eC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxcbiAgICAgIGB9ZWxzZSBDPWBcXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7eC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAke1QoXCJcIil9O1xcbiAgICAgIGxldCB2YWx1ZSA9ICR7Xy5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XFxuICAgICAgJHt4LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xcbiAgICAgIGA7cmV0dXJuYFxcbiAgICAgICR7dy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoXyx2LHgpfVxcbiAgICAgICR7dy5tYWluU3RhcnQoKX1cXG4gICAgICAgICR7dy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cXG4gICAgICAgICR7Q31cXG4gICAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3JtczpkfSksZ2V0U2hhZGVyU291cmNlOnl9fSxzdT1lPT54ZSh7YXhpczplLmF4aXN9KSx1dT0oZSx0KT0+e2xldCByPWUuaW5wdXRzO3djKHIpLGUuY29tcHV0ZSh2YyhlLmlucHV0cyx0KSl9fSk7dmFyICRjLF9jLGR1LGN1LHB1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO1llKCk7X2UoKTskYz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKX0sX2M9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbz1lWzBdLmRhdGFUeXBlLGk9ci5sZW5ndGgsdT1lWzFdLmRpbXMsYT1lWzFdLmRhdGFUeXBlLHA9Vy5ub3JtYWxpemVBeGlzKHQuYXhpcyxpKSxtPXJbcF0saD11LnNsaWNlKDApLGQ9Vy5zaXplKGgpLHk9VihcImlucHV0XCIsbyxpKSx3PVYoXCJpbmRpY2VzSW5wdXRcIixhLHUubGVuZ3RoKSxfPUooXCJvdXRwdXRcIixvLGgubGVuZ3RoKSx2PVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6ZH0se3R5cGU6XCJpbnQzMlwiLGRhdGE6bX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9XTtyZXR1cm4gdi5wdXNoKC4uLkcocikpLHYucHVzaCguLi5HKHUpKSx2LnB1c2goLi4uRyhoKSkse25hbWU6XCJHYXRoZXJFbGVtZW50c1wiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmgsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dn0pLGdldFNoYWRlclNvdXJjZTpDPT5gXFxuICAgICAgJHtDLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh5LHcsXyl9XFxuICAgICAgJHtDLm1haW5TdGFydCgpfVxcbiAgICAgICR7Qy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cXG5cXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG5cXG4gICAgICB2YXIgaWR4ID0gJHt3LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgaWYgKGlkeCA8IDApIHtcXG4gICAgICAgIGlkeCA9IGlkeCArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcXG4gICAgICB9XFxuICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7eS50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xcbiAgICAgICR7eS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIsXCJ1MzIoaWR4KVwiKX07XFxuICAgICAgbGV0IHZhbHVlID0gJHt5LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XFxuXFxuICAgICAgJHtfLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xcbiAgfWB9fSxkdT1lPT54ZSh7YXhpczplLmF4aXN9KSxjdT0oZSx0KT0+e2xldCByPWUuaW5wdXRzOyRjKHIpLGUuY29tcHV0ZShfYyhlLmlucHV0cyx0KSl9fSk7dmFyIFNjLHhjLG11LGZ1LGh1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO19lKCk7U2M9ZT0+e2lmKCFlKXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMl0uZGltcy5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoZVswXS5kYXRhVHlwZSE9PWVbMV0uZGF0YVR5cGV8fGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9LHhjPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1lWzFdLmRpbXMuc2xpY2UoKSxbaSx1LGFdPVNuLmdldFNoYXBlT2ZHZW1tUmVzdWx0KHIsdC50cmFuc0Esbyx0LnRyYW5zQixlLmxlbmd0aD09PTM/ZVsyXS5kaW1zOnZvaWQgMCkscD1baSx1XTtpZighcCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBtPVcuc2l6ZShwKSxoPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6bX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOml9LHt0eXBlOlwidWludDMyXCIsZGF0YTp1fSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6YX0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmFscGhhfSx7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuYmV0YX1dLGQ9W1widHlwZVwiLFwidHlwZVwiXTtlLmxlbmd0aD09PTMmJihoLnB1c2goLi4uRyhlWzJdLmRpbXMpKSxkLnB1c2goXCJyYW5rXCIpKSxoLnB1c2goLi4uRyhwKSk7bGV0IHk9dz0+e2xldCBfPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCP189XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW24gKiB1bmlmb3Jtcy5LICsga107XCI6dC50cmFuc0EmJiF0LnRyYW5zQj9fPVwidmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltrICogdW5pZm9ybXMuTiArIG5dO1wiOiF0LnRyYW5zQSYmdC50cmFuc0I/Xz1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjohdC50cmFuc0EmJiF0LnRyYW5zQiYmKF89XCJ2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCIpO2xldCB2PXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIix4PVYoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLFQ9VihcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksQz14LnR5cGUudmFsdWUsUz1udWxsLEU9W3gsVF07ZS5sZW5ndGg9PT0zJiYoUz1WKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksRS5wdXNoKFMpKTtsZXQgTz1KKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxwLmxlbmd0aCk7RS5wdXNoKE8pO2xldCBVPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9XTtyZXR1cm5gXFxuICAke3cucmVnaXN0ZXJVbmlmb3JtcyhVKS5kZWNsYXJlVmFyaWFibGVzKC4uLkUpfVxcblxcbiAgJHt3Lm1haW5TdGFydCgpfVxcbiAgICAke3cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxcblxcbiAgICBsZXQgbSA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5OO1xcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xcblxcbiAgICB2YXIgdmFsdWUgPSAke0N9KDApO1xcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xcbiAgICAgICR7X31cXG4gICAgfVxcblxcbiAgICAke3Z9XFxuICAgICR7KCgpPT5TIT1udWxsP2BsZXQgY09mZnNldCA9ICR7Uy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcInZlYzIobSwgbilcIixPKX07IHZhbHVlICs9ICR7Q30odW5pZm9ybXMuYmV0YSkgKiAke1MuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCIpKCl9XFxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xcbiAgfWB9O3JldHVybntuYW1lOlwiR2VtbVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczpkfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnAsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfSxwcm9ncmFtVW5pZm9ybXM6aH0pLGdldFNoYWRlclNvdXJjZTp5fX0sbXU9ZT0+e2xldCB0PWUudHJhbnNBLHI9ZS50cmFuc0Isbz1lLmFscGhhLGk9ZS5iZXRhO3JldHVybnt0cmFuc0E6dCx0cmFuc0I6cixhbHBoYTpvLGJldGE6aSxjYWNoZUtleTpgJHtlLnRyYW5zQX07JHtlLnRyYW5zQn07JHtlLmFscGhhPT09MX1gfX0sZnU9KGUsdCk9PntTYyhlLmlucHV0cyksZS5jb21wdXRlKHhjKGUuaW5wdXRzLHQpKX19KTt2YXIgQ2MsQWMsSWMsZ3UseXU9USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7Q2UoKTtfZSgpO0NjPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG89cixpPTIsdT1XLnNpemVUb0RpbWVuc2lvbihyLGkpLGE9Vy5zaXplRnJvbURpbWVuc2lvbihyLGkpLHA9SGUoYSksbT1hL3AsaD1bclswXSxyWzFdLG1dLGQ9W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiXSx5PVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6YX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOm19XTt5LnB1c2goLi4uRyhoKSwuLi5HKGgpKTtsZXQgdz1fPT57bGV0IHY9VihcInhcIixlWzBdLmRhdGFUeXBlLGgubGVuZ3RoLHApLHg9VihcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLFQ9VihcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyksQz1KKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxoLmxlbmd0aCxwKSxTPVt2LHgsVCxDXSxFPXYudHlwZS52YWx1ZSxPPXA9PT0xP1wiZjMyXCI6YHZlYyR7cH08ZjMyPmAsVT02NCxNPVt7bmFtZTpcIm5vcm1TaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5vcm1QYWNrZWRTaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxcbiAgdmFyPHdvcmtncm91cD4gbWVhblNoYXJlZCA6IGYzMjtcXG4gIHZhcjx3b3JrZ3JvdXA+IHNxdWFyZWROb3JtU2hhcmVkIDogZjMyO1xcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwU2hhcmVkIDogYXJyYXk8JHtPfSwgJHtVfT47XFxuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gJHtVfXU7XFxuICAke18ucmVnaXN0ZXJVbmlmb3JtcyhNKS5kZWNsYXJlVmFyaWFibGVzKC4uLlMpfVxcbiAgJHtfLm1haW5TdGFydChVKX1cXG4gICAgbGV0IG5vcm0gPSBnbG9iYWxfaWR4IC8gd29ya2dyb3VwU2l6ZTtcXG4gICAgbGV0IGJhdGNoID0gbm9ybSAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XFxuICAgIGxldCBjaGFubmVsID0gbm9ybSAlIHVuaWZvcm1zLnhfc2hhcGVbMV07XFxuICAgIGxldCBsb2NhbEluZGV4ID0gbG9jYWxfaWQueDtcXG5cXG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XFxuICAgIHZhciBpbml0aWFsID0gJHtPfSgwKTtcXG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCB1bmlmb3Jtcy5ub3JtUGFja2VkU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XFxuICAgICAgaW5pdGlhbCA9IGluaXRpYWwgKyAke099KCR7di5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0pO1xcbiAgICB9XFxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XFxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtZWFuIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxcbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cFNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XFxuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XFxuICAgICAgfVxcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgfVxcbiAgICBpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxuICAgICAgbWVhblNoYXJlZCA9ICR7dXQoXCJ3b3JrZ3JvdXBTaGFyZWRbMF1cIixwKX0gLyBmMzIodW5pZm9ybXMubm9ybVNpemUpO1xcbiAgICB9XFxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgLy8gcmVpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnkuXFxuICAgIGluaXRpYWwgPSAke099KDApO1xcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IHVuaWZvcm1zLm5vcm1QYWNrZWRTaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcXG4gICAgICBsZXQgZGV2aWF0aW9uID0gICR7T30oJHt2LmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSkgLSAke099KG1lYW5TaGFyZWQpO1xcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsICsgZGV2aWF0aW9uICogZGV2aWF0aW9uO1xcbiAgICB9XFxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XFxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzdW0gb2Ygc3F1YXJlIG9mIGRldmlhdGlvbiBvZiBjdXJyZW50IGNoYW5uZWwgZGF0YS5cXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcXG4gICAgICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSArIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4ICsgY3VyclNpemVdO1xcbiAgICAgIH1cXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgIH1cXG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xcbiAgICAgIHNxdWFyZWROb3JtU2hhcmVkID0gJHt1dChcIndvcmtncm91cFNoYXJlZFswXVwiLHApfTtcXG4gICAgfVxcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgIGxldCBpbnZTdGREZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkTm9ybVNoYXJlZCAvIGYzMih1bmlmb3Jtcy5ub3JtU2l6ZSkgKyBmMzIoJHt0LmVwc2lsb259KSk7XFxuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiBmMzIoJHt4LmdldEJ5T2Zmc2V0KFwiY2hhbm5lbFwiKX0pO1xcbiAgICBsZXQgY2hhbm5lbFNoaWZ0ID0gZjMyKCR7VC5nZXRCeU9mZnNldChcImNoYW5uZWxcIil9KSAtIG1lYW5TaGFyZWQgKiBjaGFubmVsU2NhbGU7XFxuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgdW5pZm9ybXMubm9ybVBhY2tlZFNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xcbiAgICAgIGxldCB2YWx1ZSA9ICR7di5nZXQoXCJiYXRjaFwiLFwiY2hhbm5lbFwiLFwiaFwiKX0gKiAke0V9KCR7T30oY2hhbm5lbFNjYWxlKSkgKyAke0V9KCR7T30oY2hhbm5lbFNoaWZ0KSk7XFxuICAgICAgJHtDLnNldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIsXCJ2YWx1ZVwiKX07XFxuICAgIH1cXG4gIH1gfTtyZXR1cm57bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuZXBzaWxvbn07JHtwfWAsaW5wdXREZXBlbmRlbmNpZXM6ZH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnV9LHByb2dyYW1Vbmlmb3Jtczp5fSksZ2V0U2hhZGVyU291cmNlOnd9fSxBYz0oZSx0LHIsbyxpLHUsYSxwKT0+e2xldCBtPUhlKGEpLGg9NjQsZD1tPT09MT9cInZlYzJmXCI6YG1hdDJ4JHttfWZgLHk9bT09PTE/XCJmMzJcIjpgdmVjJHttfWZgLHc9KE0sTik9PmAke2R9KCR7TX0sICR7Tn0pYCxfPWkqYS9tLHY9TWF0aC5jZWlsKHUvaCkseD1bXCJ0eXBlXCJdLFQ9W3t0eXBlOlwidWludDMyXCIsZGF0YTp2fSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOk1hdGguZmxvb3IoYS9tKX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOk1hdGguZmxvb3IodSphL20pfV0sQz1NPT57bGV0IE49VihcImlucHV0XCIsdC5kYXRhVHlwZSx0LmRpbXMsbSk7cmV0dXJuYFxcbiAgJHtNLmRlY2xhcmVWYXJpYWJsZXMoTil9XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7ZH0+O1xcbiAgc3RydWN0IFVuaWZvcm1zIHt3Z19zaXplOnUzMiwgSDp1MzIsIEM6dTMyLCBpbWFnZV9zaXplOnUzMn07XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcXG5cXG4gICR7TS5tYWluU3RhcnQoaCl9XFxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gJHtofSAvIHVuaWZvcm1zLkM7XFxuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IChnbG9iYWxfaWR4IC8gJHtofSkgJSB1bmlmb3Jtcy5DO1xcbiAgICBsZXQgd2dJZCA9IGdsb2JhbF9pZHggJSAke2h9O1xcbiAgICBsZXQgd2dPZmZzZXQgPSB3Z0lkICogdW5pZm9ybXMud2dfc2l6ZTtcXG4gICAgaWYgKHdnT2Zmc2V0ID49IHVuaWZvcm1zLkgpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsZXQgd2dNYXggPSBtaW4od2dPZmZzZXQgKyB1bmlmb3Jtcy53Z19zaXplLCB1bmlmb3Jtcy5IKTtcXG5cXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIHVuaWZvcm1zLmltYWdlX3NpemUgKyBjdXJyZW50Q2hhbm5lbE51bWJlcjtcXG4gICAgdmFyIHN1bSA9ICR7WmUoXCJmMzJcIixtKX07XFxuICAgIHZhciBzcXVhcmVkU3VtID0gJHtaZShcImYzMlwiLG0pfTtcXG4gICAgZm9yICh2YXIgaTogdTMyID0gd2dPZmZzZXQ7IGkgPCB3Z01heDsgaSsrKSB7XFxuICAgICAgICBsZXQgdmFsdWUgPSAke3l9KGlucHV0W29mZnNldCArIGkgKiB1bmlmb3Jtcy5DXSk7XFxuICAgICAgICBzdW0gKz0gdmFsdWU7XFxuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlICogdmFsdWU7XFxuICAgIH1cXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt3KFwic3VtXCIsXCJzcXVhcmVkU3VtXCIpfTtcXG4gIH1gfSxTPWUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVNZWFuXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bX1gLGlucHV0RGVwZW5kZW5jaWVzOnh9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6W2ksYSxoLDJdLGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4OmkqYS9tfSxwcm9ncmFtVW5pZm9ybXM6VH0pLGdldFNoYWRlclNvdXJjZTpDfSx7aW5wdXRzOlt0XSxvdXRwdXRzOlstMV19KVswXSxFPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6X30se3R5cGU6XCJ1aW50MzJcIixkYXRhOnV9LHt0eXBlOlwidWludDMyXCIsZGF0YTpNYXRoLmZsb29yKGEvbSl9LHt0eXBlOlwidWludDMyXCIsZGF0YTpNYXRoLmZsb29yKGgqYS9tKX1dLE89W1widHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXSxVPU09PntsZXQgTj1WKFwic2NhbGVcIixyLmRhdGFUeXBlLHIuZGltcyxtKSxZPVYoXCJiaWFzXCIsby5kYXRhVHlwZSxvLmRpbXMsbSk7cmV0dXJuYFxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7ZH0+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZSA6IGFycmF5PCR7Ti50eXBlLnN0b3JhZ2V9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhcyA6IGFycmF5PCR7WS50eXBlLnN0b3JhZ2V9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtkfT47XFxuICBzdHJ1Y3QgVW5pZm9ybXMge3VuaXRzX29mX3dvcmsgOiB1MzIsIEg6IHUzMiwgQyA6IHUzMiwgaW1hZ2Vfc2l6ZSA6IHUzMn07XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcXG5cXG4gICR7TS5tYWluU3RhcnQoKX1cXG4gICAgJHtNLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy51bml0c19vZl93b3JrXCIpfVxcbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLkM7XFxuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xcblxcbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogdW5pZm9ybXMuaW1hZ2Vfc2l6ZTtcXG4gICAgdmFyIHN1bSA9ICR7WmUoXCJmMzJcIixtKX07XFxuICAgIHZhciBzcXVhcmVkU3VtID0gJHtaZShcImYzMlwiLG0pfTtcXG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7aH07IGkrKykge1xcbiAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRbb2Zmc2V0ICsgaSArIGN1cnJlbnRDaGFubmVsTnVtYmVyICogJHtofV07XFxuICAgICAgICBzdW0gKz0gdmFsdWVbMF07XFxuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlWzFdO1xcbiAgICB9XFxuICAgIHN1bSA9IHN1bSAvIGYzMih1bmlmb3Jtcy5IKTtcXG4gICAgc3F1YXJlZFN1bSA9IHNxdWFyZWRTdW0gLyBmMzIodW5pZm9ybXMuSCk7XFxuICAgIGxldCBpbnZTdGREZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkU3VtIC0gc3VtICogc3VtICsgZjMyKCR7cH0pKTtcXG4gICAgbGV0IGNoYW5uZWxTY2FsZSA9IGludlN0ZERldiAqICR7eX0oc2NhbGVbY3VycmVudENoYW5uZWxOdW1iZXJdKTtcXG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9ICR7eX0oYmlhc1tjdXJyZW50Q2hhbm5lbE51bWJlcl0pIC0gc3VtICogY2hhbm5lbFNjYWxlO1xcblxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3coXCJjaGFubmVsU2NhbGVcIixcImNoYW5uZWxTaGlmdFwiKX07XFxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OmAke219OyR7cH1gLGlucHV0RGVwZW5kZW5jaWVzOk99LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6W2ksYSwyXSxkYXRhVHlwZToxfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoXy82NCl9LHByb2dyYW1Vbmlmb3JtczpFfSksZ2V0U2hhZGVyU291cmNlOlV9LHtpbnB1dHM6W1MscixvXSxvdXRwdXRzOlstMV19KVswXX0sSWM9KGUsdCxyKT0+e2xldCBvPXRbMF0uZGltcyxpPW8sdT1vWzBdLGE9b1tvLmxlbmd0aC0xXSxwPVcuc2l6ZUZyb21EaW1lbnNpb24obywxKS9hLG09SGUoYSksaD1XLnNpemUoaSkvbSxkPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOk1hdGguZmxvb3IoYS9tKX1dLHk9W1widHlwZVwiLFwidHlwZVwiXSx3PUFjKGUsdFswXSx0WzFdLHRbMl0sdSxwLGEsci5lcHNpbG9uKSxfPXY9PntsZXQgeD1OZSh0WzBdLmRhdGFUeXBlKSxUPW09PT0xP1widmVjMmZcIjpgbWF0Mngke219ZmAsQz1tPT09MT94OmB2ZWMke219PCR7eH0+YCxTPVYoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLG0pLEU9SihcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsaSxtKTtyZXR1cm5gXFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHtTLnR5cGUuc3RvcmFnZX0+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZUlucHV0IDogYXJyYXk8JHtUfT47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7RS50eXBlLnN0b3JhZ2V9PjtcXG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcXG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xcblxcbiAgJHt2Lm1haW5TdGFydCgpfVxcbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XFxuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xcblxcbiAgICBsZXQgc2NhbGVPZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiB1bmlmb3Jtcy5DICsgY3VycmVudENoYW5uZWxOdW1iZXI7XFxuICAgIGxldCBzY2FsZSA9IHNjYWxlSW5wdXRbc2NhbGVPZmZzZXRdO1xcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7Q30oc2NhbGVbMF0pLCAke0N9KHNjYWxlWzFdKSk7XFxuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uTkhXQ1wiLHNoYWRlckNhY2hlOntoaW50OmAke219YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZH0pLGdldFNoYWRlclNvdXJjZTpffSx7aW5wdXRzOlt0WzBdLHddfSl9LGd1PShlLHQpPT57dC5mb3JtYXQ9PT1cIk5IV0NcIj9JYyhlLGUuaW5wdXRzLHQpOmUuY29tcHV0ZShDYyhlLmlucHV0cyx0KSl9fSk7dmFyIFRjLEVjLGJ1LHd1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7X2UoKTtUYz1lPT57aWYoIWV8fGUubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLlwiKX0sRWM9KGUsdCxyKT0+e2xldCBvPWVbMF0uZGltcyxpPWVbMV0sdT1lWzJdLGE9byxwPVcubm9ybWFsaXplQXhpcyh0LmF4aXMsby5sZW5ndGgpLG09Vy5zaXplVG9EaW1lbnNpb24obyxwKSxoPVcuc2l6ZUZyb21EaW1lbnNpb24obyxwKSxkPVcuc2l6ZShpLmRpbXMpLHk9dT9XLnNpemUodS5kaW1zKTowO2lmKGQhPT1ofHx1JiZ5IT09aCl0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke2h9LlxcbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxcbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke2R9IGFuZCBiaWFzIHNpemUgb2YgJHt5fWApO2xldCB3PVtdO2ZvcihsZXQgTz0wO088by5sZW5ndGg7KytPKU88cD93LnB1c2gob1tPXSk6dy5wdXNoKDEpO2xldCBfPUhlKGgpLHY9W1widHlwZVwiLFwidHlwZVwiXSx4PVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6bX0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTpofSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6TWF0aC5mbG9vcihoL18pfSx7dHlwZTpcImZsb2F0MzJcIixkYXRhOnQuZXBzaWxvbn1dO3UmJnYucHVzaChcInR5cGVcIik7bGV0IFQ9cj4xLEM9cj4yLFM9Tz0+e2xldCBVPU5lKGVbMF0uZGF0YVR5cGUpLE09W1YoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsXyksVihcInNjYWxlXCIsaS5kYXRhVHlwZSxpLmRpbXMsXyldO3UmJk0ucHVzaChWKFwiYmlhc1wiLHUuZGF0YVR5cGUsdS5kaW1zLF8pKSxNLnB1c2goSihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsYSxfKSksVCYmTS5wdXNoKEooXCJtZWFuX2RhdGFfb3V0cHV0XCIsMSx3KSksQyYmTS5wdXNoKEooXCJpbnZfc3RkX291dHB1dFwiLDEsdykpO2xldCBOPVt7bmFtZTpcIm5vcm1fY291bnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibm9ybV9zaXplXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZV92ZWN0b3JpemVkXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZjMyXCJ9XTtyZXR1cm5gXFxuICAke08ucmVnaXN0ZXJVbmlmb3JtcyhOKS5kZWNsYXJlVmFyaWFibGVzKC4uLk0pfVxcbiAgJHtPLm1haW5TdGFydCgpfVxcbiAgICAke08uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm5vcm1fY291bnRcIil9XFxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XFxuICAgIHZhciBtZWFuVmVjdG9yID0gJHtaZShcImYzMlwiLF8pfTtcXG4gICAgdmFyIG1lYW5TcXVhcmVWZWN0b3IgPSAke1plKFwiZjMyXCIsXyl9O1xcblxcbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcXG4gICAgICBsZXQgdmFsdWUgPSAke2d0KFUsXyxcInhbaCArIG9mZnNldF1cIil9O1xcbiAgICAgIG1lYW5WZWN0b3IgKz0gdmFsdWU7XFxuICAgICAgbWVhblNxdWFyZVZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xcbiAgICB9XFxuICAgIGxldCBtZWFuID0gJHt1dChcIm1lYW5WZWN0b3JcIixfKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemU7XFxuICAgIGxldCBpbnZTdGREZXYgPVxcbiAgICAgICAgaW52ZXJzZVNxcnQoJHt1dChcIm1lYW5TcXVhcmVWZWN0b3JcIixfKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgLSBtZWFuICogbWVhbiArIHVuaWZvcm1zLmVwc2lsb24pO1xcblxcbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7Z3QoVSxfLFwieFtqICsgb2Zmc2V0XVwiKX07XFxuICAgICAgbGV0IGYzMnNjYWxlID0gJHtndChVLF8sXCJzY2FsZVtqXVwiKX07XFxuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtNWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAtIG1lYW4pICogaW52U3RkRGV2ICogZjMyc2NhbGVcXG4gICAgICAgICR7dT9gKyAke2d0KFUsXyxcImJpYXNbal1cIil9YDpcIlwifVxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgJHtUP1wibWVhbl9kYXRhX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW5cIjpcIlwifTtcXG4gICAgJHtDP1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZTdGREZXZcIjpcIlwifTtcXG4gIH1gfSxFPVt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gVCYmRS5wdXNoKHtkaW1zOncsZGF0YVR5cGU6MX0pLEMmJkUucHVzaCh7ZGltczp3LGRhdGFUeXBlOjF9KSx7bmFtZTpcIkxheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke199OyR7cn1gLGlucHV0RGVwZW5kZW5jaWVzOnZ9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpFLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfSxwcm9ncmFtVW5pZm9ybXM6eH0pLGdldFNoYWRlclNvdXJjZTpTfX0sYnU9KGUsdCk9PntUYyhlLmlucHV0cyksZS5jb21wdXRlKEVjKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCkpfX0pO3ZhciBQYywkdSx2dSxPYyxVbyxfdSxTdT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtZZSgpOyRuKCk7eG8oKTtfZSgpO3ByKCk7UGM9KGUsdCk9PntsZXQgcj1lWzBdLG89ZVsxXSxpPWVbMl0sdT1lWzNdLGE9ZVs0XSxwPWVbNV0sbT1lWzZdLGg9ZVs3XTtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9uc1wiKTtsZXQgZD0hMSx5PXIuZGltc1swXSx3PXIuZGltc1sxXSxfPXIuZGltcy5sZW5ndGg9PT0zP2Q/ci5kaW1zWzJdLzM6ci5kaW1zWzJdOnQubnVtSGVhZHMqci5kaW1zWzRdLHY9dyx4PTAsVD0wLEM9TWF0aC5mbG9vcihfL3QubnVtSGVhZHMpO2lmKG0mJmgpe2lmKG0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcXCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnNcXCcpO2lmKGguZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcXCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9uc1xcJyk7eD1tLmRpbXNbMl0sVD1tLmRpbXNbMl19ZWxzZSBpZihtfHxoKXRocm93IG5ldyBFcnJvcihcXCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudFxcJyk7bGV0IFM7aWYobyl7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlblxcJyk7aWYoby5kaW1zLmxlbmd0aDwzfHxvLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnNcXCcpO2lmKHIuZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSlcXCcpO2lmKG8uZGltcy5sZW5ndGg9PT0zKXtpZihvLmRpbXNbMl0hPT1yLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKGhpZGRlbl9zaXplKVxcJyk7Uz0yLHY9by5kaW1zWzFdfWVsc2UgaWYoby5kaW1zLmxlbmd0aD09PTUpe2lmKG8uZGltc1syXSE9PXQubnVtSGVhZHN8fG8uZGltc1szXSE9PTJ8fG8uZGltc1s0XSE9PUMpdGhyb3cgbmV3IEVycm9yKFxcJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2XFwnKTtpZihpKXRocm93IG5ldyBFcnJvcihcXCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LlxcJyk7Uz01LHY9by5kaW1zWzFdfWVsc2V7aWYoby5kaW1zWzFdIT09dC5udW1IZWFkc3x8by5kaW1zWzNdIT09Qyl0aHJvdyBuZXcgRXJyb3IoXFwnRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleVxcJyk7Uz0wLHY9by5kaW1zWzJdfX1lbHNle2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHlcXCcpO2lmKHIuZGltcy5sZW5ndGg9PT01JiYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKFxcJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3ZcXCcpO1M9M31pZih1KXtpZih1LmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvblxcJyk7aWYoaSYmci5kaW1zLmxlbmd0aD09PTUmJnIuZGltc1szXT09PTIpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2LlwiKX1sZXQgRT0wO2lmKGEpe0U9ODtsZXQgWT1hLmRpbXM7dGhyb3cgWS5sZW5ndGg9PT0xP1lbMF09PT15P0U9MTpZWzBdPT09Myp5KzImJihFPTMpOlkubGVuZ3RoPT09MiYmWVswXT09PXkmJllbMV09PT12JiYoRT01KSxFPT09OD9uZXcgRXJyb3IoXFwnSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgpXFwnKTpuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIil9bGV0IE89ITEsVT1fO2lmKGkpe2lmKGkuZGltcy5sZW5ndGghPT0zJiZpLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnNcXCcpO2lmKHIuZGltc1swXSE9PWkuZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXFwnSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKVxcJyk7aWYoaS5kaW1zLmxlbmd0aD09PTMpe2lmKHYhPT1pLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpXFwnKTtVPWkuZGltc1syXX1lbHNle2lmKHYhPT1pLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKFxcJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKVxcJyk7VT1pLmRpbXNbMV0qaS5kaW1zWzNdLE89ITB9fWxldCBNPXgrdixOPSExO2lmKGEpdGhyb3cgbmV3IEVycm9yKFwiS2V5IHBhZGRpbmcgbWFzayBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHApdGhyb3cgbmV3IEVycm9yKFwiZXh0cmFBZGRRayBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKG0pdGhyb3cgbmV3IEVycm9yKFwicGFzdEtleSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGgpdGhyb3cgbmV3IEVycm9yKFwicGFzdFZhbHVlIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJue2JhdGNoU2l6ZTp5LHNlcXVlbmNlTGVuZ3RoOncscGFzdFNlcXVlbmNlTGVuZ3RoOngsa3ZTZXF1ZW5jZUxlbmd0aDp2LHRvdGFsU2VxdWVuY2VMZW5ndGg6TSxtYXhTZXF1ZW5jZUxlbmd0aDpULGlucHV0SGlkZGVuU2l6ZTowLGhpZGRlblNpemU6Xyx2SGlkZGVuU2l6ZTpVLGhlYWRTaXplOkMsdkhlYWRTaXplOk1hdGguZmxvb3IoVS90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6RSxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6TixwYXNzUGFzdEluS3Y6Tyxxa3ZGb3JtYXQ6U319LCR1PWU9PnhlKHsuLi5lfSksdnU9eGUoe3Blcm06WzAsMiwxLDNdfSksT2M9KGUsdCxyLG8saSx1LGEpPT57bGV0IHA9W28saSx1XSxtPVcuc2l6ZShwKSxoPVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6bX0se3R5cGU6XCJ1aW50MzJcIixkYXRhOmF9LHt0eXBlOlwidWludDMyXCIsZGF0YTp1fV0sZD15PT57bGV0IHc9SihcInFrdl93aXRoX2JpYXNcIix0LmRhdGFUeXBlLHApLF89VihcInFrdlwiLHQuZGF0YVR5cGUscCksdj1WKFwiYmlhc1wiLHIuZGF0YVR5cGUscCkseD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiaWFzX29mZnNldFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcXG4gICR7eS5yZWdpc3RlclVuaWZvcm1zKHgpLmRlY2xhcmVWYXJpYWJsZXMoXyx2LHcpfVxcbiAgJHt5Lm1haW5TdGFydCgpfVxcbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxcbiAgICBsZXQgYmlhc19vZmZzZXRfaWR4ID0gKGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgKyB1bmlmb3Jtcy5iaWFzX29mZnNldDtcXG5cXG4gICAgcWt2X3dpdGhfYmlhc1tnbG9iYWxfaWR4XSA9IHFrdltnbG9iYWxfaWR4XSArIGJpYXNbYmlhc19vZmZzZXRfaWR4XTtcXG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiTXVsdGlIZWFkQXR0ZW50aW9uQWRkQmlhc1wiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnAsZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NCl9LHByb2dyYW1Vbmlmb3JtczpofSksZ2V0U2hhZGVyU291cmNlOmR9LHtpbnB1dHM6W3Qscl0sb3V0cHV0czpbLTFdfSlbMF19LFVvPShlLHQscixvLGksdSxhLHApPT57bGV0IG09dTtpZihhKXtpZihvPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1ZcIik7cmV0dXJuIG09T2MoZSx1LGEsdCxvLHIqaSxwKSxtPW0ucmVzaGFwZShbdCxvLHIsaV0pLGUuY29tcHV0ZSh5dChtLHZ1LnBlcm0pLHtpbnB1dHM6W21dLG91dHB1dHM6Wy0xXX0pWzBdfWVsc2UgcmV0dXJuIHUuZGltcy5sZW5ndGg9PT0zJiYobT11LnJlc2hhcGUoW3QsbyxyLGldKSksZS5jb21wdXRlKHl0KG0sdnUucGVybSkse2lucHV0czpbbV0sb3V0cHV0czpbLTFdfSlbMF19LF91PShlLHQpPT57bGV0IHI9UGMoZS5pbnB1dHMsdCk7aWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKGUuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgbz1lLmlucHV0c1sxXSYmZS5pbnB1dHNbMl0mJmUuaW5wdXRzWzFdLmRpbXMubGVuZ3RoPT09NCYmZS5pbnB1dHNbMl0uZGltcy5sZW5ndGg9PT00LGk9VW8oZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIuc2VxdWVuY2VMZW5ndGgsci5oZWFkU2l6ZSxlLmlucHV0c1swXSxlLmlucHV0c1szXSwwKTtpZihvKXJldHVybiBFbihlLGksZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl0sZS5pbnB1dHNbNF0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsZS5pbnB1dHNbNV0scix0KTtsZXQgdT1VbyhlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5rdlNlcXVlbmNlTGVuZ3RoLHIuaGVhZFNpemUsZS5pbnB1dHNbMV0sZS5pbnB1dHNbM10sci5oaWRkZW5TaXplKSxhPVVvKGUsci5iYXRjaFNpemUsci5udW1IZWFkcyxyLmt2U2VxdWVuY2VMZW5ndGgsci52SGVhZFNpemUsZS5pbnB1dHNbMl0sZS5pbnB1dHNbM10sMipyLmhpZGRlblNpemUpO0VuKGUsaSx1LGEsZS5pbnB1dHNbNF0sdm9pZCAwLGUuaW5wdXRzWzZdLGUuaW5wdXRzWzddLGUuaW5wdXRzWzVdLHIsdCl9fSk7dmFyIGtjLFJjLEJjLERjLE1jLHpjLFVjLFZjLHh1LEN1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7X2UoKTtrYz1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxSYz0oZSx0LHIpPT57bGV0IG89XCJcIjtmb3IobGV0IGk9dC0xO2k+PTA7LS1pKW8rPWBcXG4gICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGkpfSkgLSAke2NlKFwidW5pZm9ybXMucGFkc1wiLGkscil9O1xcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChrID49IGkzMigke2NlKFwidW5pZm9ybXMueF9zaGFwZVwiLGksdCl9KSkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixpLHQpfSk7XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICAgICAgdmFsdWUgPSAke2UudHlwZS52YWx1ZX0odW5pZm9ybXMuY29uc3RhbnRfdmFsdWUpO1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgICAgICAke299XFxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XFxuICAgICAgICAgIH1cXG4gICAgICBgfSxCYz0oZSx0LHIpPT57bGV0IG89XCJcIjtmb3IobGV0IGk9dC0xO2k+PTA7LS1pKW8rPWBcXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixpKX0pIC0gJHtjZShcInVuaWZvcm1zLnBhZHNcIixpLHIpfTtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgayA9IC1rO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke2NlKFwidW5pZm9ybXMueF9zaGFwZVwiLGksdCl9KSAtIDEpO1xcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XFxuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtjZShcInVuaWZvcm1zLnhfc2hhcGVcIixpLHQpfSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixpLHQpfSk7XFxuICAgICAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgICAgICAgICR7b31cXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xcbiAgICAgICAgICBgfSxEYz0oZSx0LHIpPT57bGV0IG89XCJcIjtmb3IobGV0IGk9dC0xO2k+PTA7LS1pKW8rPWBcXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixpKX0pIC0gJHtjZShcInVuaWZvcm1zLnBhZHNcIixpLHIpfTtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgayA9IDA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsaSx0KX0pKSB7XFxuICAgICAgICAgICAgICAgICAgayA9IGkzMigke2NlKFwidW5pZm9ybXMueF9zaGFwZVwiLGksdCl9KSAtIDE7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtjZShcInVuaWZvcm1zLnhfc3RyaWRlc1wiLGksdCl9KTtcXG4gICAgICAgICAgICBgO3JldHVybmBcXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xcbiAgICAgICAgICAgICAgJHtvfVxcbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XFxuICAgICAgICAgIGB9LE1jPShlLHQscik9PntsZXQgbz1cIlwiO2ZvcihsZXQgaT10LTE7aT49MDstLWkpbys9YFxcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGkpfSkgLSAke2NlKFwidW5pZm9ybXMucGFkc1wiLGkscil9O1xcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XFxuICAgICAgICAgICAgICAgICAgayArPSBpMzIoJHtjZShcInVuaWZvcm1zLnhfc2hhcGVcIixpLHQpfV0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke2NlKFwidW5pZm9ybXMueF9zaGFwZVwiLGksdCl9KSkge1xcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsaSx0KX0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Y2UoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixpLHQpfSk7XFxuICAgICAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcXG4gICAgICAgICAgICAgICR7b31cXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xcbiAgICAgICAgICBgfSx6Yz0oZSx0LHIpPT57c3dpdGNoKHIubW9kZSl7Y2FzZSAwOnJldHVybiBSYyhlLHQsci5wYWRzLmxlbmd0aCk7Y2FzZSAxOnJldHVybiBCYyhlLHQsci5wYWRzLmxlbmd0aCk7Y2FzZSAyOnJldHVybiBEYyhlLHQsci5wYWRzLmxlbmd0aCk7Y2FzZSAzOnJldHVybiBNYyhlLHQsci5wYWRzLmxlbmd0aCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVcIil9fSxVYz0oZSx0KT0+e2xldCByPVcucGFkU2hhcGUoZVswXS5kaW1zLnNsaWNlKCksdC5wYWRzKSxvPWVbMF0uZGltcyx1PVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6Vy5zaXplKHIpfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5wYWRzfV07aWYodC5tb2RlPT09MCl7bGV0IG09c3QoZVswXS5kYXRhVHlwZSk7dS5wdXNoKHt0eXBlOm0sZGF0YTp0LnZhbHVlfSl9dS5wdXNoKC4uLkcoZVswXS5kaW1zKSwuLi5HKHIpKTtsZXQgYT1bXCJyYW5rXCJdLHA9bT0+e2xldCBoPUooXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoKSxkPVYoXCJ4XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCkseT1kLnR5cGUudmFsdWUsdz16YyhoLG8ubGVuZ3RoLHQpLF89W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH1dO3JldHVybiB0Lm1vZGU9PT0wJiZfLnB1c2goe25hbWU6XCJjb25zdGFudF92YWx1ZVwiLHR5cGU6eX0pLGBcXG4gICAgICAgICAgICAke20ucmVnaXN0ZXJVbmlmb3JtcyhfKS5kZWNsYXJlVmFyaWFibGVzKGQsaCl9XFxuICAgICAgICAgICAgJHttLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XFxuXFxuICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke2gub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHt5fSgwKTtcXG4gICAgICAgICAgICAke3d9XFxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9YCxpbnB1dERlcGVuZGVuY2llczphfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKFcuc2l6ZShyKS82NCl9LHByb2dyYW1Vbmlmb3Jtczp1fSksZ2V0U2hhZGVyU291cmNlOnB9fSxWYz0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLG89ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsaT1lWzBdLmRpbXMubGVuZ3RoLHU9bmV3IEludDMyQXJyYXkoMippKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgcD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IG09MDttPHAubGVuZ3RoO20rKyl1W051bWJlcihwW21dKV09TnVtYmVyKHJbbV0pLHVbTnVtYmVyKHBbbV0pK2ldPU51bWJlcihyW20rcC5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgocCxtKT0+dVtOdW1iZXIobSldPU51bWJlcihwKSk7bGV0IGE9W107cmV0dXJuIHUuZm9yRWFjaChwPT5hLnB1c2gocCkpLHttb2RlOnQubW9kZSx2YWx1ZTpvLHBhZHM6YX19ZWxzZSByZXR1cm4gdH0seHU9KGUsdCk9PntrYyhlLmlucHV0cyk7bGV0IHI9VmMoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKFVjKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIFVuLEF1LEl1LFR1LEV1LFdjLE5jLFB1LE91LGt1LFJ1LEJ1LER1LE11LHp1LFV1LFZ1LFd1LE51LEh1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtkcigpO0NlKCk7X2UoKTtVbj1lPT57aWYobHIud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiYoIWV8fGUubGVuZ3RoIT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIil9LEF1PShlLHQscik9PntsZXQgbz10LmZvcm1hdD09PVwiTkhXQ1wiLGk9ZS5kaW1zLnNsaWNlKCk7byYmaS5zcGxpY2UoMSwwLGkucG9wKCkpO2xldCB1PU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIiksYT10Lmtlcm5lbFNoYXBlLnNsaWNlKCkscD10LnN0cmlkZXMuc2xpY2UoKSxtPXU/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxoPXQucGFkcy5zbGljZSgpO1h0LmFkanVzdFBvb2xBdHRyaWJ1dGVzKHIsaSxhLHAsbSxoKTtsZXQgZD1YdC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKHIsaSxwLG0sYSxoLHQuYXV0b1BhZCkseT1PYmplY3QuYXNzaWduKHt9LHQpO3U/T2JqZWN0LmFzc2lnbih5LHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6cCxwYWRzOmgsZGlsYXRpb25zOm0sY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24oeSx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOnAscGFkczpoLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTtsZXQgdz1kLnNsaWNlKCk7cmV0dXJuIHcucHVzaCh3LnNwbGljZSgxLDEpWzBdKSxbeSxvP3c6ZF19LEl1PShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixvPVcuc2l6ZShlKSxpPVcuc2l6ZSh0Lmtlcm5lbFNoYXBlKSx1PVt7dHlwZTpcInVpbnQzMlwiLGRhdGE6b30se3R5cGU6XCJ1aW50MzJcIixkYXRhOml9XSxhPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgcD10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLG09dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0saD10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLGQ9dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0seT0hIShoK2QpO3UucHVzaCh7dHlwZTpcInVpbnQzMlwiLGRhdGE6cH0se3R5cGU6XCJ1aW50MzJcIixkYXRhOm19LHt0eXBlOlwidWludDMyXCIsZGF0YTpofSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6ZH0pLGEucHVzaCh7bmFtZTpcImt3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN3XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3U3RhcnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdFbmRcIix0eXBlOlwidTMyXCJ9KTtsZXQgdz0hMTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCBfPXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMl0sdj10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0yXSx4PXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMl0sVD10LnBhZHNbdC5wYWRzLmxlbmd0aC0yXTt3PSEhKHgrVCksdS5wdXNoKHt0eXBlOlwidWludDMyXCIsZGF0YTpffSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dn0se3R5cGU6XCJ1aW50MzJcIixkYXRhOnh9LHt0eXBlOlwidWludDMyXCIsZGF0YTpUfSksYS5wdXNoKHtuYW1lOlwia2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaEVuZFwiLHR5cGU6XCJ1MzJcIn0pfXJldHVyblt1LGEsITAseSx3XX1lbHNle2lmKHIpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBwPVcuY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSk7dS5wdXNoKHt0eXBlOlwidWludDMyXCIsZGF0YTpwfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5wYWRzfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dC5zdHJpZGVzfSksYS5wdXNoKHtuYW1lOlwia2VybmVsU3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6cC5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSk7bGV0IG09dC5wYWRzLnJlZHVjZSgoaCxkKT0+aCtkKTtyZXR1cm5bdSxhLCEhbSwhMSwhMV19fSxUdT0oZSx0LHIsbyxpLHUsYSxwLG0saCxkLHkpPT57bGV0IHc9aS5mb3JtYXQ9PT1cIk5IV0NcIixfPXQudHlwZS52YWx1ZSx2PUooXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLG8pO2lmKGkua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgeD1cIlwiLFQ9XCJcIixDPVwiXCIsUz1yLSh3PzI6MSk7aWYoZD94PWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtTfV0gPSBpbmRpY2VzWyR7U31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcXG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtTfV0gPCAwIHx8IHhJbmRpY2VzWyR7U31dXFxuICAgICAgICAgICAgICAgICAgICAgID49IHVuaWZvcm1zLnhfc2hhcGVbJHtTfV0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICAgJHt1fVxcbiAgICAgICAgICAgICAgICB9YDp4PWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtTfV0gPSBpbmRpY2VzWyR7U31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcXG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgICAgICR7dX1cXG4gICAgICAgICAgICAgICAgfWAsaS5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgTz1yLSh3PzM6Mik7eT9UPWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtPfV0gPSBpbmRpY2VzWyR7T31dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcXG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtPfV0gPCAwIHx8IHhJbmRpY2VzWyR7T31dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtPfV0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHBhZCArPSBpMzIodW5pZm9ybXMua3cpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgYDpUPWBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtPfV0gPSBpbmRpY2VzWyR7T31dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcXG4gICAgICAgICAgICAgICAgYCxDPWBcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBgfXJldHVybmBcXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhtKS5kZWNsYXJlVmFyaWFibGVzKHQsdil9XFxuXFxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxcblxcbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7cH0pO1xcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XFxuICAgICAgICAgICAgICAke1R9XFxuICAgICAgICAgICAgICAke3h9XFxuICAgICAgICAgICAgICAke0N9XFxuICAgICAgICAgICAgICAke2F9XFxuXFxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9YH1lbHNle2lmKHcpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCB4PWkua2VybmVsU2hhcGUubGVuZ3RoLFQ9aS5wYWRzLmxlbmd0aCxDPVwiXCI7cmV0dXJuIGg/Qz1gXFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XFxuICAgICAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XFxuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICR7dX1cXG4gICAgICAgICAgICAgIH1gOkM9YFxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICR7dX1cXG4gICAgICAgICAgICBgLGBcXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhtKS5kZWNsYXJlVmFyaWFibGVzKHQsdil9XFxuXFxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxcbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke3Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XFxuXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke3h9PjtcXG5cXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7X30oJHtwfSk7XFxuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcXG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7eC0xfXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke2NlKFwidW5pZm9ybXMua2VybmVsU3RyaWRlc1wiLFwialwiLHgpfTtcXG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqICR7Y2UoXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIseCl9O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHt4LTF9XSA9IG9mZnNldDtcXG5cXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7ci14fXU7IGogPCAke3J9dTsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtjZShcInVuaWZvcm1zLnN0cmlkZXNcIixgaiAtICR7ci14fXVgLHgpfVxcbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3IteH11XSAtICR7Y2UoXCJ1bmlmb3Jtcy5wYWRzXCIsXCJqIC0gMnVcIixUKX07XFxuICAgICAgICAgICAgICAgICAgJHtDfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgJHthfVxcblxcbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICAgICAgICAgICAgfWB9fSxFdT1lPT5gJHtlLmZvcm1hdH07JHtlLmNlaWxNb2RlfTske2UuYXV0b1BhZH07JHtlLmtlcm5lbFNoYXBlLmxlbmd0aH1gLFdjPWU9PmAke0V1KGUpfTske2UuY291bnRJbmNsdWRlUGFkfWAsTmM9ZT0+YCR7RXUoZSl9OyR7ZS5zdG9yYWdlT3JkZXJ9OyR7ZS5kaWxhdGlvbnN9YCxQdT1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxPdT0oZSx0LHIsbyk9PntsZXRbaSx1XT1BdSh0LG8sciksYT1WKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkscD1hLnR5cGUudmFsdWUsbT1cInZhbHVlICs9IHhfdmFsO1wiLGg9XCJcIjtpLmNvdW50SW5jbHVkZVBhZD9oKz1gdmFsdWUgLz0gJHtwfSh1bmlmb3Jtcy5rZXJuZWxTaXplKTtgOmgrPWB2YWx1ZSAvPSAke3B9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtsZXRbZCx5LHcsXyx2XT1JdSh1LGkpO2QucHVzaCguLi5HKHQuZGltcyksLi4uRyh1KSk7bGV0IHg9W1wicmFua1wiXTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke28uY2FjaGVLZXl9OyR7d307JHtffTske3Z9YCxpbnB1dERlcGVuZGVuY2llczp4fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKFcuc2l6ZSh1KS82NCl9LHByb2dyYW1Vbmlmb3JtczpkfSksZ2V0U2hhZGVyU291cmNlOlQ9PlR1KFQsYSx0LmRpbXMubGVuZ3RoLHUubGVuZ3RoLGksbSxoLDAseSx3LF8sdil9fSxrdT1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAscj1QdShlKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO2xldCBvPXtjb3VudEluY2x1ZGVQYWQ6dCwuLi5yLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5vLGNhY2hlS2V5OldjKG8pfX0sUnU9KGUsdCk9PntVbihlLmlucHV0cyksZS5jb21wdXRlKE91KFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LEJ1PXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXX0sRHU9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5CdSxjYWNoZUtleTp0fX0sTXU9KGUsdCk9PntVbihlLmlucHV0cyksZS5jb21wdXRlKE91KFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LHp1PShlLHQscixvKT0+e2xldFtpLHVdPUF1KHQsbyxyKSxhPWBcXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xcbiAgICBgLHA9XCJcIixtPVYoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxoPVtcInJhbmtcIl0sW2QseSx3LF8sdl09SXUodSxpKTtyZXR1cm4gZC5wdXNoKC4uLkcodC5kaW1zKSwuLi5HKHUpKSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke28uY2FjaGVLZXl9OyR7d307JHtffTske3Z9YCxpbnB1dERlcGVuZGVuY2llczpofSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnUsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKFcuc2l6ZSh1KS82NCl9LHByb2dyYW1Vbmlmb3JtczpkfSksZ2V0U2hhZGVyU291cmNlOng9PlR1KHgsbSx0LmRpbXMubGVuZ3RoLHUubGVuZ3RoLGksYSxwLC0xZTUseSx3LF8sdil9fSxVdT0oZSx0KT0+e1VuKGUuaW5wdXRzKSxlLmNvbXB1dGUoenUoXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxWdT1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLHI9ZS5kaWxhdGlvbnMsbz1QdShlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihvLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7bGV0IGk9e3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpyLC4uLm8sY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLmksY2FjaGVLZXk6TmMoaSl9fSxXdT1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLkJ1LGNhY2hlS2V5OnR9fSxOdT0oZSx0KT0+e1VuKGUuaW5wdXRzKSxlLmNvbXB1dGUoenUoXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBHYyxMYyxHdSxMdT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZHIoKTtWZSgpO19lKCk7R2M9KGUsdCxyKT0+e2xldCBvPWU9PT10LGk9ZTx0JiZyPDAsdT1lPnQmJnI+MDtpZihvfHxpfHx1KXRocm93IG5ldyBFcnJvcihcIlJhbmdlIHRoZXNlIGlucHV0c1xcJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LExjPShlLHQscixvKT0+e2xldCBpPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9yKSksdT1baV0sYT1pLHA9c3QobyksbT1be3R5cGU6XCJ1aW50MzJcIixkYXRhOmF9LHt0eXBlOnAsZGF0YTplfSx7dHlwZTpwLGRhdGE6cn0sLi4uRyh1KV0saD1kPT57bGV0IHk9SihcIm91dHB1dFwiLG8sdS5sZW5ndGgpLHc9eS50eXBlLnZhbHVlLF89W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdGFydFwiLHR5cGU6d30se25hbWU6XCJkZWx0YVwiLHR5cGU6d31dO3JldHVybmBcXG4gICAgICAgICR7ZC5yZWdpc3RlclVuaWZvcm1zKF8pLmRlY2xhcmVWYXJpYWJsZXMoeSl9XFxuICAgICAgICAke2QubWFpblN0YXJ0KCl9XFxuICAgICAgICAke2QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XFxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7d30oZ2xvYmFsX2lkeCkgKiB1bmlmb3Jtcy5kZWx0YTtcXG4gICAgICB9YH07cmV0dXJue25hbWU6XCJSYW5nZVwiLHNoYWRlckNhY2hlOntoaW50OmAke299YH0sZ2V0U2hhZGVyU291cmNlOmgsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KX19LEd1PWU9PntsZXQgdD0wLHI9MCxvPTA7ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT02Pyh0PWUuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXSxvPWUuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXSk6ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT0xJiYodD1lLmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdLG89ZS5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0pLGxyLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmR2ModCxyLG8pLGUuY29tcHV0ZShMYyh0LHIsbyxlLmlucHV0c1swXS5kYXRhVHlwZSkse2lucHV0czpbXX0pfX0pO3ZhciBGYyxqYyxxYyxLYyxZYyxaYyxYYyxKYyxRYyxlcCx0cCxGdSxycCxucCxvcCxpcCxhcCxqdSxxdSxLdT1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtZZSgpO19lKCk7RmM9KGUsdCk9PntpZihlLmV2ZXJ5KHI9PnI+MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmVcIil9KSksZS5sZW5ndGg+MCl7aWYodC5tb2RlPT09XCJsaW5lYXJcIil7aWYoIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09M3x8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xfHxlLmxlbmd0aD09PTUmJmVbMF09PT0xJiZlWzFdPT09MSkpdGhyb3cgbmV3IEVycm9yKGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSxqYz0oZSx0LHIpPT57dC5ldmVyeShpPT5pPj0wJiZpPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IG89bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgoaSx1KT0+b1tpXT1lW3VdKSxvfSxxYz0oZSx0LHIsbyxpLHUpPT57bGV0W2EscCxtXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0saD1lWzBdLmRpbXMubGVuZ3RoO2lmKGE+MCYmZS5sZW5ndGg+YSYmZVthXS5kaW1zLmxlbmd0aD4wKWVbYV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChkPT51LnB1c2goZCkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYocD4wJiZlLmxlbmd0aD5wJiZlW3BdLmRpbXMubGVuZ3RoPjApe2lmKGVbcF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChkPT5vLnB1c2goZCkpLG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT1oJiZyPj0xOCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7RmMobyx0KSx0LmF4ZXMubGVuZ3RoPjAmJmpjKG8sdC5heGVzLGgpLmZvckVhY2goKGQseSk9Pm9beV09ZCl9aWYobT4wJiZlLmxlbmd0aD5tJiYoZVttXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChkPT5pLnB1c2goTnVtYmVyKGQpKSksaS5sZW5ndGghPT1ofHxyPj0xOCYmaS5sZW5ndGg9PT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihvLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFxcJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZFxcJyk7aWYoaS5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcXCdSZXNpemUgcmVxdWlyZXMgXCJzaXplc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgcmFuayBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkXFwnKX1pZih0eXBlb2YgbzxcInVcIiYmdHlwZW9mIGk8XCJ1XCImJm8ubGVuZ3RoPjAmJmkubGVuZ3RoPmgpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sS2M9KGUsdCk9PmBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcXG4gICAgIGxlbmd0aE9yaWdpbmFsOiB1MzIsIHJvaVN0YXJ0OiBmMzIsIHJvaUVuZDogZjMyKSAtPiAke3R9IHsgYCsoKCk9Pntzd2l0Y2goZSl7Y2FzZVwiYXN5bW1ldHJpY1wiOnJldHVybmByZXR1cm4gJHt0fSh4UmVzaXplZCkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSAtIDAuNTtcXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcXG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJ0Zl9oYWxmX3BpeGVsX2Zvcl9ublwiOnJldHVybmByZXR1cm4gKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKTtgO2Nhc2VcImFsaWduX2Nvcm5lcnNcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdob2xlIHBhcnQgYW5kIHRoZSBmcmFjdGlvbmFsIHBhcnQgYXJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBkdWUgdG8gaW5hY2N1cmFjeSBvZiBmbG9hdGluZ1xcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXFxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQtYnktb25lIGVycm9yIGxhdGVyIGluIGZsb29yKCkuXFxuICAgICAgICAgICAgICAgICAgICBsZXQgd2hvbGUgPSAke3R9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpKTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdCA9XFxuICAgICAgICAgICAgICAgICAgICAgICAgJHt0fSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpICUgKGxlbmd0aFJlc2l6ZWQgLSAxKSkgLyAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aG9sZSArIGZyYWN0O1xcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAke3R9KHJvaVN0YXJ0KSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKSArXFxuICAgICAgICAgICAgICAgICAgICAgICAgKCR7dH0oeFJlc2l6ZWQpICogJHt0fShyb2lFbmQgLSByb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cXG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICR7dH0ocm9pU3RhcnQgKyByb2lFbmQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpO1xcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuYGNvbnN0IG91dHB1dFdpZHRoID0gJHt0fXhTY2FsZSAqICR7dH0obGVuZ3RoUmVzaXplZCk7XFxuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9ICR7dH0obGVuZ3RoUmVzaXplZCkgLyBvdXRwdXRXaWR0aDtcXG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke3R9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XFxuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgKCgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkpIC0gMC41O2A7Y2FzZVwiaGFsZl9waXhlbFwiOnJldHVybmByZXR1cm4gKCgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkpIC0gMC41O2A7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixZYz0oZSx0LHIpPT5gZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtyfSwgaXNEb3duU2FtcGxlOiBib29sKSAtPiAke3J9IHtgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJyb3VuZF9wcmVmZXJfY2VpbFwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgIH1cIjtjYXNlXCJmbG9vclwiOnJldHVyblwicmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7XCI7Y2FzZVwiY2VpbFwiOnJldHVyblwicmV0dXJuIGNlaWwoeE9yaWdpbmFsKTtcIjtjYXNlXCJyb3VuZF9wcmVmZXJfZmxvb3JcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9vcih4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwic2ltcGxlXCI6ZGVmYXVsdDppZih0PDExKXJldHVyblwiaWYgKGlzRG93blNhbXBsZSkgICAgICAgICAgICAgICAgICAgICB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyAgICAgICAgICAgICAgICAgICAgIH1cIjt0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLFpjPShlLHQscik9PntsZXQgbz1uZXcgQXJyYXkocikuZmlsbCgwKS5jb25jYXQobmV3IEFycmF5KHIpLmZpbGwoMSkpLGk9ZS5sZW5ndGg9PT0wP286ZS5zbGljZSgpO3JldHVybiB0Lmxlbmd0aD4wPyh0LmZvckVhY2goKHUsYSk9PntvW3VdPWlbYV0sb1thK3JdPWlbdC5sZW5ndGgrYV19KSxvKTppfSxYYz0oZSx0LHIsbyk9PntsZXQgaT1bXTtpZihyLmxlbmd0aD4wKWlmKG8ubGVuZ3RoPjApe2lmKGUuZm9yRWFjaCh1PT5pLnB1c2godSkpLE1hdGgubWF4KC4uLm8pPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMgaXMgb3V0IG9mIGJvdW5kXCIpO28uZm9yRWFjaCgodSxhKT0+aVt1XT1yW2FdKX1lbHNlIHIuZm9yRWFjaCh1PT5pLnB1c2godSkpO2Vsc2V7aWYodC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLlwiKTtpPWUubWFwKCh1LGEpPT5NYXRoLnJvdW5kKHUqdFthXSkpfXJldHVybiBpfSxKYz0oZSx0LHIpPT57bGV0IG89KCgpPT57c3dpdGNoKHIua2VlcEFzcGVjdFJhdGlvUG9saWN5KXtjYXNlXCJub3RfbGFyZ2VyXCI6cmV0dXJuIHIuYXhlcy5sZW5ndGg+MD9NYXRoLm1pbiguLi5yLmF4ZXMubWFwKHU9PnRbdV0pLE51bWJlci5NQVhfVkFMVUUpOk1hdGgubWluKC4uLnQsTnVtYmVyLk1BWF9WQUxVRSk7Y2FzZVwibm90X3NtYWxsZXJcIjpyZXR1cm4gci5heGVzLmxlbmd0aD4wP01hdGgubWF4KC4uLnIuYXhlcy5tYXAodT0+dFt1XSksTnVtYmVyLk1JTl9WQUxVRSk6TWF0aC5tYXgoLi4udCxOdW1iZXIuTUlOX1ZBTFVFKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgS2VlcCBhc3BlY3QgcmF0aW8gcG9saWN5ICR7ci5rZWVwQXNwZWN0UmF0aW9Qb2xpY3l9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpO3QuZmlsbCgxLDAsdC5sZW5ndGgpO2xldCBpPWUuc2xpY2UoKTtyZXR1cm4gci5heGVzLmxlbmd0aD4wPyhyLmF4ZXMuZm9yRWFjaCh1PT50W3VdPW8pLHIuYXhlcy5mb3JFYWNoKHU9PmlbdV09TWF0aC5yb3VuZChlW3VdKnRbdV0pKSk6KHQuZmlsbChvLDAsdC5sZW5ndGgpLGkuZm9yRWFjaCgodSxhKT0+aVthXT1NYXRoLnJvdW5kKHUqdFthXSkpKSxpfSxRYz0oZSx0LHIsbyxpKT0+YFxcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PCR7ZS50eXBlLnZhbHVlfSwgJHtyLmxlbmd0aH0+IHtcXG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke3IubGVuZ3RofT47XFxuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xcbiAgICAgICAgdmFyIHNjYWxlID0gJHtjZShcInVuaWZvcm1zLnNjYWxlc1wiLFwiaVwiLG8pfTtcXG4gICAgICAgIHZhciByb2lfbG93ID0gJHtjZShcInVuaWZvcm1zLnJvaVwiLFwiaVwiLGkpfTtcXG4gICAgICAgIHZhciByb2lfaGkgPSAke2NlKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3QubGVuZ3RofWAsaSl9O1xcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtlLnR5cGUudmFsdWV9KG91dHB1dF9pbmRleCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHQubGVuZ3RoKX07XFxuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBvcmlnaW5hbF9pbmRpY2VzO1xcbiAgICB9YCxlcD0oZSx0LHIsbyxpLHUsYSk9PmBcXG4gICAgZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XFxuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7by5sZW5ndGh9OyBpKyspIHtcXG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcXG4gICAgICAgIHZhciBpbnB1dF9pbmRleDogdTMyO1xcbiAgICAgICAgdmFyIHNjYWxlID0gJHtjZShcInVuaWZvcm1zLnNjYWxlc1wiLFwiaVwiLGkpfTtcXG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcXG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7Y2UoXCJ1bmlmb3Jtcy5yb2lcIixcImlcIix1KX07XFxuICAgICAgICAgIHZhciByb2lfaGkgPSAke2NlKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3IubGVuZ3RofWAsdSl9O1xcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XFxuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixvLmxlbmd0aCl9O1xcbiAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XFxuICAgICAgICAgIGlmICghJHthfSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbF9pZHggPCAwKSB7XFxuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XFxuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSAxO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCIgaW5wdXRfaW5kZXhcIil9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xcbiAgICB9YCx0cD0oZSx0KT0+YFxcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XFxuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtlLmluZGljZXNHZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcXG4gICAgICAgIGlmIChpbnB1dF9pbmRleCA8IDAgfHwgaW5wdXRfaW5kZXggPj0gJHtjZShcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9YCxGdT0oZSx0LHIsbyk9PmUucmFuaz5vP2BcXG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsdCxcImNoYW5uZWxcIil9O1xcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixyLFwiYmF0Y2hcIil9O1xcbmA6XCJcIixycD0oZSx0LHIsbyxpKT0+e2xldFthLHAsbSxoXT1yLmxlbmd0aD09PTI/Wy0xLDAsMSwtMV06WzAsMiwzLDFdLGQ9ZS50eXBlLnZhbHVlO3JldHVybmBcXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gJHtkfSB7XFxuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHAsYG1heCgwLCBtaW4ocm93LCAke3JbcF19IC0gMSkpYCl9O1xcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLG0sYG1heCgwLCBtaW4oY29sLCAke3JbbV19IC0gMSkpYCl9O1xcbiAgICAgICR7RnUoZSxoLGEsMil9XFxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcXG4gICAgfVxcblxcbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2R9IHtcXG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xcbiAgICAgIHZhciByb3c6JHtkfSA9IG9yaWdpbmFsSW5kaWNlc1ske3B9XTtcXG4gICAgICB2YXIgY29sOiR7ZH0gPSBvcmlnaW5hbEluZGljZXNbJHttfV07XFxuICAgICAgJHtvP2BpZiAocm93IDwgMCB8fCByb3cgPiAoJHtyW3BdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gKCR7clttXX0gLSAxKSkge1xcbiAgICAgICAgcmV0dXJuICR7aX07XFxuICAgICAgfWA6XCJcIn07XFxuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7cltwXX0gLSAxKSk7XFxuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7clttXX0gLSAxKSk7XFxuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcXG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XFxuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7ci5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2h9XSlgOlwiMFwifTtcXG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHthfV0pYDpcIjBcIn07XFxuICAgICAgdmFyIHgxMTogJHtkfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xcbiAgICAgIHZhciB4MTI6ICR7ZH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcXG4gICAgICB2YXIgeDIxOiAke2R9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XFxuICAgICAgdmFyIHgyMjogJHtkfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xcbiAgICAgIHZhciBkeDE6ICR7ZH0gPSBhYnMocm93IC0gJHtkfShyb3cxKSk7XFxuICAgICAgdmFyIGR4MjogJHtkfSA9IGFicygke2R9KHJvdzIpIC0gcm93KTtcXG4gICAgICB2YXIgZHkxOiAke2R9ID0gYWJzKGNvbCAtICR7ZH0oY29sMSkpO1xcbiAgICAgIHZhciBkeTI6ICR7ZH0gPSBhYnMoJHtkfShjb2wyKSAtIGNvbCk7XFxuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xcbiAgICAgICAgZHgxID0gMC41O1xcbiAgICAgICAgZHgyID0gMC41O1xcbiAgICAgIH1cXG4gICAgICBpZiAoY29sMSA9PSBjb2wyKSB7XFxuICAgICAgICBkeTEgPSAwLjU7XFxuICAgICAgICBkeTIgPSAwLjU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcXG4gICAgfWB9LG5wPShlLHQscixvLGksdSxhLHAsbSxoKT0+e2xldCBkPXIubGVuZ3RoPT09Mix5PSEwLFt3LF9dPWQ/WzAsMV06eT9bMiwzXTpbMSwyXSx2PWUudHlwZS52YWx1ZSx4PVQ9PntsZXQgQz1UPT09dz9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxcbiAgICAgIGZuICR7Q31DdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30sIG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHt2fSB7XFxuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFQpfTtcXG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHt2fSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7aVtUXX0sXFxuICAgICAgICAke29bVF19LCAke3JbVF19LCAke3VbVF19LCAke3VbVF19ICsgJHtyLmxlbmd0aH0pO1xcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6ICR7dn0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcXG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xcblxcbiAgICAgICAgaWYgKCR7cH0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke3JbVF19IC0gMSkpKSB7XFxuICAgICAgICAgIHJldHVybiAke219O1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7dn0sIDQ+ID0gYXJyYXk8JHt2fSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XFxuICAgICAgICAgIHZhciAke0N9OiAke3Z9ID0gb3JpZ2luYWxJZHggKyAke3Z9KGkpO1xcbiAgICAgICAgICBpZiAoJHtDfSA8IDAgfHwgJHtDfSA+PSAke3JbVF19KSB7XFxuICAgICAgICAgICAgJHsoKCk9Pmg/YGNvZWZzW2kgKyAxXSA9IDAuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtgOnA/YHJldHVybiAke219O2A6YCR7Q30gPSBtYXgoMCwgbWluKCR7Q30sICR7cltUXX0gLSAxKSk7YCkoKX07XFxuICAgICAgICAgIH1cXG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcXG4gICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIixULGB1MzIoJHtDfSlgKX07XFxuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHtUPT09dz9lLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNfY29weVwiKTpcInJvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKVwifTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XFxuICAgICAgfWB9O3JldHVybmBcXG4gICAgJHt4KHcpfTtcXG4gICAgJHt4KF8pfTtcXG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7dn0pIC0+IGFycmF5PCR7dn0sIDQ+IHtcXG4gICAgdmFyIGFic1MgPSBhYnMocyk7XFxuICAgIHZhciBjb2VmZnM6IGFycmF5PCR7dn0sIDQ+ID0gYXJyYXk8JHt2fSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHt2fSA9IDEuMCAtIGFic1M7XFxuICAgIHZhciB0d29NaW51c0Fic1M6ICR7dn0gPSAyLjAgLSBhYnNTO1xcbiAgICB2YXIgb25lUGx1c0Fic1M6ICR7dn0gPSAxLjAgKyBhYnNTO1xcbiAgICBjb2VmZnNbMF0gPSAoKCR7YX0gKiBvbmVQbHVzQWJzUyAtIDUgKiAke2F9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7YX0pICogb25lUGx1c0Fic1MgLSA0ICogJHthfTtcXG4gICAgY29lZmZzWzFdID0gKCgke2F9ICsgMikgKiBhYnNTIC0gKCR7YX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XFxuICAgIGNvZWZmc1syXSA9ICgoJHthfSArIDIpICogb25lTWludXNBYnNTIC0gKCR7YX0gKyAzKSkgKiBvbmVNaW51c0Fic1MgKiBvbmVNaW51c0Fic1MgKyAxO1xcbiAgICBjb2VmZnNbM10gPSAoKCR7YX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHthfSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHthfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHthfTtcXG4gICAgcmV0dXJuIGNvZWZmcztcXG4gIH1cXG5cXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7dn0sIDQ+LCBjb2VmczogYXJyYXk8JHt2fSwgND4pIC0+ICR7dn0ge1xcbiAgICB2YXIgY29lZnNTdW06ICR7dn0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcXG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xcbiAgfVxcblxcbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3Z9IHtcXG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XFxuICAgIHJldHVybiBjb2xDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlcywgb3V0cHV0X2luZGljZXMpO1xcbiAgfVxcbiAgICBgfSxvcD0oZSx0LHIsbyxpKT0+e2xldFthLHAsbSxoLGRdPXIubGVuZ3RoPT09Mz9bLTEsMCwxLDIsLTFdOlswLDIsMyw0LDFdLHk9ZS50eXBlLnZhbHVlO3JldHVybmBcXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGRlcHRoOnUzMiwgaGVpZ2h0OiB1MzIsIHdpZHRoOiB1MzIpIC0+ICR7eX0ge1xcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcXG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixwLGBtYXgoMCwgbWluKGRlcHRoLCAke3JbcF19IC0gMSkpYCl9O1xcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLG0sYG1heCgwLCBtaW4oaGVpZ2h0LCAke3JbbV19IC0gMSkpYCl9O1xcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGgsYG1heCgwLCBtaW4od2lkdGgsICR7cltoXX0gLSAxKSlgKX07XFxuICAgICAgJHtGdShlLGQsYSwzKX1cXG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xcbiAgICB9XFxuXFxuICAgIGZuIHRyaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3l9IHtcXG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xcbiAgICAgIHZhciBkZXB0aDoke3l9ID0gb3JpZ2luYWxJbmRpY2VzWyR7cH1dO1xcbiAgICAgIHZhciBoZWlnaHQ6JHt5fSA9IG9yaWdpbmFsSW5kaWNlc1ske219XTtcXG4gICAgICB2YXIgd2lkdGg6JHt5fSA9IG9yaWdpbmFsSW5kaWNlc1ske2h9XTtcXG4gICAgICAke28/YGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtyW3BdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7clttXX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtyW2hdfSAtIDEpKSB7XFxuICAgICAgcmV0dXJuICR7aX07XFxuICAgICAgICB9YDpcIlwifTtcXG5cXG4gICAgZGVwdGggPSBtYXgoMCwgbWluKGRlcHRoLCAke3JbcF19IC0gMSkpO1xcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke3JbbV19IC0gMSkpO1xcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtyW2hdfSAtIDEpKTtcXG4gICAgICB2YXIgZGVwdGgxOiB1MzIgPSB1MzIoZGVwdGgpO1xcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcXG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xcbiAgICAgIHZhciBkZXB0aDI6IHUzMiA9IHUzMihkZXB0aCArIDEpO1xcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XFxuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XFxuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7ci5sZW5ndGg+Mz9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2R9XSlgOlwiMFwifTtcXG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHthfV0pYDpcIjBcIn07XFxuXFxuICAgICAgdmFyIHgxMTE6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMSk7XFxuICAgICAgdmFyIHgxMTI6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMik7XFxuICAgICAgdmFyIHgxMjE6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XFxuICAgICAgdmFyIHgxMjI6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMik7XFxuICAgICAgdmFyIHgyMTE6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMSk7XFxuICAgICAgdmFyIHgyMTI6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XFxuICAgICAgdmFyIHgyMjE6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMSk7XFxuICAgICAgdmFyIHgyMjI6ICR7eX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMik7XFxuICAgICAgdmFyIGR4MTogJHt5fSA9IGFicyhkZXB0aCAtICR7eX0oZGVwdGgxKSk7XFxuICAgICAgdmFyIGR4MjogJHt5fSA9IGFicygke3l9KGRlcHRoMikgLSBkZXB0aCk7XFxuICAgICAgdmFyIGR5MTogJHt5fSA9IGFicyhoZWlnaHQgLSAke3l9KGhlaWdodDEpKTtcXG4gICAgICB2YXIgZHkyOiAke3l9ID0gYWJzKCR7eX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xcbiAgICAgIHZhciBkejE6ICR7eX0gPSBhYnMod2lkdGggLSAke3l9KHdpZHRoMSkpO1xcbiAgICAgIHZhciBkejI6ICR7eX0gPSBhYnMoJHt5fSh3aWR0aDIpIC0gd2lkdGgpO1xcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XFxuICAgICAgICBkeDEgPSAwLjU7XFxuICAgICAgICBkeDIgPSAwLjU7XFxuICAgICAgfVxcbiAgICAgIGlmIChoZWlnaHQxID09IGhlaWdodDIpIHtcXG4gICAgICAgIGR5MSA9IDAuNTtcXG4gICAgICAgIGR5MiA9IDAuNTtcXG4gICAgICB9XFxuICAgICAgaWYgKHdpZHRoMSA9PSB3aWR0aDIpIHtcXG4gICAgICAgIGR6MSA9IDAuNTtcXG4gICAgICAgIGR6MiA9IDAuNTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xcbiAgICAgICAgICAgICAgeDIxMSAqIGR4MSAqIGR5MiAqIGR6MiArIHgyMTIgKiBkeDEgKiBkeTIgKiBkejEgKyB4MjIxICogZHgxICogZHkxICpkejIgKyB4MjIyICogZHgxICogZHkxICogZHoxKTtcXG4gICAgfWB9LGlwPShlLHQscixvLGksdSk9PntsZXQgYT1lLmRpbXMscD1aYyh1LHQuYXhlcyxhLmxlbmd0aCksbT1YYyhhLG8saSx0LmF4ZXMpLGg9by5zbGljZSgpO28ubGVuZ3RoPT09MCYmKGg9YS5tYXAoKFMsRSk9PlM9PT0wPzE6bVtFXS9TKSx0LmtlZXBBc3BlY3RSYXRpb1BvbGljeSE9PVwic3RyZXRjaFwiJiYobT1KYyhhLGgsdCkpKTtsZXQgZD1KKFwib3V0cHV0XCIsZS5kYXRhVHlwZSxtLmxlbmd0aCkseT1WKFwiaW5wdXRcIixlLmRhdGFUeXBlLGEubGVuZ3RoKSx3PVcuc2l6ZShtKSxfPWEubGVuZ3RoPT09bS5sZW5ndGgmJmEuZXZlcnkoKFMsRSk9PlM9PT1tW0VdKSx2PXQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLHg9dC5leHRyYXBvbGF0aW9uVmFsdWUsVD15LnR5cGUudmFsdWUsQz1TPT5gXFxuICAgICAgJHtfP1wiXCI6YFxcbiAgICAgICR7S2ModC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSxUKX07XFxuICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxcbiAgICAgICAgICAgICAgJHt0cCh5LGEpfTtcXG4gICAgICAgICAgICAgICR7WWModC5uZWFyZXN0TW9kZSxyLFQpfTtcXG4gICAgICAgICAgICAgICR7ZXAoeSxkLGEsbSxoLmxlbmd0aCxwLmxlbmd0aCx2KX07XFxuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcXG4gICAgICAgICAgICAgICR7UWMoZCxhLG0saC5sZW5ndGgscC5sZW5ndGgpfTtcXG4gICAgICAgICAgICAgICR7KCgpPT57aWYoYS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQpcmV0dXJuYCR7cnAoeSxkLGEsdix4KX1gO2lmKGEubGVuZ3RoPT09M3x8YS5sZW5ndGg9PT01KXJldHVybmAke29wKHksZCxhLHYseCl9YDt0aHJvdyBFcnJvcihcIkxpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XFxuICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcXG4gICAgICAgICAgICAkeygoKT0+e2lmKGEubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00KXJldHVybmAke25wKHksZCxhLG0saCxwLHQuY3ViaWNDb2VmZkEsdix0LmV4dHJhcG9sYXRpb25WYWx1ZSx0LmV4Y2x1ZGVPdXRzaWRlKX1gO3Rocm93IEVycm9yKFwiQ3ViaWMgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiBhbmQgNCBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIkludmFsaWQgcmVzaXplIG1vZGVcIil9fSkoKX07XFxuICAgICAgYH1cXG4gICAgICAke1MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzY2FsZXNcIixcImYzMlwiLGgubGVuZ3RoKS5yZWdpc3RlclVuaWZvcm0oXCJyb2lcIixcImYzMlwiLHAubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKHksZCl9XFxuICAgICAgJHtTLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cXG4gICAgICAgICR7Xz9cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1wiOmBcXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke3kudHlwZS5pbmRpY2VzfTtcXG4gICAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlcykpIHtcXG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3kuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt0LmV4dHJhcG9sYXRpb25WYWx1ZX07XFxuICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVybmBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2EubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00P1wiYmlsaW5lYXJJbnRlcnBvbGF0aW9uXCI6XCJ0cmlsaW5lYXJJbnRlcnBvbGF0aW9uXCJ9KG91dHB1dF9pbmRpY2VzKTtgO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xcbmB9XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSZXNpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke3J9fCR7aC5sZW5ndGg+MD9oOlwiXCJ9fCR7aS5sZW5ndGg+MD9pOlwiXCJ9fCR7cC5sZW5ndGg+MD9wOlwiXCJ9fCR7X318JHthfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOkMsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczptLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh3LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6d30se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTpofSx7dHlwZTpcImZsb2F0MzJcIixkYXRhOnB9LC4uLkcoYSksLi4uRyhtKV19KX19LGFwPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sanU9KGUsdCk9PntsZXQgcj1bXSxvPVtdLGk9W10sdT1hcChlKTtpZih0LmFudGlhbGlhcyE9PTApdGhyb3cgRXJyb3IoXCJPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZFwiKTtxYyhlLmlucHV0cyx0LHUscixvLGkpLGUuY29tcHV0ZShpcChlLmlucHV0c1swXSx0LHUscixvLGkpLHtpbnB1dHM6WzBdfSl9LHF1PWU9PntsZXQgdD1lLmFudGlhbGlhcyxyPWUuYXhlcyxvPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsaT1lLmN1YmljQ29lZmZBLHU9ZS5leGNsdWRlT3V0c2lkZSE9PTAsYT1lLmV4dHJhcG9sYXRpb25WYWx1ZSxwPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LG09ZS5tb2RlLGg9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiB4ZSh7YW50aWFsaWFzOnQsYXhlczpyLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOm8sY3ViaWNDb2VmZkE6aSxleGNsdWRlT3V0c2lkZTp1LGV4dHJhcG9sYXRpb25WYWx1ZTphLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpwLG1vZGU6bSxuZWFyZXN0TW9kZTpofSl9fSk7dmFyIHNwLHVwLFl1LFp1PVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7X2UoKTtzcD1lPT57aWYoIWV8fGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLlwiKTtsZXQgdD1lWzBdLHI9ZVsxXSxvPWVbMl07aWYodC5kYXRhVHlwZSE9PXIuZGF0YVR5cGV8fHQuZGF0YVR5cGUhPT1vLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZVwiKTtpZih0LmRpbXMubGVuZ3RoIT09MyYmdC5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSAyRCBvciAzRFwiKTtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGJlIDJEIG9yIDNEXCIpO2xldCBpPXQuZGltc1t0LmRpbXMubGVuZ3RoLTFdLHU9dC5kaW1zW3QuZGltcy5sZW5ndGgtMl07aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMV0hPT1pKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTJdIT09dSl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXRcIik7aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBiZSAxRFwiKTtpZihvLmRpbXNbby5kaW1zLmxlbmd0aC0xXSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKGUubGVuZ3RoPjMpe2xldCBhPWVbM107aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGJlIDFEXCIpO2lmKGEuZGltc1thLmRpbXMubGVuZ3RoLTFdIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX1pZihlLmxlbmd0aD40KXtsZXQgYT1lWzRdO2lmKGEuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBiZSAxRFwiKTtpZihhLmRpbXNbYS5kaW1zLmxlbmd0aC0xXSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9fSx1cD0oZSx0LHIsbyk9PntsZXQgaT1lWzBdLmRpbXMsdT1XLnNpemUoaSksYT1pLHA9dSxtPWkuc2xpY2UoLTEpWzBdLGg9bz9pLnNsaWNlKDAsLTEpLmNvbmNhdCgxKTpbXSxkPWUubGVuZ3RoPjMseT1lLmxlbmd0aD40LHc9byYmcj4xLF89byYmcj4yLHY9cj4zLHg9SGUobSksVD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOnB9LHt0eXBlOlwidWludDMyXCIsZGF0YTp4fSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6bX0se3R5cGU6XCJmbG9hdDMyXCIsZGF0YTp0LmVwc2lsb259XSxDPUU9PntsZXQgTz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJjb21wb25lbnRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZjMyXCJ9XSxVPVtWKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHgpLFYoXCJza2lwXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMseCksVihcImdhbW1hXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMseCldO2QmJlUucHVzaChWKFwiYmV0YVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLHgpKSx5JiZVLnB1c2goVihcImJpYXNcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcyx4KSksVS5wdXNoKEooXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGEseCkpLHcmJlUucHVzaChKKFwibWVhbl9vdXRwdXRcIiwxLGgpKSxfJiZVLnB1c2goSihcImludl9zdGRfb3V0cHV0XCIsMSxoKSksdiYmVS5wdXNoKEooXCJpbnB1dF9za2lwX2JpYXNfc3VtXCIsZVswXS5kYXRhVHlwZSxhLHgpKTtsZXQgTT1OZShlWzBdLmRhdGFUeXBlKTtyZXR1cm5gXFxuXFxuICAgICAgJHtFLnJlZ2lzdGVyVW5pZm9ybXMoTykuZGVjbGFyZVZhcmlhYmxlcyguLi5VKX1cXG5cXG4gICAgICAke0UubWFpblN0YXJ0KCl9XFxuICAgICAgICAke0UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplIC8gdW5pZm9ybXMuaGlkZGVuX3NpemVcIil9XFxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xcbiAgICAgICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkO1xcbiAgICAgICAgdmFyIHN1bSA9ICR7WmUoXCJmMzJcIix4KX07XFxuICAgICAgICB2YXIgc3F1YXJlU3VtID0gJHtaZShcImYzMlwiLHgpfTtcXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkOyBpKyspIHtcXG4gICAgICAgICAgbGV0IHNraXBfdmFsdWUgPSBza2lwW29mZnNldCArIGldO1xcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7eT9cImJpYXNbaV1cIjpcIjAuMFwifTtcXG4gICAgICAgICAgbGV0IGlucHV0X3ZhbHVlID0geFtvZmZzZXQgKyBpXTtcXG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRfdmFsdWUgKyBza2lwX3ZhbHVlICsgYmlhc192YWx1ZTtcXG4gICAgICAgICAgJHt2P1wiaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XFxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xcbiAgICAgICAgICBsZXQgZjMyX3ZhbHVlID0gJHtndChNLHgsXCJ2YWx1ZVwiKX07XFxuICAgICAgICAgIHN1bSArPSBmMzJfdmFsdWU7XFxuICAgICAgICAgIHNxdWFyZVN1bSArPSBmMzJfdmFsdWUgKiBmMzJfdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgbWVhbiA9ICR7dXQoXCJzdW1cIix4KX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpO1xcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHt1dChcInNxdWFyZVN1bVwiLHgpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgLSBtZWFuICogbWVhbiArIHVuaWZvcm1zLmVwc2lsb24pO1xcbiAgICAgICAgJHt3P1wibWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XFxuICAgICAgICAke18/XCJpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2O1wiOlwiXCJ9XFxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgaGlkZGVuX3NpemVfdmVjdG9yaXplZDsgaSsrKSB7XFxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gLSAke019KG1lYW4pKSAqICR7TX0oaW52X3N0ZF9kZXYpICogZ2FtbWFbaV0gKyAke2Q/XCJiZXRhW2ldXCI6XCIwLjBcIn07XFxuICAgICAgICB9XFxuICAgICAgfWB9LFM9W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiByPjEmJlMucHVzaCh7ZGltczpoLGRhdGFUeXBlOjF9KSxyPjImJlMucHVzaCh7ZGltczpoLGRhdGFUeXBlOjF9KSxyPjMmJlMucHVzaCh7ZGltczppLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KSx7bmFtZTpcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt4fTske3d9OyR7X307JHt2fWAsaW5wdXREZXBlbmRlbmNpZXM6ZS5tYXAoKEUsTyk9PlwidHlwZVwiKX0sZ2V0U2hhZGVyU291cmNlOkMsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlMsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC9tLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlR9KX19LFl1PShlLHQpPT57c3AoZS5pbnB1dHMpO2xldCBvPVswXTtlLm91dHB1dENvdW50PjEmJm8ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4yJiZvLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MyYmby5wdXNoKDMpLGUuY29tcHV0ZSh1cChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQsITEpLHtvdXRwdXRzOm99KX19KTt2YXIgbHAsVm4sZHAsWHUsY3AscHAsSnUsUXUsZWw9USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7Q2UoKTtZZSgpO19lKCk7bHA9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtpZih0LmF4ZXMubGVuZ3RoIT09MCl7aWYodC5heGVzLmxlbmd0aCE9PXQuc3RhcnRzLmxlbmd0aHx8dC5heGVzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcywgc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIil9ZWxzZSBpZih0LnN0YXJ0cy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO2Uuc2xpY2UoMSkuZm9yRWFjaCgocixvKT0+e2lmKGVbbysxXS5kYXRhVHlwZSE9PTYmJmVbbysxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke299IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKX0pfSxWbj0oZSx0KT0+e2xldCByPVtdO2lmKGUubGVuZ3RoPnQpaWYoZVt0XS5kYXRhVHlwZT09PTcpZVt0XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChvPT5yLnB1c2goTnVtYmVyKG8pKSk7ZWxzZSBpZihlW3RdLmRhdGFUeXBlPT09NillW3RdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHt0fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7cmV0dXJuIHJ9LGRwPShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IHI9Vm4oZSwxKSxvPVZuKGUsMiksaT1WbihlLDMpO3JldHVybiBpLmxlbmd0aD09PTAmJihpPVsuLi5BcnJheShlWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldKSx4ZSh7c3RhcnRzOnIsZW5kczpvLGF4ZXM6aX0pfWVsc2UgcmV0dXJuIHR9LFh1PShlLHQscixvLGkpPT57bGV0IHU9ZTtyZXR1cm4gZTwwJiYodSs9cltvW3RdXSksaVt0XTwwP01hdGgubWF4KDAsTWF0aC5taW4odSxyW29bdF1dLTEpKTpNYXRoLm1heCgwLE1hdGgubWluKHUscltvW3RdXSkpfSxjcD0oZSx0LHIpPT5gZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XFxuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtyLmxlbmd0aH07IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke2NlKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xcbiAgICAgICAgICAgIGxldCBzdGVwc19pID0gJHtjZShcInVuaWZvcm1zLnN0ZXBzXCIsXCJpXCIsci5sZW5ndGgpfTtcXG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7Y2UoXCJ1bmlmb3Jtcy5zaWduc1wiLFwiaVwiLHIubGVuZ3RoKX07XFxuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtjZShcInVuaWZvcm1zLnN0YXJ0c1wiLFwiaVwiLHIubGVuZ3RoKX07XFxuICAgICAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfaW5kZXggJSBpbnB1dF9zaGFwZV9pO1xcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcXG4gICAgICB9YCxwcD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxvPVcuc2l6ZShyKSxpPXQuYXhlcy5sZW5ndGg+MD9XLm5vcm1hbGl6ZUF4ZXModC5heGVzLHIubGVuZ3RoKTpbLi4uQXJyYXkoci5sZW5ndGgpLmtleXMoKV0sdT1WbihlLDQpO3UuZm9yRWFjaChDPT5DIT09MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwic3RlcCBjYW5ub3QgYmUgMFwiKX0pKSx1Lmxlbmd0aD09PTAmJih1PUFycmF5KGkubGVuZ3RoKS5maWxsKDEpKTtsZXQgYT10LnN0YXJ0cy5tYXAoKEMsUyk9Plh1KEMsUyxyLGksdSkpLHA9dC5lbmRzLm1hcCgoQyxTKT0+WHUoQyxTLHIsaSx1KSk7aWYoaS5sZW5ndGghPT1hLmxlbmd0aHx8aS5sZW5ndGghPT1wLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCwgZW5kcyBhbmQgYXhlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcIik7aWYoaS5sZW5ndGghPT1yLmxlbmd0aClmb3IobGV0IEM9MDtDPHIubGVuZ3RoOysrQylpLmluY2x1ZGVzKEMpfHwoYS5zcGxpY2UoQywwLDApLHAuc3BsaWNlKEMsMCxyW0NdKSx1LnNwbGljZShDLDAsMSkpO2xldCBtPXUubWFwKEM9Pk1hdGguc2lnbihDKSk7dS5mb3JFYWNoKChDLFMsRSk9PntpZihDPDApe2xldCBPPShwW1NdLWFbU10pL0MsVT1hW1NdLE09VStPKnVbU107YVtTXT1NLHBbU109VSxFW1NdPS1DfX0pO2xldCBoPXIuc2xpY2UoMCk7aS5mb3JFYWNoKChDLFMpPT57aFtDXT1NYXRoLmNlaWwoKHBbQ10tYVtDXSkvdVtDXSl9KTtsZXQgZD17ZGltczpoLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9LHk9SihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsaC5sZW5ndGgpLHc9VihcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxfPVcuc2l6ZShoKSx2PVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDphLmxlbmd0aH0se25hbWU6XCJzaWduc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6bS5sZW5ndGh9LHtuYW1lOlwic3RlcHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnUubGVuZ3RofV0seD1be3R5cGU6XCJ1aW50MzJcIixkYXRhOl99LHt0eXBlOlwidWludDMyXCIsZGF0YTphfSx7dHlwZTpcImludDMyXCIsZGF0YTptfSx7dHlwZTpcInVpbnQzMlwiLGRhdGE6dX0sLi4uRyhlWzBdLmRpbXMpLC4uLkcoaCldLFQ9Qz0+YFxcbiAgICAgICR7Qy5yZWdpc3RlclVuaWZvcm1zKHYpLmRlY2xhcmVWYXJpYWJsZXModyx5KX1cXG4gICAgICAgICR7Y3Aodyx5LHIpfVxcbiAgICAgICAgJHtDLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAke0MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XFxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xcbiAgICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsdy5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpKX1cXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bS5sZW5ndGh9XyR7YS5sZW5ndGh9XyR7dS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6VCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W2RdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6eH0pfX0sSnU9KGUsdCk9PntscChlLmlucHV0cyx0KTtsZXQgcj1kcChlLmlucHV0cyx0KTtlLmNvbXB1dGUocHAoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sUXU9ZT0+e2xldCB0PWUuc3RhcnRzLHI9ZS5lbmRzLG89ZS5heGVzO3JldHVybiB4ZSh7c3RhcnRzOnQsZW5kczpyLGF4ZXM6b30pfX0pO3ZhciBtcCxmcCx0bCxybCxubD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtZZSgpO19lKCk7bXA9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LlwiKX0sZnA9KGUsdCk9PntsZXQgcj1lLmRpbXMsbz1XLnNpemUociksaT02NCx1PXQuYXhpcztpZih1PDAmJih1PXIubGVuZ3RoK3UpLHU8ci5sZW5ndGgtMSl0aHJvdyBuZXcgRXJyb3IoXCJzb2Z0bWF4IG9ubHkgc3VwcG9ydHMgbGFzdCBheGlzIGZvciBub3cuXCIpO2xldCBhPXJbdV0scD1vL2EsbT1IZShhKSxoPWEvbSxkPShULEMpPT5DPT09ND9gbWF4KG1heCgke1R9LngsICR7VH0ueSksIG1heCgke1R9LnosICR7VH0udykpYDpDPT09Mj9gbWF4KCR7VH0ueCwgJHtUfS55KWA6Qz09PTM/YG1heChtYXgoJHtUfS54LCAke1R9LnkpLCAke1R9LnopYDpULHk9VihcInhcIixlLmRhdGFUeXBlLGUuZGltcyxtKSx3PUooXCJyZXN1bHRcIixlLmRhdGFUeXBlLGUuZGltcyxtKSxfPXkudHlwZS52YWx1ZSx2PU5lKGUuZGF0YVR5cGUpPT09XCJmMzJcIj9gdmFyIHRocmVhZE1heCA9ICR7X30oLTMuNDAyODIzZSszOGYpO2A6YHZhciB0aHJlYWRNYXggPSAke199KC02NTUwNC4waCk7YCx4PVQ9PmBcXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke199O1xcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7X307XFxuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHtffSwgJHtpfT47XFxuXFxuICAgICAgZm4gZ2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIpIC0+ICR7X30ge1xcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcXG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcXG4gICAgICB9XFxuXFxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke199KSB7XFxuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICAke1QucmVnaXN0ZXJVbmlmb3JtKFwicGFja2VkQ29sc1wiLFwiaTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSx3KX1cXG4gICAgICAke1QubWFpblN0YXJ0KCl9XFxuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZHgpO1xcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xcbiAgICAgICAgY29uc3Qgd2cgPSAke2l9O1xcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xcbiAgICAgICAgbGV0IGNvbHMgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xcblxcbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcXG4gICAgICAgICR7dn1cXG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcXG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcXG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XFxuICAgICAgICB9XFxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XFxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcXG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcXG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XFxuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XFxuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7X30oJHtkKFwidGhyZWFkU2hhcmVkWzBdXCIsbSl9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXFxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHtffSgwLjApO1xcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcXG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XFxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcXG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcXG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHtffSgke3V0KFwidGhyZWFkU2hhcmVkWzBdXCIsbSl9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcXG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XFxuICAgICAgICAgIGxldCB2YWx1ZSA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpIC8gcm93U3VtU2hhcmVkO1xcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1gO3JldHVybntuYW1lOlwiU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke219YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6cH0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTpcInVpbnQzMlwiLGRhdGE6aH1dfSksZ2V0U2hhZGVyU291cmNlOnh9fSx0bD0oZSx0KT0+e21wKGUuaW5wdXRzKSxlLmNvbXB1dGUoZnAoZS5pbnB1dHNbMF0sdCkpfSxybD1lPT54ZSh7YXhpczplLmF4aXN9KX0pO3ZhciBocCxncCx5cCxicCx3cCxvbCxpbCxhbD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Q2UoKTtZZSgpO19lKCk7aHA9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpfSxncD0oZSx0KT0+e2xldCByPVtdLG89dC5udW1PdXRwdXRzO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goaT0+ci5wdXNoKE51bWJlcihpKSkpLG89ci5sZW5ndGgpLHhlKHtudW1PdXRwdXRzOm8sYXhpczp0LmF4aXMsc3BsaXRTaXplczpyfSl9LHlwPWU9PmBcXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX11OyBpICs9IDF1ICkge1xcbiAgICBpZiAoaW5kZXggPCAke2NlKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJpXCIsZSl9KSB7XFxuICAgICAgICByZXR1cm4gaTtcXG4gICAgfVxcbiAgICB9XFxuICAgIHJldHVybiAke2V9dTtcXG59YCxicD1lPT57bGV0IHQ9ZS5sZW5ndGgscj1bXTtmb3IobGV0IG89MDtvPHQ7KytvKXtsZXQgaT1lW29dLnNldEJ5SW5kaWNlcyhcImluZGljZXNcIixcImlucHV0W2dsb2JhbF9pZHhdXCIpO3Q9PT0xP3IucHVzaChpKTpvPT09MD9yLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7b311KSB7ICR7aX0gfWApOm89PT10LTE/ci5wdXNoKGBlbHNlIHsgJHtpfSB9YCk6ci5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7b30pIHsgJHtpfSB9YCl9cmV0dXJuYFxcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcXG4gICAgICAgICR7ci5qb2luKGBcXG5gKX1cXG4gICAgICB9YH0sd3A9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbz1XLnNpemUociksaT1lWzBdLmRhdGFUeXBlLHU9Vy5ub3JtYWxpemVBeGlzKHQuYXhpcyxyLmxlbmd0aCksYT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxwPVYoXCJpbnB1dFwiLGksciksbT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxoPVtdLGQ9W10seT0wLHc9W3t0eXBlOlwidWludDMyXCIsZGF0YTpvfV07Zm9yKGxldCB2PTA7djx0Lm51bU91dHB1dHM7disrKXt5Kz10LnNwbGl0U2l6ZXNbdl0sbVt2XT15O2xldCB4PXIuc2xpY2UoKTt4W3QuYXhpc109dC5zcGxpdFNpemVzW3ZdLGQucHVzaCh4KSxhW3ZdPUooYG91dHB1dCR7dn1gLGkseCksaC5wdXNoKHtkaW1zOmRbdl0sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pfXcucHVzaCh7dHlwZTpcInVpbnQzMlwiLGRhdGE6bX0pLHcucHVzaCguLi5HKHIpKSxkLmZvckVhY2godj0+dy5wdXNoKC4uLkcodikpKTtsZXQgXz12PT5gXFxuICAke3YucmVnaXN0ZXJVbmlmb3JtKFwiaW5wdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNpemVfaW5fc3BsaXRfYXhpc1wiLFwidTMyXCIsbS5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMocCwuLi5hKX1cXG4gICR7eXAobS5sZW5ndGgpfVxcbiAgJHticChhKX1cXG5cXG4gICR7di5tYWluU3RhcnQoKX1cXG4gICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5pbnB1dF9zaXplXCIpfVxcblxcbiAgICB2YXIgaW5kaWNlcyA9ICR7cC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgdmFyIGluZGV4ID0gJHtwLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsdSl9O1xcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcXG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xcbiAgICAgIGluZGV4IC09ICR7Y2UoXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcIm91dHB1dF9udW1iZXIgLSAxdVwiLG0ubGVuZ3RoKX07XFxuICAgICAgJHtwLmluZGljZXNTZXQoXCJpbmRpY2VzXCIsdSxcImluZGV4XCIpfTtcXG4gICAgfVxcbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XFxuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6XyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6aCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnd9KX19LG9sPShlLHQpPT57aHAoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDpncChlLmlucHV0cyx0KTtlLmNvbXB1dGUod3AoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0saWw9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxvPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihvIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiB4ZSh7YXhpczp0LG51bU91dHB1dHM6byxzcGxpdFNpemVzOnJ9KX19KTt2YXIgc2wsdnAsJHAsX3AsdWwsbGw9USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7Q2UoKTtfZSgpO3NsPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSx2cD1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTYmJmVbMF0uZGF0YVR5cGUhPT0xMil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlc1wiKTtpZihlWzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLURcIik7aWYoc2woZVsxXSkubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yXCIpfSwkcD0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKXIucHVzaChlW29dKnRbb10pO3JldHVybiByfSxfcD1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9c2woZVsxXSksbz0kcCh0LHIpLGk9Vy5zaXplKG8pLHU9ZVswXS5kYXRhVHlwZSxhPVYoXCJpbnB1dFwiLHUsdC5sZW5ndGgpLHA9SihcIm91dHB1dFwiLHUsby5sZW5ndGgpLG09aD0+YFxcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke2EuaW5kaWNlcyguLi50KX07XFxuICAgICAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhhLHApfVxcbiAgICAgICR7aC5tYWluU3RhcnQoKX1cXG4gICAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxcbiAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7cC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcXG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHthLnR5cGUuaW5kaWNlc307XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3QubGVuZ3RofTsgaSsrKSB7XFxuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2EuaW5kaWNlc0dldChcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIpfTtcXG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke3AuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcXG5cXG4gICAgICAgICR7YS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRfZGltX3ZhbHVlXCIpfVxcbiAgICAgIH1cXG4gICAgICAke3Auc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpKX1cXG4gICAgfWA7cmV0dXJue25hbWU6XCJUaWxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cn1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOml9LC4uLkcoZVswXS5kaW1zKSwuLi5HKG8pXX0pLGdldFNoYWRlclNvdXJjZTptfX0sdWw9ZT0+e3ZwKGUuaW5wdXRzKSxlLmNvbXB1dGUoX3AoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIFNwLHhwLGRsLGNsPVEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO0NlKCk7X2UoKTtTcD0oZSx0LHIsbyxpKT0+e2xldCB1PUooXCJvdXRwdXRfZGF0YVwiLGksci5sZW5ndGgsNCksYT1WKFwiYV9kYXRhXCIsdFsxXS5kYXRhVHlwZSx0WzFdLmRpbXMubGVuZ3RoLDQpLHA9VihcImJfZGF0YVwiLHRbMl0uZGF0YVR5cGUsdFsyXS5kaW1zLmxlbmd0aCw0KSxtPVYoXCJjX2RhdGFcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcy5sZW5ndGgsNCksaCxkPSh5LHcsXyk9PmBzZWxlY3QoJHt3fSwgJHt5fSwgJHtffSlgO2lmKCFvKWg9dS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixkKGEuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLHAuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLG0uZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtsZXQgeT0odyxfLHY9XCJcIik9PntsZXQgeD1gYV9kYXRhW2luZGV4X2Eke199XVtjb21wb25lbnRfYSR7X31dYCxUPWBiX2RhdGFbaW5kZXhfYiR7X31dW2NvbXBvbmVudF9iJHtffV1gLEM9YGJvb2woY19kYXRhW2luZGV4X2Mke199XSAmICR7NDI3ODE5MDA4MD4+PigzLV8pKjh9dSlgO3JldHVybmBcXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke199ID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtffXVgKX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldF9hJHtffSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCx1KX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldF9iJHtffSA9ICR7cC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCx1KX07XFxuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHtffSA9ICR7bS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCx1KX07XFxuICAgICAgICAgICAgbGV0IGluZGV4X2Eke199ID0gb2Zmc2V0X2Eke199IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGluZGV4X2Ike199ID0gb2Zmc2V0X2Ike199IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGluZGV4X2Mke199ID0gb2Zmc2V0X2Mke199IC8gNHU7XFxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9hJHtffSA9IG9mZnNldF9hJHtffSAlIDR1O1xcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYiR7X30gPSBvZmZzZXRfYiR7X30gJSA0dTtcXG4gICAgICAgICAgICAke3d9WyR7X31dID0gJHt2fSgke2QoeCxULEMpfSk7XFxuICAgICAgICAgIGB9O2k9PT05P2g9YFxcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xcbiAgICAgICAgICAgICR7eShcImRhdGFcIiwwLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7eShcImRhdGFcIiwxLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7eShcImRhdGFcIiwyLFwidTMyXCIpfVxcbiAgICAgICAgICAgICR7eShcImRhdGFcIiwzLFwidTMyXCIpfVxcbiAgICAgICAgICAgIG91dHB1dF9kYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6aD1gXFxuICAgICAgICAgICAgJHt5KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cXG4gICAgICAgICAgICAke3koXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxcbiAgICAgICAgICAgICR7eShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMil9XFxuICAgICAgICAgICAgJHt5KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cXG4gICAgICAgICAgYH1yZXR1cm5gXFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0sYSxwLHUpfVxcbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cXG4gICAgICAgICR7aH1cXG4gICAgICB9YH0seHA9ZT0+e2xldCB0PWVbMV0uZGltcyxyPWVbMl0uZGltcyxvPWVbMF0uZGltcyxpPWVbMV0uZGF0YVR5cGUsdT0hKFcuYXJlRXF1YWwodCxyKSYmVy5hcmVFcXVhbChyLG8pKSxhPXQscD1XLnNpemUodCk7aWYodSl7bGV0IGg9dnQuY2FsY1NoYXBlKHZ0LmNhbGNTaGFwZSh0LHIsITEpLG8sITEpO2lmKCFoKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgcGVyZm9ybSB3aGVyZSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTthPWgscD1XLnNpemUoYSl9bGV0IG09TWF0aC5jZWlsKHAvNCk7cmV0dXJue25hbWU6XCJXaGVyZVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6aD0+U3AoaCxlLGEsdSxpKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6aX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6XCJ1aW50MzJcIixkYXRhOm19LC4uLkcobyksLi4uRyh0KSwuLi5HKHIpLC4uLkcoYSldfSl9fSxkbD1lPT57ZS5jb21wdXRlKHhwKGUuaW5wdXRzKSl9fSk7dmFyIHBsLG1sPVEoKCk9PntcInVzZSBzdHJpY3RcIjtEYSgpO3hvKCk7VWEoKTtXYSgpOyRzKCk7a3MoKTtEcygpO0VvKCk7WXMoKTtKcygpO251KCk7YXUoKTtsdSgpO3B1KCk7aHUoKTt5dSgpO3d1KCk7T28oKTtTdSgpO0N1KCk7SHUoKTtMdSgpO0luKCk7S3UoKTtadSgpO2VsKCk7bmwoKTthbCgpO2xsKCk7cHIoKTtDbygpO2NsKCk7cGw9bmV3IE1hcChbW1wiQWJzXCIsW05hXV0sW1wiQWNvc1wiLFtIYV1dLFtcIkFjb3NoXCIsW0dhXV0sW1wiQWRkXCIsW19zXV0sW1wiQXJnTWF4XCIsW0JhLFNvXV0sW1wiQXJnTWluXCIsW1JhLFNvXV0sW1wiQXNpblwiLFtMYV1dLFtcIkFzaW5oXCIsW0ZhXV0sW1wiQXRhblwiLFtqYV1dLFtcIkF0YW5oXCIsW3FhXV0sW1wiQXR0ZW50aW9uXCIsW01hXV0sW1wiQXZlcmFnZVBvb2xcIixbUnUsa3VdXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixbemFdXSxbXCJCaWFzQWRkXCIsW1ZhXV0sW1wiQmlhc1NwbGl0R2VsdVwiLFt2c11dLFtcIkNhc3RcIixbWWEsS2FdXSxbXCJDZWlsXCIsW1hhXV0sW1wiQ2xpcFwiLFtaYV1dLFtcIkNvbmNhdFwiLFtScyxCc11dLFtcIkNvbnZcIixbUm8sa29dXSxbXCJDb252VHJhbnNwb3NlXCIsW0tzLHFzXV0sW1wiQ29zXCIsW0phXV0sW1wiQ29zaFwiLFtRYV1dLFtcIkN1bVN1bVwiLFtacyxYc11dLFtcIkRpdlwiLFtTc11dLFtcIkVpbnN1bVwiLFt0dSxydV1dLFtcIkVsdVwiLFtlcyxQbl1dLFtcIkVxdWFsXCIsW3hzXV0sW1wiRXJmXCIsW3RzXV0sW1wiRXhwXCIsW3JzXV0sW1wiRXhwYW5kXCIsW2l1XV0sW1wiRmxvb3JcIixbbnNdXSxbXCJGdXNlZENvbnZcIixbUm8sa29dXSxbXCJHYXRoZXJcIixbdXUsc3VdXSxbXCJHYXRoZXJFbGVtZW50c1wiLFtjdSxkdV1dLFtcIkdlbHVcIixbb3NdXSxbXCJHZW1tXCIsW2Z1LG11XV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbTXUsRHVdXSxbXCJHbG9iYWxNYXhQb29sXCIsW051LFd1XV0sW1wiR3JlYXRlclwiLFtUc11dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW1BzXV0sW1wiSGFyZFNpZ21vaWRcIixbcHMsY3NdXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixbZ3VdXSxbXCJMYXllck5vcm1hbGl6YXRpb25cIixbYnVdXSxbXCJMZWFreVJlbHVcIixbaXMsUG5dXSxbXCJMZXNzXCIsW0VzXV0sW1wiTGVzc09yRXF1YWxcIixbT3NdXSxbXCJMb2dcIixbd3NdXSxbXCJNYXRNdWxcIixbV3NdXSxbXCJNYXhQb29sXCIsW1V1LFZ1XV0sW1wiTXVsXCIsW0NzXV0sW1wiTXVsdGlIZWFkQXR0ZW50aW9uXCIsW191LCR1XV0sW1wiTmVnXCIsW3NzXV0sW1wiTm90XCIsW2FzXV0sW1wiUGFkXCIsW3h1XV0sW1wiUG93XCIsW0FzXV0sW1wiUmFuZ2VcIixbR3VdXSxbXCJSZWNpcHJvY2FsXCIsW3VzXV0sW1wiUmVkdWNlTWluXCIsW0lhXV0sW1wiUmVkdWNlTWVhblwiLFtfYV1dLFtcIlJlZHVjZU1heFwiLFtBYV1dLFtcIlJlZHVjZVN1bVwiLFtFYV1dLFtcIlJlZHVjZVByb2RcIixbVGFdXSxbXCJSZWR1Y2VMMVwiLFtTYV1dLFtcIlJlZHVjZUwyXCIsW3hhXV0sW1wiUmVkdWNlTG9nU3VtXCIsW09hXV0sW1wiUmVkdWNlTG9nU3VtRXhwXCIsW0NhXV0sW1wiUmVkdWNlU3VtU3F1YXJlXCIsW1BhXV0sW1wiUmVsdVwiLFtsc11dLFtcIlJlc2l6ZVwiLFtqdSxxdV1dLFtcIlNpZ21vaWRcIixbZHNdXSxbXCJTaW5cIixbbXNdXSxbXCJTaW5oXCIsW2ZzXV0sW1wiU2xpY2VcIixbSnUsUXVdXSxbXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsW1l1XV0sW1wiU3BsaXRcIixbb2wsaWxdXSxbXCJTcXJ0XCIsW2hzXV0sW1wiU29mdG1heFwiLFt0bCxybF1dLFtcIlN1YlwiLFtJc11dLFtcIlRhblwiLFtnc11dLFtcIlRhbmhcIixbeXNdXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbYnMsUG5dXSxbXCJUaWxlXCIsW3VsXV0sW1wiVHJhbnNwb3NlXCIsW2xhLGRhXV0sW1wiV2hlcmVcIixbZGxdXV0pfSk7dmFyIFduLGZsPVEoKCk9PntcInVzZSBzdHJpY3RcIjtkcigpO3p0KCk7X2UoKTtXbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdCh0KXtyZXR1cm4gdGhpcy5yZXBvLmdldCh0KX1zZXRBcnRpZmFjdCh0LHIpe3RoaXMucmVwby5zZXQodCxyKX1ydW4odCxyLG8saSx1KXtZdCh0LnByb2dyYW1JbmZvLm5hbWUpO2xldCBhPXRoaXMuYmFja2VuZC5kZXZpY2UscD10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMikscC5zZXRQaXBlbGluZSh0LmNvbXB1dGVQaXBlbGluZSk7bGV0IG09W107Zm9yKGxldCBkIG9mIHIpbS5wdXNoKHtiaW5kaW5nOm0ubGVuZ3RoLHJlc291cmNlOntidWZmZXI6ZC5idWZmZXJ9fSk7Zm9yKGxldCBkIG9mIG8pbS5wdXNoKHtiaW5kaW5nOm0ubGVuZ3RoLHJlc291cmNlOntidWZmZXI6ZC5idWZmZXJ9fSk7dSYmbS5wdXNoKHtiaW5kaW5nOm0ubGVuZ3RoLHJlc291cmNlOnV9KTtsZXQgaD1hLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnQuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOm0sbGFiZWw6dC5wcm9ncmFtSW5mby5uYW1lfSk7cC5zZXRCaW5kR3JvdXAoMCxoKSxwLmRpc3BhdGNoV29ya2dyb3VwcyguLi5pKSx0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKywodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLmJhY2tlbmQucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5iYWNrZW5kLmZsdXNoKCksWnQodC5wcm9ncmFtSW5mby5uYW1lKX1kaXNwb3NlKCl7fWJ1aWxkKHQscil7WXQodC5uYW1lKTtsZXQgbz10aGlzLmJhY2tlbmQuZGV2aWNlLGk9W107by5mZWF0dXJlcy5oYXMoXCJzaGFkZXItZjE2XCIpJiZpLnB1c2goXCJlbmFibGUgZjE2O1wiKTtsZXQgdT1zYShyKSxhPXQuZ2V0U2hhZGVyU291cmNlKHUpLHA9YCR7aS5qb2luKGBcXG5gKX1cXG4ke3UuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cXG4ke2F9YCxtPW8uY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOnAsbGFiZWw6dC5uYW1lfSk7RGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSAke3QubmFtZX0gc2hhZGVyIGNvZGU6ICR7cH1gKTtsZXQgaD1vLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOm0sZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybiBadCh0Lm5hbWUpLHtwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTpofX1ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSh0KXtsZXQgcj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQueCxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC55fHwxLGk9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnp8fDEsdT10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZihyPD11JiZvPD11JiZpPD11KXJldHVybltyLG8saV07bGV0IGE9cipvKmkscD1NYXRoLmNlaWwoTWF0aC5zcXJ0KGEpKTtpZihwPnUpe2lmKHA9TWF0aC5jZWlsKE1hdGguY2JydChhKSkscD51KXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW3AscCxwXX1lbHNlIHJldHVybltwLHAsMV19fX0pO3ZhciBDcCxBcCxObixobD1RKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZHIoKTtWZSgpO3p0KCk7cmEoKTthYSgpO21sKCk7ZmwoKTtDcD0oZSx0KT0+e2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHt0Lmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtlLmxlbmd0aH0uYCk7bGV0IHI9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pe2xldCBpPWVbb10uZGF0YVR5cGU7c3dpdGNoKHRbb10pe2Nhc2VcIm5vbmVcIjp7ci5wdXNoKFwiXCIpO2JyZWFrfWNhc2VcInR5cGVcIjp7ci5wdXNoKGAke2l9YCk7YnJlYWt9Y2FzZVwicmFua1wiOntsZXQgdT1lW29dLmRpbXMubGVuZ3RoO3IucHVzaChgJHtpfTske3V9YCk7YnJlYWt9Y2FzZVwiZGltc1wiOntsZXQgdT1lW29dLmRpbXMuam9pbihcIixcIik7ci5wdXNoKGAke2l9OyR7dX1gKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHt0W29dfWApfX1yZXR1cm4gci5qb2luKFwifFwiKX0sQXA9KGUsdCxyKT0+e2xldCBvPWUubmFtZTtyZXR1cm4gZS5zaGFkZXJDYWNoZT8uaGludCYmKG8rPVwiW1wiK2Uuc2hhZGVyQ2FjaGUuaGludCtcIl1cIiksbys9XCI6XCIrcitgOiR7Q3AodCxlLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcz8/bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKFwiZGltc1wiKSl9YCxvfSxObj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuY3VycmVudEtlcm5lbElkPW51bGw7dGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsO3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGw7dGhpcy5tYXhEaXNwYXRjaE51bWJlcj0xNjt0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wO3RoaXMucGVuZGluZ0tlcm5lbHM9W107dGhpcy5wZW5kaW5nUXVlcmllcz1uZXcgTWFwO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0LHIpe3RoaXMuZW52PXQ7bGV0IG89W10saT17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOnIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOnIubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOnIubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczpvfTtyLmZlYXR1cmVzLmhhcyhcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKT9vLnB1c2goXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIik6ci5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJm8ucHVzaChcInRpbWVzdGFtcC1xdWVyeVwiKSxyLmZlYXR1cmVzLmhhcyhcInNoYWRlci1mMTZcIikmJm8ucHVzaChcInNoYWRlci1mMTZcIiksdGhpcy5kZXZpY2U9YXdhaXQgci5yZXF1ZXN0RGV2aWNlKGkpLHRoaXMuZ3B1RGF0YU1hbmFnZXI9aWEodGhpcyksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgV24odGhpcyksdGhpcy5rZXJuZWxzPW5ldyBNYXAsdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YT1uZXcgTWFwLHRoaXMua2VybmVsQ3VzdG9tRGF0YT1uZXcgTWFwLGVhKHQubG9nTGV2ZWwsISF0LmRlYnVnKSx0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvcj11PT57dS5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvciYmY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHt1LmVycm9yLm1lc3NhZ2V9YCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJkZXZpY2VcIix7dmFsdWU6dGhpcy5kZXZpY2V9KSx0aGlzLnNldFF1ZXJ5VHlwZSgpfWRpc3Bvc2UoKXt0eXBlb2YgdGhpcy5xdWVyeVNldDxcInVcIiYmdGhpcy5xdWVyeVNldC5kZXN0cm95KCksdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCl9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtpZighdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpe2xldCB0PXt9O3RoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIiYmKHQudGltZXN0YW1wV3JpdGVzPXtxdWVyeVNldDp0aGlzLnF1ZXJ5U2V0LGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMixlbmRPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMX0pLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKS5iZWdpbkNvbXB1dGVQYXNzKHQpfXJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXtpZighdGhpcy5jb21tYW5kRW5jb2RlcilyZXR1cm47WXQoKSx0aGlzLmVuZENvbXB1dGVQYXNzKCk7bGV0IHQ7dGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmKHRoaXMuY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KHRoaXMucXVlcnlTZXQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDApLHQ9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRHxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pLHRoaXMucGVuZGluZ1F1ZXJpZXMuc2V0KHQsdGhpcy5wZW5kaW5nS2VybmVscyksdGhpcy5wZW5kaW5nS2VybmVscz1bXSx0aGlzLmNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcih0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwLHQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgpKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnQubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpPT57bGV0IHI9bmV3IEJpZ1VpbnQ2NEFycmF5KHQuZ2V0TWFwcGVkUmFuZ2UoKSksbz10aGlzLnBlbmRpbmdRdWVyaWVzLmdldCh0KTtmb3IobGV0IGk9MDtpPHIubGVuZ3RoLzI7aSsrKXtsZXQgdT1vW2ldLGE9dS5rZXJuZWxJZCxwPXRoaXMua2VybmVscy5nZXQoYSksbT1wLmtlcm5lbFR5cGUsaD1wLmtlcm5lbE5hbWUsZD11LnByb2dyYW1OYW1lLHk9dS5pbnB1dFRlbnNvclZpZXdzLHc9dS5vdXRwdXRUZW5zb3JWaWV3cyxfPXJbaSoyXSx2PXJbaSoyKzFdO3R5cGVvZiB0aGlzLnF1ZXJ5VGltZUJhc2U+XCJ1XCImJih0aGlzLnF1ZXJ5VGltZUJhc2U9Xyk7bGV0IHg9TnVtYmVyKF8tdGhpcy5xdWVyeVRpbWVCYXNlKSxUPU51bWJlcih2LXRoaXMucXVlcnlUaW1lQmFzZSk7aWYoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHgpfHwhTnVtYmVyLmlzU2FmZUludGVnZXIoVCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlXCIpO2lmKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSl0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7dmVyc2lvbjoxLGlucHV0c01ldGFkYXRhOnkubWFwKEM9Pih7ZGltczpDLmRpbXMsZGF0YVR5cGU6c3QoQy5kYXRhVHlwZSl9KSksb3V0cHV0c01ldGFkYXRhOncubWFwKEM9Pih7ZGltczpDLmRpbXMsZGF0YVR5cGU6c3QoQy5kYXRhVHlwZSl9KSksa2VybmVsSWQ6YSxrZXJuZWxUeXBlOm0sa2VybmVsTmFtZTpoLHByb2dyYW1OYW1lOmQsc3RhcnRUaW1lOngsZW5kVGltZTpUfSk7ZWxzZXtsZXQgQz1cIlwiO3kuZm9yRWFjaCgoRSxPKT0+e0MrPWBpbnB1dFske099XTogWyR7RS5kaW1zfV0gfCAke3N0KEUuZGF0YVR5cGUpfSwgYH0pO2xldCBTPVwiXCI7dy5mb3JFYWNoKChFLE8pPT57Uys9YG91dHB1dFske099XTogWyR7RS5kaW1zfV0gfCAke3N0KEUuZGF0YVR5cGUpfSwgYH0pLGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke2F9fCR7bX18JHtofXwke2R9XCIgJHtDfSR7U31leGVjdXRpb24gdGltZTogJHtULXh9IG5zYCl9bW8oXCJHUFVcIixgJHtkfTo6JHtffTo6JHt2fWApfXQudW5tYXAoKSx0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZSh0KX0pLFp0KCl9cnVuKHQscixvLGksdSl7WXQodC5uYW1lKTtsZXQgYT1bXTtmb3IobGV0IFM9MDtTPHIubGVuZ3RoOysrUyl7bGV0IEU9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQocltTXS5kYXRhKTtpZighRSl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHtyW1NdLmRhdGF9YCk7YVtTXT1FfWxldHtvdXRwdXRzOnAsZGlzcGF0Y2hHcm91cDptLHByb2dyYW1Vbmlmb3JtczpofT10LmdldFJ1bkRhdGEociksZD1vLmxlbmd0aD09PTA/cC5tYXAoKFMsRSk9PkUpOm87aWYoZC5sZW5ndGghPT1wLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7ZC5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtwLmxlbmd0aH0uYCk7bGV0IHk9W10sdz1bXTtmb3IobGV0IFM9MDtTPHAubGVuZ3RoOysrUyl7aWYoIU51bWJlci5pc0ludGVnZXIoZFtTXSl8fGRbU108LTN8fGRbU10+PXAubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7ZFtTXX1gKTtpZihkW1NdPT09LTMpY29udGludWU7bGV0IEU9ZFtTXT09PS0xLE89ZFtTXT09PS0yLFU9RXx8Tz91KHBbU10uZGF0YVR5cGUscFtTXS5kaW1zKTppKGRbU10scFtTXS5kYXRhVHlwZSxwW1NdLmRpbXMpLE09dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoVS5kYXRhKTtpZighTSl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7VS5kYXRhfWApO2lmKEUmJnRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKE0pLE8pe2xldCBOPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtOfHwoTj1bXSx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCxOKSksTi5wdXNoKE0pfXkucHVzaChVKSx3LnB1c2goTSl9bGV0IF87aWYoaCl7bGV0IFM9MCxFPVtdO2guZm9yRWFjaChOPT57bGV0IFk9dHlwZW9mIE4uZGF0YT09XCJudW1iZXJcIj9bTi5kYXRhXTpOLmRhdGE7aWYoWS5sZW5ndGg9PT0wKXJldHVybjtsZXQgc2U9Ti50eXBlPT09XCJmbG9hdDE2XCI/Mjo0LEIsdGU7Ti50eXBlPT09XCJmbG9hdDE2XCI/KHRlPVkubGVuZ3RoPjQ/MTY6WS5sZW5ndGg+Mj84OlkubGVuZ3RoKnNlLEI9WS5sZW5ndGg+ND8xNjpzZSpZLmxlbmd0aCk6KHRlPVkubGVuZ3RoPD0yP1kubGVuZ3RoKnNlOjE2LEI9MTYpLFM9TWF0aC5jZWlsKFMvdGUpKnRlLEUucHVzaChTKTtsZXQgUGU9Ti50eXBlPT09XCJmbG9hdDE2XCI/ODo0O1MrPVkubGVuZ3RoPjQ/TWF0aC5jZWlsKFkubGVuZ3RoL1BlKSpCOlkubGVuZ3RoKnNlfSk7bGV0IE89MTY7Uz1NYXRoLmNlaWwoUy9PKSpPO2xldCBVPW5ldyBBcnJheUJ1ZmZlcihTKTtoLmZvckVhY2goKE4sWSk9PntsZXQgc2U9RVtZXSxCPXR5cGVvZiBOLmRhdGE9PVwibnVtYmVyXCI/W04uZGF0YV06Ti5kYXRhO04udHlwZT09PVwiaW50MzJcIj9uZXcgSW50MzJBcnJheShVLHNlLEIubGVuZ3RoKS5zZXQoQik6Ti50eXBlPT09XCJ1aW50MzJcIj9uZXcgVWludDMyQXJyYXkoVSxzZSxCLmxlbmd0aCkuc2V0KEIpOk4udHlwZT09PVwiZmxvYXQxNlwiP25ldyBVaW50MTZBcnJheShVLHNlLEIubGVuZ3RoKS5zZXQoQik6bmV3IEZsb2F0MzJBcnJheShVLHNlLEIubGVuZ3RoKS5zZXQoQil9KTtsZXQgTT10aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShTLEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO3RoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKE0uYnVmZmVyLDAsVSwwLFMpLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShNLmlkKSxfPXtvZmZzZXQ6MCxzaXplOlMsYnVmZmVyOk0uYnVmZmVyfX1sZXQgdj10aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKG0pLHg9dlsxXT09PTEmJnZbMl09PT0xLFQ9QXAodCxyLHgpLEM9dGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChUKTtpZihDfHwoQz10aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHQsdiksdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChULEMpLERlKFwiaW5mb1wiLCgpPT5gW2FydGlmYWN0XSBrZXk6ICR7VH0sIHByb2dyYW1OYW1lOiAke3QubmFtZX1gKSksRGUoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHtUfSkgd2l0aCAke3ZbMF19eCR7dlsxXX14JHt2WzJdfWApLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCIpe2xldCBTPXtrZXJuZWxJZDp0aGlzLmN1cnJlbnRLZXJuZWxJZCxwcm9ncmFtTmFtZTpDLnByb2dyYW1JbmZvLm5hbWUsaW5wdXRUZW5zb3JWaWV3czpyLG91dHB1dFRlbnNvclZpZXdzOnl9O3RoaXMucGVuZGluZ0tlcm5lbHMucHVzaChTKX1yZXR1cm4gdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4oQyxhLHcsdixfKSxadCh0Lm5hbWUpLHl9dXBsb2FkKHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxyKX1tZW1jcHkodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LHIpfWFzeW5jIGRvd25sb2FkKHQscil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LHIpfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQscixvLGkpe2xldCB1PXBsLmdldCh0KTtpZighdSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTtsZXQgYT17a2VybmVsVHlwZTp0LGtlcm5lbE5hbWU6aSxrZXJuZWxFbnRyeTp1WzBdLGF0dHJpYnV0ZXM6W3VbMV0sb119O3RoaXMua2VybmVscy5zZXQocixhKX1yZWxlYXNlS2VybmVsKHQpe2xldCByPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKHIpe2ZvcihsZXQgbyBvZiByKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShvLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LHIsbyl7bGV0IGk9dGhpcy5rZXJuZWxzLmdldCh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldCB1PWkua2VybmVsVHlwZSxhPWkua2VybmVsTmFtZSxwPWkua2VybmVsRW50cnksbT1pLmF0dHJpYnV0ZXM7aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7dX1dICR7YX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LG1bMF0mJihtWzFdPW1bMF0obVsxXSksbVswXT12b2lkIDApLERlKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske3V9XSAke2F9XCIuLi5gKTtsZXQgaD10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBoJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIikscChyLG1bMV0pLDB9Y2F0Y2goZCl7cmV0dXJuIG8ucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske3V9XSAke2F9XCIgZmFpbGVkLiAke2R9YCkpLDF9ZmluYWxseXtoJiZvLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4oZD0+ZD9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske3V9XSAke2F9XCI6ICR7ZC5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgZCBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGQuaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LHIsbyxpKXtsZXQgdT10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTt1fHwodT1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQsdSkpO2xldCBhPXUuZ2V0KHIpLHA9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG8saSxhPy5bMV0pO3JldHVybiB1LnNldChyLFtwLG9dKSxwfXVucmVnaXN0ZXJCdWZmZXJzKHQpe2xldCByPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO3ImJihyLmZvckVhY2gobz0+dGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIob1sxXSkpLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHQpKX1nZXRCdWZmZXIodCl7bGV0IHI9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke3R9YCk7cmV0dXJuIHIuYnVmZmVyfWNyZWF0ZURvd25sb2FkZXIodCxyLG8pe3JldHVybiBhc3luYygpPT57bGV0IGk9YXdhaXQgZ28odGhpcyx0LHIpO3JldHVybiB0YShpLmJ1ZmZlcixvKX19d3JpdGVUaW1lc3RhbXAodCl7dGhpcy5xdWVyeVR5cGU9PT1cImluc2lkZS1wYXNzZXNcIiYmdGhpcy5jb21wdXRlUGFzc0VuY29kZXIud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCx0KX1zZXRRdWVyeVR5cGUoKXt0aGlzLnF1ZXJ5VHlwZT1cIm5vbmVcIiwodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ubW9kZT09PVwiZGVmYXVsdFwifHx0aGlzLmVudi53YXNtLnRyYWNlKSYmKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKT90aGlzLnF1ZXJ5VHlwZT1cImluc2lkZS1wYXNzZXNcIjp0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJih0aGlzLnF1ZXJ5VHlwZT1cImF0LXBhc3Nlc1wiKSx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0eXBlb2YgdGhpcy5xdWVyeVNldD5cInVcIiYmKHRoaXMucXVlcnlTZXQ9dGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe3R5cGU6XCJ0aW1lc3RhbXBcIixjb3VudDp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjJ9KSx0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlcj10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRX0pKSl9b25SdW5TdGFydCgpe3RoaXMuc2V0UXVlcnlUeXBlKCl9fX0pO3ZhciBnbD17fTtobihnbCx7aW5pdDooKT0+SXB9KTt2YXIgTnIsVm8sSXAseWw9USgoKT0+e1widXNlIHN0cmljdFwiO1ZlKCk7aGwoKTt6dCgpO0NlKCk7TnI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LHIsbyxpKXt0aGlzLm1vZHVsZT10O3RoaXMuZGF0YVR5cGU9cjt0aGlzLmRhdGE9bzt0aGlzLmRpbXM9aX1nZXRGbG9hdDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1XLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEZsb2F0MzJBcnJheTpuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0QmlnSW50NjRBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PVcuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgQmlnSW50NjRBcnJheTpuZXcgQmlnSW50NjRBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEludDMyQXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1XLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEludDMyQXJyYXk6bmV3IEludDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1yZXNoYXBlKHQpe2lmKFcuc2l6ZSh0KSE9PVcuc2l6ZSh0aGlzLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmV3IHNoYXBlXCIpO3JldHVybiBuZXcgZSh0aGlzLm1vZHVsZSx0aGlzLmRhdGFUeXBlLHRoaXMuZGF0YSx0KX19LFZvPWNsYXNze2NvbnN0cnVjdG9yKHQscixvKXt0aGlzLm1vZHVsZT10O3RoaXMuYmFja2VuZD1yO3RoaXMuY3VzdG9tRGF0YU9mZnNldD0wO3RoaXMuY3VzdG9tRGF0YVNpemU9MDtsZXQgaT10LkhFQVBVMzIsdT1vPj4+Mjt0aGlzLm9wS2VybmVsQ29udGV4dD1pW3UrK107bGV0IGE9aVt1KytdO3RoaXMub3V0cHV0Q291bnQ9aVt1KytdLHRoaXMuY3VzdG9tRGF0YU9mZnNldD1pW3UrK10sdGhpcy5jdXN0b21EYXRhU2l6ZT1pW3UrK107bGV0IHA9W107Zm9yKGxldCBtPTA7bTxhO20rKyl7bGV0IGg9aVt1KytdLGQ9aVt1KytdLHk9aVt1KytdLHc9W107Zm9yKGxldCBfPTA7Xzx5O18rKyl3LnB1c2goaVt1KytdKTtwLnB1c2gobmV3IE5yKHQsaCxkLHcpKX10aGlzLmlucHV0cz1wfWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQscil7bGV0IG89cj8uaW5wdXRzPy5tYXAocD0+dHlwZW9mIHA9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbcF06cCk/P3RoaXMuaW5wdXRzLGk9cj8ub3V0cHV0cz8/W10sdT0ocCxtLGgpPT5uZXcgTnIodGhpcy5tb2R1bGUsbSx0aGlzLm91dHB1dChwLGgpLGgpLGE9KHAsbSk9PntsZXQgaD1NcihwKTtpZighaCl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtwfWApO2xldCBkPWgqVy5zaXplKG0pO3JldHVybiBuZXcgTnIodGhpcy5tb2R1bGUscCx0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGQpLmlkLG0pfTtyZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bih0LG8saSx1LGEpfW91dHB1dCh0LHIpe2xldCBvPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgaT10aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxK3IubGVuZ3RoKSo0KSx1PWk+PjI7dGhpcy5tb2R1bGUuSEVBUFUzMlt1KytdPXIubGVuZ3RoO2ZvcihsZXQgYT0wO2E8ci5sZW5ndGg7YSsrKXRoaXMubW9kdWxlLkhFQVBVMzJbdSsrXT1yW2FdO3JldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCx0LGkpfWNhdGNoKGkpe3Rocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbFxcJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtyfV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtpfWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKG8pfX19LElwPWFzeW5jKGUsdCxyKT0+e2xldCBvPWUuanNlcEluaXQ7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuXCIpO2xldCBpPW5ldyBObjthd2FpdCBpLmluaXRpYWxpemUodCxyKSxvKGksdT0+aS5hbGxvYyh1KSx1PT5pLmZyZWUodSksKHUsYSxwLG09ITEpPT57aWYobSlEZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke3V9LCBkc3Q9JHthfSwgc2l6ZT0ke3B9YCksaS5tZW1jcHkodSxhKTtlbHNle0RlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke3V9LCBncHVEYXRhSWQ9JHthfSwgc2l6ZT0ke3B9YCk7bGV0IGg9ZS5IRUFQVTguc3ViYXJyYXkodT4+PjAsKHU+Pj4wKStwKTtpLnVwbG9hZChhLGgpfX0sYXN5bmModSxhLHApPT57RGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHt1fSwgZGF0YU9mZnNldD0ke2F9LCBzaXplPSR7cH1gKSxhd2FpdCBpLmRvd25sb2FkKHUsKCk9PmUuSEVBUFU4LnN1YmFycmF5KGE+Pj4wLChhPj4+MCkrcCkpfSwodSxhLHApPT5pLmNyZWF0ZUtlcm5lbCh1LGEscCxlLlVURjhUb1N0cmluZyhlLl9Kc2VwR2V0Tm9kZU5hbWUoYSkpKSx1PT5pLnJlbGVhc2VLZXJuZWwodSksKHUsYSxwLG0pPT57RGUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwUnVuOiBzZXNzaW9uSGFuZGxlPSR7cH0sIGtlcm5lbD0ke3V9LCBjb250ZXh0RGF0YU9mZnNldD0ke2F9YCk7bGV0IGg9bmV3IFZvKGUsaSxhKTtyZXR1cm4gaS5jb21wdXRlS2VybmVsKHUsaCxtKX0pfX0pO3ZhciBQaTtQaT12aSgpO3ZhciBObD1JaSgpLHNvLHVvPSExLGduPSExLEVpPSExLEhsPWU9PntpZihlPT09MSlyZXR1cm4hMTtpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuIHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIitlK1wiLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLlwiKSwhMTt0eXBlb2YgcHJvY2VzczxcInVcIiYmcHJvY2Vzcy52ZXJzaW9ucyYmcHJvY2Vzcy52ZXJzaW9ucy5ub2RlJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIitlK1wiLCBob3dldmVyLCBjdXJyZW50bHkgb25ueHJ1bnRpbWUtd2ViIGRvZXMgbm90IHN1cHBvcnQgbXVsdGktdGhyZWFkcyBpbiBOb2RlLmpzLiBQbGVhc2UgY29uc2lkZXIgdXNpbmcgb25ueHJ1bnRpbWUtbm9kZSBmb3IgcGVyZm9ybWFuY2UgY3JpdGljYWwgc2NlbmFyaW9zLlwiKTt0cnl7cmV0dXJuIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sR2w9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sTGw9KGUsdCk9PmU/dD9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20tc2ltZC53YXNtXCI6dD9cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLndhc21cIixPaT1hc3luYyBlPT57aWYodW8pcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGduKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGRldGVjdGVkLlwiKTtpZihFaSl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGZhaWxlZC5cIik7Z249ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcyxvPWUuc2ltZCxpPUhsKHIpLHU9byYmR2woKSxhPWUud2FzbVBhdGhzLHA9dHlwZW9mIGE9PVwic3RyaW5nXCI/YTp2b2lkIDAsbT1MbCh1LGkpLGg9dHlwZW9mIGE9PVwib2JqZWN0XCI/YVttXTp2b2lkIDAsZD0hMSx5PVtdO2lmKHQ+MCYmeS5wdXNoKG5ldyBQcm9taXNlKHc9PntzZXRUaW1lb3V0KCgpPT57ZD0hMCx3KCl9LHQpfSkpLHkucHVzaChuZXcgUHJvbWlzZSgodyxfKT0+e2xldCB2PWk/Tmw6UGkseD17bG9jYXRlRmlsZTooVCxDKT0+e2lmKGkmJlQuZW5kc1dpdGgoXCIud29ya2VyLmpzXCIpJiZ0eXBlb2YgQmxvYjxcInVcIilyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbVGkoKV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTtpZihULmVuZHNXaXRoKFwiLndhc21cIikpe2lmKGgpcmV0dXJuIGg7bGV0IFM9cD8/QztyZXR1cm4gbT09PVwib3J0LXdhc20tc2ltZC53YXNtXCI/UytcIm9ydC13YXNtLXNpbWQuanNlcC53YXNtXCI6bT09PVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI/UytcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6UyttfXJldHVybiBDK1R9fTtpZihpKWlmKHgubnVtVGhyZWFkcz1yLHR5cGVvZiBCbG9iPlwidVwiKXgubWFpblNjcmlwdFVybE9yQmxvYj0odm9pZCAwKShfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2xldCBUPWB2YXIgb3J0V2FzbVRocmVhZGVkPSR7di50b1N0cmluZygpfTtgO3gubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbVF0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfXYoeCkudGhlbihUPT57Z249ITEsdW89ITAsc289VCx3KCl9LFQ9Pntnbj0hMSxFaT0hMCxfKFQpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKHkpLGQpdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxVZT0oKT0+e2lmKHVvJiZzbylyZXR1cm4gc287dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9O3ZhciBXZT0oZSx0KT0+e2xldCByPVVlKCksbz1yLmxlbmd0aEJ5dGVzVVRGOChlKSsxLGk9ci5fbWFsbG9jKG8pO3JldHVybiByLnN0cmluZ1RvVVRGOChlLGksbyksdC5wdXNoKGkpLGl9LERyPShlLHQscixvKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYoci5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW2ksdV0pPT57bGV0IGE9dD90K2k6aTtpZih0eXBlb2YgdT09XCJvYmplY3RcIilEcih1LGErXCIuXCIscixvKTtlbHNlIGlmKHR5cGVvZiB1PT1cInN0cmluZ1wifHx0eXBlb2YgdT09XCJudW1iZXJcIilvKGEsdS50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiB1PT1cImJvb2xlYW5cIilvKGEsdT9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiB1fWApfSl9LEJlPWU9PntsZXQgdD1VZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IG89dC5zdGFja0FsbG9jKDgpO3QuX09ydEdldExhc3RFcnJvcihvLG8rNCk7bGV0IGk9dC5IRUFQMzJbby80XSx1PXQuSEVBUFUzMltvLzQrMV0sYT11P3QuVVRGOFRvU3RyaW5nKHUpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7aX0sIEVSUk9SX01FU1NBR0U6ICR7YX1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX07dmFyIGtpPWU9PntsZXQgdD1VZSgpLHI9MCxvPVtdLGk9ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApaS5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApaS5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihpLnRlcm1pbmF0ZT0hMSk7bGV0IHU9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYodT1XZShlLnRhZyxvKSkscj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKGkubG9nU2V2ZXJpdHlMZXZlbCxpLmxvZ1ZlcmJvc2l0eUxldmVsLCEhaS50ZXJtaW5hdGUsdSkscj09PTAmJkJlKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZEcihlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKGEscCk9PntsZXQgbT1XZShhLG8pLGg9V2UocCxvKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShyLG0saCkhPT0wJiZCZShgQ2FuXFwndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke2F9IC0gJHtwfS5gKX0pLFtyLG9dfWNhdGNoKHUpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhyKSxvLmZvckVhY2goYT0+dC5fZnJlZShhKSksdX19O3ZhciBGbD1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSxqbD1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0scWw9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKHI9Pih0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LEtsPShlLHQscik9Pntmb3IobGV0IG8gb2YgdCl7bGV0IGk9dHlwZW9mIG89PVwic3RyaW5nXCI/bzpvLm5hbWU7c3dpdGNoKGkpe2Nhc2VcIndlYm5uXCI6aWYoaT1cIldFQk5OXCIsdHlwZW9mIG8hPVwic3RyaW5nXCIpe2xldCBhPW87aWYoYT8uZGV2aWNlVHlwZSl7bGV0IHA9V2UoXCJkZXZpY2VUeXBlXCIsciksbT1XZShhLmRldmljZVR5cGUscik7VWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUscCxtKSE9PTAmJkJlKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdkZXZpY2VUeXBlXFwnIC0gJHthLmRldmljZVR5cGV9LmApfWlmKGE/Lm51bVRocmVhZHMpe2xldCBwPWEubnVtVGhyZWFkczsodHlwZW9mIHAhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHApfHxwPDApJiYocD0wKTtsZXQgbT1XZShcIm51bVRocmVhZHNcIixyKSxoPVdlKHAudG9TdHJpbmcoKSxyKTtVZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxtLGgpIT09MCYmQmUoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6IFxcJ251bVRocmVhZHNcXCcgLSAke2EubnVtVGhyZWFkc30uYCl9aWYoYT8ucG93ZXJQcmVmZXJlbmNlKXtsZXQgcD1XZShcInBvd2VyUHJlZmVyZW5jZVwiLHIpLG09V2UoYS5wb3dlclByZWZlcmVuY2Uscik7VWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUscCxtKSE9PTAmJkJlKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdwb3dlclByZWZlcmVuY2VcXCcgLSAke2EucG93ZXJQcmVmZXJlbmNlfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYoaT1cIkpTXCIsdHlwZW9mIG8hPVwic3RyaW5nXCIpe2xldCBhPW87aWYoYT8ucHJlZmVycmVkTGF5b3V0KXtpZihhLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZhLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyIFxcJ05DSFdcXCcgb3IgXFwnTkhXQ1xcJzogJHthLnByZWZlcnJlZExheW91dH1gKTtsZXQgcD1XZShcInByZWZlcnJlZExheW91dFwiLHIpLG09V2UoYS5wcmVmZXJyZWRMYXlvdXQscik7VWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUscCxtKSE9PTAmJkJlKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiBcXCdwcmVmZXJyZWRMYXlvdXRcXCcgLSAke2EucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtpfWApfWxldCB1PVdlKGkscik7VWUoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSx1KSE9PTAmJkJlKGBDYW5cXCd0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7aX0uYCl9fSxSaT1lPT57bGV0IHQ9VWUoKSxyPTAsbz1bXSxpPWV8fHt9O3FsKGkpO3RyeXtsZXQgdT1GbChpLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLGE9amwoaS5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIikscD10eXBlb2YgaS5sb2dJZD09XCJzdHJpbmdcIj9XZShpLmxvZ0lkLG8pOjAsbT1pLmxvZ1NldmVyaXR5TGV2ZWw/PzI7aWYoIU51bWJlci5pc0ludGVnZXIobSl8fG08MHx8bT40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bX1gKTtsZXQgaD1pLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGgpfHxoPDB8fGg+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2h9YCk7bGV0IGQ9dHlwZW9mIGkub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9XZShpLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsbyk6MDtpZihyPXQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHUsISFpLmVuYWJsZUNwdU1lbUFyZW5hLCEhaS5lbmFibGVNZW1QYXR0ZXJuLGEsISFpLmVuYWJsZVByb2ZpbGluZywwLHAsbSxoLGQpLHI9PT0wJiZCZShcIkNhblxcJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIiksaS5leGVjdXRpb25Qcm92aWRlcnMmJktsKHIsaS5leGVjdXRpb25Qcm92aWRlcnMsbyksaS5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbeSx3XW9mIE9iamVjdC5lbnRyaWVzKGkuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiB5IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke3l9YCk7aWYodHlwZW9mIHchPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHcpfHx3PDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7d31gKTtsZXQgXz1XZSh5LG8pO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShyLF8sdykhPT0wJiZCZShgQ2FuXFwndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHt5fSAtICR7d30uYCl9cmV0dXJuIGkuZXh0cmEhPT12b2lkIDAmJkRyKGkuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoeSx3KT0+e2xldCBfPVdlKHksbyksdj1XZSh3LG8pO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShyLF8sdikhPT0wJiZCZShgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHt5fSAtICR7d30uYCl9KSxbcixvXX1jYXRjaCh1KXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHIpLG8uZm9yRWFjaChhPT50Ll9mcmVlKGEpKSx1fX07VmUoKTt2YXIgRGk9YXN5bmMgZT0+e2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKWlmKHR5cGVvZiBwcm9jZXNzPFwidVwiJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGUpdHJ5e3JldHVybiBuZXcgVWludDhBcnJheShhd2FpdCh2b2lkIDApKGUpKX1jYXRjaCh0KXtpZih0LmNvZGU9PT1cIkVSUl9GU19GSUxFX1RPT19MQVJHRVwiKXtsZXQgcj0odm9pZCAwKShlKSxvPVtdO2ZvciBhd2FpdChsZXQgaSBvZiByKW8ucHVzaChpKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChvKSl9dGhyb3cgdH1lbHNle2xldCB0PWF3YWl0IGZldGNoKGUpO2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9YCk7bGV0IHI9dC5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLG89cj9wYXJzZUludChyLDEwKTowO2lmKG88MTA3Mzc0MTgyNClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdC5hcnJheUJ1ZmZlcigpKTt7aWYoIXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtsZXQgaT10LmJvZHkuZ2V0UmVhZGVyKCksdTt0cnl7dT1uZXcgQXJyYXlCdWZmZXIobyl9Y2F0Y2gocCl7aWYocCBpbnN0YW5jZW9mIFJhbmdlRXJyb3Ipe2xldCBtPU1hdGguY2VpbChvLzY1NTM2KTt1PW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6bSxtYXhpbXVtOm19KS5idWZmZXJ9ZWxzZSB0aHJvdyBwfWxldCBhPTA7Zm9yKDs7KXtsZXR7ZG9uZTpwLHZhbHVlOm19PWF3YWl0IGkucmVhZCgpO2lmKHApYnJlYWs7bGV0IGg9bS5ieXRlTGVuZ3RoO25ldyBVaW50OEFycmF5KHUsYSxoKS5zZXQobSksYSs9aH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkodSwwLG8pfX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgQmxvYj9uZXcgVWludDhBcnJheShhd2FpdCBlLmFycmF5QnVmZmVyKCkpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9O3ZhciBUcD0oZSx0KT0+e1VlKCkuX09ydEluaXQoZSx0KSE9PTAmJkJlKFwiQ2FuXFwndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sd2w9YXN5bmMgZT0+e1RwKGUud2FzbS5udW1UaHJlYWRzLHpyKGUubG9nTGV2ZWwpKX0sdmw9YXN5bmMoZSx0KT0+e2lmKHQ9PT1cIndlYmdwdVwifHx0PT09XCJ3ZWJublwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLmdwdSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50XCIpO2xldCByPWF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXFwnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLlxcJyk7aWYoIWUud2FzbS5zaW1kKXRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgZm9yIFdlYkdQVT1PTiBhbmQgU0lNRD1PRkYuIFBsZWFzZSBzZXQgYGVudi53YXNtLnNpbWRgIHRvIHRydWUgd2hlbiB1c2luZyBgd2ViZ3B1YCBFUFwiKTtsZXQgbz0oeWwoKSx1cihnbCkpLmluaXQ7YXdhaXQgbyhVZSgpLGUscil9fSxIcj1uZXcgTWFwLEVwPWU9PntsZXQgdD1VZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IG89dC5zdGFja0FsbG9jKDgpO3JldHVybiB0Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50KGUsbyxvKzQpIT09MCYmQmUoXCJDYW5cXCd0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIiksW3QuSEVBUDMyW28vNF0sdC5IRUFQMzJbby80KzFdXX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX0sV289ZT0+e2xldCB0PVVlKCkscj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihyPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSwkbD1hc3luYyhlLHQpPT57bGV0IHIsbyxpPVVlKCk7QXJyYXkuaXNBcnJheShlKT9bcixvXT1lOmUuYnVmZmVyPT09aS5IRUFQVTguYnVmZmVyP1tyLG9dPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbcixvXT1XbyhlKTtsZXQgdT0wLGE9MCxwPTAsbT1bXSxoPVtdLGQ9W107dHJ5e2lmKFthLG1dPVJpKHQpLHQ/LmV4dGVybmFsRGF0YSYmaS5tb3VudEV4dGVybmFsRGF0YSl7bGV0IEM9W107Zm9yKGxldCBTIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgRT10eXBlb2YgUz09XCJzdHJpbmdcIj9TOlMucGF0aDtDLnB1c2goRGkodHlwZW9mIFM9PVwic3RyaW5nXCI/UzpTLmRhdGEpLnRoZW4oTz0+e2kubW91bnRFeHRlcm5hbERhdGEoRSxPKX0pKX1hd2FpdCBQcm9taXNlLmFsbChDKX11PWF3YWl0IGkuX09ydENyZWF0ZVNlc3Npb24ocixvLGEpLHU9PT0wJiZCZShcIkNhblxcJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIik7bGV0W3ksd109RXAodSksXz1bXSx2PVtdLHg9W107Zm9yKGxldCBDPTA7Qzx5O0MrKyl7bGV0IFM9aS5fT3J0R2V0SW5wdXROYW1lKHUsQyk7Uz09PTAmJkJlKFwiQ2FuXFwndCBnZXQgYW4gaW5wdXQgbmFtZS5cIiksaC5wdXNoKFMpLF8ucHVzaChpLlVURjhUb1N0cmluZyhTKSl9Zm9yKGxldCBDPTA7Qzx3O0MrKyl7bGV0IFM9aS5fT3J0R2V0T3V0cHV0TmFtZSh1LEMpO1M9PT0wJiZCZShcIkNhblxcJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxkLnB1c2goUyk7bGV0IEU9aS5VVEY4VG9TdHJpbmcoUyk7di5wdXNoKEUpO3tsZXQgTz10eXBlb2YgdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PVwic3RyaW5nXCI/dC5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbjp0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW0VdPz9cImNwdVwiO2lmKE8hPT1cImNwdVwiJiZPIT09XCJjcHUtcGlubmVkXCImJk8hPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtPfS5gKTt4LnB1c2goTyl9fWxldCBUPW51bGw7cmV0dXJuIHguc29tZShDPT5DPT09XCJncHUtYnVmZmVyXCIpJiYocD1pLl9PcnRDcmVhdGVCaW5kaW5nKHUpLHA9PT0wJiZCZShcIkNhblxcJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpLFQ9e2hhbmRsZTpwLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczp4LG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6eC5tYXAoQz0+Y28oQykpfSksSHIuc2V0KHUsW3UsaCxkLFRdKSxbdSxfLHZdfWNhdGNoKHkpe3Rocm93IGguZm9yRWFjaCh3PT5pLl9PcnRGcmVlKHcpKSxkLmZvckVhY2godz0+aS5fT3J0RnJlZSh3KSkscCE9PTAmJmkuX09ydFJlbGVhc2VCaW5kaW5nKHApLHUhPT0wJiZpLl9PcnRSZWxlYXNlU2Vzc2lvbih1KSx5fWZpbmFsbHl7aS5fZnJlZShyKSxhIT09MCYmaS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGEpLG0uZm9yRWFjaCh5PT5pLl9mcmVlKHkpKSxpLnVubW91bnRFeHRlcm5hbERhdGE/LigpfX0sX2w9ZT0+e2xldCB0PVVlKCkscj1Ici5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbbyxpLHUsYV09cjthJiZ0Ll9PcnRSZWxlYXNlQmluZGluZyhhLmhhbmRsZSksdC5qc2VwVW5yZWdpc3RlckJ1ZmZlcnM/LihlKSxpLmZvckVhY2gocD0+dC5fT3J0RnJlZShwKSksdS5mb3JFYWNoKHA9PnQuX09ydEZyZWUocCkpLHQuX09ydFJlbGVhc2VTZXNzaW9uKG8pLEhyLmRlbGV0ZShlKX0sYmw9KGUsdCxyLG8saSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgdT1VZSgpLGE9ZVswXSxwPWVbMV0sbT1lWzNdLGgsZDtpZihhPT09XCJzdHJpbmdcIiYmbT09PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2lmKG09PT1cImdwdS1idWZmZXJcIil7bGV0IF89ZVsyXS5ncHVCdWZmZXIsdj1NcihsbyhhKSk7ZD1wLnJlZHVjZSgoeCxUKT0+eCpULDEpKnYsaD11LmpzZXBSZWdpc3RlckJ1ZmZlcihvLGksXyxkKX1lbHNle2xldCBfPWVbMl07aWYoQXJyYXkuaXNBcnJheShfKSl7ZD00Kl8ubGVuZ3RoLGg9dS5fbWFsbG9jKGQpLHIucHVzaChoKTtsZXQgdj1oLzQ7Zm9yKGxldCB4PTA7eDxfLmxlbmd0aDt4Kyspe2lmKHR5cGVvZiBfW3hdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7eH0gaXMgbm90IGEgc3RyaW5nYCk7dS5IRUFQVTMyW3YrK109V2UoX1t4XSxyKX19ZWxzZSBkPV8uYnl0ZUxlbmd0aCxoPXUuX21hbGxvYyhkKSxyLnB1c2goaCksdS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KF8uYnVmZmVyLF8uYnl0ZU9mZnNldCxkKSxoKX1sZXQgeT11LnN0YWNrU2F2ZSgpLHc9dS5zdGFja0FsbG9jKDQqcC5sZW5ndGgpO3RyeXtsZXQgXz13LzQ7cC5mb3JFYWNoKHg9PnUuSEVBUDMyW18rK109eCk7bGV0IHY9dS5fT3J0Q3JlYXRlVGVuc29yKGxvKGEpLGgsZCx3LHAubGVuZ3RoLGNvKG0pKTt2PT09MCYmQmUoYENhblxcJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7b30sIGluZGV4PSR7aX0uYCksdC5wdXNoKHYpfWZpbmFsbHl7dS5zdGFja1Jlc3RvcmUoeSl9fSxTbD1hc3luYyhlLHQscixvLGksdSk9PntsZXQgYT1VZSgpLHA9SHIuZ2V0KGUpO2lmKCFwKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFttLGgsZCx5XT1wLHc9dC5sZW5ndGgsXz1vLmxlbmd0aCx2PTAseD1bXSxUPVtdLEM9W10sUz1bXSxFPWEuc3RhY2tTYXZlKCksTz1hLnN0YWNrQWxsb2Modyo0KSxVPWEuc3RhY2tBbGxvYyh3KjQpLE09YS5zdGFja0FsbG9jKF8qNCksTj1hLnN0YWNrQWxsb2MoXyo0KTt0cnl7W3YseF09a2kodSk7Zm9yKGxldCBlZT0wO2VlPHc7ZWUrKylibChyW2VlXSxULFMsZSx0W2VlXSk7Zm9yKGxldCBlZT0wO2VlPF87ZWUrKylibChpW2VlXSxDLFMsZSx3K29bZWVdKTtsZXQgWT1PLzQsc2U9VS80LEI9TS80LHRlPU4vNDtmb3IobGV0IGVlPTA7ZWU8dztlZSsrKWEuSEVBUFUzMltZKytdPVRbZWVdLGEuSEVBUFUzMltzZSsrXT1oW3RbZWVdXTtmb3IobGV0IGVlPTA7ZWU8XztlZSsrKWEuSEVBUFUzMltCKytdPUNbZWVdLGEuSEVBUFUzMlt0ZSsrXT1kW29bZWVdXTtpZih5KXtsZXR7aGFuZGxlOmVlLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpiZSxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOk1lfT15O2lmKGgubGVuZ3RoIT09dyl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7d30pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbFxcJ3MgaW5wdXQgY291bnQgKCR7aC5sZW5ndGh9KS5gKTtmb3IobGV0IHBlPTA7cGU8dztwZSsrKXtsZXQgeWU9dFtwZV07YXdhaXQgYS5fT3J0QmluZElucHV0KGVlLGhbeWVdLFRbcGVdKSE9PTAmJkJlKGBDYW5cXCd0IGJpbmQgaW5wdXRbJHtwZX1dIGZvciBzZXNzaW9uPSR7ZX0uYCl9Zm9yKGxldCBwZT0wO3BlPF87cGUrKyl7bGV0IHllPW9bcGVdO2lbcGVdPy5bM10/YS5fT3J0QmluZE91dHB1dChlZSxkW3llXSxDW3BlXSwwKSE9PTAmJkJlKGBDYW5cXCd0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtwZX1dIGZvciBzZXNzaW9uPSR7ZX0uYCk6YS5fT3J0QmluZE91dHB1dChlZSxkW3llXSwwLE1lW3llXSkhPT0wJiZCZShgQ2FuXFwndCBiaW5kIG91dHB1dFske3BlfV0gdG8gJHtiZVtwZV19IGZvciBzZXNzaW9uPSR7ZX0uYCl9fWEuanNlcE9uUnVuU3RhcnQ/LigpO2xldCBQZTt5P1BlPWF3YWl0IGEuX09ydFJ1bldpdGhCaW5kaW5nKG0seS5oYW5kbGUsXyxNLHYpOlBlPWF3YWl0IGEuX09ydFJ1bihtLFUsTyx3LE4sXyxNLHYpLFBlIT09MCYmQmUoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IEVlPVtdO2ZvcihsZXQgZWU9MDtlZTxfO2VlKyspe2xldCBiZT1hLkhFQVBVMzJbTS80K2VlXTtpZihiZT09PUNbZWVdKXtFZS5wdXNoKGlbZWVdKTtjb250aW51ZX1sZXQgTWU9YS5zdGFja1NhdmUoKSxwZT1hLnN0YWNrQWxsb2MoNCo0KSx5ZT0hMSxkZSx3ZT0wO3RyeXthLl9PcnRHZXRUZW5zb3JEYXRhKGJlLHBlLHBlKzQscGUrOCxwZSsxMikhPT0wJiZCZShgQ2FuXFwndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7ZWV9LmApO2xldCBSZT1wZS80LEdlPWEuSEVBUFUzMltSZSsrXTt3ZT1hLkhFQVBVMzJbUmUrK107bGV0IEY9YS5IRUFQVTMyW1JlKytdLGllPWEuSEVBUFUzMltSZSsrXSxoZT1bXTtmb3IobGV0IGtlPTA7a2U8aWU7a2UrKyloZS5wdXNoKGEuSEVBUFUzMltGLzQra2VdKTthLl9PcnRGcmVlKEYpO2xldCBYZT1oZS5yZWR1Y2UoKGtlLExlKT0+a2UqTGUsMSk7ZGU9c3QoR2UpO2xldCBudD15Py5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbb1tlZV1dO2lmKGRlPT09XCJzdHJpbmdcIil7aWYobnQ9PT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtsZXQga2U9W10sTGU9d2UvNDtmb3IobGV0IEl0PTA7SXQ8WGU7SXQrKyl7bGV0IFR0PWEuSEVBUFUzMltMZSsrXSxWdD1JdD09PVhlLTE/dm9pZCAwOmEuSEVBUFUzMltMZV0tVHQ7a2UucHVzaChhLlVURjhUb1N0cmluZyhUdCxWdCkpfUVlLnB1c2goW2RlLGhlLGtlLFwiY3B1XCJdKX1lbHNlIGlmKG50PT09XCJncHUtYnVmZmVyXCImJlhlPjApe2xldCBrZT1hLmpzZXBHZXRCdWZmZXIod2UpLExlPU1yKEdlKTtpZihMZT09PXZvaWQgMHx8IUJpKGRlKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkZX1gKTt5ZT0hMCxFZS5wdXNoKFtkZSxoZSx7Z3B1QnVmZmVyOmtlLGRvd25sb2FkOmEuanNlcENyZWF0ZURvd25sb2FkZXIoa2UsWGUqTGUsZGUpLGRpc3Bvc2U6KCk9PnthLl9PcnRSZWxlYXNlVGVuc29yKGJlKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZXtsZXQga2U9eW4oZGUpLExlPW5ldyBrZShYZSk7bmV3IFVpbnQ4QXJyYXkoTGUuYnVmZmVyLExlLmJ5dGVPZmZzZXQsTGUuYnl0ZUxlbmd0aCkuc2V0KGEuSEVBUFU4LnN1YmFycmF5KHdlLHdlK0xlLmJ5dGVMZW5ndGgpKSxFZS5wdXNoKFtkZSxoZSxMZSxcImNwdVwiXSl9fWZpbmFsbHl7YS5zdGFja1Jlc3RvcmUoTWUpLGRlPT09XCJzdHJpbmdcIiYmd2UmJmEuX2ZyZWUod2UpLHllfHxhLl9PcnRSZWxlYXNlVGVuc29yKGJlKX19cmV0dXJuIHkmJmEuX09ydENsZWFyQm91bmRPdXRwdXRzKHkuaGFuZGxlKSxFZX1maW5hbGx5e2Euc3RhY2tSZXN0b3JlKEUpLFQuZm9yRWFjaChZPT5hLl9PcnRSZWxlYXNlVGVuc29yKFkpKSxDLmZvckVhY2goWT0+YS5fT3J0UmVsZWFzZVRlbnNvcihZKSksUy5mb3JFYWNoKFk9PmEuX2ZyZWUoWSkpLHYhPT0wJiZhLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyh2KSx4LmZvckVhY2goWT0+YS5fZnJlZShZKSl9fSx4bD1lPT57bGV0IHQ9VWUoKSxyPUhyLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7bGV0IG89clswXSxpPXQuX09ydEVuZFByb2ZpbGluZyhvKTtpPT09MCYmQmUoXCJDYW5cXCd0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksdC5fT3J0RnJlZShpKX0sQ2w9ZT0+e2xldCB0PVtdO2ZvcihsZXQgciBvZiBlKXtsZXQgbz1yWzJdOyFBcnJheS5pc0FycmF5KG8pJiZcImJ1ZmZlclwiaW4gbyYmdC5wdXNoKG8uYnVmZmVyKX1yZXR1cm4gdH07c2VsZi5vbm1lc3NhZ2U9ZT0+e2xldHt0eXBlOnQsaW46cn09ZS5kYXRhO3RyeXtzd2l0Y2godCl7Y2FzZVwiaW5pdC13YXNtXCI6T2koci53YXNtKS50aGVuKCgpPT57d2wocikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0sbz0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm99KX0pfSxvPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6b30pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOm8sZW52Oml9PXI7dmwoaSxvKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dH0pfSx1PT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6dX0pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6b309cixpPVdvKG8pO3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Oml9KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOm8sb3B0aW9uczppfT1yOyRsKG8saSkudGhlbih1PT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6dX0pfSx1PT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6dX0pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOl9sKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpvLGlucHV0SW5kaWNlczppLGlucHV0czp1LG91dHB1dEluZGljZXM6YSxvcHRpb25zOnB9PXI7U2wobyxpLHUsYSxuZXcgQXJyYXkoYS5sZW5ndGgpLmZpbGwobnVsbCkscCkudGhlbihtPT57bS5zb21lKGg9PmhbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDptfSxDbChtKSl9LG09Pntwb3N0TWVzc2FnZSh7dHlwZTp0LGVycjptfSl9KTticmVha31jYXNlXCJlbmQtcHJvZmlsaW5nXCI6eGwocikscG9zdE1lc3NhZ2Uoe3R5cGU6dH0pO2JyZWFrO2RlZmF1bHQ6fX1jYXRjaChvKXtwb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpvfSl9fTt9KSgpO1xcbi8qKlxcbiAqIEBsaWNlbnNlXFxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXG4gKlxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcbiAqXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gKi9cXG4vKipcXG4gKiBAbGljZW5zZVxcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXFxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XFxuICpcXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcXG4gKlxcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICovXFxuLyoqXFxuICogQGxpY2Vuc2VcXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XFxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxcbiAqXFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxuICpcXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXFxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAqL1xcbid9KTt2YXIgc3IsdnQscm4sbGEsZGEsZmksbWksX3IsU3IsQmYsdWEsZ2QseWQsYmQsdmQsd2QsJGQsX2QsaGk9USgoKT0+e1widXNlIHN0cmljdFwiO2J0KCk7bWQoKTt2cigpO3NyPSgpPT4hIUFlLndhc20ucHJveHkmJnR5cGVvZiBkb2N1bWVudDxcInVcIixybj0hMSxsYT0hMSxkYT0hMSxtaT1uZXcgTWFwLF9yPShlLHQpPT57bGV0IHI9bWkuZ2V0KGUpO3I/ci5wdXNoKHQpOm1pLnNldChlLFt0XSl9LFNyPSgpPT57aWYocm58fCFsYXx8ZGF8fCF2dCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxCZj1lPT57c3dpdGNoKGUuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjpybj0hMSxlLmRhdGEuZXJyPyhkYT0hMCxmaVsxXShlLmRhdGEuZXJyKSk6KGxhPSEwLGZpWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtZXBcIjpjYXNlXCJjb3B5LWZyb21cIjpjYXNlXCJjcmVhdGVcIjpjYXNlXCJyZWxlYXNlXCI6Y2FzZVwicnVuXCI6Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOntsZXQgdD1taS5nZXQoZS5kYXRhLnR5cGUpO2UuZGF0YS5lcnI/dC5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnQuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVha31kZWZhdWx0On19LHVhPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjOnZvaWQgMCxnZD1hc3luYygpPT57aWYoIWxhKXtpZihybil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGRhKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7aWYocm49ITAsc3IoKSlyZXR1cm4gQWUud2FzbS53YXNtUGF0aHM9PT12b2lkIDAmJnVhJiZ1YS5pbmRleE9mKFwiYmxvYjpcIikhPT0wJiYoQWUud2FzbS53YXNtUGF0aHM9dWEuc3Vic3RyKDAsK3VhLmxhc3RJbmRleE9mKFwiL1wiKSsxKSksbmV3IFByb21pc2UoKGUsdCk9Pnt2dD8udGVybWluYXRlKCk7bGV0IHI9VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbaGQoKV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTt2dD1uZXcgV29ya2VyKHIse25hbWU6XCJvcnQtd2FzbS1wcm94eS13b3JrZXJcIn0pLHZ0Lm9uZXJyb3I9aT0+dChpKSx2dC5vbm1lc3NhZ2U9QmYsVVJMLnJldm9rZU9iamVjdFVSTChyKSxmaT1bZSx0XTtsZXQgYT17dHlwZTpcImluaXQtd2FzbVwiLGluOkFlfTt2dC5wb3N0TWVzc2FnZShhKX0pO3RyeXthd2FpdCBNbyhBZS53YXNtKSxhd2FpdCBzZChBZSksbGE9ITB9Y2F0Y2goZSl7dGhyb3cgZGE9ITAsZX1maW5hbGx5e3JuPSExfX19LHlkPWFzeW5jIGU9PntpZihzcigpKXJldHVybiBTcigpLG5ldyBQcm9taXNlKCh0LHIpPT57X3IoXCJpbml0LWVwXCIsW3Qscl0pO2xldCBhPXt0eXBlOlwiaW5pdC1lcFwiLGluOntlcE5hbWU6ZSxlbnY6QWV9fTt2dC5wb3N0TWVzc2FnZShhKX0pO2F3YWl0IHVkKEFlLGUpfSxiZD1hc3luYyBlPT5zcigpPyhTcigpLG5ldyBQcm9taXNlKCh0LHIpPT57X3IoXCJjb3B5LWZyb21cIixbdCxyXSk7bGV0IGE9e3R5cGU6XCJjb3B5LWZyb21cIixpbjp7YnVmZmVyOmV9fTt2dC5wb3N0TWVzc2FnZShhLFtlLmJ1ZmZlcl0pfSkpOnBpKGUpLHZkPWFzeW5jKGUsdCk9PntpZihzcigpKXtpZih0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbil0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gb3B0aW9uIFwicHJlZmVycmVkT3V0cHV0TG9jYXRpb25cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtyZXR1cm4gU3IoKSxuZXcgUHJvbWlzZSgocixhKT0+e19yKFwiY3JlYXRlXCIsW3IsYV0pO2xldCBpPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOmUsb3B0aW9uczp0fX0scz1bXTtlIGluc3RhbmNlb2YgVWludDhBcnJheSYmcy5wdXNoKGUuYnVmZmVyKSx2dC5wb3N0TWVzc2FnZShpLHMpfSl9ZWxzZSByZXR1cm4gbGQoZSx0KX0sd2Q9YXN5bmMgZT0+e2lmKHNyKCkpcmV0dXJuIFNyKCksbmV3IFByb21pc2UoKHQscik9PntfcihcInJlbGVhc2VcIixbdCxyXSk7bGV0IGE9e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07dnQucG9zdE1lc3NhZ2UoYSl9KTtkZChlKX0sJGQ9YXN5bmMoZSx0LHIsYSxpLHMpPT57aWYoc3IoKSl7aWYoci5zb21lKG89Pm9bM10hPT1cImNwdVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtpZihpLnNvbWUobz0+bykpdGhyb3cgbmV3IEVycm9yKFwicHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtyZXR1cm4gU3IoKSxuZXcgUHJvbWlzZSgobyxjKT0+e19yKFwicnVuXCIsW28sY10pO2xldCBwPXIsbT17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6cCxvdXRwdXRJbmRpY2VzOmEsb3B0aW9uczpzfX07dnQucG9zdE1lc3NhZ2UobSxmZChwKSl9KX1lbHNlIHJldHVybiBjZChlLHQscixhLGkscyl9LF9kPWFzeW5jIGU9PntpZihzcigpKXJldHVybiBTcigpLG5ldyBQcm9taXNlKCh0LHIpPT57X3IoXCJlbmQtcHJvZmlsaW5nXCIsW3Qscl0pO2xldCBhPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O3Z0LnBvc3RNZXNzYWdlKGEpfSk7cGQoZSl9fSk7dmFyIFNkLE1mLGNhLHhkPVEoKCk9PntcInVzZSBzdHJpY3RcIjtidCgpO2hpKCk7emUoKTtOYSgpO1NkPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybltlLnR5cGUsZS5kaW1zLGUuZGF0YSxcImNwdVwiXTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse2dwdUJ1ZmZlcjplLmdwdUJ1ZmZlcn0sXCJncHUtYnVmZmVyXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0sTWY9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IFplKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIU5uKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6cixkb3dubG9hZDphLGRpc3Bvc2U6aX09ZVsyXTtyZXR1cm4gWmUuZnJvbUdwdUJ1ZmZlcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDphLGRpc3Bvc2U6aX0pfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZVszXX1gKX19LGNhPWNsYXNze2FzeW5jIGZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpe3JldHVybiBiZChhd2FpdCBacih0KSl9YXN5bmMgbG9hZE1vZGVsKHQscil7ZHQoKTtsZXQgYTt0eXBlb2YgdD09XCJzdHJpbmdcIj90eXBlb2YgcHJvY2VzczxcInVcIiYmcHJvY2Vzcy52ZXJzaW9ucyYmcHJvY2Vzcy52ZXJzaW9ucy5ub2RlP2E9YXdhaXQgWnIodCk6YT1hd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpOmE9dCxbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0IHZkKGEsciksY3QoKX1hc3luYyBkaXNwb3NlKCl7cmV0dXJuIHdkKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxyLGEpe2R0KCk7bGV0IGk9W10scz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKGI9PntsZXQgdz1iWzBdLCQ9YlsxXSx4PXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKHcpO2lmKHg9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7d30nYCk7aS5wdXNoKCQpLHMucHVzaCh4KX0pO2xldCBvPVtdLGM9W107T2JqZWN0LmVudHJpZXMocikuZm9yRWFjaChiPT57bGV0IHc9YlswXSwkPWJbMV0seD10aGlzLm91dHB1dE5hbWVzLmluZGV4T2Yodyk7aWYoeD09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7d30nYCk7by5wdXNoKCQpLGMucHVzaCh4KX0pO2xldCBwPWkubWFwKChiLHcpPT5TZChiLCgpPT5gaW5wdXQgXCIke3RoaXMuaW5wdXROYW1lc1tzW3ddXX1cImApKSxtPW8ubWFwKChiLHcpPT5iP1NkKGIsKCk9PmBvdXRwdXQgXCIke3RoaXMub3V0cHV0TmFtZXNbY1t3XV19XCJgKTpudWxsKSxsPWF3YWl0ICRkKHRoaXMuc2Vzc2lvbklkLHMscCxjLG0sYSksZz17fTtmb3IobGV0IGI9MDtiPGwubGVuZ3RoO2IrKylnW3RoaXMub3V0cHV0TmFtZXNbY1tiXV1dPW9bYl0/P01mKGxbYl0pO3JldHVybiBjdCgpLGd9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7X2QodGhpcy5zZXNzaW9uSWQpfX19KTt2YXIgRGYscGEsQ2Q9USgoKT0+e1widXNlIHN0cmljdFwiO2J0KCk7aGkoKTt4ZCgpO0RmPSgpPT57aWYoKHR5cGVvZiBBZS53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHxBZS53YXNtLmluaXRUaW1lb3V0PDApJiYoQWUud2FzbS5pbml0VGltZW91dD0wKSx0eXBlb2YgQWUud2FzbS5zaW1kIT1cImJvb2xlYW5cIiYmKEFlLndhc20uc2ltZD0hMCksdHlwZW9mIEFlLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYoQWUud2FzbS5wcm94eT0hMSksdHlwZW9mIEFlLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYoQWUud2FzbS50cmFjZT0hMSksdHlwZW9mIEFlLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoQWUud2FzbS5udW1UaHJlYWRzKXx8QWUud2FzbS5udW1UaHJlYWRzPD0wKXsodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWR8fHR5cGVvZiBwcm9jZXNzPFwidVwiJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGUpJiYoQWUud2FzbS5udW1UaHJlYWRzPTEpO2xldCBlPXR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCI/KHZvaWQgMCkoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7QWUud2FzbS5udW1UaHJlYWRzPU1hdGgubWluKDQsTWF0aC5jZWlsKChlfHwxKS8yKSl9fSxwYT1jbGFzc3thc3luYyBpbml0KHQpe0RmKCksYXdhaXQgZ2QoKSxhd2FpdCB5ZCh0KX1hc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih0LHIpe2xldCBhPW5ldyBjYTtyZXR1cm4gYXdhaXQgYS5sb2FkTW9kZWwodCxyKSxQcm9taXNlLnJlc29sdmUoYSl9fX0pO3ZhciBJZD17fTtucihJZCx7d2FzbUJhY2tlbmQ6KCk9PnpmfSk7dmFyIHpmLEFkPVEoKCk9PntcInVzZSBzdHJpY3RcIjtDZCgpO3pmPW5ldyBwYX0pO3ZhciBXZj17fTtucihXZix7SW5mZXJlbmNlU2Vzc2lvbjooKT0+bW8sVFJBQ0U6KCk9PnFyLFRSQUNFX0ZVTkNfQkVHSU46KCk9PmR0LFRSQUNFX0ZVTkNfRU5EOigpPT5jdCxUZW5zb3I6KCk9PlplLFRyYWluaW5nU2Vzc2lvbjooKT0+Ym8sZGVmYXVsdDooKT0+VWYsZW52OigpPT5BZSxyZWdpc3RlckJhY2tlbmQ6KCk9PkZ0fSk7bW9kdWxlLmV4cG9ydHM9R3QoV2YpO2J0KCk7YnQoKTtidCgpO3ZhciB3bz1cIjEuMTguMC1kZXYuMjAyNDAxMzAtOWY2OGEyN2M3YVwiO3ZhciBVZj1FYTt7bGV0IGU9KEFkKCksR3QoSWQpKS53YXNtQmFja2VuZDtGdChcIndlYmdwdVwiLGUsNSksRnQoXCJ3ZWJublwiLGUsNSksRnQoXCJjcHVcIixlLDEwKSxGdChcIndhc21cIixlLDEwKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQWUudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6d28sZW51bWVyYWJsZTohMH0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3J0LndlYmdwdS5taW4uanMubWFwXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vXG4vLyBBbiBleGFtcGxlIGhvdyB0byBydW4gc2VnbWVudC1hbnl0aGluZyB3aXRoIHdlYmdwdSBpbiBvbm54cnVudGltZS13ZWIuXG4vL1xuXG5jb25zdCBvcnQgPSByZXF1aXJlKCdvbm54cnVudGltZS13ZWIvd2ViZ3B1Jyk7XG5cbmNvbnN0IE1BWF9XSURUSCA9IDUwMDtcbmNvbnN0IE1BWF9IRUlHSFQgPSA1MDA7XG5jb25zdCBNT0RFTF9XSURUSCA9IDEwMjQ7XG5jb25zdCBNT0RFTF9IRUlHSFQgPSAxMDI0O1xuXG5jb25zdCBNT0RFTF9NQVAgPSB7XG4gICAgc2FtX2I6IFtcbiAgICAgICAgXCJodHRwczovL2h1Z2dpbmdmYWNlLmNvL3NjaG11ZWxsL3NhbS1iLWZwMTYvcmVzb2x2ZS9tYWluL3NhbV92aXRfYl8wMWVjNjQuZW5jb2Rlci1mcDE2Lm9ubnhcIixcbiAgICAgICAgXCJodHRwczovL2h1Z2dpbmdmYWNlLmNvL3NjaG11ZWxsL3NhbS1iLWZwMTYvcmVzb2x2ZS9tYWluL3NhbV92aXRfYl8wMWVjNjQuZGVjb2Rlci5vbm54XCJcbiAgICBdLFxuICAgIHNhbV9iX2xvY2FsOiBbXCJtb2RlbHMvc2FtX3ZpdF9iXzAxZWM2NC5lbmNvZGVyLWZwMTYub25ueFwiLCBcIm1vZGVscy9zYW1fdml0X2JfMDFlYzY0LmRlY29kZXIub25ueFwiXSxcbn07XG5cbmNvbnN0IGNvbmZpZyA9IGdldENvbmZpZygpO1xuXG5vcnQuZW52Lndhc20ubnVtVGhyZWFkcyA9IGNvbmZpZy50aHJlYWRzO1xub3J0LmVudi53YXNtLnByb3h5ID0gdHJ1ZTtcblxubGV0IGNhbnZhcztcbmxldCBmaWxlaW47XG5sZXQgZGVjb2Rlcl9sYXRlbmN5O1xuXG52YXIgaW1hZ2VfZW1iZWRkaW5ncztcbnZhciBzZXNzID0gW107XG52YXIgcG9pbnRzID0gW107XG52YXIgbGFiZWxzID0gW107XG52YXIgaW1hZ2VJbWFnZURhdGE7XG52YXIgaXNDbGlja2VkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGxvZyhpKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXR1cycpLmlubmVyVGV4dCArPSBgXFxuJHtpfWA7XG59XG5cbi8qKlxuICogZ2V0IHNvbWUgcGFyYW1ldGVycyBmcm9tIHVybFxuICovXG5mdW5jdGlvbiBnZXRDb25maWcoKSB7XG4gICAgY29uc3QgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBtb2RlbDogXCJzYW1fYlwiLFxuICAgICAgICBwcm92aWRlcjogXCJ3ZWJncHVcIixcbiAgICAgICAgZGV2aWNlOiBcImdwdVwiLFxuICAgICAgICB0aHJlYWRzOiBcIjFcIixcbiAgICB9O1xuICAgIGxldCB2YXJzID0gcXVlcnkuc3BsaXQoXCImXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcGFpciA9IHZhcnNbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBpZiAocGFpclswXSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZ1twYWlyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gYXJndW1lbnQ6IFwiICsgcGFpclswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uZmlnLnRocmVhZHMgPSBwYXJzZUludChjb25maWcudGhyZWFkcyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuLyoqXG4gKiBoYW5kbGVyIHRvIGhhbmRsZSBjbGljayBvbiB0aGUgaW1hZ2UgY2FudmFzXG4gKiAgd2l0aCBjdGw6IGFkZCBwb2ludFxuICogIHdpdGggc2hpZnQ6IGZvcmdyb3VuZCBsYWJlbFxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmIChpc0NsaWNrZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpc0NsaWNrZWQgPSB0cnVlO1xuICAgICAgICBjYW52YXMuc3R5bGUuY3Vyc29yID0gXCJ3YWl0XCI7XG5cbiAgICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gKGV2ZW50LnNoaWZ0S2V5KSA/IDAgOiAxO1xuXG4gICAgICAgIGlmIChpbWFnZV9lbWJlZGRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHNlc3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1iID0gYXdhaXQgaW1hZ2VfZW1iZWRkaW5ncztcblxuICAgICAgICBpZiAoIWV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGFiZWxzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKTtcblxuICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2VJbWFnZURhdGEud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZUltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VJbWFnZURhdGEsIDAsIDApO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgMTAsIDEwKTtcblxuICAgICAgICBjb25zdCBwb2ludENvb3JkcyA9IG5ldyBvcnQuVGVuc29yKG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzKSwgWzEsIHBvaW50cy5sZW5ndGggLyAyLCAyXSk7XG4gICAgICAgIGNvbnN0IHBvaW50TGFiZWxzID0gbmV3IG9ydC5UZW5zb3IobmV3IEZsb2F0MzJBcnJheShsYWJlbHMpLCBbMSwgbGFiZWxzLmxlbmd0aF0pO1xuICAgICAgICBjb25zdCBtYXNrSW5wdXQgPSBuZXcgb3J0LlRlbnNvcihuZXcgRmxvYXQzMkFycmF5KDI1NiAqIDI1NiksIFsxLCAxLCAyNTYsIDI1Nl0pO1xuICAgICAgICBjb25zdCBoYXNNYXNrID0gbmV3IG9ydC5UZW5zb3IobmV3IEZsb2F0MzJBcnJheShbMF0pLCBbMSxdKTtcbiAgICAgICAgY29uc3Qgb3JpZ2lhbmxJbWFnZVNpemUgPSBuZXcgb3J0LlRlbnNvcihuZXcgRmxvYXQzMkFycmF5KFtNT0RFTF9IRUlHSFQsIE1PREVMX1dJRFRIXSksIFsyLF0pO1xuXG4gICAgICAgIGNvbnN0IHMgPSBhd2FpdCBzZXNzWzFdO1xuICAgICAgICBjb25zdCB0ID0gbmV3IG9ydC5UZW5zb3IoZW1iLmltYWdlX2VtYmVkZGluZ3MudHlwZSwgRmxvYXQzMkFycmF5LmZyb20oZW1iLmltYWdlX2VtYmVkZGluZ3MuZGF0YSksIGVtYi5pbWFnZV9lbWJlZGRpbmdzLmRpbXMpO1xuICAgICAgICBjb25zdCBmZWVkID0ge1xuICAgICAgICAgICAgXCJpbWFnZV9lbWJlZGRpbmdzXCI6IHQsXG4gICAgICAgICAgICBcInBvaW50X2Nvb3Jkc1wiOiBwb2ludENvb3JkcyxcbiAgICAgICAgICAgIFwicG9pbnRfbGFiZWxzXCI6IHBvaW50TGFiZWxzLFxuICAgICAgICAgICAgXCJtYXNrX2lucHV0XCI6IG1hc2tJbnB1dCxcbiAgICAgICAgICAgIFwiaGFzX21hc2tfaW5wdXRcIjogaGFzTWFzayxcbiAgICAgICAgICAgIFwib3JpZ19pbV9zaXplXCI6IG9yaWdpYW5sSW1hZ2VTaXplXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgcy5ydW4oZmVlZCk7XG4gICAgICAgIGRlY29kZXJfbGF0ZW5jeS5pbm5lclRleHQgPSBgJHsocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkudG9GaXhlZCgxKX1tc2A7XG4gICAgICAgIGNvbnN0IG1hc2sgPSByZXMubWFza3M7XG4gICAgICAgIGNvbnN0IG1hc2tJbWFnZURhdGEgPSBtYXNrLnRvSW1hZ2VEYXRhKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMztcbiAgICAgICAgY3R4LmRyYXdJbWFnZShhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChtYXNrSW1hZ2VEYXRhKSwgMCwgMCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjYW52YXMuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgICAgIGlzQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIGhhbmRsZXIgY2FsbGVkIHdoZW4gaW1hZ2UgYXZhaWxhYmxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUltYWdlKGltZykge1xuICAgIGNvbnN0IGVuY29kZXJfbGF0ZW5jeSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZW5jb2Rlcl9sYXRlbmN5XCIpO1xuICAgIGVuY29kZXJfbGF0ZW5jeS5pbm5lclRleHQgPSBcIlwiO1xuICAgIGZpbGVpbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgZGVjb2Rlcl9sYXRlbmN5LmlubmVyVGV4dCA9IFwiXCI7XG4gICAgY2FudmFzLnN0eWxlLmN1cnNvciA9IFwid2FpdFwiO1xuICAgIGltYWdlX2VtYmVkZGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHdpZHRoID0gaW1nLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG4gICAgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCA+IE1BWF9XSURUSCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogKE1BWF9XSURUSCAvIHdpZHRoKTtcbiAgICAgICAgICAgIHdpZHRoID0gTUFYX1dJRFRIO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhlaWdodCA+IE1BWF9IRUlHSFQpIHtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggKiAoTUFYX0hFSUdIVCAvIGhlaWdodCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBNQVhfSEVJR0hUO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpbWFnZUltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBjb25zdCB0ID0gYXdhaXQgb3J0LlRlbnNvci5mcm9tSW1hZ2UoaW1hZ2VJbWFnZURhdGEsIG9wdGlvbnMgPSB7IHJlc2l6ZWRXaWR0aDogTU9ERUxfV0lEVEgsIHJlc2l6ZWRIZWlnaHQ6IE1PREVMX0hFSUdIVCB9KTtcbiAgICBjb25zdCBmZWVkID0geyBcImlucHV0X2ltYWdlXCI6IHQgfTtcbiAgICBjb25zdCBzID0gYXdhaXQgc2Vzc1swXTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaW1hZ2VfZW1iZWRkaW5ncyA9IHMucnVuKGZlZWQpO1xuICAgIGltYWdlX2VtYmVkZGluZ3MudGhlbigoKSA9PiB7XG4gICAgICAgIGVuY29kZXJfbGF0ZW5jeS5pbm5lclRleHQgPSBgJHsocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkudG9GaXhlZCgxKX1tc2A7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgICB9KTtcbiAgICBmaWxlaW4uZGlzYWJsZWQgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIGZldGNoIGFuZCBjYWNoZSB1cmxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRDYWNoZSh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKFwib25ueFwiKTtcbiAgICAgICAgaWYgKGNvbmZpZy5jbGVhcl9jYWNoZSkge1xuICAgICAgICAgICAgY2FjaGUuZGVsZXRlKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2godXJsKTtcbiAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgY2FjaGUuYWRkKHVybCk7XG4gICAgICAgICAgICBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhY2hlLm1hdGNoKHVybCk7XG4gICAgICAgICAgICBsb2coYCR7dXJsfSAoZnJvbSBuZXR3b3JrKWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nKGAke3VybH0gKGZyb20gY2FjaGUpYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNhY2hlZFJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZyhgJHt1cmx9IChmcm9tIG5ldHdvcmspYCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwpLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgfVxufVxuXG4vKlxuICogbG9hZCBlbmNvZGVyIGFuZCBkZWNvZGVyIHNlcXVlbnRpYWxseVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkX21vZGVsKG1vZGVsLCBpZHgsIGltZykge1xuICAgIGxldCBwcm92aWRlciA9IGNvbmZpZy5wcm92aWRlcjtcblxuICAgIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSBcIndlYm5uXCI6XG4gICAgICAgICAgICBpZiAoIShcIm1sXCIgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIndlYm5uIGlzIE5PVCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIndlYm5uXCIsXG4gICAgICAgICAgICAgICAgZGV2aWNlVHlwZTogY29uZmlnLmRldmljZSxcbiAgICAgICAgICAgICAgICBwb3dlclByZWZlcmVuY2U6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2ViZ3B1XCI6XG4gICAgICAgICAgICBpZiAoIW5hdmlnYXRvci5ncHUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJncHUgaXMgTk9UIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdCA9IHsgZXhlY3V0aW9uUHJvdmlkZXJzOiBbcHJvdmlkZXJdIH07XG5cbiAgICBmZXRjaEFuZENhY2hlKG1vZGVsW2lkeF0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgc2Vzc1tpZHhdID0gb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKGRhdGEsIG9wdCk7XG4gICAgICAgIHNlc3NbaWR4XS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxvZyhgJHttb2RlbFtpZHhdfSBsb2FkZWQuYCk7XG4gICAgICAgICAgICBpZiAoaWR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBsb2FkX21vZGVsKG1vZGVsLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIGxvZyhgJHttb2RlbFtpZHhdfSBmYWlsZWQgd2l0aCAke2V9LmApO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFuZGxlSW1hZ2UoaW1nKTtcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgY29uc3QgbW9kZWwgPSBNT0RFTF9NQVBbY29uZmlnLm1vZGVsXTtcblxuICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW1nX2NhbnZhc1wiKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcbiAgICBjYW52YXMuc3R5bGUuY3Vyc29yID0gXCJ3YWl0XCI7XG5cbiAgICBmaWxlaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGUtaW5cIik7XG4gICAgZGVjb2Rlcl9sYXRlbmN5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWNvZGVyX2xhdGVuY3lcIik7XG5cbiAgICBsZXQgaW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcmlnaW5hbC1pbWFnZVwiKTtcblxuICAgIGxvYWRfbW9kZWwobW9kZWwsIDAsIGltZykudGhlbigoKSA9PiB7fSwgKGUpID0+IHtcbiAgICAgICAgbG9nKGUpO1xuICAgIH0pO1xuXG4gICAgLy8gaW1hZ2UgdXBsb2FkXG4gICAgZmlsZWluLm9uY2hhbmdlID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZXZ0LnRhcmdldCB8fCB3aW5kb3cuZXZlbnQuc3JjLCBmaWxlcyA9IHRhcmdldC5maWxlcztcbiAgICAgICAgaWYgKEZpbGVSZWFkZXIgJiYgZmlsZXMgJiYgZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gaGFuZGxlSW1hZ2UoaW1nKTtcbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZXNbMF0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4geyBtYWluKCk7IH0pO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImEiLCJpIiwic2VsZiIsIkVuIiwiYXIiLCJGdCIsIk9uIiwiamkiLCJZaSIsImlyIiwiQWUiLCJYaSIsIlFpIiwiQWEiLCJlbyIsInRvIiwicm8iLCJubyIsIkZyIiwiUm4iLCJpbyIsIm9vIiwidW8iLCJsbyIsImF0IiwiWmUiLCJxciIsInBvIiwiZHQiLCJjdCIsIk1uIiwibW8iLCJEbiIsImJvIiwiQ2EiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIkJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiTWQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiRGQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIlEiLCJlIiwidCIsImJyIiwibnIiLCJyIiwiZ2V0IiwiZW51bWVyYWJsZSIsIkd0IiwiY2FsbCIsInpkIiwidmFsdWUiLCJrbiIsIk1hcCIsImluaXQiLCJjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciIsIlR5cGVFcnJvciIsInNldCIsImJhY2tlbmQiLCJwcmlvcml0eSIsIkVycm9yIiwiaW5kZXhPZiIsInNwbGljZSIsInMiLCJsZW5ndGgiLCJwdXNoIiwiYXN5bmMiLCJpbml0aWFsaXplZCIsImFib3J0ZWQiLCJpbml0UHJvbWlzZSIsIm8iLCJuYW1lIiwiZXJyIiwibWFwIiwiam9pbiIsInFpIiwiS2kiLCJJYSIsIndhc20iLCJ3ZWJnbCIsIndlYmdwdSIsInZlcnNpb25zIiwiY29tbW9uIiwibG9nTGV2ZWwiLCJaaSIsIkppIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiT2Zmc2NyZWVuQ2FudmFzIiwid2lkdGgiLCJkaW1zIiwiaGVpZ2h0IiwiZ2V0Q29udGV4dCIsInRlbnNvckxheW91dCIsInAiLCJtIiwiZm9ybWF0IiwiYyIsIm5vcm0iLCJtZWFuIiwiYmlhcyIsImwiLCJnIiwiYiIsInciLCIkIiwieCIsIlQiLCJDIiwiZGF0YSIsIlMiLCJFIiwiTyIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwidG9EYXRhVVJMIiwiY3JlYXRlSW1hZ2VEYXRhIiwiVSIsImFvIiwiUG4iLCJ0ZW5zb3JGb3JtYXQiLCJGbG9hdDMyQXJyYXkiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSW1hZ2VEYXRhIiwiSW1hZ2VCaXRtYXAiLCJIVE1MQ2FudmFzRWxlbWVudCIsInJlc2l6ZWRIZWlnaHQiLCJyZXNpemVkV2lkdGgiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJQcm9taXNlIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsInNyYyIsIm9ubG9hZCIsInB1dEltYWdlRGF0YSIsImRvd25sb2FkIiwiZGlzcG9zZSIsImxvY2F0aW9uIiwidHlwZSIsInRleHR1cmUiLCJkYXRhVHlwZSIsImdwdUJ1ZmZlciIsInNvIiwiVWludDhBcnJheSIsIkludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJVaW50MzJBcnJheSIsIkJpZ0ludDY0QXJyYXkiLCJmcm9tIiwiQmlnVWludDY0QXJyYXkiLCJjbyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJSYW5nZUVycm9yIiwiY29uc3RydWN0b3IiLCJ0aGlzIiwiZGF0YUxvY2F0aW9uIiwiY3B1RGF0YSIsImdwdVRleHR1cmVEYXRhIiwiZG93bmxvYWRlciIsImRpc3Bvc2VyIiwiZ3B1QnVmZmVyRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsIkJpZ0ludCIsInNpemUiLCJmcm9tSW1hZ2UiLCJmcm9tVGV4dHVyZSIsImZyb21HcHVCdWZmZXIiLCJmcm9tUGlubmVkQnVmZmVyIiwidG9JbWFnZURhdGEiLCJlbnN1cmVWYWxpZCIsImdldERhdGEiLCJpc0Rvd25sb2FkaW5nIiwicmVzaGFwZSIsIkJuIiwiVGEiLCJ0cmFjZSIsImNvbnNvbGUiLCJ0aW1lU3RhbXAiLCJzdGFjayIsInNwbGl0IiwiaW5jbHVkZXMiLCJ0cmltIiwiZm8iLCJoYW5kbGVyIiwicnVuIiwib3V0cHV0TmFtZXMiLCJpbnB1dE5hbWVzIiwicmVsZWFzZSIsImNyZWF0ZSIsIkFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiZXhlY3V0aW9uUHJvdmlkZXJzIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJobyIsImdvIiwieW8iLCJoYXNPcHRpbWl6ZXJNb2RlbCIsImhhc0V2YWxNb2RlbCIsInRyYWluaW5nSW5wdXROYW1lcyIsInRyYWluaW5nT3V0cHV0TmFtZXMiLCJldmFsSW5wdXROYW1lcyIsImV2YWxPdXRwdXROYW1lcyIsImV2YWxNb2RlbCIsIm9wdGltaXplck1vZGVsIiwiY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlciIsImNoZWNrcG9pbnRTdGF0ZSIsInRyYWluTW9kZWwiLCJ0eXBlTmFycm93aW5nRm9yUnVuU3RlcCIsImNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzIiwibGF6eVJlc2V0R3JhZCIsInJ1blRyYWluU3RlcCIsInJ1bk9wdGltaXplclN0ZXAiLCJydW5FdmFsU3RlcCIsImdldFBhcmFtZXRlcnNTaXplIiwibG9hZFBhcmFtZXRlcnNCdWZmZXIiLCJnZXRDb250aWd1b3VzUGFyYW1ldGVycyIsInZvIiwiRWEiLCJJbmZlcmVuY2VTZXNzaW9uIiwiVFJBQ0UiLCJUUkFDRV9GVU5DX0JFR0lOIiwiVFJBQ0VfRlVOQ19FTkQiLCJUZW5zb3IiLCJUcmFpbmluZ1Nlc3Npb24iLCJlbnYiLCJyZWdpc3RlckJhY2tlbmQiLCJidCIsIk9hIiwiY3JlYXRlUmVhZFN0cmVhbSIsIiRvIiwicmVhZEZpbGUiLCJXZCIsInJlYWRGaWxlU3luYyIsIk5kIiwia2EiLCJQYSIsIlZkIiwiUmEiLCJ4byIsIlNvIiwiQmEiLCJfbyIsImN1cnJlbnRTY3JpcHQiLCJfX2ZpbGVuYW1lIiwicmVhZHkiLCJ1IiwiZiIsIm1vdW50RXh0ZXJuYWxEYXRhIiwiZ2IiLCJ1bm1vdW50RXh0ZXJuYWxEYXRhIiwianNlcEluaXQiLCJ5IiwiXyIsIkEiLCJNIiwiSCIsIlgiLCJGYiIsInZiIiwieGIiLCJvYiIsIndiIiwiU2EiLCJ5YiIsInpiIiwiaiIsInEiLCJuZSIsIm1lIiwiJGUiLCJldCIsIlAiLCJvZSIsImNyIiwicmVzb2x2ZSIsInJlamVjdCIsImZiIiwiQWIiLCJlcnJvcnMiLCJmbHVzaCIsImFsbCIsImZpbHRlciIsIl9PcnRDcmVhdGVTZXNzaW9uIiwiX09ydFJ1biIsIl9PcnRSdW5XaXRoQmluZGluZyIsIl9PcnRCaW5kSW5wdXQiLCJqc2VwUmVnaXN0ZXJCdWZmZXIiLCJyZWdpc3RlckJ1ZmZlciIsImpzZXBVbnJlZ2lzdGVyQnVmZmVycyIsInVucmVnaXN0ZXJCdWZmZXJzIiwianNlcEdldEJ1ZmZlciIsImdldEJ1ZmZlciIsImpzZXBDcmVhdGVEb3dubG9hZGVyIiwiY3JlYXRlRG93bmxvYWRlciIsImpzZXBPblJ1blN0YXJ0Iiwib25SdW5TdGFydCIsImFzc2lnbiIsIndpbmRvdyIsImltcG9ydFNjcmlwdHMiLCJwcm9jZXNzIiwibm9kZSIsImRpcm5hbWUiLCJfX2Rpcm5hbWUiLCJpZSIsIlVSTCIsIm5vcm1hbGl6ZSIsImJ1ZmZlciIsInRoaXNQcm9ncmFtIiwiYXJndiIsInJlcGxhY2UiLCJzbGljZSIsImV4aXRDb2RlIiwiaW5zcGVjdCIsImhyZWYiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInN0YXR1cyIsIm9uZXJyb3IiLCJsb2ciLCJiaW5kIiwiZXJyb3IiLCJXZWJBc3NlbWJseSIsIkdlIiwiRCIsIlYiLCJZIiwic2UiLCJCIiwidGUiLCJrZSIsIk9lIiwiZWUiLCJiZSIsIlVlIiwiSEVBUDgiLCJIRUFQMTYiLCJIRUFQVTgiLCJIRUFQVTE2IiwiSEVBUDMyIiwiSEVBUFUzMiIsIkhFQVBGMzIiLCJIRUFQRjY0IiwiSEVBUDY0IiwiSEVBUFU2NCIsInBlIiwieWUiLCJkZSIsInZlIiwiV2UiLCJCZSIsIlJ1bnRpbWVFcnJvciIsImhlIiwiRiIsInN0YXJ0c1dpdGgiLCJKZSIsImxvY2F0ZUZpbGUiLCJvdCIsIkZlIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInRoZW4iLCJvayIsImFycmF5QnVmZmVyIiwiY2F0Y2giLCJSZSIsImluc3RhbnRpYXRlIiwiTXQiLCJxZSIsInN1YnN0cmluZyIsInN1YmFycmF5IiwiYWxwaGEiLCJiZXRhIiwibWluIiwibWF4Iiwia2VlcERpbXMiLCJub29wV2l0aEVtcHR5QXhlcyIsImF4ZXMiLCJwZXJtIiwiYXV0b1BhZCIsImRpbGF0aW9ucyIsImdyb3VwIiwia2VybmVsX3NoYXBlIiwicGFkcyIsInN0cmlkZXMiLCJ3SXNDb25zdCIsIm91dHB1dFBhZGRpbmciLCJvdXRwdXRTaGFwZSIsImFjdGl2YXRpb24iLCJrZXJuZWxTaGFwZSIsIkllIiwiYXV0b19wYWQiLCJjZWlsX21vZGUiLCJjb3VudF9pbmNsdWRlX3BhZCIsInN0b3JhZ2Vfb3JkZXIiLCJ0cmFuc0EiLCJ0cmFuc0IiLCJzZWxlY3RMYXN0SW5kZXgiLCJheGlzIiwibnVtT3V0cHV0cyIsInNwbGl0U2l6ZXMiLCJhbnRpYWxpYXMiLCJjb29yZGluYXRlVHJhbnNmb3JtTW9kZSIsImN1YmljQ29lZmZBIiwiZXhjbHVkZU91dHNpZGUiLCJleHRyYXBvbGF0aW9uVmFsdWUiLCJrZWVwQXNwZWN0UmF0aW9Qb2xpY3kiLCJtb2RlIiwibmVhcmVzdE1vZGUiLCJzdGFydHMiLCJlbmRzIiwiZXBzaWxvbiIsImVxdWF0aW9uIiwibW9tZW50dW0iLCJzcGF0aWFsIiwidHJhaW5pbmdNb2RlIiwiZXhjbHVzaXZlIiwicmV2ZXJzZSIsIm51bUhlYWRzIiwiaXNVbmlkaXJlY3Rpb25hbCIsIm1hc2tGaWx0ZXJWYWx1ZSIsInNjYWxlIiwiZG9Sb3RhcnkiLCJxa3ZIaWRkZW5TaXplcyIsInBhc3RQcmVzZW50U2hhcmVCdWZmZXIiLCJ3X2lzX2NvbnN0IiwiYWN0aXZhdGlvbl9wYXJhbXMiLCJLdCIsIm1lc3NhZ2UiLCJOdCIsImNiIiwicmIiLCJxYiIsImtiIiwiamIiLCJubiIsImd0IiwieHIiLCJUZXh0RGVjb2RlciIsIlZ0IiwiZGVjb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiRHQiLCJjaGFyQ29kZUF0IiwiQ3QiLCJDciIsInRvU3RyaW5nIiwic3QiLCJJciIsIlp0IiwiQXIiLCJLZSIsInRiIiwiZm9yRWFjaCIsImFuIiwiVHIiLCJFciIsIiRhIiwibmIiLCJQZSIsIk9yIiwicGIiLCJ3ZSIsInV0IiwibHIiLCJmcm9tV2lyZVR5cGUiLCJrciIsImZhIiwiUHIiLCJtYSIsImZlIiwiZHIiLCJvbiIsImhhIiwic24iLCJSciIsImVyIiwibHQiLCJCciIsInRvV2lyZVR5cGUiLCJYdCIsInd0IiwiTXIiLCJIdCIsIkRyIiwienIiLCJsbiIsImRuIiwiVXIiLCIkdCIsIkJyb3dzZXIiLCJsYiIsInNiIiwicmVzdW1lIiwidWUiLCJMdCIsInBuIiwicGF1c2UiLCJ0ciIsImh0Iiwib25FeGl0IiwiZm4iLCJudCIsIlF0IiwibW4iLCJwciIsIldyIiwiZ2xvYmFsVGhpcyIsIkZ1bmN0aW9uIiwiZnIiLCJ0dCIsImhuIiwieXQiLCJWciIsIm1yIiwicnQiLCJKdCIsIlllIiwiVVNFUiIsIkxPR05BTUUiLCJQQVRIIiwiUFdEIiwiSE9NRSIsIkxBTkciLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZXMiLCJnbiIsInluIiwiYm4iLCJ3biIsIld0IiwiVXQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldERheSIsIkRhdGUiLCJhYiIsImJiIiwiZ2V0VGltZSIsInNldERhdGUiLCJzZXRNb250aCIsInNldEZ1bGxZZWFyIiwiRGIiLCJDYiIsImhiIiwibWIiLCJpYiIsIldhIiwiR2IiLCJCYiIsIkViIiwiUmVnRXhwIiwiTWF0aCIsImZsb29yIiwiYWJzIiwidm4iLCIkbiIsImhyIiwiQmluZGluZ0Vycm9yIiwic3VwZXIiLCJJbnRlcm5hbEVycm9yIiwiaGFzIiwicG9wIiwiY291bnRfZW12YWxfaGFuZGxlcyIsInlhIiwiaWEiLCJiYSIsImNhIiwiVyIsImFhIiwiTiIsIkciLCJhcmdQYWNrQWR2YW5jZSIsInJlYWRWYWx1ZUZyb21Qb2ludGVyIiwiZWIiLCJnYSIsIm4iLCJVaW50OENsYW1wZWRBcnJheSIsInoiLCJ1YiIsImRhIiwiayIsIk5yIiwic2hpZnQiLCJkZWxldGVPYmplY3QiLCJhcHBseSIsIm10IiwiZCIsImgiLCJOYU4iLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENEYXkiLCJVVEMiLCJnZXRTZWNvbmRzIiwiZ2V0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJzZXRUaW1lIiwiZ2V0WWVhciIsImlzTmFOIiwiX24iLCJSIiwiSyIsInRvVGltZVN0cmluZyIsIm1hdGNoIiwidiIsIkkiLCJub3ciLCJMIiwicGVyZm9ybWFuY2UiLCJKIiwiZ3JvdyIsIloiLCJlYSIsImVudHJpZXMiLCJhcmd1bWVudHMiLCJTbiIsIkZpYmVycyIsIkhiIiwidW4iLCJWYSIsInhuIiwiamEiLCJ1bnNoaWZ0IiwiY2xlYXJJbnRlcnZhbCIsImluc3RhbnRpYXRlV2FzbSIsImluc3RhbnRpYXRlU3RyZWFtaW5nIiwiQnQiLCJpbnN0YW5jZSIsIl9PcnRJbml0IiwibGEiLCJfT3J0R2V0TGFzdEVycm9yIiwiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zIiwibmEiLCJfT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIiLCJvYSIsIl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUiLCJwYSIsIl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkiLCJxYSIsIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMiLCJyYSIsInNhIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwidGEiLCJfT3J0R2V0SW5wdXRPdXRwdXRDb3VudCIsInVhIiwiX09ydEdldElucHV0TmFtZSIsInZhIiwiX09ydEdldE91dHB1dE5hbWUiLCJ3YSIsIl9PcnRGcmVlIiwieGEiLCJfT3J0Q3JlYXRlVGVuc29yIiwiX09ydEdldFRlbnNvckRhdGEiLCJ6YSIsIl9PcnRSZWxlYXNlVGVuc29yIiwiX09ydENyZWF0ZVJ1bk9wdGlvbnMiLCJfT3J0QWRkUnVuQ29uZmlnRW50cnkiLCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnMiLCJEYSIsIl9PcnRDcmVhdGVCaW5kaW5nIiwiRmEiLCJfT3J0QmluZE91dHB1dCIsIkdhIiwiX09ydENsZWFyQm91bmRPdXRwdXRzIiwiSGEiLCJfT3J0UmVsZWFzZUJpbmRpbmciLCJKYSIsIkthIiwiX09ydEVuZFByb2ZpbGluZyIsIkxhIiwiX0pzZXBPdXRwdXQiLCJNYSIsIl9Kc2VwR2V0Tm9kZU5hbWUiLCJOYSIsInp0IiwiX21hbGxvYyIsIl9mcmVlIiwiUWEiLCJnciIsInlyIiwiVWEiLCJIciIsIlhhIiwiWWEiLCJaYSIsIl9hIiwiTHIiLCJwcmVSdW4iLCJjYWxsZWRSdW4iLCJfX19zdGFydF9lbV9qcyIsIl9fX3N0b3BfZW1fanMiLCJzdGFja0FsbG9jIiwic3RhY2tTYXZlIiwic3RhY2tSZXN0b3JlIiwiVVRGOFRvU3RyaW5nIiwic3RyaW5nVG9VVEY4IiwibGVuZ3RoQnl0ZXNVVEY4IiwiQ28iLCJJbyIsIkFvIiwiY3B1cyIsIkhkIiwiQm8iLCJHZCIsInpuIiwiUm8iLCJGZCIsInFkIiwiamQiLCJNbyIsIk5lIiwiVmUiLCJqciIsIk1lIiwiRG8iLCJLZCIsIllkIiwiWmQiLCJYZCIsIlVvIiwicHQiLCJLciIsIlduIiwiWXIiLCJObiIsIlpyIiwiUWQiLCJKZCIsIk5vIiwiVm8iLCJIbyIsImVjIiwiRGUiLCJMbyIsIkhuIiwidGMiLCJGbyIsImpvIiwieGUiLCJBdCIsIm9yIiwiTG4iLCJHbiIsIkZuIiwiSGUiLCJfdCIsIkxlIiwiUWUiLCJTdCIsImZ0IiwiY2UiLCJxbiIsIllvIiwid3IiLCJuYyIsIlpvIiwiYWMiLCJpYyIsInh0IiwiWG8iLCJRbyIsIm9jIiwic2MiLCJ1YyIsImxjIiwiZGMiLCJjYyIsInBjIiwiZmMiLCJtYyIsImhjIiwiVHQiLCJKbyIsImVzIiwidHMiLCJycyIsIm5zIiwiYXMiLCJpcyIsIm9zIiwic3MiLCJ1cyIsIkV0IiwiZ2MiLCJLbiIsIk90IiwieWMiLCJiYyIsInZjIiwid2MiLCIkYyIsIl9jIiwiU2MiLCJ4YyIsIkNjIiwiSWMiLCJrdCIsImRzIiwiY3MiLCJwcyIsImZzIiwibXMiLCJocyIsImdzIiwieXMiLCJicyIsInZzIiwid3MiLCIkcyIsIl9zIiwiQWMiLCJUYyIsIkVjIiwiT2MiLCJZbiIsImtjIiwieHMiLCJQYyIsIlJjIiwiQmMiLCJDcyIsIk1jIiwiRGMiLCJBcyIsInpjIiwiRWUiLCJFcyIsIk9zIiwia3MiLCJQcyIsIlJzIiwiQnMiLCJNcyIsIkRzIiwienMiLCJVYyIsIlVzIiwiV3MiLCJOcyIsIlZzIiwiWm4iLCJIcyIsIlhuIiwiTHMiLCJHcyIsIkZzIiwicXMiLCJqcyIsIktzIiwiWXMiLCJacyIsIlhzIiwiUXMiLCJKcyIsImV1IiwidHUiLCJydSIsIm51IiwiYXUiLCJpdSIsIm91Iiwic3UiLCJOYyIsIlZjIiwidXUiLCJIYyIsIkxjIiwiUHQiLCJkdSIsImN1IiwicHUiLCJmdSIsIm11IiwiaHUiLCJndSIsInl1IiwiYnUiLCJ2dSIsIkZjIiwicWMiLCJqYyIsIktjIiwiJHUiLCJfdSIsIlJ0IiwiUW4iLCJqZSIsIkpuIiwiWWMiLCJaYyIsIlhyIiwieHUiLCJYYyIsIlFyIiwiUWMiLCJKYyIsIkN1IiwicmkiLCJlcCIsIlR1IiwiZWkiLCJFdSIsInRwIiwiT3UiLCJhaSIsInJwIiwibnAiLCJpaSIsImFwIiwia3UiLCJpcCIsIm9pIiwib3AiLCJzcCIsInVwIiwiQnUiLCJNdSIsImxwIiwiZHAiLCJjcCIsInBwIiwiRHUiLCJmcCIsIlV1IiwiV3UiLCJzaSIsIlZ1IiwiaHAiLCJ1aSIsImxpIiwiSHUiLCJncCIsIkx1IiwiR3UiLCJ5cCIsInF1IiwiYnAiLCJ2cCIsImp1Iiwid3AiLCIkcCIsIll1IiwiWnUiLCJfcCIsIlNwIiwiUXUiLCJKdSIsInhwIiwiQ3AiLCJ0bCIsInJsIiwiSXAiLCJBcCIsIlRwIiwiYWwiLCJFcCIsIk9wIiwib2wiLCJrcCIsImxsIiwidWwiLCJQcCIsImRpIiwiZGwiLCJScCIsIkJwIiwiTXAiLCJEcCIsInpwIiwiVXAiLCJXcCIsIk5wIiwicGwiLCJtbCIsImhsIiwiZ2wiLCJ5bCIsIlZwIiwiSHAiLCJibCIsInZsIiwid2wiLCIkbCIsIl9sIiwiU2wiLCJ4bCIsIkNsIiwiSWwiLCJBbCIsIlRsIiwiRWwiLCJHcCIsIkZwIiwia2wiLCJxcCIsImpwIiwiS3AiLCJZcCIsIlpwIiwiWHAiLCJRcCIsIkpwIiwiZWYiLCJ0ZiIsInJmIiwiUmwiLCJuZiIsImFmIiwib2YiLCJzZiIsInVmIiwiQmwiLCJNbCIsImxmIiwiZGYiLCJ6bCIsImNmIiwicGYiLCJXbCIsImZmIiwibWYiLCJObCIsIlZsIiwiaGYiLCJnZiIsIkxsIiwiR2wiLCJ5ZiIsImJmIiwidmYiLCJ3ZiIsIiRmIiwicWwiLCJqbCIsIllsIiwiX2YiLCJTZiIsInhmIiwiWmwiLCJDZiIsIklmIiwiUWwiLCJlZCIsIkFmIiwiVGYiLCJUbyIsImtvIiwiT28iLCJFbyIsInJjIiwiJGIiLCJPYiIsImFlIiwiZ2UiLCJTZSIsImxlIiwiRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCIsIldvcmtlciIsIndyaXRlU3luYyIsIndhc21NZW1vcnkiLCJNZW1vcnkiLCJpbml0aWFsIiwibWF4aW11bSIsInNoYXJlZCIsInVyIiwiWXQiLCJUZSIsInRlcm1pbmF0ZSIsIm9ubWVzc2FnZSIsIlBiIiwiY21kIiwic3RhcnRfcm91dGluZSIsImFyZyIsIlZiIiwicHRocmVhZF9wdHIiLCJ1bnJlZiIsInBvc3RNZXNzYWdlIiwiQW4iLCJEaSIsIlViIiwiSWIiLCJyZWNlaXZlT2JqZWN0VHJhbnNmZXIiLCJ0aHJlYWRJbml0VExTIiwiVGIiLCJzZXRFeGl0U3RhdHVzIiwiU2IiLCJudW1UaHJlYWRzIiwiUmIiLCJ0YXJnZXRUaHJlYWQiLCJJbiIsInRyYW5zZmVyTGlzdCIsInRocmVhZCIsImxvYWRlZCIsImFsZXJ0IiwidGhyZWFkSWQiLCJ0ZXh0IiwidGFyZ2V0IiwiYXJncyIsImZpbGVuYW1lIiwibGluZW5vIiwiaGFuZGxlcnMiLCJ1cmxPckJsb2IiLCJtYWluU2NyaXB0VXJsT3JCbG9iIiwid2FzbU1vZHVsZSIsIlBUaHJlYWQiLCJNYiIsIktiIiwiZXN0YWJsaXNoU3RhY2tTcGFjZSIsIlVpIiwiaW52b2tlRW50cnlQb2ludCIsIldpIiwiY24iLCJZYiIsIk5iIiwiUWIiLCJBdG9taWNzIiwic3RvcmUiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX21haWxib3hfYXdhaXQiLCJ6aSIsImNoZWNrTWFpbGJveCIsIkJpIiwiSXQiLCJIaSIsIkpiIiwiWGIiLCJyZSIsIkdyIiwiTmkiLCJMaSIsImdpIiwieWkiLCJiaSIsInZpIiwid2kiLCIkaSIsIl9pIiwiU2kiLCJ4aSIsIkNpIiwiSWkiLCJBaSIsIlRkIiwiVGkiLCJFaSIsIk9pIiwia2kiLCJGaSIsInJyIiwiTGIiLCJFZCIsIk9kIiwiUGkiLCJDbiIsImtkIiwiUGQiLCJNaSIsIlpiIiwic2V0VGltZW91dCIsIldiIiwicmVmIiwiUmkiLCJ0aW1lT3JpZ2luIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsIlZpIiwiZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkIiwiUmQiLCJfcHRocmVhZF9zZWxmIiwiX19lbXNjcmlwdGVuX3Rsc19pbml0IiwiX19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncyIsImRiIiwiX19lbXNjcmlwdGVuX3RocmVhZF9pbml0IiwiX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkIiwiVG4iLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQiLCJkeW5DYWxsX2lpIiwiR2kiLCJzdGFydFdvcmtlciIsImtlZXBSdW50aW1lQWxpdmUiLCJFeGl0U3RhdHVzIiwiUG8iLCJ6bSIsIkxkIiwidnIiLCJjcm9zc09yaWdpbklzb2xhdGVkIiwid2FybiIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJ2YWxpZGF0ZSIsImluaXRUaW1lb3V0Iiwic2ltZCIsIndhc21QYXRocyIsImVuZHNXaXRoIiwiQmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsInJhY2UiLCJVbiIsImFkZCIsInpvIiwibG9nU2V2ZXJpdHlMZXZlbCIsImlzSW50ZWdlciIsImxvZ1ZlcmJvc2l0eUxldmVsIiwidGFnIiwiZXh0cmEiLCJXZWFrU2V0IiwiV28iLCJzZXNzaW9uIiwidXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSIsInNvbWUiLCJlbmFibGVNZW1QYXR0ZXJuIiwiZGV2aWNlVHlwZSIsInBvd2VyUHJlZmVyZW5jZSIsInByZWZlcnJlZExheW91dCIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwibG9nSWQiLCJvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJlbmFibGVQcm9maWxpbmciLCJmcmVlRGltZW5zaW9uT3ZlcnJpZGVzIiwiemUiLCJoZWFkZXJzIiwicGFyc2VJbnQiLCJib2R5IiwiZ2V0UmVhZGVyIiwiY2VpbCIsImRvbmUiLCJyZWFkIiwiY29kZSIsIkJ1ZmZlciIsImNvbmNhdCIsInF0IiwidG9JU09TdHJpbmciLCJHbyIsIlZuIiwiS28iLCJkZXZpY2UiLCJjcmVhdGVCdWZmZXIiLCJ1c2FnZSIsIkdQVUJ1ZmZlclVzYWdlIiwiQ09QWV9EU1QiLCJNQVBfUkVBRCIsImdldENvbW1hbmRFbmNvZGVyIiwiZW5kQ29tcHV0ZVBhc3MiLCJjb3B5QnVmZmVyVG9CdWZmZXIiLCJtYXBBc3luYyIsIkdQVU1hcE1vZGUiLCJSRUFEIiwiZ2V0TWFwcGVkUmFuZ2UiLCJkZXN0cm95Iiwic3RvcmFnZUNhY2hlIiwiZnJlZUJ1ZmZlcnMiLCJmcmVlVW5pZm9ybUJ1ZmZlcnMiLCJidWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyIsImJ1ZmZlcnNQZW5kaW5nIiwiZXh0ZXJuYWxCdWZmZXJzIiwidXBsb2FkIiwiYnl0ZU9mZnNldCIsIm9yaWdpbmFsU2l6ZSIsIm1hcHBlZEF0Q3JlYXRpb24iLCJNQVBfV1JJVEUiLCJDT1BZX1NSQyIsInVubWFwIiwiZ3B1RGF0YSIsIm1lbWNweSIsInJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJkZWxldGUiLCJpZCIsInVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlciIsIlNUT1JBR0UiLCJVTklGT1JNIiwicmVmcmVzaFBlbmRpbmdCdWZmZXJzIiwiWGUiLCJjYWNoZUtleSIsImtleSIsInNvcnQiLCJDZSIsImNhbGNNYXRNdWxTaGFwZSIsImNhbGNTaGFwZSIsImlzVmFsaWRCcm9hZGNhc3QiLCJnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlIiwic2l6ZUZyb21EaW1lbnNpb24iLCJzaXplVG9EaW1lbnNpb24iLCJjb21wdXRlU3RyaWRlcyIsIm5vcm1hbGl6ZUF4aXMiLCJub3JtYWxpemVBeGVzIiwic29ydEJhc2VkT25QZXJtIiwicGFkU2hhcGUiLCJhcmVFcXVhbCIsImV2ZXJ5IiwiYWRqdXN0UG9vbEF0dHJpYnV0ZXMiLCJhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQiLCJhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSIsImNvbXB1dGVQb29sT3V0cHV0U2hhcGUiLCJjb21wdXRlU2hhcGVIZWxwZXIiLCJjb21wdXRlQ29udk91dHB1dFNoYXBlIiwiZ2V0U2hhcGVPZkdlbW1SZXN1bHQiLCJfZSIsImtleXMiLCJpbmRpY2VzIiwic3RvcmFnZSIsInRlbnNvciIsIm9mZnNldFRvSW5kaWNlcyIsImluZGljZXNUb09mZnNldCIsImJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0Iiwic2V0QnlJbmRpY2VzIiwiZ2V0QnlJbmRpY2VzIiwiaW1wbCIsInZhbHVlcyIsImluZGljZXNHZXQiLCJyYW5rIiwiaW5kaWNlc1NldCIsInNldEJ5T2Zmc2V0IiwiZ2V0QnlPZmZzZXQiLCJzaGFwZSIsIm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwIiwiaW50ZXJuYWxWYXJpYWJsZXMiLCJ2YXJpYWJsZXMiLCJ1bmlmb3JtcyIsInZhcmlhYmxlSW5kZXgiLCJndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzIiwibWFpblN0YXJ0IiwiYXBwZW5kVmFyaWFibGVVbmlmb3JtcyIsImRlY2xhcmVWYXJpYWJsZSIsImRlY2xhcmVWYXJpYWJsZXMiLCJyZWdpc3RlckludGVybmFsVmFyaWFibGUiLCJyZWdpc3RlckludGVybmFsVmFyaWFibGVzIiwicmVnaXN0ZXJVbmlmb3JtIiwicmVnaXN0ZXJVbmlmb3JtcyIsInVuaWZvcm1EZWNsYXJhdGlvbiIsImFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMiLCIkciIsInNoYWRlckNhY2hlIiwiaGludCIsImlucHV0RGVwZW5kZW5jaWVzIiwiZ2V0UnVuRGF0YSIsIm91dHB1dHMiLCJkaXNwYXRjaEdyb3VwIiwicHJvZ3JhbVVuaWZvcm1zIiwiZ2V0U2hhZGVyU291cmNlIiwiaW5wdXRzIiwiY29tcHV0ZSIsImxzIiwiam4iLCJzdW0iLCJwcm9kIiwic3VtU3F1YXJlIiwibG9nU3VtRXhwIiwibDEiLCJsMiIsImxvZ1N1bSIsImdldEJpZ0ludDY0QXJyYXkiLCJTcyIsImJhdGNoU2l6ZSIsInNlcXVlbmNlTGVuZ3RoIiwicGFzdFNlcXVlbmNlTGVuZ3RoIiwia3ZTZXF1ZW5jZUxlbmd0aCIsInRvdGFsU2VxdWVuY2VMZW5ndGgiLCJtYXhTZXF1ZW5jZUxlbmd0aCIsImlucHV0SGlkZGVuU2l6ZSIsImhpZGRlblNpemUiLCJ2SGlkZGVuU2l6ZSIsImhlYWRTaXplIiwidkhlYWRTaXplIiwibWFza1R5cGUiLCJicm9hZGNhc3RSZXNQb3NCaWFzIiwicGFzc1Bhc3RJbkt2IiwicWt2Rm9ybWF0Iiwic3FydCIsImdwdURhdGFUeXBlIiwiSXMiLCJvdXRwdXRDb3VudCIsInZhbGlkYXRlSW5wdXRDb250ZW50IiwiVHMiLCJnZXRGbG9hdDMyQXJyYXkiLCJsdSIsInd1Iiwic2NhbGFyIiwidmVjdG9yIiwiU3UiLCJqdCIsImNsaXBNYXgiLCJjbGlwTWluIiwiSnIiLCJJdSIsIkF1IiwidGkiLCJuaSIsImtlcm5lbEN1c3RvbURhdGEiLCJ3VCIsIlB1IiwiUnUiLCJ6dSIsInJlZHVjZSIsImZpbGwiLCJOdSIsImdldEludDMyQXJyYXkiLCJGdSIsInN5bWJvbFRvSW5kaWNlcyIsImlucHV0SW5kZXgiLCJhZGRTeW1ib2wiLCJoYXNFbGxpcHNpcyIsInN5bWJvbFRvSW5mbyIsImxocyIsIm91dHB1dERpbXMiLCJwcm9jZXNzVGVybSIsImNvdW50IiwiZWxsaXBzaXNEaW1zIiwiZGltVmFsdWUiLCJyaHMiLCJpbnB1dEluZGljZXMiLCJLdSIsIlh1IiwiZWwiLCJubCIsImlsIiwic2wiLCJjbCIsImZsIiwiT2wiLCJjZWlsTW9kZSIsImNvdW50SW5jbHVkZVBhZCIsInN0b3JhZ2VPcmRlciIsIlBsIiwiRGwiLCJyb3VuZCIsIk1BWF9WQUxVRSIsIk1JTl9WQUxVRSIsImN1c3RvbURhdGFCdWZmZXIiLCJVbCIsIkhsIiwic2lnbiIsIkZsIiwiS2wiLCJYbCIsIkpsIiwidGQiLCJyZCIsInJlcG8iLCJhdHRyaWJ1dGVzQm91bmQiLCJnZXRBcnRpZmFjdCIsInNldEFydGlmYWN0IiwicHJvZ3JhbUluZm8iLCJnZXRDb21wdXRlUGFzc0VuY29kZXIiLCJ3cml0ZVRpbWVzdGFtcCIsInBlbmRpbmdEaXNwYXRjaE51bWJlciIsInNldFBpcGVsaW5lIiwiY29tcHV0ZVBpcGVsaW5lIiwiYmluZGluZyIsInJlc291cmNlIiwiY3JlYXRlQmluZEdyb3VwIiwibGF5b3V0IiwiZ2V0QmluZEdyb3VwTGF5b3V0IiwibGFiZWwiLCJzZXRCaW5kR3JvdXAiLCJkaXNwYXRjaFdvcmtncm91cHMiLCJtYXhEaXNwYXRjaE51bWJlciIsInF1ZXJ5VHlwZSIsImJ1aWxkIiwiZmVhdHVyZXMiLCJjcmVhdGVTaGFkZXJNb2R1bGUiLCJjcmVhdGVDb21wdXRlUGlwZWxpbmUiLCJlbnRyeVBvaW50Iiwibm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUiLCJsaW1pdHMiLCJtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbiIsImNicnQiLCJuZCIsImN1cnJlbnRLZXJuZWxJZCIsImNvbW1hbmRFbmNvZGVyIiwiY29tcHV0ZVBhc3NFbmNvZGVyIiwicGVuZGluZ0tlcm5lbHMiLCJwZW5kaW5nUXVlcmllcyIsInNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nIiwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEiLCJpbml0aWFsaXplIiwicmVxdWlyZWRMaW1pdHMiLCJtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUiLCJtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUiLCJtYXhCdWZmZXJTaXplIiwibWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVYIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVZIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVaIiwicmVxdWlyZWRGZWF0dXJlcyIsInJlcXVlc3REZXZpY2UiLCJncHVEYXRhTWFuYWdlciIsInByb2dyYW1NYW5hZ2VyIiwia2VybmVscyIsImtlcm5lbFBlcnNpc3RlbnREYXRhIiwiZGVidWciLCJvbnVuY2FwdHVyZWRlcnJvciIsIkdQVVZhbGlkYXRpb25FcnJvciIsInNldFF1ZXJ5VHlwZSIsInF1ZXJ5U2V0IiwiY3JlYXRlQ29tbWFuZEVuY29kZXIiLCJ0aW1lc3RhbXBXcml0ZXMiLCJiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4IiwiZW5kT2ZQYXNzV3JpdGVJbmRleCIsImJlZ2luQ29tcHV0ZVBhc3MiLCJlbmQiLCJyZXNvbHZlUXVlcnlTZXQiLCJxdWVyeVJlc29sdmVCdWZmZXIiLCJxdWV1ZSIsInN1Ym1pdCIsImZpbmlzaCIsImtlcm5lbElkIiwia2VybmVsVHlwZSIsImtlcm5lbE5hbWUiLCJwcm9ncmFtTmFtZSIsImlucHV0VGVuc29yVmlld3MiLCJvdXRwdXRUZW5zb3JWaWV3cyIsInF1ZXJ5VGltZUJhc2UiLCJwcm9maWxpbmciLCJvbmRhdGEiLCJ2ZXJzaW9uIiwiaW5wdXRzTWV0YWRhdGEiLCJvdXRwdXRzTWV0YWRhdGEiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwidGVtcG9yYXJ5RGF0YSIsIndyaXRlQnVmZmVyIiwib2Zmc2V0IiwiYWxsb2MiLCJmcmVlIiwiY3JlYXRlS2VybmVsIiwia2VybmVsRW50cnkiLCJhdHRyaWJ1dGVzIiwicmVsZWFzZUtlcm5lbCIsImNvbXB1dGVLZXJuZWwiLCJwdXNoRXJyb3JTY29wZSIsInBvcEVycm9yU2NvcGUiLCJjcmVhdGVRdWVyeVNldCIsIlFVRVJZX1JFU09MVkUiLCJhZCIsIkVmIiwiZW4iLCJjaSIsIk9mIiwic2QiLCJ1ZCIsInRuIiwia2YiLCJwaSIsImxkIiwiZGQiLCJvZCIsImNkIiwicGQiLCJmZCIsInNyIiwidnQiLCJybiIsImZpIiwibWkiLCJfciIsIlNyIiwiQmYiLCJnZCIsInlkIiwiYmQiLCJ2ZCIsIndkIiwiJGQiLCJfZCIsIlNkIiwiTWYiLCJEZiIsImN1c3RvbURhdGFPZmZzZXQiLCJjdXN0b21EYXRhU2l6ZSIsIm9wS2VybmVsQ29udGV4dCIsIm91dHB1dCIsIm1kIiwiZ3B1IiwicmVxdWVzdEFkYXB0ZXIiLCJleHRlcm5hbERhdGEiLCJwYXRoIiwicHJlZmVycmVkT3V0cHV0TG9jYXRpb24iLCJoYW5kbGUiLCJvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMiLCJvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIiwiaGQiLCJodyIsIlJmIiwiaGkiLCJwcm94eSIsIm91dCIsInJldm9rZU9iamVjdFVSTCIsImluIiwiZXBOYW1lIiwibW9kZWwiLCJvcHRpb25zIiwic2Vzc2lvbklkIiwib3V0cHV0SW5kaWNlcyIsInhkIiwiZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkiLCJsb2FkTW9kZWwiLCJDZCIsIklkIiwid2FzbUJhY2tlbmQiLCJ6ZiIsIkFkIiwiV2YiLCJkZWZhdWx0IiwiVWYiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJ1bmRlZmluZWQiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwib3J0IiwiTUFYX1dJRFRIIiwiTUFYX0hFSUdIVCIsIk1PREVMX1dJRFRIIiwiTU9ERUxfSEVJR0hUIiwiTU9ERUxfTUFQIiwic2FtX2IiLCJzYW1fYl9sb2NhbCIsImNvbmZpZyIsInByb3ZpZGVyIiwidGhyZWFkcyIsInZhcnMiLCJzZWFyY2giLCJwYWlyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZ2V0Q29uZmlnIiwiY2FudmFzIiwiZmlsZWluIiwiZGVjb2Rlcl9sYXRlbmN5IiwiaW1hZ2VfZW1iZWRkaW5ncyIsImltYWdlSW1hZ2VEYXRhIiwic2VzcyIsInBvaW50cyIsImxhYmVscyIsImlzQ2xpY2tlZCIsImdldEVsZW1lbnRCeUlkIiwiaW5uZXJUZXh0IiwiaGFuZGxlQ2xpY2siLCJldmVudCIsInN0eWxlIiwiY3Vyc29yIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJsZWZ0IiwiY2xpZW50WSIsInRvcCIsImVtYiIsImN0cmxLZXkiLCJjdHgiLCJjbGVhclJlY3QiLCJwb2ludENvb3JkcyIsInBvaW50TGFiZWxzIiwibWFza0lucHV0IiwiaGFzTWFzayIsIm9yaWdpYW5sSW1hZ2VTaXplIiwiZmVlZCIsInN0YXJ0IiwicmVzIiwidG9GaXhlZCIsIm1hc2tJbWFnZURhdGEiLCJtYXNrcyIsImdsb2JhbEFscGhhIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJoYW5kbGVJbWFnZSIsImltZyIsImVuY29kZXJfbGF0ZW5jeSIsImRpc2FibGVkIiwibG9hZF9tb2RlbCIsImlkeCIsIm9wdCIsInVybCIsImNhY2hlIiwiY2FjaGVzIiwiY2xlYXJfY2FjaGUiLCJjYWNoZWRSZXNwb25zZSIsImZldGNoQW5kQ2FjaGUiLCJhZGRFdmVudExpc3RlbmVyIiwib25jaGFuZ2UiLCJldnQiLCJmaWxlcyIsIkZpbGVSZWFkZXIiLCJmaWxlUmVhZGVyIiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsIm1haW4iXSwic291cmNlUm9vdCI6IiJ9